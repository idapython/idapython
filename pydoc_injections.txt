Help on function auto_apply_tail in module ida_auto:

auto_apply_tail(*args) -> 'void'
    auto_apply_tail(tail_ea, parent_ea)
    
    
    Plan to apply the tail_ea chunk to the parent
    
    @param tail_ea: linear address of start of tail (C++: ea_t)
    @param parent_ea: linear address within parent. If BADADDR,
                      automatically try to find parent via xrefs. (C++:
                      ea_t)

Help on function auto_apply_type in module ida_auto:

auto_apply_type(*args) -> 'void'
    auto_apply_type(caller, callee)
    
    
    Plan to apply the callee's type to the calling point.
    
    
    @param caller (C++: ea_t)
    @param callee (C++: ea_t)

Help on function auto_cancel in module ida_auto:

auto_cancel(*args) -> 'void'
    auto_cancel(ea1, ea2)
    
    
    Remove an address range (ea1..ea2) from queues 'AU_CODE' , 'AU_PROC' ,
    'AU_USED' . To remove an address range from other queues use
    'auto_unmark()' function. 'ea1' may be higher than 'ea2', the kernel
    will swap them in this case. 'ea2' doesn't belong to the range.
    
    @param ea1 (C++: ea_t)
    @param ea2 (C++: ea_t)

Help on class auto_display_t in module ida_auto:

class auto_display_t(builtins.object)
 |  Proxy of C++ auto_display_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> auto_display_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_auto_display_t(...)
 |      delete_auto_display_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      auto_display_t_ea_get(self) -> ea_t
 |  
 |  state
 |      auto_display_t_state_get(self) -> idastate_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      auto_display_t_type_get(self) -> atype_t

Help on function auto_get in module ida_auto:

auto_get(*args) -> 'ea_t'
    auto_get(type, lowEA, highEA) -> ea_t
    
    
    Retrieve an address from queues regarding their priority. Returns
    'BADADDR' if no addresses not lower than 'lowEA' and less than
    'highEA' are found in the queues. Otherwise *type will have queue
    type.
    
    @param type (C++: atype_t  *)
    @param lowEA (C++: ea_t)
    @param highEA (C++: ea_t)

Help on function auto_is_ok in module ida_auto:

auto_is_ok(*args) -> 'bool'
    auto_is_ok() -> bool
    
    
    Are all queues empty? (i.e. has autoanalysis finished?).

Help on function auto_make_code in module ida_auto:

auto_make_code(*args) -> 'void'
    auto_make_code(ea)
    
    
    Plan to make code.
    
    
    @param ea (C++: ea_t)

Help on function auto_make_proc in module ida_auto:

auto_make_proc(*args) -> 'void'
    auto_make_proc(ea)
    
    
    Plan to make code&function.
    
    
    @param ea (C++: ea_t)

Help on function auto_mark in module ida_auto:

auto_mark(*args) -> 'void'
    auto_mark(ea, type)
    
    
    Put single address into a queue. Queues keep addresses sorted.
    
    
    @param ea (C++: ea_t)
    @param type (C++: atype_t)

Help on function auto_mark_range in module ida_auto:

auto_mark_range(*args) -> 'void'
    auto_mark_range(start, end, type)
    
    
    Put range of addresses into a queue. 'start' may be higher than 'end',
    the kernel will swap them in this case. 'end' doesn't belong to the
    range.
    
    @param start (C++: ea_t)
    @param end (C++: ea_t)
    @param type (C++: atype_t)

Help on function auto_recreate_insn in module ida_auto:

auto_recreate_insn(*args) -> 'int'
    auto_recreate_insn(ea) -> int
    
    
    Try to create instruction
    
    @param ea: linear address of callee (C++: ea_t)
    @return: the length of the instruction or 0

Help on function auto_unmark in module ida_auto:

auto_unmark(*args) -> 'void'
    auto_unmark(start, end, type)
    
    
    Remove range of addresses from a queue. 'start' may be higher than
    'end', the kernel will swap them in this case. 'end' doesn't belong to
    the range.
    
    @param start (C++: ea_t)
    @param end (C++: ea_t)
    @param type (C++: atype_t)

Help on function auto_wait in module ida_auto:

auto_wait(*args) -> 'bool'
    auto_wait() -> bool
    
    
    Process everything in the queues and return true.
    
    @return: false if the user clicked cancel. (the wait box must be
             displayed by the caller if desired)

Help on function auto_wait_range in module ida_auto:

auto_wait_range(*args) -> 'ssize_t'
    auto_wait_range(ea1, ea2) -> ssize_t
    
    
    Process everything in the specified range and return true.
    
    @param ea1 (C++: ea_t)
    @param ea2 (C++: ea_t)
    @return: number of autoanalysis steps made. -1 if the user clicked
             cancel. (the wait box must be displayed by the caller if
             desired)

Help on function enable_auto in module ida_auto:

enable_auto(*args) -> 'bool'
    enable_auto(enable) -> bool
    
    
    Temporarily enable/disable autoanalyzer. Not user-facing, but rather
    because IDA sometimes need to turn AA on/off regardless of
    inf.s_genflags:INFFL_AUTO
    
    @param enable (C++: bool)
    @return: old state

Help on function get_auto_display in module ida_auto:

get_auto_display(*args) -> 'void'
    get_auto_display(auto_display)
    
    
    Get structure which holds the autoanalysis indicator contents.
    
    
    @param auto_display (C++: auto_display_t  *)

Help on function get_auto_state in module ida_auto:

get_auto_state(*args) -> 'atype_t'
    get_auto_state() -> atype_t
    
    
    Get current state of autoanalyzer. If auto_state == 'AU_NONE' , IDA is
    currently not running the analysis (it could be temporarily
    interrupted to perform the user's requests, for example).

Help on function is_auto_enabled in module ida_auto:

is_auto_enabled(*args) -> 'bool'
    is_auto_enabled() -> bool
    
    
    Get autoanalyzer state.

Help on function may_create_stkvars in module ida_auto:

may_create_stkvars(*args) -> 'bool'
    may_create_stkvars() -> bool
    
    
    Is it allowed to create stack variables automatically?. This function
    should be used by IDP modules before creating stack vars.

Help on function may_trace_sp in module ida_auto:

may_trace_sp(*args) -> 'bool'
    may_trace_sp() -> bool
    
    
    Is it allowed to trace stack pointer automatically?. This function
    should be used by IDP modules before tracing sp.

Help on function peek_auto_queue in module ida_auto:

peek_auto_queue(*args) -> 'ea_t'
    peek_auto_queue(low_ea, type) -> ea_t
    
    
    Peek into a queue 'type' for an address not lower than 'low_ea'. Do
    not remove address from the queue.
    
    @param low_ea (C++: ea_t)
    @param type (C++: atype_t)
    @return: the address or  BADADDR

Help on function plan_and_wait in module ida_auto:

plan_and_wait(*args) -> 'int'
    plan_and_wait(ea1, ea2, final_pass=True) -> int
    
    
    Analyze the specified range. Try to create instructions where
    possible. Make the final pass over the specified range if specified.
    This function doesn't return until the range is analyzed.
    
    @param ea1 (C++: ea_t)
    @param ea2 (C++: ea_t)
    @param final_pass (C++: bool)

Help on function plan_ea in module ida_auto:

plan_ea(*args) -> 'void'
    plan_ea(ea)
    
    
    Plan to perform reanalysis.
    
    
    @param ea (C++: ea_t)

Help on function plan_range in module ida_auto:

plan_range(*args) -> 'void'
    plan_range(sEA, eEA)
    
    
    Plan to perform reanalysis.
    
    
    @param sEA (C++: ea_t)
    @param eEA (C++: ea_t)

Help on function reanalyze_callers in module ida_auto:

reanalyze_callers(*args) -> 'void'
    reanalyze_callers(ea, noret)
    
    
    Plan to reanalyze callers of the specified address. This function will
    add to 'AU_USED' queue all instructions that call (not jump to) the
    specified address.
    
    @param ea: linear address of callee (C++: ea_t)
    @param noret: !=0: the callee doesn't return, mark to undefine
                  subsequent instructions in the caller. 0: do nothing.
                  (C++: bool)

Help on function revert_ida_decisions in module ida_auto:

revert_ida_decisions(*args) -> 'void'
    revert_ida_decisions(ea1, ea2)
    
    
    Delete all analysis info that IDA generated for for the given range.
    
    
    @param ea1 (C++: ea_t)
    @param ea2 (C++: ea_t)

Help on function set_auto_state in module ida_auto:

set_auto_state(*args) -> 'atype_t'
    set_auto_state(new_state) -> atype_t
    
    
    Set current state of autoanalyzer.
    
    @param new_state: new state of autoanalyzer (C++: atype_t)
    @return: previous state

Help on function set_ida_state in module ida_auto:

set_ida_state(*args) -> 'idastate_t'
    set_ida_state(st) -> idastate_t
    
    
    Change IDA status indicator value
    
    @param st: - new indicator status (C++: idastate_t)
    @return: old indicator status

Help on function show_addr in module ida_auto:

show_addr(*args) -> 'void'
    show_addr(ea)
    
    
    Show an address on the autoanalysis indicator. The address is
    displayed in the form " @:12345678".
    
    @param ea: - linear address to display (C++: ea_t)

Help on function show_auto in module ida_auto:

show_auto(*args) -> 'void'
    show_auto(ea, type=AU_NONE)
    
    
    Change autoanalysis indicator value.
    
    @param ea: linear address being analyzed (C++: ea_t)
    @param type: autoanalysis type (see  Autoanalysis queues ) (C++:
                 atype_t)

Help on function __walk_types_and_formats in module ida_bytes:

__walk_types_and_formats(formats, type_action, format_action, installing)
    # -----------------------------------------------------------------------

Help on function add_byte in module ida_bytes:

add_byte(*args) -> 'void'
    add_byte(ea, value)
    
    
    Add a value to one byte of the program. This function works for wide
    byte processors too.
    
    @param ea: linear address (C++: ea_t)
    @param value: byte value (C++: uint32)

Help on function add_dword in module ida_bytes:

add_dword(*args) -> 'void'
    add_dword(ea, value)
    
    
    Add a value to one dword of the program. This function works for wide
    byte processors too. This function takes into account order of bytes
    specified in \inf{is_be()}this function works incorrectly if
    \ph{nbits} > 16
    
    @param ea: linear address (C++: ea_t)
    @param value: byte value (C++: uint64)

Help on function add_hidden_range in module ida_bytes:

add_hidden_range(*args) -> 'bool'
    add_hidden_range(ea1, ea2, description, header, footer, color) -> bool
    
    
    Mark a range of addresses as hidden. The range will be created in the
    invisible state with the default color
    
    @param ea1: linear address of start of the address range (C++: ea_t)
    @param ea2: linear address of end of the address range (C++: ea_t)
    @param description: range parameters (C++: const char *)
    @param header: range parameters (C++: const char *)
    @param footer: range parameters (C++: const char *)
    @param color (C++: bgcolor_t)
    @return: success

Help on function add_mapping in module ida_bytes:

add_mapping(*args) -> 'bool'
    add_mapping(_from, to, size) -> bool
    
    
    IDA supports memory mapping. References to the addresses from the
    mapped range use data and meta-data from the mapping range.You should
    set flag PR2_MAPPING in ph.flag2 to use memory mapping Add memory
    mapping range.
    
    @param _from: start of the mapped range (nonexistent address) (C++:
                  ea_t)
    @param to: start of the mapping range (existent address) (C++: ea_t)
    @param size: size of the range (C++: asize_t)
    @return: success

Help on function add_qword in module ida_bytes:

add_qword(*args) -> 'void'
    add_qword(ea, value)
    
    
    Add a value to one qword of the program. This function does not work
    for wide byte processors. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    @param ea: linear address (C++: ea_t)
    @param value: byte value (C++: uint64)

Help on function add_word in module ida_bytes:

add_word(*args) -> 'void'
    add_word(ea, value)
    
    
    Add a value to one word of the program. This function works for wide
    byte processors too. This function takes into account order of bytes
    specified in \inf{is_be()}
    
    @param ea: linear address (C++: ea_t)
    @param value: byte value (C++: uint64)

Help on function align_flag in module ida_bytes:

align_flag(*args) -> 'flags_t'
    align_flag() -> flags_t
    
    
    Get a flags_t representing an alignment directive.

Help on function append_cmt in module ida_bytes:

append_cmt(*args) -> 'bool'
    append_cmt(ea, str, rptble) -> bool
    
    
    Append to an indented comment. Creates a new comment if none exists.
    Appends a newline character and the specified string otherwise.
    
    @param ea: linear address (C++: ea_t)
    @param str: comment string to append (C++: const char *)
    @param rptble: append to repeatable comment? (C++: bool)
    @return: success

Help on function attach_custom_data_format in module ida_bytes:

attach_custom_data_format(*args) -> 'bool'
    attach_custom_data_format(dtid, dfid) -> bool
    
    
    Attach the data format to the data type.
    
    @param dtid: data type id that can use the data format. 0 means all
                 standard data types. Such data formats can be applied to
                 any data item or instruction operands. For instruction
                 operands, the  data_format_t::value_size  check is not
                 performed by the kernel. (C++: int)
    @param dfid: data format id (C++: int)

Help on function bin_flag in module ida_bytes:

bin_flag(*args) -> 'flags_t'
    bin_flag() -> flags_t
    
    
    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'

Help on function bin_search in module ida_bytes:

bin_search(*args) -> 'ea_t'
    bin_search(start_ea, end_ea, image, imask, step, flags) -> ea_t

Help on function byte_flag in module ida_bytes:

byte_flag(*args) -> 'flags_t'
    byte_flag() -> flags_t
    
    
    Get a flags_t representing a byte.

Help on function bytesize in module ida_bytes:

bytesize(*args) -> 'int'
    bytesize(ea) -> int
    
    
    Get number of bytes required to store a byte at the given address.
    
    
    @param ea (C++: ea_t)

Help on function calc_def_align in module ida_bytes:

calc_def_align(*args) -> 'int'
    calc_def_align(ea, mina, maxa) -> int
    
    
    Calculate default alignment.
    
    
    @param ea (C++: ea_t)
    @param mina (C++: int)
    @param maxa (C++: int)

Help on function calc_dflags in module ida_bytes:

calc_dflags(*args) -> 'flags_t'
    calc_dflags(f, force) -> flags_t

Help on function calc_max_align in module ida_bytes:

calc_max_align(*args) -> 'int'
    calc_max_align(endea) -> int
    
    
    Returns: 0..32.
    
    
    @param endea (C++: ea_t)

Help on function calc_max_item_end in module ida_bytes:

calc_max_item_end(*args) -> 'ea_t'
    calc_max_item_end(ea, how=15) -> ea_t
    
    
    Calculate maximal reasonable end address of a new item. This function
    will limit the item with the current segment bounds.
    
    @param ea: linear address (C++: ea_t)
    @param how: when to stop the search. A combination of  Item end search
                flags (C++: int)
    @return: end of new item. If it is not possible to create an item, it
             will return 'ea'.

Help on function calc_min_align in module ida_bytes:

calc_min_align(*args) -> 'int'
    calc_min_align(length) -> int
    
    
    Returns: 1..32.
    
    
    @param length (C++: asize_t)

Help on function can_define_item in module ida_bytes:

can_define_item(*args) -> 'bool'
    can_define_item(ea, length, flags) -> bool
    
    
    Can define item (instruction/data) of the specified 'length', starting
    at 'ea'?if there is an item starting at 'ea', this function ignores
    itthis function converts to unexplored all encountered data items with
    fixup information. Should be fixed in the future.a new item would
    cross segment boundariesa new item would overlap with existing items
    (except items specified by 'flags')
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param flags: if not 0, then the kernel will ignore the data types
                  specified by the flags and destroy them. For example:
                  1000 dw 5                  1002 db 5 ; undef
                  1003 db 5 ; undef                  1004 dw 5
                  1006 dd 5                    can_define_item(1000, 6, 0)
                  - false because of dw at 1004    can_define_item(1000,
                  6, word_flag()) - true, word at 1004 is destroyed (C++:
                  flags_t)
    @return: 1-yes, 0-no

Help on function change_storage_type in module ida_bytes:

change_storage_type(*args) -> 'error_t'
    change_storage_type(start_ea, end_ea, stt) -> error_t
    
    
    Change flag storage type for address range.
    
    @param start_ea: should be lower than end_ea. (C++: ea_t)
    @param end_ea: does not belong to the range. (C++: ea_t)
    @param stt: storage_type_t (C++: storage_type_t)
    @return: error code

Help on function char_flag in module ida_bytes:

char_flag(*args) -> 'flags_t'
    char_flag() -> flags_t
    
    
    see 'Bits: instruction operand types'

Help on function chunk_size in module ida_bytes:

chunk_size(*args) -> 'asize_t'
    chunk_size(ea) -> asize_t
    
    
    Get size of the contiguous address block containing 'ea'.
    
    @param ea (C++: ea_t)
    @return: 0 if 'ea' doesn't belong to the program.

Help on function chunk_start in module ida_bytes:

chunk_start(*args) -> 'ea_t'
    chunk_start(ea) -> ea_t
    
    
    Get start of the contiguous address block containing 'ea'.
    
    @param ea (C++: ea_t)
    @return: BADADDR  if 'ea' doesn't belong to the program.

Help on function clr_lzero in module ida_bytes:

clr_lzero(*args) -> 'bool'
    clr_lzero(ea, n) -> bool
    
    
    Clear lzero bit.
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function clr_op_type in module ida_bytes:

clr_op_type(*args) -> 'bool'
    clr_op_type(ea, n) -> bool
    
    
    Remove operand representation information. (set operand representation
    to be 'undefined')
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, -1) (C++: int)
    @return: success

Help on function code_flag in module ida_bytes:

code_flag(*args) -> 'flags_t'
    code_flag() -> flags_t
    
    
     'FF_CODE'

Help on function create_16bit_data in module ida_bytes:

create_16bit_data(*args) -> 'bool'
    create_16bit_data(ea, length) -> bool
    
    
    Convert to 16-bit quantity (take byte size into account)
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)

Help on function create_32bit_data in module ida_bytes:

create_32bit_data(*args) -> 'bool'
    create_32bit_data(ea, length) -> bool
    
    
    Convert to 32-bit quantity (take byte size into account)
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)

Help on function create_align in module ida_bytes:

create_align(*args) -> 'bool'
    create_align(ea, length, alignment) -> bool
    
    
    Alignment: 0 or 2..32. If it is 0, is will be calculated.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param alignment (C++: int)

Help on function create_byte in module ida_bytes:

create_byte(*args) -> 'bool'
    create_byte(ea, length, force=False) -> bool
    
    
    Convert to byte.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function create_custdata in module ida_bytes:

create_custdata(*args) -> 'bool'
    create_custdata(ea, length, dtid, fid, force=False) -> bool
    
    
    Convert to custom data type.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param dtid (C++: int)
    @param fid (C++: int)
    @param force (C++: bool)

Help on function create_data in module ida_bytes:

create_data(*args) -> 'bool'
    create_data(ea, dataflag, size, tid) -> bool
    
    
    Convert to data (byte, word, dword, etc). This function may be used to
    create arrays.
    
    @param ea: linear address (C++: ea_t)
    @param dataflag: type of data. Value of function  byte_flag() ,
                     word_flag() , etc. (C++: flags_t)
    @param size: size of array in bytes. should be divisible by the size
                 of one item of the specified type. for variable sized
                 items it can be specified as 0, and the kernel will try
                 to calculate the size. (C++: asize_t)
    @param tid: type id. If the specified type is a structure, then tid is
                structure id. Otherwise should be  BADNODE . (C++: tid_t)
    @return: success

Help on function create_double in module ida_bytes:

create_double(*args) -> 'bool'
    create_double(ea, length, force=False) -> bool
    
    
    Convert to double.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function create_dword in module ida_bytes:

create_dword(*args) -> 'bool'
    create_dword(ea, length, force=False) -> bool
    
    
    Convert to dword.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function create_float in module ida_bytes:

create_float(*args) -> 'bool'
    create_float(ea, length, force=False) -> bool
    
    
    Convert to float.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function create_oword in module ida_bytes:

create_oword(*args) -> 'bool'
    create_oword(ea, length, force=False) -> bool
    
    
    Convert to octaword/xmm word.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function create_packed_real in module ida_bytes:

create_packed_real(*args) -> 'bool'
    create_packed_real(ea, length, force=False) -> bool
    
    
    Convert to packed decimal real.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function create_qword in module ida_bytes:

create_qword(*args) -> 'bool'
    create_qword(ea, length, force=False) -> bool
    
    
    Convert to quadword.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function create_strlit in module ida_bytes:

create_strlit(*args) -> 'bool'
    create_strlit(start, len, strtype) -> bool
    
    
    Convert to string literal and give a meaningful name. 'start' may be
    higher than 'end', the kernel will swap them in this case
    
    @param start: starting address (C++: ea_t)
    @param len: length of the string in bytes. if 0, then
                get_max_strlit_length()  will be used to determine the
                length (C++: size_t)
    @param strtype: string type. one of  String type codes (C++: int32)
    @return: success

Help on function create_struct in module ida_bytes:

create_struct(*args) -> 'bool'
    create_struct(ea, length, tid, force=False) -> bool
    
    
    Convert to struct.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param tid (C++: tid_t)
    @param force (C++: bool)

Help on function create_tbyte in module ida_bytes:

create_tbyte(*args) -> 'bool'
    create_tbyte(ea, length, force=False) -> bool
    
    
    Convert to tbyte.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function create_word in module ida_bytes:

create_word(*args) -> 'bool'
    create_word(ea, length, force=False) -> bool
    
    
    Convert to word.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function create_yword in module ida_bytes:

create_yword(*args) -> 'bool'
    create_yword(ea, length, force=False) -> bool
    
    
    Convert to ymm word.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function create_zword in module ida_bytes:

create_zword(*args) -> 'bool'
    create_zword(ea, length, force=False) -> bool
    
    
    Convert to zmm word.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param force (C++: bool)

Help on function cust_flag in module ida_bytes:

cust_flag(*args) -> 'flags_t'
    cust_flag() -> flags_t
    
    
    Get a flags_t representing custom type data.

Help on function custfmt_flag in module ida_bytes:

custfmt_flag(*args) -> 'flags_t'
    custfmt_flag() -> flags_t
    
    
    see 'Bits: instruction operand types'

Help on class data_format_t in module ida_bytes:

class data_format_t(builtins.object)
 |  Proxy of C++ data_format_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __real__init__ = __init__(self, *args)
 |      __init__(self, _self, name, value_size=0, menu_name=None, props=0, hotkey=None, text_width=0) -> data_format_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_data_format_t(...)
 |      delete_data_format_t(self)
 |  
 |  _data_format_t__get_id = __get_id(self, *args) -> 'int'
 |      __get_id(self) -> int
 |  
 |  is_present_in_menus(self, *args) -> 'bool'
 |      is_present_in_menus(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hotkey
 |      data_format_t_hotkey_get(self) -> char const *
 |  
 |  id
 |      __get_id(self) -> int
 |  
 |  menu_name
 |      data_format_t_menu_name_get(self) -> char const *
 |  
 |  name
 |      data_format_t_name_get(self) -> char const *
 |  
 |  props
 |      data_format_t_props_get(self) -> int
 |  
 |  text_width
 |      data_format_t_text_width_get(self) -> int32
 |  
 |  thisown
 |      The membership flag
 |  
 |  value_size
 |      data_format_t_value_size_get(self) -> asize_t

Help on class data_type_t in module ida_bytes:

class data_type_t(builtins.object)
 |  Proxy of C++ data_type_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __real__init__ = __init__(self, *args)
 |      __init__(self, _self, name, value_size=0, menu_name=None, hotkey=None, asm_keyword=None, props=0) -> data_type_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_data_type_t(...)
 |      delete_data_type_t(self)
 |  
 |  _data_type_t__get_id = __get_id(self, *args) -> 'int'
 |      __get_id(self) -> int
 |  
 |  is_present_in_menus(self, *args) -> 'bool'
 |      is_present_in_menus(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  asm_keyword
 |      data_type_t_asm_keyword_get(self) -> char const *
 |  
 |  hotkey
 |      data_type_t_hotkey_get(self) -> char const *
 |  
 |  id
 |      __get_id(self) -> int
 |  
 |  menu_name
 |      data_type_t_menu_name_get(self) -> char const *
 |  
 |  name
 |      data_type_t_name_get(self) -> char const *
 |  
 |  props
 |      data_type_t_props_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  value_size
 |      data_type_t_value_size_get(self) -> asize_t

Help on function dec_flag in module ida_bytes:

dec_flag(*args) -> 'flags_t'
    dec_flag() -> flags_t
    
    
    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'

Help on function del_hidden_range in module ida_bytes:

del_hidden_range(*args) -> 'bool'
    del_hidden_range(ea) -> bool
    
    
    Delete hidden range.
    
    @param ea: any address in the hidden range (C++: ea_t)
    @return: success

Help on function del_items in module ida_bytes:

del_items(*args) -> 'bool'
    del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool
    
    
    Convert item (instruction/data) to unexplored bytes. The whole item
    (including the head and tail bytes) will be destroyed. It is allowed
    to pass any address in the item to this function
    
    @param ea: any address within the first item to delete (C++: ea_t)
    @param flags: combination of  Unexplored byte conversion flags (C++:
                  int)
    @param nbytes: number of bytes in the range to be undefined (C++:
                   asize_t)
    @param may_destroy: optional routine invoked before deleting a head
                        item. If callback returns false then item has not
                        to be deleted and operation fails (C++:
                        may_destroy_cb_t  *)
    @return: true on sucessful operation, otherwise false

Help on function del_mapping in module ida_bytes:

del_mapping(*args) -> 'void'
    del_mapping(ea)
    
    
    Delete memory mapping range.
    
    @param ea: any address in the mapped range (C++: ea_t)

Help on function del_value in module ida_bytes:

del_value(*args) -> 'void'
    del_value(ea)
    
    
    Delete byte value from flags. The corresponding byte becomes
    uninitialized.
    
    @param ea (C++: ea_t)

Help on function detach_custom_data_format in module ida_bytes:

detach_custom_data_format(*args) -> 'bool'
    detach_custom_data_format(dtid, dfid) -> bool
    
    
    Detach the data format from the data type. Unregistering a custom data
    type detaches all attached data formats, no need to detach them
    explicitly. You still need unregister them. Unregistering a custom
    data format detaches it from all attached data types.
    
    @param dtid: data type id to detach data format from (C++: int)
    @param dfid: data format id to detach (C++: int)

Help on function disable_flags in module ida_bytes:

disable_flags(*args) -> 'error_t'
    disable_flags(start_ea, end_ea) -> error_t
    
    
    Deallocate flags for address range. Exit with an error message if not
    enough disk space (this may occur too).
    
    @param start_ea: should be lower than end_ea. (C++: ea_t)
    @param end_ea: does not belong to the range. (C++: ea_t)
    @return: 0 if ok, otherwise return error code

Help on function double_flag in module ida_bytes:

double_flag(*args) -> 'flags_t'
    double_flag() -> flags_t
    
    
    Get a flags_t representing a double.

Help on function dword_flag in module ida_bytes:

dword_flag(*args) -> 'flags_t'
    dword_flag() -> flags_t
    
    
    Get a flags_t representing a double word.

Help on function enable_flags in module ida_bytes:

enable_flags(*args) -> 'error_t'
    enable_flags(start_ea, end_ea, stt) -> error_t
    
    
    Allocate flags for address range. This function does not change the
    storage type of existing ranges. Exit with an error message if not
    enough disk space.
    
    @param start_ea: should be lower than end_ea. (C++: ea_t)
    @param end_ea: does not belong to the range. (C++: ea_t)
    @param stt: storage_type_t (C++: storage_type_t)
    @return: 0 if ok, otherwise an error code

Help on function enum_flag in module ida_bytes:

enum_flag(*args) -> 'flags_t'
    enum_flag() -> flags_t
    
    
    see 'Bits: instruction operand types'

Help on function equal_bytes in module ida_bytes:

equal_bytes(*args) -> 'bool'
    equal_bytes(ea, image, mask, len, sense_case) -> bool
    
    
    Compare 'len' bytes of the program starting from 'ea' with 'image'.
    
    @param ea: linear address (C++: ea_t)
    @param image: bytes to compare with (C++: const  uchar  *)
    @param mask: array of 1/0 bytes, it's length is 'len'. 1 means to
                 perform the comparison of the corresponding byte. 0 means
                 not to perform. if mask == NULL, then all bytes of
                 'image' will be compared. if mask ==  SKIP_FF_MASK  then
                 0xFF bytes will be skipped (C++: const  uchar  *)
    @param len: length of block to compare in bytes. (C++: size_t)
    @param sense_case: case-sensitive comparison? (C++: bool)

Help on function f_has_cmt in module ida_bytes:

f_has_cmt(*args) -> 'bool'
    f_has_cmt(f, arg2) -> bool

Help on function f_has_dummy_name in module ida_bytes:

f_has_dummy_name(*args) -> 'bool'
    f_has_dummy_name(f, arg2) -> bool
    
    
    Does the current byte have dummy (auto-generated, with special prefix)
    name?
    
    
    @param f (C++: flags_t)

Help on function f_has_extra_cmts in module ida_bytes:

f_has_extra_cmts(*args) -> 'bool'
    f_has_extra_cmts(f, arg2) -> bool

Help on function f_has_name in module ida_bytes:

f_has_name(*args) -> 'bool'
    f_has_name(f, arg2) -> bool
    
    
    Does the current byte have non-trivial (non-dummy) name?
    
    
    @param f (C++: flags_t)

Help on function f_has_user_name in module ida_bytes:

f_has_user_name(*args) -> 'bool'
    f_has_user_name(F, arg2) -> bool
    
    
    Does the current byte have user-specified name?
    
    
    @param F (C++: flags_t)

Help on function f_has_xref in module ida_bytes:

f_has_xref(*args) -> 'bool'
    f_has_xref(f, arg2) -> bool
    
    
    Does the current byte have cross-references to it?
    
    
    @param f (C++: flags_t)

Help on function f_is_align in module ida_bytes:

f_is_align(*args) -> 'bool'
    f_is_align(F, arg2) -> bool
    
    
    See 'is_align()'
    
    
    @param F (C++: flags_t)

Help on function f_is_byte in module ida_bytes:

f_is_byte(*args) -> 'bool'
    f_is_byte(F, arg2) -> bool
    
    
    See 'is_byte()'
    
    
    @param F (C++: flags_t)

Help on function f_is_code in module ida_bytes:

f_is_code(*args) -> 'bool'
    f_is_code(F, arg2) -> bool
    
    
    Does flag denote start of an instruction?
    
    
    @param F (C++: flags_t)

Help on function f_is_custom in module ida_bytes:

f_is_custom(*args) -> 'bool'
    f_is_custom(F, arg2) -> bool
    
    
    See 'is_custom()'
    
    
    @param F (C++: flags_t)

Help on function f_is_data in module ida_bytes:

f_is_data(*args) -> 'bool'
    f_is_data(F, arg2) -> bool
    
    
    Does flag denote start of data?
    
    
    @param F (C++: flags_t)

Help on function f_is_double in module ida_bytes:

f_is_double(*args) -> 'bool'
    f_is_double(F, arg2) -> bool
    
    
    See 'is_double()'
    
    
    @param F (C++: flags_t)

Help on function f_is_dword in module ida_bytes:

f_is_dword(*args) -> 'bool'
    f_is_dword(F, arg2) -> bool
    
    
    See 'is_dword()'
    
    
    @param F (C++: flags_t)

Help on function f_is_float in module ida_bytes:

f_is_float(*args) -> 'bool'
    f_is_float(F, arg2) -> bool
    
    
    See 'is_float()'
    
    
    @param F (C++: flags_t)

Help on function f_is_head in module ida_bytes:

f_is_head(*args) -> 'bool'
    f_is_head(F, arg2) -> bool
    
    
    Does flag denote start of instruction OR data?
    
    
    @param F (C++: flags_t)

Help on function f_is_not_tail in module ida_bytes:

f_is_not_tail(*args) -> 'bool'
    f_is_not_tail(F, arg2) -> bool
    
    
    Does flag denote tail byte?
    
    
    @param F (C++: flags_t)

Help on function f_is_oword in module ida_bytes:

f_is_oword(*args) -> 'bool'
    f_is_oword(F, arg2) -> bool
    
    
    See 'is_oword()'
    
    
    @param F (C++: flags_t)

Help on function f_is_pack_real in module ida_bytes:

f_is_pack_real(*args) -> 'bool'
    f_is_pack_real(F, arg2) -> bool
    
    
    See 'is_pack_real()'
    
    
    @param F (C++: flags_t)

Help on function f_is_qword in module ida_bytes:

f_is_qword(*args) -> 'bool'
    f_is_qword(F, arg2) -> bool
    
    
    See 'is_qword()'
    
    
    @param F (C++: flags_t)

Help on function f_is_strlit in module ida_bytes:

f_is_strlit(*args) -> 'bool'
    f_is_strlit(F, arg2) -> bool
    
    
    See 'is_strlit()'
    
    
    @param F (C++: flags_t)

Help on function f_is_struct in module ida_bytes:

f_is_struct(*args) -> 'bool'
    f_is_struct(F, arg2) -> bool
    
    
    See 'is_struct()'
    
    
    @param F (C++: flags_t)

Help on function f_is_tail in module ida_bytes:

f_is_tail(*args) -> 'bool'
    f_is_tail(F, arg2) -> bool
    
    
    Does flag denote tail byte?
    
    
    @param F (C++: flags_t)

Help on function f_is_tbyte in module ida_bytes:

f_is_tbyte(*args) -> 'bool'
    f_is_tbyte(F, arg2) -> bool
    
    
    See 'is_tbyte()'
    
    
    @param F (C++: flags_t)

Help on function f_is_word in module ida_bytes:

f_is_word(*args) -> 'bool'
    f_is_word(F, arg2) -> bool
    
    
    See 'is_word()'
    
    
    @param F (C++: flags_t)

Help on function f_is_yword in module ida_bytes:

f_is_yword(*args) -> 'bool'
    f_is_yword(F, arg2) -> bool
    
    
    See 'is_yword()'
    
    
    @param F (C++: flags_t)

Help on function find_byte in module ida_bytes:

find_byte(*args) -> 'ea_t'
    find_byte(sEA, size, value, bin_search_flags) -> ea_t
    
    
    Find forward a byte with the specified value (only 8-bit value from
    the database). example: ea=4 size=3 will inspect addresses 4, 5, and 6
    
    @param sEA: linear address (C++: ea_t)
    @param size: number of bytes to inspect (C++: asize_t)
    @param value: value to find (C++: uchar)
    @param bin_search_flags: combination of  Search flags (C++: int)
    @return: address of byte or  BADADDR

Help on function find_byter in module ida_bytes:

find_byter(*args) -> 'ea_t'
    find_byter(sEA, size, value, bin_search_flags) -> ea_t
    
    
    Find reverse a byte with the specified value (only 8-bit value from
    the database). example: ea=4 size=3 will inspect addresses 6, 5, and 4
    
    @param sEA: the lower address of the search range (C++: ea_t)
    @param size: number of bytes to inspect (C++: asize_t)
    @param value: value to find (C++: uchar)
    @param bin_search_flags: combination of  Search flags (C++: int)
    @return: address of byte or  BADADDR

Help on function find_custom_data_format in module ida_bytes:

find_custom_data_format(*args) -> 'int'
    find_custom_data_format(name) -> int
    
    
    Get id of a custom data format.
    
    @param name: name of the custom data format (C++: const char *)
    @return: id or -1

Help on function find_custom_data_type in module ida_bytes:

find_custom_data_type(*args) -> 'int'
    find_custom_data_type(name) -> int
    
    
    Get id of a custom data type.
    
    @param name: name of the custom data type (C++: const char *)
    @return: id or -1

Help on function float_flag in module ida_bytes:

float_flag(*args) -> 'flags_t'
    float_flag() -> flags_t
    
    
    Get a flags_t representing a float.

Help on function flt_flag in module ida_bytes:

flt_flag(*args) -> 'flags_t'
    flt_flag() -> flags_t
    
    
    see 'Bits: instruction operand types'

Help on function free_chunk in module ida_bytes:

free_chunk(*args) -> 'ea_t'
    free_chunk(bottom, size, step) -> ea_t
    
    
    Search for a hole in the addressing space of the program.
    
    @param bottom: address to start searching (C++: ea_t)
    @param size: size of desired block (C++: asize_t)
    @param step: bit mask for the start of hole (0xF would align hole to a
                 paragraph). if 'step' is negative, the bottom address
                 with be aligned. otherwise the kernel will try to use it
                 as is and align it only when the hole is too small. (C++:
                 int32)
    @return: start of the hole or  BADADDR

Help on function get_16bit in module ida_bytes:

get_16bit(*args) -> 'uint32'
    get_16bit(ea) -> uint32
    
    
    Get 16bits of the program at 'ea'.
    
    @param ea (C++: ea_t)
    @return: 1 byte (getFullByte()) if the current processor has 16-bit
             byte, otherwise return  get_word()

Help on function get_32bit in module ida_bytes:

get_32bit(*args) -> 'uint32'
    get_32bit(ea) -> uint32
    
    
    Get not more than 32bits of the program at 'ea'.
    
    @param ea (C++: ea_t)
    @return: 32 bit value, depending on \ph{nbits}:   if ( nbits <= 8 )
             return get_dword(ea);   if ( nbits <= 16) return
             get_wide_word(ea);   return get_wide_byte(ea);

Help on function get_64bit in module ida_bytes:

get_64bit(*args) -> 'uint64'
    get_64bit(ea) -> uint64
    
    
    Get not more than 64bits of the program at 'ea'.
    
    @param ea (C++: ea_t)
    @return: 64 bit value, depending on \ph{nbits}:   if ( nbits <= 8 )
             return get_qword(ea);   if ( nbits <= 16) return
             get_wide_dword(ea);   return get_wide_byte(ea);

Help on function get_8bit in module ida_bytes:

get_8bit(*args) -> 'PyObject *'
    get_8bit(ea, v, nbit) -> PyObject *

Help on function get_byte in module ida_bytes:

get_byte(*args) -> 'uchar'
    get_byte(ea) -> uchar
    
    
    Get one byte (8-bit) of the program at 'ea'. This function works only
    for 8bit byte processors.
    
    @param ea (C++: ea_t)

Help on function get_bytes in module ida_bytes:

get_bytes(*args) -> 'PyObject *'
    get_bytes(ea, size, gmb_flags=0x01) -> PyObject *
    
    
    Get the specified number of bytes of the program.
    @param ea: program address
    @param size: number of bytes to return
    @return: the bytes (as a str), or None in case of failure

Help on function get_bytes_and_mask in module ida_bytes:

get_bytes_and_mask(*args) -> 'PyObject *'
    get_bytes_and_mask(ea, size, gmb_flags=0x01) -> PyObject *
    
    
    Get the specified number of bytes of the program, and a bitmask
    specifying what bytes are defined and what bytes are not.
    @param ea: program address
    @param size: number of bytes to return
    @return: a tuple (bytes, mask), or None in case of failure.
             Both 'bytes' and 'mask' are 'str' instances.

Help on function get_cmt in module ida_bytes:

get_cmt(*args) -> 'qstring *'
    get_cmt(ea, rptble) -> str
    
    
    Get an indented comment.
    
    @param ea: linear address. may point to tail byte, the function will
               find start of the item (C++: ea_t)
    @param rptble: get repeatable comment? (C++: bool)
    @return: size of comment or -1

Help on function get_custom_data_format in module ida_bytes:

get_custom_data_format(*args) -> 'data_format_t const *'
    get_custom_data_format(dfid) -> data_format_t
    
    
    Get definition of a registered custom data format.
    
    @param dfid: data format id (C++: int)
    @return: data format definition or NULL

Help on function get_custom_data_formats in module ida_bytes:

get_custom_data_formats(*args) -> 'int'
    get_custom_data_formats(out, dtid) -> int
    
    
    Get list of attached custom data formats for the specified data type.
    
    @param out: buffer for the output. may be NULL (C++: intvec_t  *)
    @param dtid: data type id (C++: int)
    @return: number of returned custom data formats. if error, returns -1

Help on function get_custom_data_type in module ida_bytes:

get_custom_data_type(*args) -> 'data_type_t const *'
    get_custom_data_type(dtid) -> data_type_t
    
    
    Get definition of a registered custom data type.
    
    @param dtid: data type id (C++: int)
    @return: data type definition or NULL

Help on function get_custom_data_types in module ida_bytes:

get_custom_data_types(*args) -> 'int'
    get_custom_data_types(out, min_size=0, max_size=BADADDR) -> int
    
    
    Get list of registered custom data type ids.
    
    @param out: buffer for the output. may be NULL (C++: intvec_t  *)
    @param min_size: minimum value size (C++: asize_t)
    @param max_size: maximum value size (C++: asize_t)
    @return: number of custom data types with the specified size limits

Help on function get_data_elsize in module ida_bytes:

get_data_elsize(*args) -> 'asize_t'
    get_data_elsize(ea, F, ti=None) -> asize_t
    
    
    Get size of data type specified in flags 'F'.
    
    @param ea: linear address of the item (C++: ea_t)
    @param F: flags (C++: flags_t)
    @param ti: additional information about the data type. For example, if
               the current item is a structure instance, then ti->tid is
               structure id. Otherwise is ignored (may be NULL). If
               specified as NULL, will be automatically retrieved from the
               database (C++: const  opinfo_t  *)
    @return: byte : 1   word : 2   etc...

Help on function get_data_value in module ida_bytes:

get_data_value(*args) -> 'bool'
    get_data_value(v, ea, size) -> bool
    
    
    Get the value at of the item at 'ea'. This function works with
    entities up to sizeof(ea_t) (bytes, word, etc)
    
    @param v: pointer to the result. may be NULL (C++: uval_t  *)
    @param ea: linear address (C++: ea_t)
    @param size: size of data to read. If 0, then the item type at 'ea'
                 will be used (C++: asize_t)
    @return: success

Help on function get_db_byte in module ida_bytes:

get_db_byte(*args) -> 'uchar'
    get_db_byte(ea) -> uchar
    
    
    Get one byte (8-bit) of the program at 'ea' from the database. Works
    even if the debugger is active. See also 'get_dbg_byte()' to read the
    process memory directly. This function works only for 8bit byte
    processors.
    
    @param ea (C++: ea_t)

Help on function get_default_radix in module ida_bytes:

get_default_radix(*args) -> 'int'
    get_default_radix() -> int
    
    
    Get default base of number for the current processor.
    
    @return: 2, 8, 10, 16

Help on function get_dword in module ida_bytes:

get_dword(*args) -> 'uint32'
    get_dword(ea) -> uint32
    
    
    Get one dword (32-bit) of the program at 'ea'. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    works only for 8bit byte processors.
    
    @param ea (C++: ea_t)

Help on function get_enum_id in module ida_bytes:

get_enum_id(*args) -> 'uchar *'
    get_enum_id(ea, n) -> enum_t
    
    
    Get enum id of 'enum' operand.
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, -1) (C++: int)
    @return: id of enum or  BADNODE

Help on function get_first_hidden_range in module ida_bytes:

get_first_hidden_range(*args) -> 'hidden_range_t *'
    get_first_hidden_range() -> hidden_range_t
    
    
    Get pointer to the first hidden range.
    
    @return: ptr to hidden range or NULL

Help on function get_flags in module ida_bytes:

get_flags(*args) -> 'flags_t'
    get_flags(ea) -> flags_t
    
    
    get flags with 'FF_IVL' & 'MS_VAL' . It is much slower under remote
    debugging because the kernel needs to read the process memory.
    
    @param ea (C++: ea_t)

Help on function get_flags_by_size in module ida_bytes:

get_flags_by_size(*args) -> 'flags_t'
    get_flags_by_size(size) -> flags_t
    
    
    Get flags from size (in bytes). Supported sizes: 1, 2, 4, 8, 16, 32.
    For other sizes returns 0
    
    @param size (C++: size_t)

Help on function get_flags_ex in module ida_bytes:

get_flags_ex(*args) -> 'flags_t'
    get_flags_ex(ea, how) -> flags_t
    
    
    Get flags for the specified address, extended form.
    
    
    @param ea (C++: ea_t)
    @param how (C++: int)

Help on function get_forced_operand in module ida_bytes:

get_forced_operand(*args) -> 'qstring *'
    get_forced_operand(ea, n) -> str
    
    
    Get forced operand.
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, 2) (C++: int)
    @return: size of forced operand or -1

Help on function get_full_data_elsize in module ida_bytes:

get_full_data_elsize(*args) -> 'asize_t'
    get_full_data_elsize(ea, F, ti=None) -> asize_t
    
    
    Get full size of data type specified in flags 'F'. takes into account
    processors with wide bytes e.g. returns 2 for a byte element with
    16-bit bytes
    
    @param ea (C++: ea_t)
    @param F (C++: flags_t)
    @param ti (C++: const  opinfo_t  *)

Help on function get_full_flags in module ida_bytes:

get_full_flags(*args) -> 'flags_t'
    get_full_flags(ea) -> flags_t
    
    
    Get flags value for address 'ea'.
    
    @param ea (C++: ea_t)
    @return: 0 if address is not present in the program

Help on function get_hidden_range in module ida_bytes:

get_hidden_range(*args) -> 'hidden_range_t *'
    get_hidden_range(ea) -> hidden_range_t
    
    
    Get pointer to hidden range structure, in: linear address.
    
    @param ea: any address in the hidden range (C++: ea_t)

Help on function get_hidden_range_num in module ida_bytes:

get_hidden_range_num(*args) -> 'int'
    get_hidden_range_num(ea) -> int
    
    
    Get number of a hidden range.
    
    @param ea: any address in the hidden range (C++: ea_t)
    @return: number of hidden range (0.. get_hidden_range_qty() -1)

Help on function get_hidden_range_qty in module ida_bytes:

get_hidden_range_qty(*args) -> 'int'
    get_hidden_range_qty() -> int
    
    
    Get number of hidden ranges.

Help on function get_item_end in module ida_bytes:

get_item_end(*args) -> 'ea_t'
    get_item_end(ea) -> ea_t
    
    
    Get the end address of the item at 'ea'. The returned address doesn't
    belong to the current item. Unexplored bytes are counted as 1 byte
    entities.
    
    @param ea (C++: ea_t)

Help on function get_item_flag in module ida_bytes:

get_item_flag(*args) -> 'flags_t'
    get_item_flag(_from, n, ea, appzero) -> flags_t
    
    
    Get flag of the item at 'ea' even if it is a tail byte of some array
    or structure. This function is used to get flags of structure members
    or array elements.
    
    @param _from: linear address of the instruction which refers to 'ea'
                  (C++: ea_t)
    @param n: number of operand which refers to 'ea' (C++: int)
    @param ea: the referenced address (C++: ea_t)
    @param appzero: append a struct field name if the field offset is
                    zero? meaningful only if the name refers to a
                    structure. (C++: bool)
    @return: flags or 0 (if failed)

Help on function get_item_head in module ida_bytes:

get_item_head(*args) -> 'ea_t'
    get_item_head(ea) -> ea_t
    
    
    Get the start address of the item at 'ea'. If there is no current
    item, then 'ea' will be returned (see definition at the end of
    'bytes.hpp' source)
    
    @param ea (C++: ea_t)

Help on function get_item_size in module ida_bytes:

get_item_size(*args) -> 'asize_t'
    get_item_size(ea) -> asize_t
    
    
    Get size of item (instruction/data) in bytes. Unexplored bytes have
    length of 1 byte. This function never returns 0.
    
    @param ea (C++: ea_t)

Help on function get_last_hidden_range in module ida_bytes:

get_last_hidden_range(*args) -> 'hidden_range_t *'
    get_last_hidden_range() -> hidden_range_t
    
    
    Get pointer to the last hidden range.
    
    @return: ptr to hidden range or NULL

Help on function get_manual_insn in module ida_bytes:

get_manual_insn(*args) -> 'qstring *'
    get_manual_insn(ea) -> str
    
    
    Retrieve the user-specified string for the manual instruction.
    
    @param ea: linear address of the instruction or data item (C++: ea_t)
    @return: size of manual instruction or -1

Help on function get_mapping in module ida_bytes:

get_mapping(*args) -> 'ea_t *, ea_t *, asize_t *'
    get_mapping(n) -> bool
    
    
    Get memory mapping range by its number.
    
    @param n: number of mapping range (0.. get_mappings_qty() -1) (C++:
              size_t)
    @return: false if the specified range doesn't exist, otherwise returns
             from ,  to ,  size

Help on function get_mappings_qty in module ida_bytes:

get_mappings_qty(*args) -> 'size_t'
    get_mappings_qty() -> size_t
    
    
    Get number of mappings.

Help on function get_max_strlit_length in module ida_bytes:

get_max_strlit_length(*args) -> 'size_t'
    get_max_strlit_length(ea, strtype, options=0) -> size_t
    
    
    Determine maximum length of string literal.
    
    @param ea: starting address (C++: ea_t)
    @param strtype: string type. one of  String type codes (C++: int32)
    @param options: combination of  string literal length options (C++:
                    int)
    @return: length of the string in octets (octet==8bit)

Help on function get_next_hidden_range in module ida_bytes:

get_next_hidden_range(*args) -> 'hidden_range_t *'
    get_next_hidden_range(ea) -> hidden_range_t
    
    
    Get pointer to next hidden range.
    
    @param ea: any address in the program (C++: ea_t)
    @return: ptr to hidden range or NULL if next hidden range doesn't
             exist

Help on function get_octet in module ida_bytes:

get_octet(*args) -> 'PyObject *'
    get_octet(ea, v, nbit) -> PyObject *
    
    
    Get 8 bits of the program at 'ea'. The main usage of this function is
    to iterate range of bytes. Here is an example:
    
    uint64 v;
    int nbit = 0;
    for ( ... ) {
      uchar byte = get_octet(&ea, &v, &nbit);
      ...
    }
    
    'ea' is incremented each time when a new byte is read. In the above
    example, it will be incremented in the first loop iteration.
    
    @param ea (C++: ea_t *)
    @param v (C++: uint64  *)
    @param nbit (C++: int *)

Help on function get_opinfo in module ida_bytes:

get_opinfo(*args) -> 'opinfo_t *'
    get_opinfo(buf, ea, n, flags) -> opinfo_t
    
    
    Get additional information about an operand representation.
    
    @param buf: buffer to receive the result. may not be NULL (C++:
                opinfo_t  *)
    @param ea: linear address of item (C++: ea_t)
    @param n: number of operand, 0 or 1 (C++: int)
    @param flags: flags of the item (C++: flags_t)
    @return: NULL if no additional representation information

Help on function get_optype_flags0 in module ida_bytes:

get_optype_flags0(*args) -> 'flags_t'
    get_optype_flags0(F) -> flags_t
    
    
    Get flags for first operand.
    
    
    @param F (C++: flags_t)

Help on function get_optype_flags1 in module ida_bytes:

get_optype_flags1(*args) -> 'flags_t'
    get_optype_flags1(F) -> flags_t
    
    
    Get flags for second operand.
    
    
    @param F (C++: flags_t)

Help on function get_original_byte in module ida_bytes:

get_original_byte(*args) -> 'uint64'
    get_original_byte(ea) -> uint64
    
    
    Get original byte value (that was before patching). This function
    works for wide byte processors too.
    
    @param ea (C++: ea_t)

Help on function get_original_dword in module ida_bytes:

get_original_dword(*args) -> 'uint64'
    get_original_dword(ea) -> uint64
    
    
    Get original dword (that was before patching) This function works for
    wide byte processors too. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)

Help on function get_original_qword in module ida_bytes:

get_original_qword(*args) -> 'uint64'
    get_original_qword(ea) -> uint64
    
    
    Get original qword value (that was before patching) This function
    DOESN'T work for wide byte processors too. This function takes into
    account order of bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)

Help on function get_original_word in module ida_bytes:

get_original_word(*args) -> 'uint64'
    get_original_word(ea) -> uint64
    
    
    Get original word value (that was before patching). This function
    works for wide byte processors too. This function takes into account
    order of bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)

Help on function get_predef_insn_cmt in module ida_bytes:

get_predef_insn_cmt(*args) -> 'qstring *'
    get_predef_insn_cmt(ins) -> str
    
    
    Get predefined comment.
    
    @param ins: current instruction information (C++: const  insn_t  &)
    @return: size of comment or -1

Help on function get_prev_hidden_range in module ida_bytes:

get_prev_hidden_range(*args) -> 'hidden_range_t *'
    get_prev_hidden_range(ea) -> hidden_range_t
    
    
    Get pointer to previous hidden range.
    
    @param ea: any address in the program (C++: ea_t)
    @return: ptr to hidden range or NULL if previous hidden range doesn't
             exist

Help on function get_qword in module ida_bytes:

get_qword(*args) -> 'uint64'
    get_qword(ea) -> uint64
    
    
    Get one qword (64-bit) of the program at 'ea'. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    works only for 8bit byte processors.
    
    @param ea (C++: ea_t)

Help on function get_radix in module ida_bytes:

get_radix(*args) -> 'int'
    get_radix(F, n) -> int
    
    
    Get radix of the operand, in: flags. If the operand is not a number,
    returns 'get_default_radix()'
    
    @param F: flags (C++: flags_t)
    @param n: number of operand (0, 1, -1) (C++: int)
    @return: 2, 8, 10, 16

Help on function get_strlit_contents in module ida_bytes:

get_strlit_contents(*args) -> 'PyObject *'
    get_strlit_contents(ea, py_len, type, flags=0) -> PyObject *
    
    
    Get bytes contents at location, possibly converted.
    It works even if the string has not been created in the database yet.
    
    Note that this will <b>always</b> return a simple string of bytes
    (i.e., a 'str' instance), and not a string of unicode characters.
    
    If you want auto-conversion to unicode strings (that is: real strings),
    you should probably be using the idautils.Strings class.
    
    @param ea: linear address of the string
    @param len: length of the string in bytes (including terminating 0)
    @param type: type of the string. Represents both the character encoding,
                 <u>and</u> the 'type' of string at the given location.
    @param flags: combination of STRCONV_..., to perform output conversion.
    @return: a bytes-filled str object.

Help on function get_stroff_path in module ida_bytes:

get_stroff_path(*args) -> 'int'
    get_stroff_path(path, delta, ea, n) -> int
    
    
    Get struct path of operand.
    
    @param path: buffer for structure path (strpath). see  nalt.hpp  for
                 more info. (C++: tid_t  *)
    @param delta: struct offset delta (C++: adiff_t *)
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, -1) (C++: int)
    @return: length of strpath

Help on function get_wide_byte in module ida_bytes:

get_wide_byte(*args) -> 'uint64'
    get_wide_byte(ea) -> uint64
    
    
    Get one wide byte of the program at 'ea'. Some processors may access
    more than 8bit quantity at an address. These processors have 32-bit
    byte organization from the IDA's point of view.
    
    @param ea (C++: ea_t)

Help on function get_wide_dword in module ida_bytes:

get_wide_dword(*args) -> 'uint64'
    get_wide_dword(ea) -> uint64
    
    
    Get two wide words (4 'bytes') of the program at 'ea'. Some processors
    may access more than 8bit quantity at an address. These processors
    have 32-bit byte organization from the IDA's point of view. This
    function takes into account order of bytes specified in
    \inf{is_be()}this function works incorrectly if \ph{nbits} > 16
    
    @param ea (C++: ea_t)

Help on function get_wide_word in module ida_bytes:

get_wide_word(*args) -> 'uint64'
    get_wide_word(ea) -> uint64
    
    
    Get one wide word (2 'byte') of the program at 'ea'. Some processors
    may access more than 8bit quantity at an address. These processors
    have 32-bit byte organization from the IDA's point of view. This
    function takes into account order of bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)

Help on function get_word in module ida_bytes:

get_word(*args) -> 'ushort'
    get_word(ea) -> ushort
    
    
    Get one word (16-bit) of the program at 'ea'. This function takes into
    account order of bytes specified in \inf{is_be()} This function works
    only for 8bit byte processors.
    
    @param ea (C++: ea_t)

Help on function get_zero_ranges in module ida_bytes:

get_zero_ranges(*args) -> 'bool'
    get_zero_ranges(zranges, range) -> bool
    
    
    Return set of ranges with zero initialized bytes. The returned set
    includes only big zero initialized ranges (at least >1KB). Some zero
    initialized byte ranges may be not included. Only zero bytes that use
    the sparse storage method (STT_MM) are reported.
    
    @param zranges: pointer to the return value. cannot be NULL (C++:
                    rangeset_t  *)
    @param range: the range of addresses to verify. can be NULL - means
                  all ranges (C++: const  range_t  *)
    @return: true if the result is a non-empty set

Help on function getn_hidden_range in module ida_bytes:

getn_hidden_range(*args) -> 'hidden_range_t *'
    getn_hidden_range(n) -> hidden_range_t
    
    
    Get pointer to hidden range structure, in: number of hidden range.
    
    @param n: number of hidden range, is in range 0..
              get_hidden_range_qty() -1 (C++: int)

Help on function has_any_name in module ida_bytes:

has_any_name(*args) -> 'bool'
    has_any_name(F) -> bool
    
    
    Does the current byte have any name?
    
    
    @param F (C++: flags_t)

Help on function has_auto_name in module ida_bytes:

has_auto_name(*args) -> 'bool'
    has_auto_name(F) -> bool
    
    
    Does the current byte have auto-generated (no special prefix) name?
    
    
    @param F (C++: flags_t)

Help on function has_cmt in module ida_bytes:

has_cmt(*args) -> 'bool'
    has_cmt(F) -> bool
    
    
    Does the current byte have an indented comment?
    
    
    @param F (C++: flags_t)

Help on function has_dummy_name in module ida_bytes:

has_dummy_name(*args) -> 'bool'
    has_dummy_name(F) -> bool
    
    
    Does the current byte have dummy (auto-generated, with special prefix)
    name?
    
    
    @param F (C++: flags_t)

Help on function has_extra_cmts in module ida_bytes:

has_extra_cmts(*args) -> 'bool'
    has_extra_cmts(F) -> bool
    
    
    Does the current byte have additional anterior or posterior lines?
    
    
    @param F (C++: flags_t)

Help on function has_immd in module ida_bytes:

has_immd(*args) -> 'bool'
    has_immd(F) -> bool
    
    
    Has immediate value?
    
    
    @param F (C++: flags_t)

Help on function has_name in module ida_bytes:

has_name(*args) -> 'bool'
    has_name(F) -> bool
    
    
    Does the current byte have non-trivial (non-dummy) name?
    
    
    @param F (C++: flags_t)

Help on function has_user_name in module ida_bytes:

has_user_name(*args) -> 'bool'
    has_user_name(F) -> bool
    
    
    Does the current byte have user-specified name?
    
    
    @param F (C++: flags_t)

Help on function has_value in module ida_bytes:

has_value(*args) -> 'bool'
    has_value(F) -> bool
    
    
    Do flags contain byte value?
    
    
    @param F (C++: flags_t)

Help on function has_xref in module ida_bytes:

has_xref(*args) -> 'bool'
    has_xref(F) -> bool
    
    
    Does the current byte have cross-references to it?
    
    
    @param F (C++: flags_t)

Help on function hex_flag in module ida_bytes:

hex_flag(*args) -> 'flags_t'
    hex_flag() -> flags_t
    
    
    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'

Help on class hidden_range_t in module ida_bytes:

class hidden_range_t(ida_range.range_t)
 |  Proxy of C++ hidden_range_t class.
 |  
 |  Method resolution order:
 |      hidden_range_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hidden_range_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_hidden_range_t(...)
 |      delete_hidden_range_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  color
 |      hidden_range_t_color_get(self) -> bgcolor_t
 |  
 |  description
 |      hidden_range_t_description_get(self) -> char *
 |  
 |  footer
 |      hidden_range_t_footer_get(self) -> char *
 |  
 |  header
 |      hidden_range_t_header_get(self) -> char *
 |  
 |  thisown
 |      The membership flag
 |  
 |  visible
 |      hidden_range_t_visible_get(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      contains(self, r) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on function is_align in module ida_bytes:

is_align(*args) -> 'bool'
    is_align(F) -> bool
    
    
     'FF_ALIGN'
    
    
    @param F (C++: flags_t)

Help on function is_attached_custom_data_format in module ida_bytes:

is_attached_custom_data_format(*args) -> 'bool'
    is_attached_custom_data_format(dtid, dfid) -> bool

Help on function is_bnot in module ida_bytes:

is_bnot(*args) -> 'bool'
    is_bnot(ea, F, n) -> bool
    
    
    Should we negate the operand?. \ash{a_bnot} should be defined in the
    idp module in order to work with this function
    
    @param ea (C++: ea_t)
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_byte in module ida_bytes:

is_byte(*args) -> 'bool'
    is_byte(F) -> bool
    
    
     'FF_BYTE'
    
    
    @param F (C++: flags_t)

Help on function is_char in module ida_bytes:

is_char(*args) -> 'bool'
    is_char(F, n) -> bool
    
    
    is character constant?
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_char0 in module ida_bytes:

is_char0(*args) -> 'bool'
    is_char0(F) -> bool
    
    
    Is the first operand character constant? (example: push 'a')
    
    
    @param F (C++: flags_t)

Help on function is_char1 in module ida_bytes:

is_char1(*args) -> 'bool'
    is_char1(F) -> bool
    
    
    Is the second operand character constant? (example: mov al, 'a')
    
    
    @param F (C++: flags_t)

Help on function is_code in module ida_bytes:

is_code(*args) -> 'bool'
    is_code(F) -> bool
    
    
    Does flag denote start of an instruction?
    
    
    @param F (C++: flags_t)

Help on function is_custfmt in module ida_bytes:

is_custfmt(*args) -> 'bool'
    is_custfmt(F, n) -> bool
    
    
    is custom data format?
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_custfmt0 in module ida_bytes:

is_custfmt0(*args) -> 'bool'
    is_custfmt0(F) -> bool
    
    
    Does the first operand use a custom data representation?
    
    
    @param F (C++: flags_t)

Help on function is_custfmt1 in module ida_bytes:

is_custfmt1(*args) -> 'bool'
    is_custfmt1(F) -> bool
    
    
    Does the second operand use a custom data representation?
    
    
    @param F (C++: flags_t)

Help on function is_custom in module ida_bytes:

is_custom(*args) -> 'bool'
    is_custom(F) -> bool
    
    
     'FF_CUSTOM'
    
    
    @param F (C++: flags_t)

Help on function is_data in module ida_bytes:

is_data(*args) -> 'bool'
    is_data(F) -> bool
    
    
    Does flag denote start of data?
    
    
    @param F (C++: flags_t)

Help on function is_defarg in module ida_bytes:

is_defarg(*args) -> 'bool'
    is_defarg(F, n) -> bool
    
    
    is defined?
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_defarg0 in module ida_bytes:

is_defarg0(*args) -> 'bool'
    is_defarg0(F) -> bool
    
    
    Is the first operand defined? Initially operand has no defined
    representation.
    
    
    @param F (C++: flags_t)

Help on function is_defarg1 in module ida_bytes:

is_defarg1(*args) -> 'bool'
    is_defarg1(F) -> bool
    
    
    Is the second operand defined? Initially operand has no defined
    representation.
    
    
    @param F (C++: flags_t)

Help on function is_double in module ida_bytes:

is_double(*args) -> 'bool'
    is_double(F) -> bool
    
    
     'FF_DOUBLE'
    
    
    @param F (C++: flags_t)

Help on function is_dword in module ida_bytes:

is_dword(*args) -> 'bool'
    is_dword(F) -> bool
    
    
     'FF_DWORD'
    
    
    @param F (C++: flags_t)

Help on function is_enum in module ida_bytes:

is_enum(*args) -> 'bool'
    is_enum(F, n) -> bool
    
    
    is enum?
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_enum0 in module ida_bytes:

is_enum0(*args) -> 'bool'
    is_enum0(F) -> bool
    
    
    Is the first operand a symbolic constant (enum member)?
    
    
    @param F (C++: flags_t)

Help on function is_enum1 in module ida_bytes:

is_enum1(*args) -> 'bool'
    is_enum1(F) -> bool
    
    
    Is the second operand a symbolic constant (enum member)?
    
    
    @param F (C++: flags_t)

Help on function is_float in module ida_bytes:

is_float(*args) -> 'bool'
    is_float(F) -> bool
    
    
     'FF_FLOAT'
    
    
    @param F (C++: flags_t)

Help on function is_float0 in module ida_bytes:

is_float0(*args) -> 'bool'
    is_float0(F) -> bool
    
    
    Is the first operand a floating point number?
    
    
    @param F (C++: flags_t)

Help on function is_float1 in module ida_bytes:

is_float1(*args) -> 'bool'
    is_float1(F) -> bool
    
    
    Is the second operand a floating point number?
    
    
    @param F (C++: flags_t)

Help on function is_flow in module ida_bytes:

is_flow(*args) -> 'bool'
    is_flow(F) -> bool
    
    
    Does the previous instruction exist and pass execution flow to the
    current byte?
    
    
    @param F (C++: flags_t)

Help on function is_fltnum in module ida_bytes:

is_fltnum(*args) -> 'bool'
    is_fltnum(F, n) -> bool
    
    
    is floating point number?
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_forced_operand in module ida_bytes:

is_forced_operand(*args) -> 'bool'
    is_forced_operand(ea, n) -> bool
    
    
    Is operand manually defined?.
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, 2) (C++: int)

Help on function is_func in module ida_bytes:

is_func(*args) -> 'bool'
    is_func(F) -> bool
    
    
    Is function start?
    
    
    @param F (C++: flags_t)

Help on function is_head in module ida_bytes:

is_head(*args) -> 'bool'
    is_head(F) -> bool
    
    
    Does flag denote start of instruction OR data?
    
    
    @param F (C++: flags_t)

Help on function is_invsign in module ida_bytes:

is_invsign(*args) -> 'bool'
    is_invsign(ea, F, n) -> bool
    
    
    Should sign of n-th operand inverted during output?. allowed values of
    n: 0-first operand, 1-other operands
    
    @param ea (C++: ea_t)
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_loaded in module ida_bytes:

is_loaded(*args) -> 'bool'
    is_loaded(ea) -> bool
    
    
    Does the specified address have a byte value (is initialized?)
    
    
    @param ea (C++: ea_t)

Help on function is_lzero in module ida_bytes:

is_lzero(*args) -> 'bool'
    is_lzero(ea, n) -> bool
    
    
    Display leading zeroes in operands. The global switch for the leading
    zeroes is in \inf{s_genflags} The leading zeroes doesn't work if the
    octal numbers start with 0 Display leading zeroes? (takes into account
    \inf{s_genflags})
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function is_manual in module ida_bytes:

is_manual(*args) -> 'bool'
    is_manual(F, n) -> bool
    
    
    is forced operand? (use 'is_forced_operand()' )
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_manual_insn in module ida_bytes:

is_manual_insn(*args) -> 'bool'
    is_manual_insn(ea) -> bool
    
    
    Is the instruction overridden?
    
    @param ea: linear address of the instruction or data item (C++: ea_t)

Help on function is_mapped in module ida_bytes:

is_mapped(*args) -> 'bool'
    is_mapped(ea) -> bool
    
    
    Is the specified address 'ea' present in the program?
    
    
    @param ea (C++: ea_t)

Help on function is_not_tail in module ida_bytes:

is_not_tail(*args) -> 'bool'
    is_not_tail(F) -> bool
    
    
    Does flag denote tail byte?
    
    
    @param F (C++: flags_t)

Help on function is_numop in module ida_bytes:

is_numop(*args) -> 'bool'
    is_numop(F, n) -> bool
    
    
    is number (bin, oct, dec, hex)?
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_numop0 in module ida_bytes:

is_numop0(*args) -> 'bool'
    is_numop0(F) -> bool
    
    
    Is the first operand a number (i.e. binary, octal, decimal or hex?)
    
    
    @param F (C++: flags_t)

Help on function is_numop1 in module ida_bytes:

is_numop1(*args) -> 'bool'
    is_numop1(F) -> bool
    
    
    Is the second operand a number (i.e. binary, octal, decimal or hex?)
    
    
    @param F (C++: flags_t)

Help on function is_off in module ida_bytes:

is_off(*args) -> 'bool'
    is_off(F, n) -> bool
    
    
    is offset?
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_off0 in module ida_bytes:

is_off0(*args) -> 'bool'
    is_off0(F) -> bool
    
    
    Is the first operand offset? (example: push offset xxx)
    
    
    @param F (C++: flags_t)

Help on function is_off1 in module ida_bytes:

is_off1(*args) -> 'bool'
    is_off1(F) -> bool
    
    
    Is the second operand offset? (example: mov ax, offset xxx)
    
    
    @param F (C++: flags_t)

Help on function is_oword in module ida_bytes:

is_oword(*args) -> 'bool'
    is_oword(F) -> bool
    
    
     'FF_OWORD'
    
    
    @param F (C++: flags_t)

Help on function is_pack_real in module ida_bytes:

is_pack_real(*args) -> 'bool'
    is_pack_real(F) -> bool
    
    
     'FF_PACKREAL'
    
    
    @param F (C++: flags_t)

Help on function is_qword in module ida_bytes:

is_qword(*args) -> 'bool'
    is_qword(F) -> bool
    
    
     'FF_QWORD'
    
    
    @param F (C++: flags_t)

Help on function is_same_data_type in module ida_bytes:

is_same_data_type(*args) -> 'bool'
    is_same_data_type(F1, F2) -> bool
    
    
    Do the given flags specify the same data type?
    
    
    @param F1 (C++: flags_t)
    @param F2 (C++: flags_t)

Help on function is_seg in module ida_bytes:

is_seg(*args) -> 'bool'
    is_seg(F, n) -> bool
    
    
    is segment?
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_seg0 in module ida_bytes:

is_seg0(*args) -> 'bool'
    is_seg0(F) -> bool
    
    
    Is the first operand segment selector? (example: push seg seg001)
    
    
    @param F (C++: flags_t)

Help on function is_seg1 in module ida_bytes:

is_seg1(*args) -> 'bool'
    is_seg1(F) -> bool
    
    
    Is the second operand segment selector? (example: mov dx, seg dseg)
    
    
    @param F (C++: flags_t)

Help on function is_stkvar in module ida_bytes:

is_stkvar(*args) -> 'bool'
    is_stkvar(F, n) -> bool
    
    
    is stack variable?
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_stkvar0 in module ida_bytes:

is_stkvar0(*args) -> 'bool'
    is_stkvar0(F) -> bool
    
    
    Is the first operand a stack variable?
    
    
    @param F (C++: flags_t)

Help on function is_stkvar1 in module ida_bytes:

is_stkvar1(*args) -> 'bool'
    is_stkvar1(F) -> bool
    
    
    Is the second operand a stack variable?
    
    
    @param F (C++: flags_t)

Help on function is_strlit in module ida_bytes:

is_strlit(*args) -> 'bool'
    is_strlit(F) -> bool
    
    
     'FF_STRLIT'
    
    
    @param F (C++: flags_t)

Help on function is_stroff in module ida_bytes:

is_stroff(*args) -> 'bool'
    is_stroff(F, n) -> bool
    
    
    is struct offset?
    
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_stroff0 in module ida_bytes:

is_stroff0(*args) -> 'bool'
    is_stroff0(F) -> bool
    
    
    Is the first operand an offset within a struct?
    
    
    @param F (C++: flags_t)

Help on function is_stroff1 in module ida_bytes:

is_stroff1(*args) -> 'bool'
    is_stroff1(F) -> bool
    
    
    Is the second operand an offset within a struct?
    
    
    @param F (C++: flags_t)

Help on function is_struct in module ida_bytes:

is_struct(*args) -> 'bool'
    is_struct(F) -> bool
    
    
     'FF_STRUCT'
    
    
    @param F (C++: flags_t)

Help on function is_suspop in module ida_bytes:

is_suspop(*args) -> 'bool'
    is_suspop(ea, F, n) -> bool
    
    
    is suspicious operand?
    
    
    @param ea (C++: ea_t)
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function is_tail in module ida_bytes:

is_tail(*args) -> 'bool'
    is_tail(F) -> bool
    
    
    Does flag denote tail byte?
    
    
    @param F (C++: flags_t)

Help on function is_tbyte in module ida_bytes:

is_tbyte(*args) -> 'bool'
    is_tbyte(F) -> bool
    
    
     'FF_TBYTE'
    
    
    @param F (C++: flags_t)

Help on function is_unknown in module ida_bytes:

is_unknown(*args) -> 'bool'
    is_unknown(F) -> bool
    
    
    Does flag denote unexplored byte?
    
    
    @param F (C++: flags_t)

Help on function is_varsize_item in module ida_bytes:

is_varsize_item(*args) -> 'int'
    is_varsize_item(ea, F, ti=None, itemsize=None) -> int
    
    
    Is the item at 'ea' variable size?.
    
    @param ea: linear address of the item (C++: ea_t)
    @param F: flags (C++: flags_t)
    @param ti: additional information about the data type. For example, if
               the current item is a structure instance, then ti->tid is
               structure id. Otherwise is ignored (may be NULL). If
               specified as NULL, will be automatically retrieved from the
               database (C++: const  opinfo_t  *)
    @param itemsize: if not NULL and the item is varsize, itemsize will
                     contain the calculated item size (for struct types,
                     the minimal size is returned) (C++: asize_t *)

Help on function is_word in module ida_bytes:

is_word(*args) -> 'bool'
    is_word(F) -> bool
    
    
     'FF_WORD'
    
    
    @param F (C++: flags_t)

Help on function is_yword in module ida_bytes:

is_yword(*args) -> 'bool'
    is_yword(F) -> bool
    
    
     'FF_YWORD'
    
    
    @param F (C++: flags_t)

Help on function is_zword in module ida_bytes:

is_zword(*args) -> 'bool'
    is_zword(F) -> bool
    
    
     'FF_ZWORD'
    
    
    @param F (C++: flags_t)

Help on function leading_zero_important in module ida_bytes:

leading_zero_important(*args) -> 'bool'
    leading_zero_important(ea, n) -> bool
    
    
    Check if leading zeroes are important.
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function nbits in module ida_bytes:

nbits(*args) -> 'int'
    nbits(ea) -> int
    
    
    Get number of bits in a byte at the given address.
    
    @param ea (C++: ea_t)
    @return: \ph{dnbits()} if the address doesn't belong to a segment,
             otherwise the result depends on the segment type

Help on function next_addr in module ida_bytes:

next_addr(*args) -> 'ea_t'
    next_addr(ea) -> ea_t
    
    
    Get next address in the program (i.e. next address which has flags).
    
    @param ea (C++: ea_t)
    @return: BADADDR  if no such address exist.

Help on function next_chunk in module ida_bytes:

next_chunk(*args) -> 'ea_t'
    next_chunk(ea) -> ea_t
    
    
    Get the first address of next contiguous chunk in the program.
    
    @param ea (C++: ea_t)
    @return: BADADDR  if next chunk doesn't exist.

Help on function next_head in module ida_bytes:

next_head(*args) -> 'ea_t'
    next_head(ea, maxea) -> ea_t
    
    
    Get start of next defined item.
    
    @param ea: begin search at this address (C++: ea_t)
    @param maxea: not included in the search range (C++: ea_t)
    @return: BADADDR  if none exists.

Help on function next_inited in module ida_bytes:

next_inited(*args) -> 'ea_t'
    next_inited(ea, maxea) -> ea_t
    
    
    Find the next initialized address.
    
    
    @param ea (C++: ea_t)
    @param maxea (C++: ea_t)

Help on function next_not_tail in module ida_bytes:

next_not_tail(*args) -> 'ea_t'
    next_not_tail(ea) -> ea_t
    
    
    Get address of next non-tail byte.
    
    @param ea (C++: ea_t)
    @return: BADADDR  if none exists.

Help on function next_that in module ida_bytes:

next_that(*args) -> 'ea_t'
    next_that(ea, maxea, callable) -> ea_t
    
    
    Find next address with a flag satisfying the function 'testf'.
    Start searching from address 'ea'+1 and inspect bytes up to 'maxea'.
    maxea is not included in the search range.
    
    @param callable: a Python callable with the following prototype:
                     callable(flags). Return True to stop enumeration.
    @return: the found address or BADADDR.

Help on function next_unknown in module ida_bytes:

next_unknown(*args) -> 'ea_t'
    next_unknown(ea, maxea) -> ea_t
    
    
    Similar to 'next_that()' , but will find the next address that is
    unexplored.
    
    
    @param ea (C++: ea_t)
    @param maxea (C++: ea_t)

Help on function num_flag in module ida_bytes:

num_flag(*args) -> 'flags_t'
    num_flag() -> flags_t
    
    
    Get number of default base (bin, oct, dec, hex)

Help on function oct_flag in module ida_bytes:

oct_flag(*args) -> 'flags_t'
    oct_flag() -> flags_t
    
    
    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'

Help on function off_flag in module ida_bytes:

off_flag(*args) -> 'flags_t'
    off_flag() -> flags_t
    
    
    see 'Bits: instruction operand types'

Help on function op_adds_xrefs in module ida_bytes:

op_adds_xrefs(*args) -> 'bool'
    op_adds_xrefs(F, n) -> bool
    
    
    Should processor module create xrefs from the operand?. Currently
    'offset' and 'structure offset' operands create xrefs
    
    @param F (C++: flags_t)
    @param n (C++: int)

Help on function op_bin in module ida_bytes:

op_bin(*args) -> 'bool'
    op_bin(ea, n) -> bool
    
    
    set op type to 'bin_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_chr in module ida_bytes:

op_chr(*args) -> 'bool'
    op_chr(ea, n) -> bool
    
    
    set op type to 'char_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_custfmt in module ida_bytes:

op_custfmt(*args) -> 'bool'
    op_custfmt(ea, n, fid) -> bool
    
    
    Set custom data format for operand (fid-custom data format id)
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)
    @param fid (C++: int)

Help on function op_dec in module ida_bytes:

op_dec(*args) -> 'bool'
    op_dec(ea, n) -> bool
    
    
    set op type to 'dec_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_enum in module ida_bytes:

op_enum(*args) -> 'bool'
    op_enum(ea, n, id, serial) -> bool
    
    
    Set operand representation to be 'enum_t'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, -1) (C++: int)
    @param id: id of enum (C++: enum_t)
    @param serial: the serial number of the constant in the enumeration,
                   usually 0. the serial numbers are used if the
                   enumeration contains several constants with the same
                   value (C++: uchar)
    @return: success

Help on function op_flt in module ida_bytes:

op_flt(*args) -> 'bool'
    op_flt(ea, n) -> bool
    
    
    set op type to 'flt_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_hex in module ida_bytes:

op_hex(*args) -> 'bool'
    op_hex(ea, n) -> bool
    
    
    set op type to 'hex_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_num in module ida_bytes:

op_num(*args) -> 'bool'
    op_num(ea, n) -> bool
    
    
    set op type to 'num_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_oct in module ida_bytes:

op_oct(*args) -> 'bool'
    op_oct(ea, n) -> bool
    
    
    set op type to 'oct_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_seg in module ida_bytes:

op_seg(*args) -> 'bool'
    op_seg(ea, n) -> bool
    
    
    Set operand representation to be 'segment'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, -1) (C++: int)
    @return: success

Help on function op_stkvar in module ida_bytes:

op_stkvar(*args) -> 'bool'
    op_stkvar(ea, n) -> bool
    
    
    Set operand representation to be 'stack variable'. Should be applied
    to an instruction within a function. Should be applied after creating
    a stack var using 'insn_t::create_stkvar()' .
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, -1) (C++: int)
    @return: success

Help on function op_stroff in module ida_bytes:

op_stroff(*args) -> 'bool'
    op_stroff(insn, n, path, path_len, delta) -> bool
    
    
    Set operand representation to be 'struct offset'. If applied to
    unexplored bytes, converts them to 16/32bit word data
    
    @param insn: the instruction (C++: const  insn_t  &)
    @param n: number of operand (0, 1, -1) (C++: int)
    @param path: structure path (strpath). see  nalt.hpp  for more info.
                 (C++: const  tid_t  *)
    @param path_len: length of the structure path (C++: int)
    @param delta: struct offset delta. usually 0. denotes the difference
                  between the structure base and the pointer into the
                  structure. (C++: adiff_t)
    @return: success
    
    Example:
    Python> 
    Python> ins = ida_ua.insn_t()
    Python> if ida_ua.decode_insn(ins, some_address):
    Python>     path_len = 1
    Python>     path = ida_pro.tid_array(path_len)
    Python>     path[0] = ida_struct.get_struc_id("my_stucture_t")
    Python>     ida_bytes.op_stroff(ins, 0, path.cast(), path_len, 0)
    Python>

Help on function oword_flag in module ida_bytes:

oword_flag(*args) -> 'flags_t'
    oword_flag() -> flags_t
    
    
    Get a flags_t representing a octaword.

Help on function packreal_flag in module ida_bytes:

packreal_flag(*args) -> 'flags_t'
    packreal_flag() -> flags_t
    
    
    Get a flags_t representing a packed decimal real.

Help on function patch_byte in module ida_bytes:

patch_byte(*args) -> 'bool'
    patch_byte(ea, x) -> bool
    
    
    Patch a byte of the program. The original value of the byte is saved
    and can be obtained by 'get_original_byte()' . This function works for
    wide byte processors too.
    
    @param ea (C++: ea_t)
    @param x (C++: uint64)

Help on function patch_bytes in module ida_bytes:

patch_bytes(*args) -> 'void'
    patch_bytes(ea, buf)
    
    
    Patch the specified number of bytes of the program. Original values of
    bytes are saved and are available with get_original...() functions.
    See also 'put_bytes()' .
    
    @param ea: linear address (C++: ea_t)
    @param buf: buffer with new values of bytes (C++: const void *)

Help on function patch_dword in module ida_bytes:

patch_dword(*args) -> 'bool'
    patch_dword(ea, x) -> bool
    
    
    Patch a dword of the program. The original value of the dword is saved
    and can be obtained by 'get_original_dword()' . This function DOESN'T
    work for wide byte processors. This function takes into account order
    of bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)
    @param x (C++: uint64)

Help on function patch_qword in module ida_bytes:

patch_qword(*args) -> 'bool'
    patch_qword(ea, x) -> bool
    
    
    Patch a qword of the program. The original value of the qword is saved
    and can be obtained by 'get_original_qword()' . This function DOESN'T
    work for wide byte processors. This function takes into account order
    of bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)
    @param x (C++: uint64)

Help on function patch_word in module ida_bytes:

patch_word(*args) -> 'bool'
    patch_word(ea, x) -> bool
    
    
    Patch a word of the program. The original value of the word is saved
    and can be obtained by 'get_original_word()' . This function works for
    wide byte processors too. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)
    @param x (C++: uint64)

Help on function prev_addr in module ida_bytes:

prev_addr(*args) -> 'ea_t'
    prev_addr(ea) -> ea_t
    
    
    Get previous address in the program.
    
    @param ea (C++: ea_t)
    @return: BADADDR  if no such address exist.

Help on function prev_chunk in module ida_bytes:

prev_chunk(*args) -> 'ea_t'
    prev_chunk(ea) -> ea_t
    
    
    Get the last address of previous contiguous chunk in the program.
    
    @param ea (C++: ea_t)
    @return: BADADDR  if previous chunk doesn't exist.

Help on function prev_head in module ida_bytes:

prev_head(*args) -> 'ea_t'
    prev_head(ea, minea) -> ea_t
    
    
    Get start of previous defined item.
    
    @param ea: begin search at this address (C++: ea_t)
    @param minea: included in the search range (C++: ea_t)
    @return: BADADDR  if none exists.

Help on function prev_inited in module ida_bytes:

prev_inited(*args) -> 'ea_t'
    prev_inited(ea, minea) -> ea_t
    
    
    Find the previous initialized address.
    
    
    @param ea (C++: ea_t)
    @param minea (C++: ea_t)

Help on function prev_not_tail in module ida_bytes:

prev_not_tail(*args) -> 'ea_t'
    prev_not_tail(ea) -> ea_t
    
    
    Get address of previous non-tail byte.
    
    @param ea (C++: ea_t)
    @return: BADADDR  if none exists.

Help on function prev_that in module ida_bytes:

prev_that(*args) -> 'ea_t'
    prev_that(ea, minea, callable) -> ea_t
    
    
    Find previous address with a flag satisfying the function 'testf'.do
    not pass 'is_unknown()' to this function to find unexplored bytes It
    will fail under the debugger. To find unexplored bytes, use
    'prev_unknown()' .
    
    @param ea: start searching from this address - 1. (C++: ea_t)
    @param minea: included in the search range. (C++: ea_t)
    @return: the found address or  BADADDR .

Help on function prev_unknown in module ida_bytes:

prev_unknown(*args) -> 'ea_t'
    prev_unknown(ea, minea) -> ea_t
    
    
    Similar to 'prev_that()' , but will find the previous address that is
    unexplored.
    
    
    @param ea (C++: ea_t)
    @param minea (C++: ea_t)

Help on function print_strlit_type in module ida_bytes:

print_strlit_type(*args) -> 'PyObject *'
    print_strlit_type(strtype, flags=0) -> PyObject *
    
    
    Get string type information: the string type name (possibly decorated
    with hotkey markers), and the tooltip.
    
    @param strtype: the string type (C++: int32)
    @param flags: or'ed PSTF_* constants (C++: int)
    @return: length of generated text

Help on function put_byte in module ida_bytes:

put_byte(*args) -> 'bool'
    put_byte(ea, x) -> bool
    
    
    Set value of one byte of the program. This function modifies the
    database. If the debugger is active then the debugged process memory
    is patched too.The original value of the byte is completely lost and
    can't be recovered by the 'get_original_byte()' function. See also
    'put_dbg_byte()' to write to the process memory directly when the
    debugger is active. This function can handle wide byte processors.
    
    @param ea: linear address (C++: ea_t)
    @param x: byte value (C++: uint64)
    @return: true if the database has been modified

Help on function put_bytes in module ida_bytes:

put_bytes(*args) -> 'void'
    put_bytes(ea, buf)
    
    
    Modify the specified number of bytes of the program. This function
    does not save the original values of bytes. See also 'patch_bytes()' .
    
    @param ea: linear address (C++: ea_t)
    @param buf: buffer with new values of bytes (C++: const void *)

Help on function put_dword in module ida_bytes:

put_dword(*args) -> 'void'
    put_dword(ea, x)
    
    
    Set value of one dword of the program. This function takes into
    account order of bytes specified in \inf{is_be()} This function works
    for wide byte processors too.the original value of the dword is
    completely lost and can't be recovered by the 'get_original_dword()'
    function.
    
    @param ea: linear address (C++: ea_t)
    @param x: dword value (C++: uint64)

Help on function put_qword in module ida_bytes:

put_qword(*args) -> 'void'
    put_qword(ea, x)
    
    
    Set value of one qword (8 bytes) of the program. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    DOESN'T works for wide byte processors.
    
    @param ea: linear address (C++: ea_t)
    @param x: qword value (C++: uint64)

Help on function put_word in module ida_bytes:

put_word(*args) -> 'void'
    put_word(ea, x)
    
    
    Set value of one word of the program. This function takes into account
    order of bytes specified in \inf{is_be()} This function works for wide
    byte processors too.The original value of the word is completely lost
    and can't be recovered by the 'get_original_word()' function. ea -
    linear address x - word value
    
    @param ea (C++: ea_t)
    @param x (C++: uint64)

Help on function qword_flag in module ida_bytes:

qword_flag(*args) -> 'flags_t'
    qword_flag() -> flags_t
    
    
    Get a flags_t representing a quad word.

Help on function register_custom_data_format in module ida_bytes:

register_custom_data_format(*args) -> 'int'
    register_custom_data_format(py_df) -> int
    
    
    Registers a custom data format with a given data type.
    @param df: an instance of data_format_t
    @return:
        < 0 if failed to register
        > 0 data format id

Help on function register_custom_data_type in module ida_bytes:

register_custom_data_type(*args) -> 'int'
    register_custom_data_type(py_dt) -> int
    
    
    Registers a custom data type.
    @param dt: an instance of the data_type_t class
    @return:
        < 0 if failed to register
        > 0 data type id

Help on function register_data_types_and_formats in module ida_bytes:

register_data_types_and_formats(formats)
    Registers multiple data types and formats at once.
    To register one type/format at a time use register_custom_data_type/register_custom_data_format
    
    It employs a special table of types and formats described below:
    
    The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
    If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
    many_formats = [
      (pascal_data_type(), pascal_data_format()),
      (simplevm_data_type(), simplevm_data_format()),
      (makedword_data_format(),),
      (simplevm_data_format(),)
    ]
    The first two tuples describe data types and their associated formats.
    The last two tuples describe two data formats to be used with built-in data types.
    The data format may be attached to several data types. The id of the
    data format is stored in the first data_format_t object. For example:
    assert many_formats[1][1] != -1
    assert many_formats[2][0] != -1
    assert many_formats[3][0] == -1

Help on function revert_byte in module ida_bytes:

revert_byte(*args) -> 'bool'
    revert_byte(ea) -> bool
    
    
    Revert patched byte
    
    @param ea (C++: ea_t)

Help on function seg_flag in module ida_bytes:

seg_flag(*args) -> 'flags_t'
    seg_flag() -> flags_t
    
    
    see 'Bits: instruction operand types'

Help on function set_cmt in module ida_bytes:

set_cmt(*args) -> 'bool'
    set_cmt(ea, comm, rptble) -> bool
    
    
    Set an indented comment.
    
    @param ea: linear address (C++: ea_t)
    @param comm: comment string   NULL: do nothing (return 0)   "" :
                 delete comment (C++: const char *)
    @param rptble: is repeatable? (C++: bool)
    @return: success

Help on function set_forced_operand in module ida_bytes:

set_forced_operand(*args) -> 'bool'
    set_forced_operand(ea, n, op) -> bool
    
    
    Set forced operand.
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, 2) (C++: int)
    @param op: text of operand   NULL: do nothing (return 0)   "" : delete
               forced operand (C++: const char *)
    @return: success

Help on function set_immd in module ida_bytes:

set_immd(*args) -> 'bool'
    set_immd(ea) -> bool
    
    
    Set 'has immediate operand' flag. Returns true if the 'FF_IMMD' bit
    was not set and now is set
    
    @param ea (C++: ea_t)

Help on function set_lzero in module ida_bytes:

set_lzero(*args) -> 'bool'
    set_lzero(ea, n) -> bool
    
    
    Set toggle lzero bit.
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function set_manual_insn in module ida_bytes:

set_manual_insn(*args) -> 'void'
    set_manual_insn(ea, manual_insn)
    
    
    Set manual instruction string.
    
    @param ea: linear address of the instruction or data item (C++: ea_t)
    @param manual_insn: "" - delete manual string. NULL - do nothing (C++:
                        const char *)

Help on function set_op_type in module ida_bytes:

set_op_type(*args) -> 'bool'
    set_op_type(ea, type, n) -> bool
    
    
    (internal function) change representation of operand(s).
    
    @param ea: linear address (C++: ea_t)
    @param type: new flag value (should be obtained from  char_flag() ,
                 num_flag()  and similar functions) (C++: flags_t)
    @param n: number of operand (0, 1, -1) (C++: int)

Help on function set_opinfo in module ida_bytes:

set_opinfo(*args) -> 'bool'
    set_opinfo(ea, n, flag, ti, suppress_events=False) -> bool
    
    
    Set additional information about an operand representation. This
    function is a low level one. Only the kernel should use it.
    
    @param ea: linear address of the item (C++: ea_t)
    @param n: number of operand, 0 or 1 (C++: int)
    @param flag: flags of the item (C++: flags_t)
    @param ti: additional representation information (C++: const  opinfo_t
               *)
    @param suppress_events: do not generate changing_op_type and
                            op_type_changed events (C++: bool)
    @return: success

Help on function stkvar_flag in module ida_bytes:

stkvar_flag(*args) -> 'flags_t'
    stkvar_flag() -> flags_t
    
    
    see 'Bits: instruction operand types'

Help on function strlit_flag in module ida_bytes:

strlit_flag(*args) -> 'flags_t'
    strlit_flag() -> flags_t
    
    
    Get a flags_t representing a string literal.

Help on function stroff_flag in module ida_bytes:

stroff_flag(*args) -> 'flags_t'
    stroff_flag() -> flags_t
    
    
    see 'Bits: instruction operand types'

Help on function stru_flag in module ida_bytes:

stru_flag(*args) -> 'flags_t'
    stru_flag() -> flags_t
    
    
    Get a flags_t representing a struct.

Help on function tbyte_flag in module ida_bytes:

tbyte_flag(*args) -> 'flags_t'
    tbyte_flag() -> flags_t
    
    
    Get a flags_t representing a tbyte.

Help on function toggle_bnot in module ida_bytes:

toggle_bnot(*args) -> 'bool'
    toggle_bnot(ea, n) -> bool
    
    
    Toggle binary negation of operand. also see 'is_bnot()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function toggle_lzero in module ida_bytes:

toggle_lzero(*args) -> 'bool'
    toggle_lzero(ea, n) -> bool

Help on function toggle_sign in module ida_bytes:

toggle_sign(*args) -> 'bool'
    toggle_sign(ea, n) -> bool
    
    
    Toggle sign of n-th operand. allowed values of n: 0-first operand,
    1-other operands
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function unregister_custom_data_format in module ida_bytes:

unregister_custom_data_format(*args) -> 'bool'
    unregister_custom_data_format(dfid) -> bool
    
    
    Unregisters a custom data format
    @param dfid: data format id
    @return: Boolean

Help on function unregister_custom_data_type in module ida_bytes:

unregister_custom_data_type(*args) -> 'bool'
    unregister_custom_data_type(dtid) -> bool
    
    
    Unregisters a custom data type.
    @param dtid: the data type id
    @return: Boolean

Help on function unregister_data_types_and_formats in module ida_bytes:

unregister_data_types_and_formats(formats)
    As opposed to register_data_types_and_formats(), this function
    unregisters multiple data types and formats at once.

Help on function update_hidden_range in module ida_bytes:

update_hidden_range(*args) -> 'bool'
    update_hidden_range(ha) -> bool
    
    
    Update hidden range information in the database. You cannot use this
    function to change the range boundaries
    
    @param ha: range to update (C++: const  hidden_range_t  *)
    @return: success

Help on function use_mapping in module ida_bytes:

use_mapping(*args) -> 'ea_t'
    use_mapping(ea) -> ea_t
    
    
    Translate address according to current mappings.
    
    @param ea: address to translate (C++: ea_t)
    @return: translated address

Help on function visit_patched_bytes in module ida_bytes:

visit_patched_bytes(*args) -> 'int'
    visit_patched_bytes(ea1, ea2, py_callable) -> int
    
    
    Enumerates patched bytes in the given range and invokes a callable
    @param ea1: start address
    @param ea2: end address
    @param callable: a Python callable with the following prototype:
                     callable(ea, fpos, org_val, patch_val).
                     If the callable returns non-zero then that value will be
                     returned to the caller and the enumeration will be
                     interrupted.
    @return: Zero if the enumeration was successful or the return
             value of the callback if enumeration was interrupted.

Help on function word_flag in module ida_bytes:

word_flag(*args) -> 'flags_t'
    word_flag() -> flags_t
    
    
    Get a flags_t representing a word.

Help on function yword_flag in module ida_bytes:

yword_flag(*args) -> 'flags_t'
    yword_flag() -> flags_t
    
    
    Get a flags_t representing a ymm word.

Help on function zword_flag in module ida_bytes:

zword_flag(*args) -> 'flags_t'
    zword_flag() -> flags_t
    
    
    Get a flags_t representing a zmm word.

=== ida_bytes EPYDOC INJECTIONS ===
ida_bytes.ALOPT_IGNCLT
"""
if set, don't stop at codepoints that are not part of the current
'culture'; accept all those that are graphical (this is typically used
used by user-initiated actions creating string literals.)
"""

ida_bytes.ALOPT_IGNHEADS
"""
don't stop if another data item is encountered. only the byte values
will be used to determine the string length. if not set, a defined
data item or instruction will truncate the string
"""

ida_bytes.ALOPT_IGNPRINT
"""
if set, don't stop at non-printable codepoints, but only at the
terminating character (or not unicode-mapped character (e.g., 0x8f in
CP1252))
"""

ida_bytes.ALOPT_MAX4K
"""
accumulated length

if string length is more than 4K, return the
"""

ida_bytes.BIN_SEARCH_BACKWARD
"""
search backward for bytes
"""

ida_bytes.BIN_SEARCH_CASE
"""
case sensitive
"""

ida_bytes.BIN_SEARCH_FORWARD
"""
search forward for bytes
"""

ida_bytes.BIN_SEARCH_INITED
"""
find_byte, find_byter: any initilized value
"""

ida_bytes.BIN_SEARCH_NOBREAK
"""
don't check for Ctrl-Break
"""

ida_bytes.BIN_SEARCH_NOCASE
"""
case insensitive
"""

ida_bytes.BIN_SEARCH_NOSHOW
"""
don't show search progress or update screen
"""

ida_bytes.DELIT_DELNAMES
"""
delete any names at the specified address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_EXPAND
"""
propagate undefined items; for example if removing an instruction
removes all references to the next instruction, then plan to convert
to unexplored the next instruction too.
"""

ida_bytes.DELIT_KEEPFUNC
"""
Just delete xrefs, ops e.t.c.

do not undefine the function start.
"""

ida_bytes.DELIT_NOCMT
"""
reject to delete if a comment is in address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_NOTRUNC
"""
even if 'AF_TRFUNC' is set

don't truncate the current function
"""

ida_bytes.DELIT_NOUNAME
"""
reject to delete if a user name is in address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_SIMPLE
"""
simply undefine the specified item(s)
"""

ida_bytes.DTP_NODUP
"""
do not use dup construct
"""

ida_bytes.DT_TYPE
"""
Mask for DATA typing.
"""

ida_bytes.FF_0CHAR
"""
Char ('x')?
"""

ida_bytes.FF_0CUST
"""
Custom representation?
"""

ida_bytes.FF_0ENUM
"""
Enumeration?
"""

ida_bytes.FF_0FLT
"""
Floating point number?
"""

ida_bytes.FF_0FOP
"""
Forced operand?
"""

ida_bytes.FF_0NUMB
"""
Binary number?
"""

ida_bytes.FF_0NUMD
"""
Decimal number?
"""

ida_bytes.FF_0NUMH
"""
Hexadecimal number?
"""

ida_bytes.FF_0NUMO
"""
Octal number?
"""

ida_bytes.FF_0OFF
"""
Offset?
"""

ida_bytes.FF_0SEG
"""
Segment?
"""

ida_bytes.FF_0STK
"""
Stack variable?
"""

ida_bytes.FF_0STRO
"""
Struct offset?
"""

ida_bytes.FF_0VOID
"""
Void (unknown)?
"""

ida_bytes.FF_1CHAR
"""
Char ('x')?
"""

ida_bytes.FF_1CUST
"""
Custom representation?
"""

ida_bytes.FF_1ENUM
"""
Enumeration?
"""

ida_bytes.FF_1FLT
"""
Floating point number?
"""

ida_bytes.FF_1FOP
"""
Forced operand?
"""

ida_bytes.FF_1NUMB
"""
Binary number?
"""

ida_bytes.FF_1NUMD
"""
Decimal number?
"""

ida_bytes.FF_1NUMH
"""
Hexadecimal number?
"""

ida_bytes.FF_1NUMO
"""
Octal number?
"""

ida_bytes.FF_1OFF
"""
Offset?
"""

ida_bytes.FF_1SEG
"""
Segment?
"""

ida_bytes.FF_1STK
"""
Stack variable?
"""

ida_bytes.FF_1STRO
"""
Struct offset?
"""

ida_bytes.FF_1VOID
"""
Void (unknown)?
"""

ida_bytes.FF_ALIGN
"""
alignment directive
"""

ida_bytes.FF_BNOT
"""
Bitwise negation of operands.
"""

ida_bytes.FF_BYTE
"""
byte
"""

ida_bytes.FF_CODE
"""
Code ?
"""

ida_bytes.FF_COMM
"""
Has comment ?
"""

ida_bytes.FF_CUSTOM
"""
custom data type
"""

ida_bytes.FF_DATA
"""
Data ?
"""

ida_bytes.FF_DOUBLE
"""
double
"""

ida_bytes.FF_DWORD
"""
double word
"""

ida_bytes.FF_FLOAT
"""
float
"""

ida_bytes.FF_FLOW
"""
Exec flow from prev instruction.
"""

ida_bytes.FF_FUNC
"""
function start?
"""

ida_bytes.FF_IMMD
"""
Has Immediate value ?
"""

ida_bytes.FF_IVL
"""
Byte has value ?
"""

ida_bytes.FF_JUMP
"""
Has jump table or switch_info?
"""

ida_bytes.FF_LABL
"""
Has dummy name?
"""

ida_bytes.FF_LINE
"""
Has next or prev lines ?
"""

ida_bytes.FF_NAME
"""
Has name ?
"""

ida_bytes.FF_OWORD
"""
octaword/xmm word (16 bytes/128 bits)
"""

ida_bytes.FF_PACKREAL
"""
packed decimal real
"""

ida_bytes.FF_QWORD
"""
quadro word
"""

ida_bytes.FF_REF
"""
has references
"""

ida_bytes.FF_SIGN
"""
Inverted sign of operands.
"""

ida_bytes.FF_STRLIT
"""
string literal
"""

ida_bytes.FF_STRUCT
"""
struct variable
"""

ida_bytes.FF_TAIL
"""
Tail ?
"""

ida_bytes.FF_TBYTE
"""
tbyte
"""

ida_bytes.FF_UNK
"""
Unknown ?
"""

ida_bytes.FF_UNUSED
"""
unused bit (was used for variable bytes)
"""

ida_bytes.FF_WORD
"""
word
"""

ida_bytes.FF_YWORD
"""
ymm word (32 bytes/256 bits)
"""

ida_bytes.FF_ZWORD
"""
zmm word (64 bytes/512 bits)
"""

ida_bytes.GFE_VALUE
"""
get flags with 'FF_IVL' & 'MS_VAL' . It is much slower under remote
debugging because the kernel needs to read the process memory.
"""

ida_bytes.GMB_READALL
"""
if this bit is not set, fail at first uninited byte

try to read all bytes
"""

ida_bytes.GMB_WAITBOX
"""
show wait box (may return -1 in this case)
"""

ida_bytes.ITEM_END_FIXUP
"""
stop at the first fixup
"""

ida_bytes.ITEM_END_INITED
"""
stop when initialization changes i.e.if is_loaded(ea): stop if
uninitialized byte is encounteredif !is_loaded(ea): stop if
initialized byte is encountered
"""

ida_bytes.ITEM_END_NAME
"""
stop at the first named location
"""

ida_bytes.ITEM_END_XREF
"""
stop at the first referenced location
"""

ida_bytes.MS_0TYPE
"""
Mask for 1st arg typing.
"""

ida_bytes.MS_1TYPE
"""
Mask for the type of other operands.
"""

ida_bytes.MS_CLS
"""
Mask for typing.
"""

ida_bytes.MS_CODE
"""
Mask for code bits.
"""

ida_bytes.MS_COMM
"""
Mask of common bits.
"""

ida_bytes.MS_VAL
"""
Mask for byte value.
"""

ida_bytes.OPND_ALL
"""
all operands
"""

ida_bytes.OPND_MASK
"""
mask for operand number
"""

ida_bytes.OPND_OUTER
"""
used only in set, get, del_offset() functions

outer offset base (combined with operand number).
"""

ida_bytes.PSTF_ENC
"""
if encoding is specified, append it
"""

ida_bytes.PSTF_HOTKEY
"""
have hotkey markers part of the name
"""

ida_bytes.PSTF_TBRIEF
"""
use brief name (e.g., in the 'Strings window')
"""

ida_bytes.PSTF_TINLIN
"""
use 'inline' name (e.g., in the structures comments)
"""

ida_bytes.PSTF_TMASK
"""
type mask
"""

ida_bytes.PSTF_TNORM
"""
use normal name
"""

ida_bytes.STRCONV_ESCAPE
"""
convert non-printable characters to C escapes (, \\xNN, \\uNNNN)
"""

ida_bytes.STRCONV_INCLLEN
"""
for Pascal-style strings, include the prefixing length byte(s) as
C-escaped sequence
"""

ida_bytes.STRCONV_REPLCHAR
"""
convert non-printable characters to the Unicode replacement character
(U+FFFD)
"""
=== ida_bytes EPYDOC INJECTIONS END ===
Help on class DBG_Hooks in module ida_dbg:

class DBG_Hooks(builtins.object)
 |  Proxy of C++ DBG_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> DBG_Hooks
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_DBG_Hooks(...)
 |      delete_DBG_Hooks(self)
 |  
 |  dbg_bpt(self, *args) -> 'int'
 |      dbg_bpt(self, tid, bptea) -> int
 |  
 |  dbg_bpt_changed(self, *args) -> 'void'
 |      dbg_bpt_changed(self, bptev_code, bpt)
 |  
 |  dbg_exception(self, *args) -> 'int'
 |      dbg_exception(self, pid, tid, ea, exc_code, exc_can_cont, exc_ea, exc_info) -> int
 |  
 |  dbg_finished_loading_bpts(self, *args) -> 'void'
 |      dbg_finished_loading_bpts(self)
 |  
 |  dbg_information(self, *args) -> 'void'
 |      dbg_information(self, pid, tid, ea, info)
 |  
 |  dbg_library_load(self, *args) -> 'void'
 |      dbg_library_load(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
 |  
 |  dbg_library_unload(self, *args) -> 'void'
 |      dbg_library_unload(self, pid, tid, ea, info)
 |  
 |  dbg_process_attach(self, *args) -> 'void'
 |      dbg_process_attach(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
 |  
 |  dbg_process_detach(self, *args) -> 'void'
 |      dbg_process_detach(self, pid, tid, ea)
 |  
 |  dbg_process_exit(self, *args) -> 'void'
 |      dbg_process_exit(self, pid, tid, ea, exit_code)
 |  
 |  dbg_process_start(self, *args) -> 'void'
 |      dbg_process_start(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
 |  
 |  dbg_request_error(self, *args) -> 'void'
 |      dbg_request_error(self, failed_command, failed_dbg_notification)
 |  
 |  dbg_run_to(self, *args) -> 'void'
 |      dbg_run_to(self, pid, tid, ea)
 |  
 |  dbg_started_loading_bpts(self, *args) -> 'void'
 |      dbg_started_loading_bpts(self)
 |  
 |  dbg_step_into(self, *args) -> 'void'
 |      dbg_step_into(self)
 |  
 |  dbg_step_over(self, *args) -> 'void'
 |      dbg_step_over(self)
 |  
 |  dbg_step_until_ret(self, *args) -> 'void'
 |      dbg_step_until_ret(self)
 |  
 |  dbg_suspend_process(self, *args) -> 'void'
 |      dbg_suspend_process(self)
 |  
 |  dbg_thread_exit(self, *args) -> 'void'
 |      dbg_thread_exit(self, pid, tid, ea, exit_code)
 |  
 |  dbg_thread_start(self, *args) -> 'void'
 |      dbg_thread_start(self, pid, tid, ea)
 |  
 |  dbg_trace(self, *args) -> 'int'
 |      dbg_trace(self, tid, ip) -> int
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function add_bpt in module ida_dbg:

add_bpt(*args) -> 'bool'
    add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
    add_bpt(bpt) -> bool
    
    
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous
    function)}Only one breakpoint can exist at a given address.
    
    @param ea: any address in the process memory space. Depending on the
               architecture, hardware breakpoints always be setup at
               random address. For example, on x86, hardware breakpoints
               should be aligned depending on their size. Moreover, on the
               x86 architecture, it is impossible to setup more than 4
               hardware breakpoints. (C++: ea_t)
    @param size: size of the breakpoint (irrelevant for software
                 breakpoints): As for the address, hardware breakpoints
                 can't always be setup with random size. (C++: asize_t)
    @param type: type of the breakpoint ( BPT_SOFT  for software
                 breakpoint) special case  BPT_DEFAULT  ( BPT_SOFT |
                 BPT_EXEC ): try to add instruction breakpoint of the
                 appropriate type as follows: software bpt if supported,
                 hwbpt otherwise (C++: bpttype_t)

Help on function add_path_mapping in module ida_dbg:

add_path_mapping(*args) -> 'void'
    add_path_mapping(src, dst)

Help on function add_virt_module in module ida_dbg:

add_virt_module(*args) -> 'bool'
    add_virt_module(mod) -> bool

Help on function attach_process in module ida_dbg:

attach_process(*args) -> 'int'
    attach_process(pid=pid_t(-1), event_id=-1) -> int
    
    
    Attach the debugger to a running process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_attach'
    }This function shouldn't be called as a request if 'NO_PROCESS' is
    used.
    
    @param pid: PID of the process to attach to. If  NO_PROCESS , a dialog
                box will interactively ask the user for the process to
                attach to. (C++: pid_t)
    @param event_id (C++: int)

Help on class bpt_location_t in module ida_dbg:

class bpt_location_t(builtins.object)
 |  Proxy of C++ bpt_location_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bpt_location_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bpt_location_t(...)
 |      delete_bpt_location_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ea(self, *args) -> 'ea_t'
 |      ea(self) -> ea_t
 |  
 |  is_empty_path(self, *args) -> 'bool'
 |      is_empty_path(self) -> bool
 |  
 |  lineno(self, *args) -> 'int'
 |      lineno(self) -> int
 |  
 |  offset(self, *args) -> 'uval_t'
 |      offset(self) -> uval_t
 |  
 |  path(self, *args) -> 'char const *'
 |      path(self) -> char const *
 |  
 |  set_abs_bpt(self, *args) -> 'void'
 |      set_abs_bpt(self, a)
 |  
 |  set_rel_bpt(self, *args) -> 'void'
 |      set_rel_bpt(self, mod, _offset)
 |  
 |  set_src_bpt(self, *args) -> 'void'
 |      set_src_bpt(self, fn, _lineno)
 |  
 |  set_sym_bpt(self, *args) -> 'void'
 |      set_sym_bpt(self, _symbol, _offset=0)
 |  
 |  symbol(self, *args) -> 'char const *'
 |      symbol(self) -> char const *
 |  
 |  type(self, *args) -> 'bpt_loctype_t'
 |      type(self) -> bpt_loctype_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  index
 |      bpt_location_t_index_get(self) -> int
 |  
 |  info
 |      bpt_location_t_info_get(self) -> ea_t
 |  
 |  loctype
 |      bpt_location_t_loctype_get(self) -> bpt_loctype_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class bpt_t in module ida_dbg:

class bpt_t(builtins.object)
 |  Proxy of C++ bpt_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bpt_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bpt_t(...)
 |      delete_bpt_t(self)
 |  
 |  badbpt(self, *args) -> 'bool'
 |      badbpt(self) -> bool
 |  
 |  enabled(self, *args) -> 'bool'
 |      enabled(self) -> bool
 |  
 |  get_cnd_elang_idx(self, *args) -> 'size_t'
 |      get_cnd_elang_idx(self) -> size_t
 |  
 |  get_size(self, *args) -> 'int'
 |      get_size(self) -> int
 |  
 |  is_absbpt(self, *args) -> 'bool'
 |      is_absbpt(self) -> bool
 |  
 |  is_active(self, *args) -> 'bool'
 |      is_active(self) -> bool
 |  
 |  is_compiled(self, *args) -> 'bool'
 |      is_compiled(self) -> bool
 |  
 |  is_hwbpt(self, *args) -> 'bool'
 |      is_hwbpt(self) -> bool
 |  
 |  is_inactive(self, *args) -> 'bool'
 |      is_inactive(self) -> bool
 |  
 |  is_low_level(self, *args) -> 'bool'
 |      is_low_level(self) -> bool
 |  
 |  is_page_bpt(self, *args) -> 'bool'
 |      is_page_bpt(self) -> bool
 |  
 |  is_partially_active(self, *args) -> 'bool'
 |      is_partially_active(self) -> bool
 |  
 |  is_relbpt(self, *args) -> 'bool'
 |      is_relbpt(self) -> bool
 |  
 |  is_srcbpt(self, *args) -> 'bool'
 |      is_srcbpt(self) -> bool
 |  
 |  is_symbpt(self, *args) -> 'bool'
 |      is_symbpt(self) -> bool
 |  
 |  is_tracemodebpt(self, *args) -> 'bool'
 |      is_tracemodebpt(self) -> bool
 |  
 |  is_traceoffbpt(self, *args) -> 'bool'
 |      is_traceoffbpt(self) -> bool
 |  
 |  is_traceonbpt(self, *args) -> 'bool'
 |      is_traceonbpt(self) -> bool
 |  
 |  listbpt(self, *args) -> 'bool'
 |      listbpt(self) -> bool
 |  
 |  set_abs_bpt(self, *args) -> 'void'
 |      set_abs_bpt(self, a)
 |  
 |  set_rel_bpt(self, *args) -> 'void'
 |      set_rel_bpt(self, mod, o)
 |  
 |  set_src_bpt(self, *args) -> 'void'
 |      set_src_bpt(self, fn, lineno)
 |  
 |  set_sym_bpt(self, *args) -> 'void'
 |      set_sym_bpt(self, sym, o)
 |  
 |  set_trace_action(self, *args) -> 'bool'
 |      set_trace_action(self, enable, trace_types) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      bpt_t_cb_get(self) -> size_t
 |  
 |  cndidx
 |      bpt_t_cndidx_get(self) -> int
 |  
 |  condition
 |      bpt_t_condition_get(self) -> PyObject *
 |  
 |  ea
 |      bpt_t_ea_get(self) -> ea_t
 |  
 |  elang
 |      bpt_t_elang_get(self) -> PyObject *
 |  
 |  flags
 |      bpt_t_flags_get(self) -> uint32
 |  
 |  loc
 |      bpt_t_loc_get(self) -> bpt_location_t
 |  
 |  pass_count
 |      bpt_t_pass_count_get(self) -> int
 |  
 |  pid
 |      bpt_t_pid_get(self) -> pid_t
 |  
 |  props
 |      bpt_t_props_get(self) -> uint32
 |  
 |  size
 |      bpt_t_size_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      bpt_t_tid_get(self) -> thid_t
 |  
 |  type
 |      bpt_t_type_get(self) -> bpttype_t

Help on class bpt_vec_t in module ida_dbg:

class bpt_vec_t(builtins.object)
 |  Proxy of C++ qvector< bpt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'bpt_t const &'
 |      __getitem__(self, i) -> bpt_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bpt_vec_t
 |      __init__(self, x) -> bpt_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_bpt_vec_t(...)
 |      delete_bpt_vec_t(self)
 |  
 |  at(self, *args) -> 'bpt_t const &'
 |      at(self, _idx) -> bpt_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< bpt_t >::const_iterator'
 |      begin(self) -> bpt_t
 |      begin(self) -> bpt_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< bpt_t >::const_iterator'
 |      end(self) -> bpt_t
 |      end(self) -> bpt_t
 |  
 |  erase(self, *args) -> 'qvector< bpt_t >::iterator'
 |      erase(self, it) -> bpt_t
 |      erase(self, first, last) -> bpt_t
 |  
 |  extract(self, *args) -> 'bpt_t *'
 |      extract(self) -> bpt_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=bpt_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< bpt_t >::iterator'
 |      insert(self, it, x) -> bpt_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'bpt_t &'
 |      push_back(self, x)
 |      push_back(self) -> bpt_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function bring_debugger_to_front in module ida_dbg:

bring_debugger_to_front(*args) -> 'void'
    bring_debugger_to_front()

Help on function check_bpt in module ida_dbg:

check_bpt(*args) -> 'int'
    check_bpt(ea) -> int
    
    
    Check the breakpoint at the specified address.
    
    @param ea (C++: ea_t)
    @return: one of  Breakpoint status codes

Help on function choose_trace_file in module ida_dbg:

choose_trace_file(*args) -> 'qstring *'
    choose_trace_file() -> str
    
    
    Show the choose trace dialog.

Help on function clear_requests_queue in module ida_dbg:

clear_requests_queue(*args) -> 'void'
    clear_requests_queue()
    
    
    Clear the queue of waiting requests. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}If a request is currently
    running, this one isn't stopped.

Help on function clear_trace in module ida_dbg:

clear_trace(*args) -> 'void'
    clear_trace()
    
    
    Clear all events in the trace buffer. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}

Help on function collect_stack_trace in module ida_dbg:

collect_stack_trace(*args) -> 'bool'
    collect_stack_trace(tid, trace) -> bool

Help on function continue_process in module ida_dbg:

continue_process(*args) -> 'bool'
    continue_process() -> bool
    
    
    Continue the execution of the process in the debugger. \sq{Type,
    Synchronous function - available as Request, Notification, none
    (synchronous function)}The 'continue_process()' function can be called
    from a notification handler to force the continuation of the process.
    In this case the request queue will not be examined, IDA will simply
    resume execution. Usually it makes sense to call
    'request_continue_process()' followed by 'run_requests()' , so that
    IDA will first start a queued request (if any) and then resume the
    application.

Help on function create_source_viewer in module ida_dbg:

create_source_viewer(*args) -> 'source_view_t *'
    create_source_viewer(out_ccv, parent, custview, sf, lines, lnnum, colnum, flags) -> source_view_t *
    
    
    Create a source code view.
    
    
    @param out_ccv (C++: TWidget **)
    @param parent (C++: TWidget *)
    @param custview (C++: TWidget *)
    @param sf (C++: source_file_ptr)
    @param lines (C++: strvec_t  *)
    @param lnnum (C++: int)
    @param colnum (C++: int)
    @param flags (C++: int)

Help on function dbg_add_bpt_tev in module ida_dbg:

dbg_add_bpt_tev(*args) -> 'bool'
    dbg_add_bpt_tev(tid, ea, bp) -> bool
    
    
    Add a new breakpoint trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)
    @param ea (C++: ea_t)
    @param bp (C++: ea_t)
    @return: false if the operation failed, true otherwise

Help on function dbg_add_call_tev in module ida_dbg:

dbg_add_call_tev(*args) -> 'void'
    dbg_add_call_tev(tid, caller, callee)
    
    
    Add a new call trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)
    @param caller (C++: ea_t)
    @param callee (C++: ea_t)

Help on function dbg_add_debug_event in module ida_dbg:

dbg_add_debug_event(*args) -> 'void'
    dbg_add_debug_event(event)
    
    
    Add a new debug event to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param event (C++: debug_event_t  *)

Help on function dbg_add_insn_tev in module ida_dbg:

dbg_add_insn_tev(*args) -> 'bool'
    dbg_add_insn_tev(tid, ea, save=SAVE_DIFF) -> bool
    
    
    Add a new instruction trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)
    @param ea (C++: ea_t)
    @param save (C++: save_reg_values_t)
    @return: false if the operation failed, true otherwise

Help on function dbg_add_many_tevs in module ida_dbg:

dbg_add_many_tevs(*args) -> 'bool'
    dbg_add_many_tevs(new_tevs) -> bool
    
    
    Add many new trace elements to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param new_tevs (C++: tevinforeg_vec_t  *)
    @return: false if the operation failed for any  tev_info_t  object

Help on function dbg_add_ret_tev in module ida_dbg:

dbg_add_ret_tev(*args) -> 'void'
    dbg_add_ret_tev(tid, ret_insn, return_to)
    
    
    Add a new return trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)
    @param ret_insn (C++: ea_t)
    @param return_to (C++: ea_t)

Help on function dbg_add_tev in module ida_dbg:

dbg_add_tev(*args) -> 'void'
    dbg_add_tev(type, tid, address)
    
    
    Add a new trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param type (C++: tev_type_t)
    @param tid (C++: thid_t)
    @param address (C++: ea_t)

Help on function dbg_add_thread in module ida_dbg:

dbg_add_thread(*args) -> 'void'
    dbg_add_thread(tid)
    
    
    Add a thread to the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)

Help on function dbg_bin_search in module ida_dbg:

dbg_bin_search(*args) -> 'unsigned-ea-like-numeric-type *, qstring *'↗
    dbg_bin_search(start_ea, end_ea, data, srch_flags) -> str

Help on function dbg_can_query in module ida_dbg:

dbg_can_query(*args) -> 'bool'
    dbg_can_query() -> bool
    
    
    This function can be used to check if the debugger can be queried:
      - debugger is loaded
      - process is suspended
      - process is not suspended but can take requests. In this case some requests like
        memory read/write, bpt management succeed and register querying will fail.
        Check if idaapi.get_process_state() < 0 to tell if the process is suspended
    @return: Boolean

Help on function dbg_del_thread in module ida_dbg:

dbg_del_thread(*args) -> 'void'
    dbg_del_thread(tid)
    
    
    Delete a thread from the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)

Help on function dbg_is_loaded in module ida_dbg:

dbg_is_loaded(*args) -> 'bool'
    dbg_is_loaded() -> bool
    
    
    Checks if a debugger is loaded
    @return: Boolean

Help on function define_exception in module ida_dbg:

define_exception(*args) -> 'char const *'
    define_exception(code, name, desc, flags) -> char const *
    
    
    Convenience function: define new exception code.
    
    @param code: exception code (cannot be 0) (C++: uint)
    @param name: exception name (cannot be empty or NULL) (C++: const char
                 *)
    @param desc: exception description (maybe NULL) (C++: const char *)
    @param flags: combination of  Exception info flags (C++: int)
    @return: failure message or NULL. You must call  store_exceptions()
             if this function succeeds

Help on function del_bpt in module ida_dbg:

del_bpt(*args) -> 'bool'
    del_bpt(ea) -> bool
    del_bpt(bptloc) -> bool
    
    
    Delete an existing breakpoint in the debugged process. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    @param ea: any address in the breakpoint range (C++: ea_t)

Help on function del_bptgrp in module ida_dbg:

del_bptgrp(*args) -> 'bool'
    del_bptgrp(name) -> bool

Help on function del_virt_module in module ida_dbg:

del_virt_module(*args) -> 'bool'
    del_virt_module(base) -> bool

Help on function detach_process in module ida_dbg:

detach_process(*args) -> 'bool'
    detach_process() -> bool
    
    
    Detach the debugger from the debugged process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_detach' }

Help on function diff_trace_file in module ida_dbg:

diff_trace_file(*args) -> 'bool'
    diff_trace_file(nonnul_filename) -> bool
    
    
    Show difference between the current trace and the one from 'filename'.

Help on function disable_bblk_trace in module ida_dbg:

disable_bblk_trace(*args) -> 'bool'
    disable_bblk_trace() -> bool

Help on function disable_bpt in module ida_dbg:

disable_bpt(*args) -> 'bool'
    disable_bpt(ea) -> bool
    disable_bpt(bptloc) -> bool

Help on function disable_func_trace in module ida_dbg:

disable_func_trace(*args) -> 'bool'
    disable_func_trace() -> bool

Help on function disable_insn_trace in module ida_dbg:

disable_insn_trace(*args) -> 'bool'
    disable_insn_trace() -> bool

Help on function disable_step_trace in module ida_dbg:

disable_step_trace(*args) -> 'bool'
    disable_step_trace() -> bool

Help on function edit_manual_regions in module ida_dbg:

edit_manual_regions(*args) -> 'void'
    edit_manual_regions()

Help on function enable_bblk_trace in module ida_dbg:

enable_bblk_trace(*args) -> 'bool'
    enable_bblk_trace(enable=True) -> bool

Help on function enable_bpt in module ida_dbg:

enable_bpt(*args) -> 'bool'
    enable_bpt(ea, enable=True) -> bool
    enable_bpt(bptloc, enable=True) -> bool

Help on function enable_func_trace in module ida_dbg:

enable_func_trace(*args) -> 'bool'
    enable_func_trace(enable=True) -> bool

Help on function enable_insn_trace in module ida_dbg:

enable_insn_trace(*args) -> 'bool'
    enable_insn_trace(enable=True) -> bool

Help on function enable_manual_regions in module ida_dbg:

enable_manual_regions(*args) -> 'void'
    enable_manual_regions(enable)

Help on function enable_step_trace in module ida_dbg:

enable_step_trace(*args) -> 'bool'
    enable_step_trace(enable=True) -> bool

Help on class eval_ctx_t in module ida_dbg:

class eval_ctx_t(builtins.object)
 |  Proxy of C++ eval_ctx_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea) -> eval_ctx_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_eval_ctx_t(...)
 |      delete_eval_ctx_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      eval_ctx_t_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag

Help on function exist_bpt in module ida_dbg:

exist_bpt(*args) -> 'bool'
    exist_bpt(ea) -> bool
    
    
    Does a breakpoint exist at the given location?
    
    
    @param ea (C++: ea_t)

Help on function exit_process in module ida_dbg:

exit_process(*args) -> 'bool'
    exit_process() -> bool
    
    
    Terminate the debugging of the current process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_exit' }

Help on function find_bpt in module ida_dbg:

find_bpt(*args) -> 'bool'
    find_bpt(bptloc, bpt) -> bool
    
    
    Find a breakpoint by location. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param bptloc: Breakpoint location (C++: const  bpt_location_t  &)
    @param bpt: bpt is filled if the breakpoint was found (C++: bpt_t  *)

Help on function get_bblk_trace_options in module ida_dbg:

get_bblk_trace_options(*args) -> 'int'
    get_bblk_trace_options() -> int
    
    
    Get current basic block tracing options. Also see 'BT_LOG_INSTS'
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}

Help on function get_bpt in module ida_dbg:

get_bpt(*args) -> 'bool'
    get_bpt(ea, bpt) -> bool
    
    
    Get the characteristics of a breakpoint. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param ea: any address in the breakpoint range (C++: ea_t)
    @param bpt: if not NULL, is filled with the characteristics. (C++:
                bpt_t  *)
    @return: false if no breakpoint exists

Help on function get_bpt_group in module ida_dbg:

get_bpt_group(*args) -> 'qstring *'
    get_bpt_group(bptloc) -> str

Help on function get_bpt_qty in module ida_dbg:

get_bpt_qty(*args) -> 'int'
    get_bpt_qty() -> int
    
    
    Get number of breakpoints. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function get_bpt_tev_ea in module ida_dbg:

get_bpt_tev_ea(*args) -> 'ea_t'
    get_bpt_tev_ea(n) -> ea_t
    
    
    Get the address associated to a read, read/write or execution trace
    event. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}Usually, a breakpoint is associated with a read, read/write
    or execution trace event. However, the returned address could be any
    address in the range of this breakpoint. If the breakpoint was deleted
    after the trace event, the address no longer corresponds to a valid
    breakpoint.
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @return: BADADDR  if not a read, read/write or execution trace event.

Help on function get_bptloc_string in module ida_dbg:

get_bptloc_string(*args) -> 'char const *'
    get_bptloc_string(i) -> char const *
    
    
    Helper function for 'bpt_location_t' .
    
    
    @param i (C++: int)

Help on function get_call_tev_callee in module ida_dbg:

get_call_tev_callee(*args) -> 'ea_t'
    get_call_tev_callee(n) -> ea_t
    
    
    Get the called function from a function call trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @return: BADADDR  if not a function call event.

Help on function get_current_source_file in module ida_dbg:

get_current_source_file(*args) -> 'bool'
    get_current_source_file(path) -> bool

Help on function get_current_source_line in module ida_dbg:

get_current_source_line(*args) -> 'int'
    get_current_source_line() -> int

Help on function get_current_thread in module ida_dbg:

get_current_thread(*args) -> 'thid_t'
    get_current_thread() -> thid_t
    
    
    Get current thread ID. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}

Help on function get_dbg_byte in module ida_dbg:

get_dbg_byte(*args) -> 'bool'
    get_dbg_byte(x, ea) -> bool
    
    
    Get one byte of the debugged process memory.
    
    @param x: pointer to byte value (C++: uint32  *)
    @param ea: linear address (C++: ea_t)
    @return: true success

Help on function get_dbg_memory_info in module ida_dbg:

get_dbg_memory_info(*args) -> 'int'
    get_dbg_memory_info(ranges) -> int

Help on function get_dbg_reg_info in module ida_dbg:

get_dbg_reg_info(*args) -> 'bool'
    get_dbg_reg_info(regname, ri) -> bool
    
    
    Get register information \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param regname (C++: const char *)
    @param ri (C++: register_info_t  *)

Help on function get_debug_event in module ida_dbg:

get_debug_event(*args) -> 'debug_event_t const *'
    get_debug_event() -> debug_event_t
    
    
    Get the current debugger event.

Help on function get_debugger_event_cond in module ida_dbg:

get_debugger_event_cond(*args) -> 'char const *'
    get_debugger_event_cond() -> char const *

Help on function get_first_module in module ida_dbg:

get_first_module(*args) -> 'bool'
    get_first_module(modinfo) -> bool

Help on function get_func_trace_options in module ida_dbg:

get_func_trace_options(*args) -> 'int'
    get_func_trace_options() -> int
    
    
    Get current function tracing options. Also see 'FT_LOG_RET' \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

Help on function get_global_var in module ida_dbg:

get_global_var(*args) -> 'bool'
    get_global_var(prov, ea, name, out) -> bool

Help on function get_grp_bpts in module ida_dbg:

get_grp_bpts(*args) -> 'ssize_t'
    get_grp_bpts(bpts, grp_name) -> ssize_t

Help on function get_insn_tev_reg_mem in module ida_dbg:

get_insn_tev_reg_mem(*args) -> 'bool'
    get_insn_tev_reg_mem(n, memmap) -> bool
    
    
    Read the memory pointed by register values from an instruction trace
    event. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param memmap: result (C++: memreg_infos_t  *)
    @return: false if not an instruction event or no memory is available

Help on function get_insn_tev_reg_result in module ida_dbg:

get_insn_tev_reg_result(*args) -> 'bool'
    get_insn_tev_reg_result(n, regname, regval) -> bool
    
    
    Read the resulting register value from an instruction trace event.
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param regname: name of desired register (C++: const char *)
    @param regval: result (C++: regval_t  *)
    @return: false if not an instruction trace event or register wasn't
             modified.

Help on function get_insn_tev_reg_val in module ida_dbg:

get_insn_tev_reg_val(*args) -> 'bool'
    get_insn_tev_reg_val(n, regname, regval) -> bool
    
    
    Read a register value from an instruction trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}This
    is the value of the register before the execution of the instruction.
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param regname: name of desired register (C++: const char *)
    @param regval: result (C++: regval_t  *)
    @return: false if not an instruction event.

Help on function get_insn_trace_options in module ida_dbg:

get_insn_trace_options(*args) -> 'int'
    get_insn_trace_options() -> int
    
    
    Get current instruction tracing options. Also see 'IT_LOG_SAME_IP'
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}

Help on function get_ip_val in module ida_dbg:

get_ip_val(*args) -> 'unsigned-ea-like-numeric-type *'↗
    get_ip_val() -> bool
    
    
    Get value of the IP (program counter) register for the current thread.
    Requires a suspended debugger.

Help on function get_local_var in module ida_dbg:

get_local_var(*args) -> 'bool'
    get_local_var(prov, ea, name, out) -> bool

Help on function get_local_vars in module ida_dbg:

get_local_vars(*args) -> 'bool'
    get_local_vars(prov, ea, out) -> bool

Help on function get_manual_regions in module ida_dbg:

get_manual_regions(*args) -> 'PyObject *'
    get_manual_regions(ranges)
    get_manual_regions() -> PyObject *
    
    
    Returns the manual memory regions
    @return: list(start_ea, end_ea, name, sclass, sbase, bitness, perm)

Help on function get_module_info in module ida_dbg:

get_module_info(*args) -> 'bool'
    get_module_info(ea, modinfo) -> bool

Help on function get_next_module in module ida_dbg:

get_next_module(*args) -> 'bool'
    get_next_module(modinfo) -> bool

Help on function get_process_options in module ida_dbg:

get_process_options(*args) -> 'void'
    get_process_options(path, args, sdir, host, _pass, port)
    
    
    Get process options. Any of the arguments may be NULL
    
    @param path (C++: qstring  *)
    @param args (C++: qstring  *)
    @param sdir (C++: qstring  *)
    @param host (C++: qstring  *)
    @param port (C++: int *)

Help on function get_process_state in module ida_dbg:

get_process_state(*args) -> 'int'
    get_process_state() -> int
    
    
    Return the state of the currently debugged process. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @return: one of  Debugged process states

Help on function get_processes in module ida_dbg:

get_processes(*args) -> 'ssize_t'
    get_processes(proclist) -> ssize_t
    
    
    Take a snapshot of running processes and return their description.
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    @param proclist (C++: procinfo_vec_t  *)
    @return: number of processes or -1 on error

Help on function get_reg_val in module ida_dbg:

get_reg_val(*args) -> 'PyObject *'
    get_reg_val(regname, regval) -> bool
    get_reg_val(regname, ival) -> bool
    get_reg_val(regname) -> PyObject *
    
    
    Read a register value from the current thread. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param regname (C++: const char *)
    @param regval (C++: regval_t  *)

Help on function get_reg_vals in module ida_dbg:

get_reg_vals(*args) -> 'int'
    get_reg_vals(tid, clsmask, values) -> int

Help on function get_ret_tev_return in module ida_dbg:

get_ret_tev_return(*args) -> 'ea_t'
    get_ret_tev_return(n) -> ea_t
    
    
    Get the return address from a function return trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @return: BADADDR  if not a function return event.

Help on function get_running_notification in module ida_dbg:

get_running_notification(*args) -> 'dbg_notification_t'
    get_running_notification() -> dbg_notification_t
    
    
    Get the notification associated (if any) with the current running
    request. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @return: dbg_null if no running request

Help on function get_running_request in module ida_dbg:

get_running_request(*args) -> 'ui_notification_t'
    get_running_request() -> ui_notification_t
    
    
    Get the current running request. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @return: ui_null if no running request

Help on function get_sp_val in module ida_dbg:

get_sp_val(*args) -> 'unsigned-ea-like-numeric-type *'↗
    get_sp_val() -> bool
    
    
    Get value of the SP register for the current thread. Requires a
    suspended debugger.

Help on function get_srcinfo_provider in module ida_dbg:

get_srcinfo_provider(*args) -> 'srcinfo_provider_t *'
    get_srcinfo_provider(name) -> srcinfo_provider_t *

Help on function get_step_trace_options in module ida_dbg:

get_step_trace_options(*args) -> 'int'
    get_step_trace_options() -> int
    
    
    Get current step tracing options. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @return: Step trace options

Help on function get_tev_ea in module ida_dbg:

get_tev_ea(*args) -> 'ea_t'
    get_tev_ea(n) -> ea_t

Help on function get_tev_event in module ida_dbg:

get_tev_event(*args) -> 'bool'
    get_tev_event(n, d) -> bool
    
    
    Get the corresponding debug event, if any, for the specified tev
    object. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param d: result (C++: debug_event_t  *)
    @return: false if the tev_t object doesn't have any associated debug
             event, true otherwise, with the debug event in "d".

Help on function get_tev_info in module ida_dbg:

get_tev_info(*args) -> 'bool'
    get_tev_info(n, tev_info) -> bool
    
    
    Get main information about a trace event. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param tev_info: result (C++: tev_info_t  *)
    @return: success

Help on function get_tev_memory_info in module ida_dbg:

get_tev_memory_info(*args) -> 'bool'
    get_tev_memory_info(n, mi) -> bool
    
    
    Get the memory layout, if any, for the specified tev object. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param mi: result (C++: meminfo_vec_t  *)
    @return: false if the tev_t object is not of type  tev_mem , true
             otherwise, with the new memory layout in "mi".

Help on function get_tev_qty in module ida_dbg:

get_tev_qty(*args) -> 'int'
    get_tev_qty() -> int
    
    
    Get number of trace events available in trace buffer. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

Help on function get_tev_reg_mem in module ida_dbg:

get_tev_reg_mem(tev, idx)

Help on function get_tev_reg_mem_ea in module ida_dbg:

get_tev_reg_mem_ea(tev, idx)

Help on function get_tev_reg_mem_qty in module ida_dbg:

get_tev_reg_mem_qty(tev)

Help on function get_tev_reg_val in module ida_dbg:

get_tev_reg_val(tev, reg)

Help on function get_tev_tid in module ida_dbg:

get_tev_tid(*args) -> 'int'
    get_tev_tid(n) -> int

Help on function get_tev_type in module ida_dbg:

get_tev_type(*args) -> 'int'
    get_tev_type(n) -> int

Help on function get_thread_qty in module ida_dbg:

get_thread_qty(*args) -> 'int'
    get_thread_qty() -> int
    
    
    Get number of threads. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}

Help on function get_trace_base_address in module ida_dbg:

get_trace_base_address(*args) -> 'ea_t'
    get_trace_base_address() -> ea_t
    
    
    Get the base address of the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @return: the base address of the currently loaded trace

Help on function get_trace_file_desc in module ida_dbg:

get_trace_file_desc(*args) -> 'qstring *'
    get_trace_file_desc(filename) -> str
    
    
    Get the file header of the specified trace file.
    
    
    @param filename (C++: const char *)

Help on function get_trace_platform in module ida_dbg:

get_trace_platform(*args) -> 'char const *'
    get_trace_platform() -> char const *
    
    
    Get platform name of current trace.

Help on function getn_bpt in module ida_dbg:

getn_bpt(*args) -> 'bool'
    getn_bpt(n, bpt) -> bool
    
    
    Get the characteristics of a breakpoint. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param n: number of breakpoint, is in range 0.. get_bpt_qty() -1 (C++:
              int)
    @param bpt: filled with the characteristics. (C++: bpt_t  *)
    @return: false if no breakpoint exists

Help on function getn_thread in module ida_dbg:

getn_thread(*args) -> 'thid_t'
    getn_thread(n) -> thid_t
    
    
    Get the ID of a thread. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param n: number of thread, is in range 0.. get_thread_qty() -1 (C++:
              int)
    @return: NO_THREAD  if the thread doesn't exist.

Help on function getn_thread_name in module ida_dbg:

getn_thread_name(*args) -> 'char const *'
    getn_thread_name(n) -> char const *
    
    
    Get the NAME of a thread \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param n: number of thread, is in range 0.. get_thread_qty() -1 or -1
              for the current thread (C++: int)
    @return: thread name or NULL if the thread doesn't exist.

Help on function graph_trace in module ida_dbg:

graph_trace(*args) -> 'bool'
    graph_trace() -> bool
    
    
    Show the trace callgraph.

Help on function handle_debug_event in module ida_dbg:

handle_debug_event(*args) -> 'int'
    handle_debug_event(ev, rqflags) -> int

Help on function hide_all_bpts in module ida_dbg:

hide_all_bpts(*args) -> 'int'
    hide_all_bpts() -> int

Help on function internal_get_sreg_base in module ida_dbg:

internal_get_sreg_base(*args) -> 'ea_t'
    internal_get_sreg_base(tid, sreg_value) -> ea_t
    
    
    Get the sreg base, for the given thread.
    
    @return: The sreg base, or BADADDR on failure.

Help on function internal_ioctl in module ida_dbg:

internal_ioctl(*args) -> 'int'
    internal_ioctl(fn, buf, poutbuf, poutsize) -> int

Help on function invalidate_dbg_state in module ida_dbg:

invalidate_dbg_state(*args) -> 'int'
    invalidate_dbg_state(dbginv) -> int
    
    
    Invalidate cached debugger information. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param dbginv: Debugged process invalidation options (C++: int)
    @return: current debugger state (one of  Debugged process states )

Help on function invalidate_dbgmem_config in module ida_dbg:

invalidate_dbgmem_config(*args) -> 'void'
    invalidate_dbgmem_config()
    
    
    Invalidate the debugged process memory configuration. Call this
    function if the debugged process might have changed its memory layout
    (allocated more memory, for example)

Help on function invalidate_dbgmem_contents in module ida_dbg:

invalidate_dbgmem_contents(*args) -> 'void'
    invalidate_dbgmem_contents(ea, size)
    
    
    Invalidate the debugged process memory contents. Call this function
    each time the process has been stopped or the process memory is
    modified. If ea == 'BADADDR' , then the whole memory contents will be
    invalidated
    
    @param ea (C++: ea_t)
    @param size (C++: asize_t)

Help on function is_bblk_trace_enabled in module ida_dbg:

is_bblk_trace_enabled(*args) -> 'bool'
    is_bblk_trace_enabled() -> bool

Help on function is_debugger_busy in module ida_dbg:

is_debugger_busy(*args) -> 'bool'
    is_debugger_busy() -> bool
    
    
    Is the debugger busy?. Some debuggers do not accept any commands while
    the debugged application is running. For such a debugger, it is unsafe
    to do anything with the database (even simple queries like get_byte
    may lead to undesired consequences). Returns: true if the debugged
    application is running under such a debugger

Help on function is_debugger_memory in module ida_dbg:

is_debugger_memory(*args) -> 'bool'
    is_debugger_memory(ea) -> bool
    
    
    Is the address mapped to debugger memory?
    
    
    @param ea (C++: ea_t)

Help on function is_debugger_on in module ida_dbg:

is_debugger_on(*args) -> 'bool'
    is_debugger_on() -> bool
    
    
    Is the debugger currently running?

Help on function is_func_trace_enabled in module ida_dbg:

is_func_trace_enabled(*args) -> 'bool'
    is_func_trace_enabled() -> bool
    
    
    Get current state of functions tracing. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}

Help on function is_insn_trace_enabled in module ida_dbg:

is_insn_trace_enabled(*args) -> 'bool'
    is_insn_trace_enabled() -> bool
    
    
    Get current state of instructions tracing. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}

Help on function is_reg_custom in module ida_dbg:

is_reg_custom(*args) -> 'bool'
    is_reg_custom(regname) -> bool
    
    
    Does a register contain a value of a custom data type? \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param regname (C++: const char *)

Help on function is_reg_float in module ida_dbg:

is_reg_float(*args) -> 'bool'
    is_reg_float(regname) -> bool
    
    
    Does a register contain a floating point value? \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param regname (C++: const char *)

Help on function is_reg_integer in module ida_dbg:

is_reg_integer(*args) -> 'bool'
    is_reg_integer(regname) -> bool
    
    
    Does a register contain an integer value? \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param regname (C++: const char *)

Help on function is_request_running in module ida_dbg:

is_request_running(*args) -> 'bool'
    is_request_running() -> bool
    
    
    Is a request currently running?

Help on function is_step_trace_enabled in module ida_dbg:

is_step_trace_enabled(*args) -> 'bool'
    is_step_trace_enabled() -> bool
    
    
    Get current state of step tracing. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function is_valid_trace_file in module ida_dbg:

is_valid_trace_file(*args) -> 'bool'
    is_valid_trace_file(filename) -> bool
    
    
    Is the specified file a valid trace file for the current database?
    
    
    @param filename (C++: const char *)

Help on function list_bptgrps in module ida_dbg:

list_bptgrps(*args) -> 'PyObject *'
    list_bptgrps(bptgrps) -> size_t
    list_bptgrps() -> PyObject *

Help on function load_debugger in module ida_dbg:

load_debugger(*args) -> 'bool'
    load_debugger(dbgname, use_remote) -> bool

Help on function load_trace_file in module ida_dbg:

load_trace_file(*args) -> 'qstring *'
    load_trace_file(filename) -> str
    
    
    Load a recorded trace file in the trace window. If the call succeeds
    and 'buf' is not null, the description of the trace stored in the
    binary trace file will be returned in 'buf'
    
    @param filename (C++: const char *)

Help on class memreg_info_t in module ida_dbg:

class memreg_info_t(builtins.object)
 |  Proxy of C++ memreg_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> memreg_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_memreg_info_t(...)
 |      delete_memreg_info_t(self)
 |  
 |  get_bytes(self, *args) -> 'PyObject *'
 |      get_bytes(self) -> PyObject *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bytes
 |      get_bytes(self) -> PyObject *
 |  
 |  ea
 |      memreg_info_t_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag

Help on class memreg_infos_t in module ida_dbg:

class memreg_infos_t(builtins.object)
 |  Proxy of C++ qvector< memreg_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'memreg_info_t const &'
 |      __getitem__(self, i) -> memreg_info_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> memreg_infos_t
 |      __init__(self, x) -> memreg_infos_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_memreg_infos_t(...)
 |      delete_memreg_infos_t(self)
 |  
 |  at(self, *args) -> 'memreg_info_t const &'
 |      at(self, _idx) -> memreg_info_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< memreg_info_t >::const_iterator'
 |      begin(self) -> memreg_info_t
 |      begin(self) -> memreg_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< memreg_info_t >::const_iterator'
 |      end(self) -> memreg_info_t
 |      end(self) -> memreg_info_t
 |  
 |  erase(self, *args) -> 'qvector< memreg_info_t >::iterator'
 |      erase(self, it) -> memreg_info_t
 |      erase(self, first, last) -> memreg_info_t
 |  
 |  extract(self, *args) -> 'memreg_info_t *'
 |      extract(self) -> memreg_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=memreg_info_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< memreg_info_t >::iterator'
 |      insert(self, it, x) -> memreg_info_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'memreg_info_t &'
 |      push_back(self, x)
 |      push_back(self) -> memreg_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function move_bpt_to_grp in module ida_dbg:

move_bpt_to_grp(*args) -> 'void'
    move_bpt_to_grp(bpt, grp_name)
    
    
    Sets new group for the breakpoint

Help on function put_dbg_byte in module ida_dbg:

put_dbg_byte(*args) -> 'bool'
    put_dbg_byte(ea, x) -> bool
    
    
    Change one byte of the debugged process memory.
    
    @param ea: linear address (C++: ea_t)
    @param x: byte value (C++: uint32)
    @return: true if the process memory has been modified

Help on function read_dbg_memory in module ida_dbg:

read_dbg_memory(*args) -> 'ssize_t'
    read_dbg_memory(ea, buffer, size) -> ssize_t

Help on function refresh_debugger_memory in module ida_dbg:

refresh_debugger_memory(*args) -> 'PyObject *'
    refresh_debugger_memory() -> PyObject *
    
    
    Refreshes the debugger memory
    @return: Nothing

Help on function rename_bptgrp in module ida_dbg:

rename_bptgrp(*args) -> 'bool'
    rename_bptgrp(old_name, new_name) -> bool

Help on function request_add_bpt in module ida_dbg:

request_add_bpt(*args) -> 'bool'
    request_add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
    request_add_bpt(bpt) -> bool
    
    
    Post an 'add_bpt(ea_t, asize_t, bpttype_t)' request.
    
    
    @param ea (C++: ea_t)
    @param size (C++: asize_t)
    @param type (C++: bpttype_t)

Help on function request_attach_process in module ida_dbg:

request_attach_process(*args) -> 'int'
    request_attach_process(pid, event_id) -> int
    
    
    Post an 'attach_process()' request.
    
    
    @param pid (C++: pid_t)
    @param event_id (C++: int)

Help on function request_clear_trace in module ida_dbg:

request_clear_trace(*args) -> 'void'
    request_clear_trace()
    
    
    Post a 'clear_trace()' request.

Help on function request_continue_process in module ida_dbg:

request_continue_process(*args) -> 'bool'
    request_continue_process() -> bool
    
    
    Post a 'continue_process()' request.This requires an explicit call to
    'run_requests()'

Help on function request_del_bpt in module ida_dbg:

request_del_bpt(*args) -> 'bool'
    request_del_bpt(ea) -> bool
    request_del_bpt(bptloc) -> bool
    
    
    Post a 'del_bpt(ea_t)' request.
    
    
    @param ea (C++: ea_t)

Help on function request_detach_process in module ida_dbg:

request_detach_process(*args) -> 'bool'
    request_detach_process() -> bool
    
    
    Post a 'detach_process()' request.

Help on function request_disable_bblk_trace in module ida_dbg:

request_disable_bblk_trace(*args) -> 'bool'
    request_disable_bblk_trace() -> bool

Help on function request_disable_bpt in module ida_dbg:

request_disable_bpt(*args) -> 'bool'
    request_disable_bpt(ea) -> bool
    request_disable_bpt(bptloc) -> bool

Help on function request_disable_func_trace in module ida_dbg:

request_disable_func_trace(*args) -> 'bool'
    request_disable_func_trace() -> bool

Help on function request_disable_insn_trace in module ida_dbg:

request_disable_insn_trace(*args) -> 'bool'
    request_disable_insn_trace() -> bool

Help on function request_disable_step_trace in module ida_dbg:

request_disable_step_trace(*args) -> 'bool'
    request_disable_step_trace() -> bool

Help on function request_enable_bblk_trace in module ida_dbg:

request_enable_bblk_trace(*args) -> 'bool'
    request_enable_bblk_trace(enable=True) -> bool

Help on function request_enable_bpt in module ida_dbg:

request_enable_bpt(*args) -> 'bool'
    request_enable_bpt(ea, enable=True) -> bool
    request_enable_bpt(bptloc, enable=True) -> bool

Help on function request_enable_func_trace in module ida_dbg:

request_enable_func_trace(*args) -> 'bool'
    request_enable_func_trace(enable=True) -> bool

Help on function request_enable_insn_trace in module ida_dbg:

request_enable_insn_trace(*args) -> 'bool'
    request_enable_insn_trace(enable=True) -> bool

Help on function request_enable_step_trace in module ida_dbg:

request_enable_step_trace(*args) -> 'bool'
    request_enable_step_trace(enable=True) -> bool

Help on function request_exit_process in module ida_dbg:

request_exit_process(*args) -> 'bool'
    request_exit_process() -> bool
    
    
    Post an 'exit_process()' request.

Help on function request_resume_thread in module ida_dbg:

request_resume_thread(*args) -> 'int'
    request_resume_thread(tid) -> int
    
    
    Post a 'resume_thread()' request.
    
    
    @param tid (C++: thid_t)

Help on function request_run_to in module ida_dbg:

request_run_to(*args) -> 'bool'
    request_run_to(ea, pid=pid_t(-1), tid=0) -> bool
    
    
    Post a 'run_to()' request.
    
    
    @param ea (C++: ea_t)
    @param pid (C++: pid_t)
    @param tid (C++: thid_t)

Help on function request_select_thread in module ida_dbg:

request_select_thread(*args) -> 'bool'
    request_select_thread(tid) -> bool
    
    
    Post a 'select_thread()' request.
    
    
    @param tid (C++: thid_t)

Help on function request_set_bblk_trace_options in module ida_dbg:

request_set_bblk_trace_options(*args) -> 'void'
    request_set_bblk_trace_options(options)
    
    
    Post a 'set_bblk_trace_options()' request.
    
    
    @param options (C++: int)

Help on function request_set_func_trace_options in module ida_dbg:

request_set_func_trace_options(*args) -> 'void'
    request_set_func_trace_options(options)
    
    
    Post a 'set_func_trace_options()' request.
    
    
    @param options (C++: int)

Help on function request_set_insn_trace_options in module ida_dbg:

request_set_insn_trace_options(*args) -> 'void'
    request_set_insn_trace_options(options)
    
    
    Post a 'set_insn_trace_options()' request.
    
    
    @param options (C++: int)

Help on function request_set_reg_val in module ida_dbg:

request_set_reg_val(*args) -> 'PyObject *'
    request_set_reg_val(regname, o) -> PyObject *
    
    
    Post a 'set_reg_val()' request.
    
    
    @param regname (C++: const char *)

Help on function request_set_resume_mode in module ida_dbg:

request_set_resume_mode(*args) -> 'bool'
    request_set_resume_mode(tid, mode) -> bool
    
    
    Post a 'set_resume_mode()' request.
    
    
    @param tid (C++: thid_t)
    @param mode (C++: resume_mode_t)

Help on function request_set_step_trace_options in module ida_dbg:

request_set_step_trace_options(*args) -> 'void'
    request_set_step_trace_options(options)
    
    
    Post a 'set_step_trace_options()' request.
    
    
    @param options (C++: int)

Help on function request_start_process in module ida_dbg:

request_start_process(*args) -> 'int'
    request_start_process(path=None, args=None, sdir=None) -> int
    
    
    Post a 'start_process()' request.
    
    
    @param path (C++: const char *)
    @param args (C++: const char *)
    @param sdir (C++: const char *)

Help on function request_step_into in module ida_dbg:

request_step_into(*args) -> 'bool'
    request_step_into() -> bool
    
    
    Post a 'step_into()' request.

Help on function request_step_over in module ida_dbg:

request_step_over(*args) -> 'bool'
    request_step_over() -> bool
    
    
    Post a 'step_over()' request.

Help on function request_step_until_ret in module ida_dbg:

request_step_until_ret(*args) -> 'bool'
    request_step_until_ret() -> bool
    
    
    Post a 'step_until_ret()' request.

Help on function request_suspend_process in module ida_dbg:

request_suspend_process(*args) -> 'bool'
    request_suspend_process() -> bool
    
    
    Post a 'suspend_process()' request.

Help on function request_suspend_thread in module ida_dbg:

request_suspend_thread(*args) -> 'int'
    request_suspend_thread(tid) -> int
    
    
    Post a 'suspend_thread()' request.
    
    
    @param tid (C++: thid_t)

Help on function resume_thread in module ida_dbg:

resume_thread(*args) -> 'int'
    resume_thread(tid) -> int
    
    
    Resume thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    @param tid: thread id (C++: thid_t)

Help on function retrieve_exceptions in module ida_dbg:

retrieve_exceptions(*args) -> 'excvec_t *'
    retrieve_exceptions() -> excvec_t
    
    
    Retrieve the exception information. You may freely modify the returned
    vector and add/edit/delete exceptions You must call
    'store_exceptions()' after any modifications Note: exceptions with
    code zero, multiple exception codes or names are prohibited

Help on function run_requests in module ida_dbg:

run_requests(*args) -> 'bool'
    run_requests() -> bool
    
    
    Execute requests until all requests are processed or an asynchronous
    function is called. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}If called from a notification handler, the
    execution of requests will be postponed to the end of the execution of
    all notification handlers.
    
    @return: false if not all requests could be processed (indicates an
             asynchronous function was started)

Help on function run_to in module ida_dbg:

run_to(*args) -> 'bool'
    run_to(ea, pid=pid_t(-1), tid=0) -> bool
    
    
    Execute the process until the given address is reached. If no process
    is active, a new process is started. Technically, the debugger sets up
    a temporary breakpoint at the given address, and continues (or starts)
    the execution of the whole process. So, all threads continue their
    execution! \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_run_to' }
    
    @param ea: target address (C++: ea_t)
    @param pid: not used yet. please do not specify this parameter. (C++:
                pid_t)
    @param tid: not used yet. please do not specify this parameter. (C++:
                thid_t)

Help on function save_trace_file in module ida_dbg:

save_trace_file(*args) -> 'bool'
    save_trace_file(filename, description) -> bool
    
    
    Save the current trace in the specified file.
    
    
    @param filename (C++: const char *)
    @param description (C++: const char *)

Help on function select_thread in module ida_dbg:

select_thread(*args) -> 'bool'
    select_thread(tid) -> bool
    
    
    Select the given thread as the current debugged thread. All thread
    related execution functions will work on this thread. The process must
    be suspended to select a new thread. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param tid: ID of the thread to select (C++: thid_t)
    @return: false if the thread doesn't exist.

Help on function send_dbg_command in module ida_dbg:

send_dbg_command(command)
    Send a direct command to the debugger backend, and
    retrieve the result as a string.
    
    Note: any double-quotes in 'command' must be backslash-escaped.
    Note: this only works with some debugger backends: Bochs, WinDbg, GDB.
    
    Returns: (True, <result string>) on success, or (False, <Error message string>) on failure

Help on function set_bblk_trace_options in module ida_dbg:

set_bblk_trace_options(*args) -> 'void'
    set_bblk_trace_options(options)
    
    
    Modify basic block tracing options (see 'BT_LOG_INSTS' )
    
    
    @param options (C++: int)

Help on function set_bpt_group in module ida_dbg:

set_bpt_group(*args) -> 'void'
    set_bpt_group(bpt, grp_name)

Help on function set_bptloc_group in module ida_dbg:

set_bptloc_group(*args) -> 'bool'
    set_bptloc_group(bptloc, grp_name) -> bool

Help on function set_bptloc_string in module ida_dbg:

set_bptloc_string(*args) -> 'int'
    set_bptloc_string(s) -> int
    
    
    Helper function for 'bpt_location_t' .
    
    
    @param s (C++: const char *)

Help on function set_debugger_event_cond in module ida_dbg:

set_debugger_event_cond(*args) -> 'void'
    set_debugger_event_cond(nonnul_cond)

Help on function set_debugger_options in module ida_dbg:

set_debugger_options(*args) -> 'uint'
    set_debugger_options(options) -> uint
    
    
    Set debugger options. Replaces debugger options with the specification
    combination 'Debugger options'
    
    @param options (C++: uint)
    @return: the old debugger options

Help on function set_func_trace_options in module ida_dbg:

set_func_trace_options(*args) -> 'void'
    set_func_trace_options(options)
    
    
    Modify function tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param options (C++: int)

Help on function set_highlight_trace_options in module ida_dbg:

set_highlight_trace_options(*args) -> 'void'
    set_highlight_trace_options(hilight, color, diff)
    
    
    Set highlight trace parameters.
    
    
    @param hilight (C++: bool)
    @param color (C++: bgcolor_t)
    @param diff (C++: bgcolor_t)

Help on function set_insn_trace_options in module ida_dbg:

set_insn_trace_options(*args) -> 'void'
    set_insn_trace_options(options)
    
    
    Modify instruction tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param options (C++: int)

Help on function set_manual_regions in module ida_dbg:

set_manual_regions(*args) -> 'void'
    set_manual_regions(ranges)

Help on function set_process_options in module ida_dbg:

set_process_options(*args) -> 'void'
    set_process_options(path, args, sdir, host, _pass, port)
    
    
    Set process options. Any of the arguments may be NULL, which means 'do
    not modify'
    
    @param path (C++: const char *)
    @param args (C++: const char *)
    @param sdir (C++: const char *)
    @param host (C++: const char *)
    @param port (C++: int)

Help on function set_process_state in module ida_dbg:

set_process_state(*args) -> 'int'
    set_process_state(newstate, p_thid, dbginv) -> int
    
    
    Set new state for the debugged process. Notifies the IDA kernel about
    the change of the debugged process state. For example, a debugger
    module could call this function when it knows that the process is
    suspended for a short period of time. Some IDA API calls can be made
    only when the process is suspended. The process state is usually
    restored before returning control to the caller. You must know that it
    is ok to change the process state, doing it at arbitrary moments may
    crash the application or IDA. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param newstate: new process state (one of  Debugged process states )
                     if  DSTATE_NOTASK  is passed then the state is not
                     changed (C++: int)
    @param p_thid: ptr to new thread id. may be NULL or pointer to
                   NO_THREAD . the pointed variable will contain the old
                   thread id upon return (C++: thid_t  *)
    @param dbginv: Debugged process invalidation options (C++: int)
    @return: old debugger state (one of  Debugged process states )

Help on function set_reg_val in module ida_dbg:

set_reg_val(*args) -> 'PyObject *'
    set_reg_val(regname, o) -> PyObject
    set_reg_val(tid, regidx, o) -> PyObject *
    
    
    Write a register value to the current thread. \sq{Type, Synchronous
    function - available as Request, Notification, none (synchronous
    function)}
    
    @param regname (C++: const char *)

Help on function set_remote_debugger in module ida_dbg:

set_remote_debugger(*args) -> 'void'
    set_remote_debugger(host, _pass, port=-1)
    
    
    Set remote debugging options. Should be used before starting the
    debugger.
    
    @param host: If empty, IDA will use local debugger. If NULL, the host
                 will not be set. (C++: const char *)
    @param port: If -1, the default port number will be used (C++: int)

Help on function set_resume_mode in module ida_dbg:

set_resume_mode(*args) -> 'bool'
    set_resume_mode(tid, mode) -> bool
    
    
    How to resume the application. Set resume mode but do not resume
    process.
    
    @param tid (C++: thid_t)
    @param mode (C++: resume_mode_t)

Help on function set_step_trace_options in module ida_dbg:

set_step_trace_options(*args) -> 'void'
    set_step_trace_options(options)
    
    
    Modify step tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param options (C++: int)

Help on function set_trace_base_address in module ida_dbg:

set_trace_base_address(*args) -> 'void'
    set_trace_base_address(ea)
    
    
    Set the base address of the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param ea (C++: ea_t)

Help on function set_trace_file_desc in module ida_dbg:

set_trace_file_desc(*args) -> 'bool'
    set_trace_file_desc(filename, description) -> bool
    
    
    Change the description of the specified trace file.
    
    
    @param filename (C++: const char *)
    @param description (C++: const char *)

Help on function set_trace_platform in module ida_dbg:

set_trace_platform(*args) -> 'void'
    set_trace_platform(platform)
    
    
    Set platform name of current trace.
    
    
    @param platform (C++: const char *)

Help on function set_trace_size in module ida_dbg:

set_trace_size(*args) -> 'bool'
    set_trace_size(size) -> bool
    
    
    Specify the new size of the circular buffer. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}If you specify 0,
    all available memory can be quickly used !!!
    
    @param size: if 0, buffer isn't circular and events are never removed.
                 If the new size is smaller than the existing number of
                 trace events, a corresponding number of trace events are
                 removed. (C++: int)

Help on function srcdbg_request_step_into in module ida_dbg:

srcdbg_request_step_into(*args) -> 'bool'
    srcdbg_request_step_into() -> bool

Help on function srcdbg_request_step_over in module ida_dbg:

srcdbg_request_step_over(*args) -> 'bool'
    srcdbg_request_step_over() -> bool

Help on function srcdbg_request_step_until_ret in module ida_dbg:

srcdbg_request_step_until_ret(*args) -> 'bool'
    srcdbg_request_step_until_ret() -> bool

Help on function srcdbg_step_into in module ida_dbg:

srcdbg_step_into(*args) -> 'bool'
    srcdbg_step_into() -> bool

Help on function srcdbg_step_over in module ida_dbg:

srcdbg_step_over(*args) -> 'bool'
    srcdbg_step_over() -> bool

Help on function srcdbg_step_until_ret in module ida_dbg:

srcdbg_step_until_ret(*args) -> 'bool'
    srcdbg_step_until_ret() -> bool

Help on function start_process in module ida_dbg:

start_process(*args) -> 'int'
    start_process(path=None, args=None, sdir=None) -> int
    
    
    Start a process in the debugger. \sq{Type, Asynchronous function -
    available as Request, Notification, 'dbg_process_start' }You can also
    use the 'run_to()' function to easily start the execution of a process
    until a given address is reached.For all parameters, a NULL value
    indicates the debugger will take the value from the defined Process
    Options.
    
    @param path: path to the executable to start (C++: const char *)
    @param args: arguments to pass to process (C++: const char *)
    @param sdir: starting directory for the process (C++: const char *)

Help on function step_into in module ida_dbg:

step_into(*args) -> 'bool'
    step_into() -> bool
    
    
    Execute one instruction in the current thread. Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_into' }

Help on function step_over in module ida_dbg:

step_over(*args) -> 'bool'
    step_over() -> bool
    
    
    Execute one instruction in the current thread, but without entering
    into functions. Others threads keep suspended. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_step_over' }

Help on function step_until_ret in module ida_dbg:

step_until_ret(*args) -> 'bool'
    step_until_ret() -> bool
    
    
    Execute instructions in the current thread until a function return
    instruction is executed (aka "step out"). Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_until_ret' }

Help on function store_exceptions in module ida_dbg:

store_exceptions(*args) -> 'bool'
    store_exceptions() -> bool
    
    
    Update the exception information stored in the debugger module by
    invoking its dbg->set_exception_info callback

Help on function suspend_process in module ida_dbg:

suspend_process(*args) -> 'bool'
    suspend_process() -> bool
    
    
    Suspend the process in the debugger. \sq{ Type,Synchronous function
    (if in a notification handler)Asynchronous function (everywhere
    else)available as Request, Notification,none (if in a notification
    handler) 'dbg_suspend_process' (everywhere else) }The
    'suspend_process()' function can be called from a notification handler
    to force the stopping of the process. In this case, no notification
    will be generated. When you suspend a process, the running command is
    always aborted.

Help on function suspend_thread in module ida_dbg:

suspend_thread(*args) -> 'int'
    suspend_thread(tid) -> int
    
    
    Suspend thread. Suspending a thread may deadlock the whole application
    if the suspended was owning some synchronization objects. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    @param tid: thread id (C++: thid_t)

Help on class tev_info_reg_t in module ida_dbg:

class tev_info_reg_t(builtins.object)
 |  Proxy of C++ tev_info_reg_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tev_info_reg_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_tev_info_reg_t(...)
 |      delete_tev_info_reg_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  info
 |      tev_info_reg_t_info_get(self) -> tev_info_t
 |  
 |  registers
 |      tev_info_reg_t_registers_get(self) -> tev_reg_values_t
 |  
 |  thisown
 |      The membership flag

Help on class tev_info_t in module ida_dbg:

class tev_info_t(builtins.object)
 |  Proxy of C++ tev_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tev_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_tev_info_t(...)
 |      delete_tev_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      tev_info_t_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      tev_info_t_tid_get(self) -> thid_t
 |  
 |  type
 |      tev_info_t_type_get(self) -> tev_type_t

Help on class tev_reg_value_t in module ida_dbg:

class tev_reg_value_t(builtins.object)
 |  Proxy of C++ tev_reg_value_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _reg_idx=-1, _value=uint64(-1)) -> tev_reg_value_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_tev_reg_value_t(...)
 |      delete_tev_reg_value_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  reg_idx
 |      tev_reg_value_t_reg_idx_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      tev_reg_value_t_value_get(self) -> regval_t

Help on class tev_reg_values_t in module ida_dbg:

class tev_reg_values_t(builtins.object)
 |  Proxy of C++ qvector< tev_reg_value_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'tev_reg_value_t const &'
 |      __getitem__(self, i) -> tev_reg_value_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tev_reg_values_t
 |      __init__(self, x) -> tev_reg_values_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_tev_reg_values_t(...)
 |      delete_tev_reg_values_t(self)
 |  
 |  at(self, *args) -> 'tev_reg_value_t const &'
 |      at(self, _idx) -> tev_reg_value_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< tev_reg_value_t >::const_iterator'
 |      begin(self) -> tev_reg_value_t
 |      begin(self) -> tev_reg_value_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< tev_reg_value_t >::const_iterator'
 |      end(self) -> tev_reg_value_t
 |      end(self) -> tev_reg_value_t
 |  
 |  erase(self, *args) -> 'qvector< tev_reg_value_t >::iterator'
 |      erase(self, it) -> tev_reg_value_t
 |      erase(self, first, last) -> tev_reg_value_t
 |  
 |  extract(self, *args) -> 'tev_reg_value_t *'
 |      extract(self) -> tev_reg_value_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=tev_reg_value_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< tev_reg_value_t >::iterator'
 |      insert(self, it, x) -> tev_reg_value_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'tev_reg_value_t &'
 |      push_back(self, x)
 |      push_back(self) -> tev_reg_value_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class tevinforeg_vec_t in module ida_dbg:

class tevinforeg_vec_t(builtins.object)
 |  Proxy of C++ qvector< tev_info_reg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'tev_info_reg_t const &'
 |      __getitem__(self, i) -> tev_info_reg_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tevinforeg_vec_t
 |      __init__(self, x) -> tevinforeg_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_tevinforeg_vec_t(...)
 |      delete_tevinforeg_vec_t(self)
 |  
 |  at(self, *args) -> 'tev_info_reg_t const &'
 |      at(self, _idx) -> tev_info_reg_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< tev_info_reg_t >::const_iterator'
 |      begin(self) -> tev_info_reg_t
 |      begin(self) -> tev_info_reg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< tev_info_reg_t >::const_iterator'
 |      end(self) -> tev_info_reg_t
 |      end(self) -> tev_info_reg_t
 |  
 |  erase(self, *args) -> 'qvector< tev_info_reg_t >::iterator'
 |      erase(self, it) -> tev_info_reg_t
 |      erase(self, first, last) -> tev_info_reg_t
 |  
 |  extract(self, *args) -> 'tev_info_reg_t *'
 |      extract(self) -> tev_info_reg_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=tev_info_reg_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< tev_info_reg_t >::iterator'
 |      insert(self, it, x) -> tev_info_reg_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'tev_info_reg_t &'
 |      push_back(self, x)
 |      push_back(self) -> tev_info_reg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function update_bpt in module ida_dbg:

update_bpt(*args) -> 'bool'
    update_bpt(bpt) -> bool
    
    
    Update modifiable characteristics of an existing breakpoint. To update
    the breakpoint location, use 'change_bptlocs()' \sq{Type, Synchronous
    function, Notification, none (synchronous function)}Only the following
    fields can be modified: 'bpt_t::cndbody'  'bpt_t::pass_count'
    'bpt_t::flags'  'bpt_t::size'  'bpt_t::type' Changing some properties
    will require removing and then re-adding the breakpoint to the process
    memory (or the debugger backend), which can lead to race conditions
    (i.e., breakpoint(s) can be missed) in case the process is not
    suspended. Here are a list of scenarios that will require the
    breakpoint to be removed & then re-added: 'bpt_t::size' is modified
    'bpt_t::type' is modified 'bpt_t::flags' 's BPT_ENABLED is modified
    'bpt_t::flags' 's BPT_LOWCND is changed 'bpt_t::flags' 's BPT_LOWCND
    remains set, but cndbody changed
    
    @param bpt (C++: const  bpt_t  *)

Help on function wait_for_next_event in module ida_dbg:

wait_for_next_event(*args) -> 'dbg_event_code_t'
    wait_for_next_event(wfne, timeout) -> dbg_event_code_t
    
    
    Wait for the next event.This function (optionally) resumes the process
    execution, and waits for a debugger event until a possible timeout
    occurs.
    
    @param wfne: combination of  Wait for debugger event flags  constants
                 (C++: int)
    @param timeout: number of seconds to wait, -1-infinity (C++: int)
    @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <=
             0)

Help on function write_dbg_memory in module ida_dbg:

write_dbg_memory(*args) -> 'ssize_t'
    write_dbg_memory(ea, py_buf, size=size_t(-1)) -> ssize_t

=== ida_dbg EPYDOC INJECTIONS ===
ida_dbg.BKPT_ACTIVE
"""
active?
"""

ida_dbg.BKPT_BADBPT
"""
failed to write the bpt to the process memory (at least one location)
"""

ida_dbg.BKPT_CNDREADY
"""
condition has been compiled
"""

ida_dbg.BKPT_FAKEPEND
"""
bpt of the same type is active at the same address(es)

fake pending bpt: it is inactive but another
"""

ida_dbg.BKPT_LISTBPT
"""
include in bpt list (user-defined bpt)
"""

ida_dbg.BKPT_PAGE
"""
only after writing the bpt to the process.

written to the process as a page bpt. is available
"""

ida_dbg.BKPT_PARTIAL
"""
partially active? (some locations were not written yet)
"""

ida_dbg.BKPT_TRACE
"""
trace bpt; should not be deleted when the process gets suspended
"""

ida_dbg.BPTCK_ACT
"""
breakpoint is active (written to the process)
"""

ida_dbg.BPTCK_NO
"""
breakpoint is disabled
"""

ida_dbg.BPTCK_NONE
"""
breakpoint does not exist
"""

ida_dbg.BPTCK_YES
"""
breakpoint is enabled
"""

ida_dbg.BPTEV_ADDED
"""
Breakpoint has been added.
"""

ida_dbg.BPTEV_CHANGED
"""
Breakpoint has been modified.
"""

ida_dbg.BPTEV_REMOVED
"""
Breakpoint has been removed.
"""

ida_dbg.BPT_BRK
"""
suspend execution upon hit
"""

ida_dbg.BPT_ELANG_SHIFT
"""
index of the extlang (scripting language) of the condition
"""

ida_dbg.BPT_ENABLED
"""
enabled?
"""

ida_dbg.BPT_LOWCND
"""
condition is calculated at low level (on the server side)
"""

ida_dbg.BPT_TRACE
"""
add trace information upon hit
"""

ida_dbg.BPT_TRACEON
"""
enable tracing when the breakpoint is reached
"""

ida_dbg.BPT_TRACE_BBLK
"""
basic block tracing
"""

ida_dbg.BPT_TRACE_FUNC
"""
function tracing
"""

ida_dbg.BPT_TRACE_INSN
"""
instruction tracing
"""

ida_dbg.BPT_TRACE_TYPES
"""
trace insns, functions, and basic blocks. if any of 'BPT_TRACE_TYPES'
bits are set but 'BPT_TRACEON' is clear, then turn off tracing for the
specified trace types
"""

ida_dbg.BPT_UPDMEM
"""
refresh the memory layout and contents before evaluating bpt condition
"""

ida_dbg.BT_LOG_INSTS
"""
log all instructions in the current basic block
"""

ida_dbg.DBGINV_ALL
"""
invalidate everything
"""

ida_dbg.DBGINV_MEMCFG
"""
invalidate cached process segmentation
"""

ida_dbg.DBGINV_MEMORY
"""
invalidate cached memory contents
"""

ida_dbg.DBGINV_NONE
"""
invalidate nothing
"""

ida_dbg.DBGINV_REDRAW
"""
refresh the screen
"""

ida_dbg.DBGINV_REGS
"""
invalidate cached register values
"""

ida_dbg.DOPT_BPT_MSGS
"""
log breakpoints
"""

ida_dbg.DOPT_END_BPT
"""
evaluate event condition on process end
"""

ida_dbg.DOPT_ENTRY_BPT
"""
break on program entry point
"""

ida_dbg.DOPT_EXCDLG
"""
exception dialogs:
"""

ida_dbg.DOPT_INFO_BPT
"""
break on debugging information
"""

ida_dbg.DOPT_INFO_MSGS
"""
log debugging info events
"""

ida_dbg.DOPT_LIB_BPT
"""
break on library load/unload
"""

ida_dbg.DOPT_LIB_MSGS
"""
log library loads/unloads
"""

ida_dbg.DOPT_LOAD_DINFO
"""
automatically load debug files (pdb)
"""

ida_dbg.DOPT_REAL_MEMORY
"""
do not hide breakpoint instructions
"""

ida_dbg.DOPT_REDO_STACK
"""
reconstruct the stack
"""

ida_dbg.DOPT_SEGM_MSGS
"""
log debugger segments modifications
"""

ida_dbg.DOPT_START_BPT
"""
break on process start
"""

ida_dbg.DOPT_TEMP_HWBPT
"""
when possible use hardware bpts for temp bpts
"""

ida_dbg.DOPT_THREAD_BPT
"""
break on thread start/exit
"""

ida_dbg.DOPT_THREAD_MSGS
"""
log thread starts/exits
"""

ida_dbg.DSTATE_NOTASK
"""
no process is currently debugged
"""

ida_dbg.DSTATE_RUN
"""
process is running
"""

ida_dbg.DSTATE_SUSP
"""
process is suspended and will not continue
"""

ida_dbg.EXCDLG_ALWAYS
"""
always display
"""

ida_dbg.EXCDLG_NEVER
"""
never display exception dialogs
"""

ida_dbg.EXCDLG_UNKNOWN
"""
display for unknown exceptions
"""

ida_dbg.FT_LOG_RET
"""
function tracing will log returning instructions
"""

ida_dbg.IT_LOG_SAME_IP
"""
instruction tracing will log instructions whose IP doesn't change
"""

ida_dbg.ST_ALREADY_LOGGED
"""
step tracing will be disabled when IP is already logged
"""

ida_dbg.ST_DIFFERENTIAL
"""
tracing: log only new instructions
"""

ida_dbg.ST_OPTIONS_MASK
"""
mask of available options, to ensure compatibility with newer IDA
versions
"""

ida_dbg.ST_OVER_DEBUG_SEG
"""
step tracing will be disabled when IP is in a debugger segment
"""

ida_dbg.ST_OVER_LIB_FUNC
"""
step tracing will be disabled when IP is in a library function
"""

ida_dbg.ST_SKIP_LOOPS
"""
step tracing will try to skip loops already recorded
"""

ida_dbg.WFNE_ANY
"""
return the first event (even if it doesn't suspend the process)
"""

ida_dbg.WFNE_CONT
"""
continue from the suspended state
"""

ida_dbg.WFNE_NOWAIT
"""
(to be used with 'WFNE_CONT' )

do not wait for any event, immediately return 'DEC_TIMEOUT'
"""

ida_dbg.WFNE_SILENT
"""
1: be slient, 0:display modal boxes if necessary
"""

ida_dbg.WFNE_SUSP
"""
wait until the process gets suspended
"""

ida_dbg.WFNE_USEC
"""
(minimum non-zero timeout is 40000us)

timeout is specified in microseconds
"""
=== ida_dbg EPYDOC INJECTIONS END ===
Help on function close_linput in module ida_diskio:

close_linput(*args) -> 'void'
    close_linput(li)
    
    
    Close loader input.
    
    
    @param li (C++: linput_t *)

Help on function create_bytearray_linput in module ida_diskio:

create_bytearray_linput(*args) -> 'linput_t *'
    create_bytearray_linput(s) -> linput_t *
    
    
    Trivial memory linput.

Help on function create_generic_linput in module ida_diskio:

create_generic_linput(*args) -> 'linput_t *'
    create_generic_linput(gl) -> linput_t *
    
    
    Create a generic linput
    
    @param gl: linput description. this object will be destroyed by
               close_linput()  using "delete gl;" (C++: generic_linput_t
               *)

Help on function create_memory_linput in module ida_diskio:

create_memory_linput(*args) -> 'linput_t *'
    create_memory_linput(start, size) -> linput_t *
    
    
    Create a linput for process memory. This linput will use
    read_dbg_memory() to read data.
    
    @param start: starting address of the input (C++: ea_t)
    @param size: size of the memory area to represent as linput if
                 unknown, may be passed as 0 (C++: asize_t)

Help on function eclose in module ida_diskio:

eclose(*args) -> 'void'
    eclose(fp)

Help on function enumerate_files in module ida_diskio:

enumerate_files(*args) -> 'PyObject *'
    enumerate_files(path, fname, callback) -> PyObject *
    
    
    Enumerate files in the specified directory while the callback returns 0.
    @param path: directory to enumerate files in
    @param fname: mask of file names to enumerate
    @param callback: a callable object that takes the filename as
                     its first argument and it returns 0 to continue
                     enumeration or non-zero to stop enumeration.
    @return:
        None in case of script errors
        tuple(code, fname) : If the callback returns non-zero

Help on function fopenA in module ida_diskio:

fopenA(*args) -> 'FILE *'
    fopenA(file) -> FILE *
    
    
    Open a file for append in text mode, deny none.
    
    @param file (C++: const char *)
    @return: NULL if failure

Help on function fopenM in module ida_diskio:

fopenM(*args) -> 'FILE *'
    fopenM(file) -> FILE *
    
    
    Open a file for read/write in binary mode, deny write.
    
    @param file (C++: const char *)
    @return: NULL if failure

Help on function fopenRB in module ida_diskio:

fopenRB(*args) -> 'FILE *'
    fopenRB(file) -> FILE *
    
    
    Open a file for read in binary mode, deny none.
    
    @param file (C++: const char *)
    @return: NULL if failure

Help on function fopenRT in module ida_diskio:

fopenRT(*args) -> 'FILE *'
    fopenRT(file) -> FILE *
    
    
    Open a file for read in text mode, deny none.
    
    @param file (C++: const char *)
    @return: NULL if failure

Help on function fopenWB in module ida_diskio:

fopenWB(*args) -> 'FILE *'
    fopenWB(file) -> FILE *
    
    
    Open a new file for write in binary mode, deny read/write. If a file
    exists, it will be removed.
    
    @param file (C++: const char *)
    @return: NULL if failure

Help on function fopenWT in module ida_diskio:

fopenWT(*args) -> 'FILE *'
    fopenWT(file) -> FILE *
    
    
    Open a new file for write in text mode, deny write. If a file exists,
    it will be removed.
    
    @param file (C++: const char *)
    @return: NULL if failure

Help on class generic_linput_t in module ida_diskio:

class generic_linput_t(builtins.object)
 |  Proxy of C++ generic_linput_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_generic_linput_t(...)
 |      delete_generic_linput_t(self)
 |  
 |  read(self, *args) -> 'ssize_t'
 |      read(self, off, buffer, nbytes) -> ssize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blocksize
 |      generic_linput_t_blocksize_get(self) -> uint32
 |  
 |  filesize
 |      generic_linput_t_filesize_get(self) -> uint64
 |  
 |  thisown
 |      The membership flag

Help on function get_ida_subdirs in module ida_diskio:

get_ida_subdirs(*args) -> 'qstrvec_t *'
    get_ida_subdirs(subdir, flags=0) -> int
    
    
    Get list of directories in which to find a specific IDA resource (see
    'IDA subdirectories' ). The order of the resulting list is as follows:
    
    - [$IDAUSR/subdir (0..N entries)]
    - $IDADIR/subdir
    
    @param subdir: name of the resource to list (C++: const char *)
    @param flags: Subdirectory modification flags  bits (C++: int)
    @return: number of directories appended to 'dirs'

Help on function get_linput_type in module ida_diskio:

get_linput_type(*args) -> 'linput_type_t'
    get_linput_type(li) -> linput_type_t
    
    
    Get linput type.
    
    
    @param li (C++: linput_t *)

Help on function get_special_folder in module ida_diskio:

get_special_folder(*args) -> 'size_t'
    get_special_folder(csidl) -> str
    
    
    Get a folder location by CSIDL (see 'Common CSIDLs' ). Path should be
    of at least MAX_PATH size
    
    @param csidl (C++: int)

Help on function get_user_idadir in module ida_diskio:

get_user_idadir(*args) -> 'char const *'
    get_user_idadir() -> char const *
    
    
    Get user ida related directory.
    
    - if $IDAUSR is defined:
        - the first element in $IDAUSR
    - else
        - default user directory ($HOME/.idapro or %APPDATA%Hex-Rays/IDA Pro)

Help on function getsysfile in module ida_diskio:

getsysfile(*args) -> 'char const *'
    getsysfile(filename, subdir) -> str
    
    
    Search for IDA system file. This function searches for a file in:each
    directory specified by IDAUSR%ida directory [+ subdir] and returns the
    first match.
    
    @param filename (C++: const char *)
    @param subdir (C++: const char *)
    @return: NULL if not found, otherwise a pointer to full file name.

Help on function idadir in module ida_diskio:

idadir(*args) -> 'char const *'
    idadir(subdir) -> char const *
    
    
    Get IDA directory (if subdir==NULL) or the specified subdirectory (see
    'IDA subdirectories' )
    
    @param subdir (C++: const char *)

Help on function open_linput in module ida_diskio:

open_linput(*args) -> 'linput_t *'
    open_linput(file, remote) -> linput_t *
    
    
    Open loader input.
    
    
    @param file (C++: const char *)
    @param remote (C++: bool)

Help on function qlgetz in module ida_diskio:

qlgetz(*args) -> 'size_t'
    qlgetz(li, fpos) -> str
    
    
    Read a zero-terminated string from the input. If fpos == -1 then no
    seek will be performed.
    
    @param li (C++: linput_t *)
    @param fpos (C++: int64)

=== ida_diskio EPYDOC INJECTIONS ===
ida_diskio.IDA_SUBDIR_IDADIR_FIRST
"""
$IDADIR/subdir will be first, not last
"""

ida_diskio.IDA_SUBDIR_IDP
"""
append the processor name as a subdirectory
"""

ida_diskio.IDA_SUBDIR_ONLY_EXISTING
"""
only existing directories will be present
"""
=== ida_diskio EPYDOC INJECTIONS END ===
Help on function add_entry in module ida_entry:

add_entry(*args) -> 'bool'
    add_entry(ord, ea, name, makecode, flags=0) -> bool
    
    
    Add an entry point to the list of entry points.
    
    @param ord: ordinal number if ordinal number is equal to 'ea' then
                ordinal is not used (C++: uval_t)
    @param ea: linear address (C++: ea_t)
    @param name: name of entry point. If the specified location already
                 has a name, the old name will be appended to the regular
                 comment. If name == NULL, then the old name will be
                 retained. (C++: const char *)
    @param makecode: should the kernel convert bytes at the entry point to
                     instruction(s) (C++: bool)
    @param flags: See AEF_* (C++: int)
    @return: success (currently always true)

Help on function get_entry in module ida_entry:

get_entry(*args) -> 'ea_t'
    get_entry(ord) -> ea_t
    
    
    Get entry point address by its ordinal
    
    @param ord: ordinal number of entry point (C++: uval_t)
    @return: address or  BADADDR

Help on function get_entry_forwarder in module ida_entry:

get_entry_forwarder(*args) -> 'qstring *'
    get_entry_forwarder(ord) -> str
    
    
    Get forwarder name for the entry point by its ordinal.
    
    @param ord: ordinal number of entry point (C++: uval_t)
    @return: size of entry forwarder name or -1

Help on function get_entry_name in module ida_entry:

get_entry_name(*args) -> 'qstring *'
    get_entry_name(ord) -> str
    
    
    Get name of the entry point by its ordinal.
    
    @param ord: ordinal number of entry point (C++: uval_t)
    @return: size of entry name or -1

Help on function get_entry_ordinal in module ida_entry:

get_entry_ordinal(*args) -> 'uval_t'
    get_entry_ordinal(idx) -> uval_t
    
    
    Get ordinal number of an entry point.
    
    @param idx: internal number of entry point. Should be in the range 0..
                get_entry_qty() -1 (C++: size_t)
    @return: ordinal number or 0.

Help on function get_entry_qty in module ida_entry:

get_entry_qty(*args) -> 'size_t'
    get_entry_qty() -> size_t
    
    
    Get number of entry points.

Help on function rename_entry in module ida_entry:

rename_entry(*args) -> 'bool'
    rename_entry(ord, name, flags=0) -> bool
    
    
    Rename entry point.
    
    @param ord: ordinal number of the entry point (C++: uval_t)
    @param name: name of entry point. If the specified location already
                 has a name, the old name will be appended to a repeatable
                 comment. (C++: const char *)
    @param flags: See AEF_* (C++: int)
    @return: success

Help on function set_entry_forwarder in module ida_entry:

set_entry_forwarder(*args) -> 'bool'
    set_entry_forwarder(ord, name, flags=0) -> bool
    
    
    Set forwarder name for ordinal.
    
    @param ord: ordinal number of the entry point (C++: uval_t)
    @param name: forwarder name for entry point. (C++: const char *)
    @param flags: See AEF_* (C++: int)
    @return: success

=== ida_entry EPYDOC INJECTIONS ===
ida_entry.AEF_IDBENC
"""
the name is given in the IDB encoding; non-ASCII bytes will be decoded
accordingly Specifying AEF_IDBENC also implies AEF_NODUMMY
"""

ida_entry.AEF_NODUMMY
"""
it begins with a dummy suffix. See also AEF_IDBENC

automatically prepend the name with '_' if
"""

ida_entry.AEF_UTF8
"""
the name is given in UTF-8 (default)
"""
=== ida_entry EPYDOC INJECTIONS END ===
Help on function add_enum in module ida_enum:

add_enum(*args) -> 'enum_t'
    add_enum(idx, name, flag) -> enum_t
    
    
    Add new enum type.if idx== 'BADADDR' then add as the last idxif
    name==NULL then generate a unique name "enum_%d"
    
    @param idx (C++: size_t)
    @param name (C++: const char *)
    @param flag (C++: flags_t)

Help on function add_enum_member in module ida_enum:

add_enum_member(*args) -> 'int'
    add_enum_member(id, name, value, bmask=(bmask_t(-1))) -> int
    
    
    Add member to enum type.
    
    @param id (C++: enum_t)
    @param name (C++: const char *)
    @param value (C++: uval_t)
    @param bmask (C++: bmask_t)
    @return: 0 if ok, otherwise one of  Add enum member result codes

Help on function del_enum in module ida_enum:

del_enum(*args) -> 'void'
    del_enum(id)
    
    
    Delete an enum type.
    
    
    @param id (C++: enum_t)

Help on function del_enum_member in module ida_enum:

del_enum_member(*args) -> 'bool'
    del_enum_member(id, value, serial, bmask) -> bool
    
    
    Delete member of enum type.
    
    
    @param id (C++: enum_t)
    @param value (C++: uval_t)
    @param serial (C++: uchar)
    @param bmask (C++: bmask_t)

Help on class enum_member_visitor_t in module ida_enum:

class enum_member_visitor_t(builtins.object)
 |  Proxy of C++ enum_member_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_member_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_enum_member_visitor_t(...)
 |      delete_enum_member_visitor_t(self)
 |  
 |  visit_enum_member(self, *args) -> 'int'
 |      visit_enum_member(self, cid, value) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function for_all_enum_members in module ida_enum:

for_all_enum_members(*args) -> 'int'
    for_all_enum_members(id, cv) -> int
    
    
    Visit all members of a given enum.
    
    
    @param id (C++: enum_t)
    @param cv (C++: enum_member_visitor_t  &)

Help on function get_bmask_cmt in module ida_enum:

get_bmask_cmt(*args) -> 'qstring *'
    get_bmask_cmt(id, bmask, repeatable) -> str

Help on function get_bmask_name in module ida_enum:

get_bmask_name(*args) -> 'qstring *'
    get_bmask_name(id, bmask) -> str

Help on function get_enum in module ida_enum:

get_enum(*args) -> 'enum_t'
    get_enum(name) -> enum_t
    
    
    Get enum by name.
    
    
    @param name (C++: const char *)

Help on function get_enum_cmt in module ida_enum:

get_enum_cmt(*args) -> 'qstring *'
    get_enum_cmt(id, repeatable) -> str
    
    
    Get enum comment.
    
    
    @param id (C++: enum_t)
    @param repeatable (C++: bool)

Help on function get_enum_flag in module ida_enum:

get_enum_flag(*args) -> 'flags_t'
    get_enum_flag(id) -> flags_t
    
    
    Get flags determining the representation of the enum. (currently they
    define the numeric base: octal, decimal, hex, bin) and signness.
    
    @param id (C++: enum_t)

Help on function get_enum_idx in module ida_enum:

get_enum_idx(*args) -> 'uval_t'
    get_enum_idx(id) -> uval_t
    
    
    Get serial number of enum. The serial number determines the place of
    the enum in the enum window.
    
    @param id (C++: enum_t)

Help on function get_enum_member in module ida_enum:

get_enum_member(*args) -> 'const_t'
    get_enum_member(id, value, serial, mask) -> const_t
    
    
    Find an enum member by enum, value and bitmaskif serial -1, return a
    member with any serial
    
    @param id (C++: enum_t)
    @param value (C++: uval_t)
    @param serial (C++: int)
    @param mask (C++: bmask_t)

Help on function get_enum_member_bmask in module ida_enum:

get_enum_member_bmask(*args) -> 'bmask_t'
    get_enum_member_bmask(id) -> bmask_t
    
    
    Get bitmask of an enum member.
    
    
    @param id (C++: const_t)

Help on function get_enum_member_by_name in module ida_enum:

get_enum_member_by_name(*args) -> 'const_t'
    get_enum_member_by_name(name) -> const_t
    
    
    Get a reference to an enum member by its name.
    
    
    @param name (C++: const char *)

Help on function get_enum_member_cmt in module ida_enum:

get_enum_member_cmt(*args) -> 'qstring *'
    get_enum_member_cmt(id, repeatable) -> str
    
    
    Get enum member's comment.
    
    
    @param id (C++: const_t)
    @param repeatable (C++: bool)

Help on function get_enum_member_enum in module ida_enum:

get_enum_member_enum(*args) -> 'enum_t'
    get_enum_member_enum(id) -> enum_t
    
    
    Get the parent enum of an enum member.
    
    
    @param id (C++: const_t)

Help on function get_enum_member_name in module ida_enum:

get_enum_member_name(*args) -> 'qstring *'
    get_enum_member_name(id) -> str
    
    
    Get name of an enum member by const_t.
    
    
    @param id (C++: const_t)

Help on function get_enum_member_serial in module ida_enum:

get_enum_member_serial(*args) -> 'uchar'
    get_enum_member_serial(cid) -> uchar
    
    
    Get serial number of an enum member.
    
    
    @param cid (C++: const_t)

Help on function get_enum_member_value in module ida_enum:

get_enum_member_value(*args) -> 'uval_t'
    get_enum_member_value(id) -> uval_t
    
    
    Get value of an enum member.
    
    
    @param id (C++: const_t)

Help on function get_enum_name in module ida_enum:

get_enum_name(*args) -> 'qstring *'
    get_enum_name(id) -> str
    
    
    Get name of enum.
    
    
    @param id (C++: enum_t)

Help on function get_enum_name2 in module ida_enum:

get_enum_name2(*args) -> 'qstring *'
    get_enum_name2(id, flags=0) -> str
    
    
    Get name of enum
    
    @param id: enum id (C++: enum_t)
    @param flags: Enum name flags (C++: int)

Help on function get_enum_qty in module ida_enum:

get_enum_qty(*args) -> 'size_t'
    get_enum_qty() -> size_t
    
    
    Get number of declared 'enum_t' types.

Help on function get_enum_size in module ida_enum:

get_enum_size(*args) -> 'size_t'
    get_enum_size(id) -> size_t
    
    
    Get the number of the members of the enum.
    
    
    @param id (C++: enum_t)

Help on function get_enum_type_ordinal in module ida_enum:

get_enum_type_ordinal(*args) -> 'int32'
    get_enum_type_ordinal(id) -> int32
    
    
    Get corresponding type ordinal number.
    
    
    @param id (C++: enum_t)

Help on function get_enum_width in module ida_enum:

get_enum_width(*args) -> 'size_t'
    get_enum_width(id) -> size_t
    
    
    Get the width of a enum element allowed values: 0
    (unspecified),1,2,4,8,16,32,64
    
    @param id (C++: enum_t)

Help on function get_first_bmask in module ida_enum:

get_first_bmask(*args) -> 'bmask_t'
    get_first_bmask(id) -> bmask_t
    
    
    Get first bitmask in the enum (bitfield)
    
    @param id (C++: enum_t)
    @return: the smallest bitmask for enum, or DEFMASK

Help on function get_first_enum_member in module ida_enum:

get_first_enum_member(*args) -> 'uval_t'
    get_first_enum_member(id, bmask=(bmask_t(-1))) -> uval_t

Help on function get_first_serial_enum_member in module ida_enum:

get_first_serial_enum_member(*args) -> 'uchar *'
    get_first_serial_enum_member(id, value, bmask) -> const_t

Help on function get_last_bmask in module ida_enum:

get_last_bmask(*args) -> 'bmask_t'
    get_last_bmask(id) -> bmask_t
    
    
    Get last bitmask in the enum (bitfield)
    
    @param id (C++: enum_t)
    @return: the biggest bitmask for enum, or DEFMASK

Help on function get_last_enum_member in module ida_enum:

get_last_enum_member(*args) -> 'uval_t'
    get_last_enum_member(id, bmask=(bmask_t(-1))) -> uval_t

Help on function get_last_serial_enum_member in module ida_enum:

get_last_serial_enum_member(*args) -> 'uchar *'
    get_last_serial_enum_member(id, value, bmask) -> const_t

Help on function get_next_bmask in module ida_enum:

get_next_bmask(*args) -> 'bmask_t'
    get_next_bmask(id, bmask) -> bmask_t
    
    
    Get next bitmask in the enum (bitfield)
    
    @param id (C++: enum_t)
    @param bmask (C++: bmask_t)
    @return: value of a bitmask with value higher than the specified
             value, or DEFMASK

Help on function get_next_enum_member in module ida_enum:

get_next_enum_member(*args) -> 'uval_t'
    get_next_enum_member(id, value, bmask=(bmask_t(-1))) -> uval_t

Help on function get_next_serial_enum_member in module ida_enum:

get_next_serial_enum_member(*args) -> 'uchar *'
    get_next_serial_enum_member(in_out_serial, first_cid) -> const_t

Help on function get_prev_bmask in module ida_enum:

get_prev_bmask(*args) -> 'bmask_t'
    get_prev_bmask(id, bmask) -> bmask_t
    
    
    Get prev bitmask in the enum (bitfield)
    
    @param id (C++: enum_t)
    @param bmask (C++: bmask_t)
    @return: value of a bitmask with value lower than the specified value,
             or DEFMASK

Help on function get_prev_enum_member in module ida_enum:

get_prev_enum_member(*args) -> 'uval_t'
    get_prev_enum_member(id, value, bmask=(bmask_t(-1))) -> uval_t

Help on function get_prev_serial_enum_member in module ida_enum:

get_prev_serial_enum_member(*args) -> 'uchar *'
    get_prev_serial_enum_member(in_out_serial, first_cid) -> const_t

Help on function getn_enum in module ida_enum:

getn_enum(*args) -> 'enum_t'
    getn_enum(n) -> enum_t
    
    
    Get enum by its ordinal number (0..n).
    
    
    @param n (C++: size_t)

Help on function is_bf in module ida_enum:

is_bf(*args) -> 'bool'
    is_bf(id) -> bool
    
    
    Is enum a bitfield? (otherwise - plain enum, no bitmasks except for
    'DEFMASK' are allowed)
    
    @param id (C++: enum_t)

Help on function is_enum_fromtil in module ida_enum:

is_enum_fromtil(*args) -> 'bool'
    is_enum_fromtil(id) -> bool
    
    
    Does enum come from type library?
    
    
    @param id (C++: enum_t)

Help on function is_enum_hidden in module ida_enum:

is_enum_hidden(*args) -> 'bool'
    is_enum_hidden(id) -> bool
    
    
    Is enum collapsed?
    
    
    @param id (C++: enum_t)

Help on function is_ghost_enum in module ida_enum:

is_ghost_enum(*args) -> 'bool'
    is_ghost_enum(id) -> bool
    
    
    Is a ghost copy of a local type?
    
    
    @param id (C++: enum_t)

Help on function is_one_bit_mask in module ida_enum:

is_one_bit_mask(*args) -> 'bool'
    is_one_bit_mask(mask) -> bool
    
    
    Is bitmask one bit?
    
    
    @param mask (C++: bmask_t)

Help on function set_bmask_cmt in module ida_enum:

set_bmask_cmt(*args) -> 'bool'
    set_bmask_cmt(id, bmask, cmt, repeatable) -> bool

Help on function set_bmask_name in module ida_enum:

set_bmask_name(*args) -> 'bool'
    set_bmask_name(id, bmask, name) -> bool

Help on function set_enum_bf in module ida_enum:

set_enum_bf(*args) -> 'bool'
    set_enum_bf(id, bf) -> bool
    
    
    Set 'bitfield' bit of enum (i.e. convert it to a bitfield)
    
    
    @param id (C++: enum_t)
    @param bf (C++: bool)

Help on function set_enum_cmt in module ida_enum:

set_enum_cmt(*args) -> 'bool'
    set_enum_cmt(id, cmt, repeatable) -> bool
    
    
    Set comment for enum type.
    
    
    @param id (C++: enum_t)
    @param cmt (C++: const char *)
    @param repeatable (C++: bool)

Help on function set_enum_flag in module ida_enum:

set_enum_flag(*args) -> 'bool'
    set_enum_flag(id, flag) -> bool
    
    
    Set data representation flags.
    
    
    @param id (C++: enum_t)
    @param flag (C++: flags_t)

Help on function set_enum_fromtil in module ida_enum:

set_enum_fromtil(*args) -> 'bool'
    set_enum_fromtil(id, fromtil) -> bool
    
    
    Specify that enum comes from a type library.
    
    
    @param id (C++: enum_t)
    @param fromtil (C++: bool)

Help on function set_enum_ghost in module ida_enum:

set_enum_ghost(*args) -> 'bool'
    set_enum_ghost(id, ghost) -> bool
    
    
    Specify that enum is a ghost copy of a local type.
    
    
    @param id (C++: enum_t)
    @param ghost (C++: bool)

Help on function set_enum_hidden in module ida_enum:

set_enum_hidden(*args) -> 'bool'
    set_enum_hidden(id, hidden) -> bool
    
    
    Collapse enum.
    
    
    @param id (C++: enum_t)
    @param hidden (C++: bool)

Help on function set_enum_idx in module ida_enum:

set_enum_idx(*args) -> 'bool'
    set_enum_idx(id, idx) -> bool
    
    
    Set serial number of enum. Also see 'get_enum_idx()' .
    
    @param id (C++: enum_t)
    @param idx (C++: size_t)

Help on function set_enum_member_cmt in module ida_enum:

set_enum_member_cmt(*args) -> 'bool'
    set_enum_member_cmt(id, cmt, repeatable) -> bool
    
    
    Set comment for enum member.
    
    
    @param id (C++: const_t)
    @param cmt (C++: const char *)
    @param repeatable (C++: bool)

Help on function set_enum_member_name in module ida_enum:

set_enum_member_name(*args) -> 'bool'
    set_enum_member_name(id, name) -> bool
    
    
    Set name of enum member.
    
    
    @param id (C++: const_t)
    @param name (C++: const char *)

Help on function set_enum_name in module ida_enum:

set_enum_name(*args) -> 'bool'
    set_enum_name(id, name) -> bool
    
    
    Set name of enum type.
    
    
    @param id (C++: enum_t)
    @param name (C++: const char *)

Help on function set_enum_type_ordinal in module ida_enum:

set_enum_type_ordinal(*args) -> 'void'
    set_enum_type_ordinal(id, ord)
    
    
    Set corresponding type ordinal number.
    
    
    @param id (C++: enum_t)
    @param ord (C++: int32)

Help on function set_enum_width in module ida_enum:

set_enum_width(*args) -> 'bool'
    set_enum_width(id, width) -> bool
    
    
    See comment for 'get_enum_width()'
    
    
    @param id (C++: enum_t)
    @param width (C++: int)

=== ida_enum EPYDOC INJECTIONS ===
ida_enum.DEFMASK
"""
default bitmask
"""

ida_enum.ENFL_REGEX
"""
apply regular expressions to beautify the name
"""

ida_enum.ENUM_MEMBER_ERROR_ENUM
"""
bad enum id
"""

ida_enum.ENUM_MEMBER_ERROR_ILLV
"""
bad bmask and value combination (~bmask & value != 0)
"""

ida_enum.ENUM_MEMBER_ERROR_MASK
"""
bad bmask
"""

ida_enum.ENUM_MEMBER_ERROR_NAME
"""
already have member with this name (bad name)
"""

ida_enum.ENUM_MEMBER_ERROR_VALUE
"""
already have 256 members with this value
"""
=== ida_enum EPYDOC INJECTIONS END ===
Help on class _IdcFunction in module ida_expr:

class _IdcFunction(builtins.object)
 |  Internal class that calls pyw_call_idc_func() with a context
 |  
 |  Methods defined here:
 |  
 |  __call__(self, args, res)
 |      Call self as a function.
 |  
 |  __init__(self, ctxptr)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fp_ptr

Help on function add_idc_class in module ida_expr:

add_idc_class(*args) -> 'idc_class_t *'
    add_idc_class(name, super=None) -> idc_class_t *
    
    
    Create a new IDC class.
    
    @param name: name of the new class (C++: const char *)
    @param super: the base class for the new class. if the new class is
                  not based on any other class, pass NULL (C++: const
                  idc_class_t *)
    @return: pointer to the created class. If such a class already exists,
             a pointer to it will be returned. Pointers to other existing
             classes may be invalidated by this call.

Help on function add_idc_func in module ida_expr:

add_idc_func(name, fp, args, defvals=None, flags=0)
        Extends the IDC language by exposing a new IDC function that is backed up by a Python function
    
        @param name: IDC function name to expose
        @param fp: Python callable that will receive the arguments and return a tuple.
        @param args: Arguments. A tuple of idaapi.VT_XXX constants
        @param flags: IDC function flags. A combination of EXTFUN_XXX constants
    
        @return: Boolean
    
    
        Add an IDC function. This function does not modify the predefined
        kernel functions. Example:
        
        static error_t idaapi myfunc5(idc_value_t *argv, idc_value_t *res)
        {
          msg("myfunc is called with arg0=%a and arg1=%s
    ", argv[0].num, argv[1].str);
          res->num = 5;     // let's return 5
          return eOk;
        }
        static const char myfunc5_args[] = { VT_LONG, VT_STR, 0 };
        static const ext_idcfunc_t myfunc_desc = { "MyFunc5", myfunc5, myfunc5_args, NULL, 0, EXTFUN_BASE };
        
        // after this:
        add_idc_func(myfunc_desc);
        
        // there is a new IDC function which can be called like this:
        MyFunc5(0x123, "test");
        
        If the function already exists, it will be replaced by the new
        function
        
        @return: success

Help on function add_idc_gvar in module ida_expr:

add_idc_gvar(*args) -> 'idc_value_t *'
    add_idc_gvar(name) -> idc_value_t
    
    
    Add global IDC variable.
    
    @param name: name of the global variable (C++: const char *)
    @return: pointer to the created variable or existing variable. NB: the
             returned pointer is valid until a new global var is added.

Help on function compile_idc_file in module ida_expr:

compile_idc_file(*args) -> 'qstring *'
    compile_idc_file(nonnul_line) -> str

Help on function compile_idc_snippet in module ida_expr:

compile_idc_snippet(*args) -> 'qstring *'
    compile_idc_snippet(func, text, resolver=None, only_safe_funcs=False) -> str
    
    
    Compile text with IDC statements.
    
    @param func: name of the function to create out of the snippet (C++:
                 const char *)
    @param text: text to compile (C++: const char *)
    @param resolver: callback object to get values of undefined variables
                     This object will be called if IDC function contains
                     references to undefined variables. May be NULL. (C++:
                     idc_resolver_t  *)
    @param only_safe_funcs: if true, any calls to functions without
                            EXTFUN_SAFE  flag will lead to a compilation
                            error. (C++: bool)

Help on function compile_idc_text in module ida_expr:

compile_idc_text(*args) -> 'qstring *'
    compile_idc_text(nonnul_line) -> str

Help on function copy_idcv in module ida_expr:

copy_idcv(*args) -> 'error_t'
    copy_idcv(dst, src) -> error_t
    
    
    Copy 'src' to 'dst'. For idc objects only a reference is copied.
    
    @param dst (C++: idc_value_t  *)
    @param src (C++: const  idc_value_t  &)

Help on function create_idcv_ref in module ida_expr:

create_idcv_ref(*args) -> 'bool'
    create_idcv_ref(ref, v) -> bool
    
    
    Create a variable reference. Currently only references to global
    variables can be created.
    
    @param ref: ptr to the result (C++: idc_value_t  *)
    @param v: variable to reference (C++: const  idc_value_t  *)
    @return: success

Help on function deep_copy_idcv in module ida_expr:

deep_copy_idcv(*args) -> 'error_t'
    deep_copy_idcv(dst, src) -> error_t
    
    
    Deep copy an IDC object. This function performs deep copy of idc
    objects. If 'src' is not an object, 'copy_idcv()' will be called
    
    @param dst (C++: idc_value_t  *)
    @param src (C++: const  idc_value_t  &)

Help on function del_idc_func in module ida_expr:

del_idc_func(name)
    Unregisters the specified IDC function
    
    @param name: IDC function name to unregister
    
    @return: Boolean
    
    
    Delete an IDC function

Help on function del_idcv_attr in module ida_expr:

del_idcv_attr(*args) -> 'error_t'
    del_idcv_attr(obj, attr) -> error_t
    
    
    Delete an object attribute.
    
    @param obj: variable that holds an object reference (C++: idc_value_t
                *)
    @param attr: attribute name (C++: const char *)
    @return: error code, eOk on success

Help on function deref_idcv in module ida_expr:

deref_idcv(*args) -> 'idc_value_t *'
    deref_idcv(v, vref_flags) -> idc_value_t
    
    
    Dereference a 'VT_REF' variable.
    
    @param v: variable to dereference (C++: idc_value_t  *)
    @param vref_flags: Dereference IDC variable flags (C++: int)
    @return: pointer to the dereference result or NULL. If returns NULL,
             qerrno is set to eExecBadRef "Illegal variable reference"

Help on function eval_expr in module ida_expr:

eval_expr(*args) -> 'qstring *'
    eval_expr(rv, where, line) -> str
    
    
    Compile and calculate an expression.
    
    @param rv: pointer to the result (C++: idc_value_t  *)
    @param where: the current linear address in the addressing space of
                  the program being disassembled. If will be used to
                  resolve names of local variables etc. if not applicable,
                  then should be  BADADDR . (C++: ea_t)
    @param line: the expression to evaluate (C++: const char *)

Help on function eval_idc_expr in module ida_expr:

eval_idc_expr(*args) -> 'qstring *'
    eval_idc_expr(rv, where, line) -> str
    
    
    Same as 'eval_expr()' , but will always use the IDC interpreter
    regardless of the currently installed extlang.
    
    @param rv (C++: idc_value_t  *)
    @param where (C++: ea_t)

Help on function exec_idc_script in module ida_expr:

exec_idc_script(*args) -> 'qstring *'
    exec_idc_script(result, path, func, args, argsnum) -> str
    
    
    Compile and execute IDC function(s) from file.
    
    @param result: ptr to  idc_value_t  to hold result of the function. If
                   execution fails, this variable will contain the
                   exception information. You may pass NULL if you are not
                   interested in the returned value. (C++: idc_value_t  *)
    @param path: text file containing text of IDC functions (C++: const
                 char *)
    @param func: function name to execute (C++: const char *)
    @param args: array of parameters (C++: const  idc_value_t)
    @param argsnum: number of parameters to pass to 'fname' This number
                    should be equal to number of parameters the function
                    expects. (C++: size_t)

Help on function exec_system_script in module ida_expr:

exec_system_script(*args) -> 'bool'
    exec_system_script(file, complain_if_no_file=True) -> bool
    
    
    Compile and execute "main" function from system file.
    
    @param file: file name with IDC function(s). The file will be searched
                 in the idc subdir of ida (C++: const char *)
    @param complain_if_no_file: 1: display warning if the file is not
                                found   0: don't complain if file doesn't
                                exist (C++: bool)

Help on function find_idc_class in module ida_expr:

find_idc_class(*args) -> 'idc_class_t *'
    find_idc_class(name) -> idc_class_t *
    
    
    Find an existing IDC class by its name.
    
    @param name: name of the class (C++: const char *)
    @return: pointer to the class or NULL. The returned pointer is valid
             until a new call to  add_idc_class()

Help on function find_idc_func in module ida_expr:

find_idc_func(*args) -> 'qstring *'
    find_idc_func(prefix, n=0) -> str

Help on function find_idc_gvar in module ida_expr:

find_idc_gvar(*args) -> 'idc_value_t *'
    find_idc_gvar(name) -> idc_value_t
    
    
    Find an existing global IDC variable by its name.
    
    @param name: name of the global variable (C++: const char *)
    @return: pointer to the variable or NULL. NB: the returned pointer is
             valid until a new global var is added. FIXME: it is difficult
             to use this function in a thread safe manner

Help on function first_idcv_attr in module ida_expr:

first_idcv_attr(*args) -> 'char const *'
    first_idcv_attr(obj) -> char const *

Help on function free_idcv in module ida_expr:

free_idcv(*args) -> 'void'
    free_idcv(v)
    
    
    Free storage used by 'VT_STR' / 'VT_OBJ' IDC variables. After this
    call the variable has a numeric value 0
    
    @param v (C++: idc_value_t  *)

Help on function get_idc_filename in module ida_expr:

get_idc_filename(*args) -> 'char const *'
    get_idc_filename(file) -> str
    
    
    Get full name of IDC file name. Search for file in list of include
    directories, IDCPATH directory and the current directory.
    
    @param file: file name without full path (C++: const char *)
    @return: NULL is file not found. otherwise returns pointer to buf

Help on function get_idcv_attr in module ida_expr:

get_idcv_attr(*args) -> 'error_t'
    get_idcv_attr(res, obj, attr, may_use_getattr=False) -> error_t
    
    
    Get an object attribute.
    
    @param res: buffer for the attribute value (C++: idc_value_t  *)
    @param obj: variable that holds an object reference. if obj is NULL it
                searches global variables, then user functions (C++: const
                idc_value_t  *)
    @param attr: attribute name (C++: const char *)
    @param may_use_getattr: may call getattr functions to calculate the
                            attribute if it does not exist (C++: bool)
    @return: error code, eOk on success

Help on function get_idcv_class_name in module ida_expr:

get_idcv_class_name(*args) -> 'qstring *'
    get_idcv_class_name(obj) -> str
    
    
    Retrieves the IDC object class name.
    
    @param obj: class instance variable (C++: const  idc_value_t  *)
    @return: error code, eOk on success

Help on function get_idcv_slice in module ida_expr:

get_idcv_slice(*args) -> 'error_t'
    get_idcv_slice(res, v, i1, i2, flags=0) -> error_t
    
    
    Get slice.
    
    @param res: output variable that will contain the slice (C++:
                idc_value_t  *)
    @param v: input variable (string or object) (C++: const  idc_value_t
              *)
    @param i1: slice start index (C++: uval_t)
    @param i2: slice end index (excluded) (C++: uval_t)
    @param flags: IDC variable slice flags  or 0 (C++: int)
    @return: eOk if success

Help on class highlighter_cbs_t in module ida_expr:

class highlighter_cbs_t(builtins.object)
 |  Proxy of C++ highlighter_cbs_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> highlighter_cbs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_highlighter_cbs_t(...)
 |      delete_highlighter_cbs_t(self)
 |  
 |  cur_block_state(self, *args) -> 'int32'
 |      cur_block_state(self) -> int32
 |  
 |  prev_block_state(self, *args) -> 'int32'
 |      prev_block_state(self) -> int32
 |  
 |  set_block_state(self, *args) -> 'void'
 |      set_block_state(self, arg0)
 |  
 |  set_style(self, *args) -> 'void'
 |      set_style(self, arg0, arg1, arg2)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class idc_global_t in module ida_expr:

class idc_global_t(builtins.object)
 |  Proxy of C++ idc_global_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idc_global_t
 |      __init__(self, n) -> idc_global_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idc_global_t(...)
 |      delete_idc_global_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      idc_global_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      idc_global_t_value_get(self) -> idc_value_t

Help on class idc_value_t in module ida_expr:

class idc_value_t(builtins.object)
 |  Proxy of C++ idc_value_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, n=0) -> idc_value_t
 |      __init__(self, r) -> idc_value_t
 |      __init__(self, _str) -> idc_value_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idc_value_t(...)
 |      delete_idc_value_t(self)
 |  
 |  _create_empty_string(self, *args) -> 'void'
 |      _create_empty_string(self)
 |  
 |  _idc_value_t__get_e = __get_e(self, *args) -> 'wrapped_array_t< ushort,6 >'
 |      __get_e(self) -> wrapped_array_t< ushort,6 >
 |  
 |  c_str(self, *args) -> 'char const *'
 |      c_str(self) -> char const *
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  create_empty_string(self, *args) -> 'void'
 |      create_empty_string(self)
 |  
 |  is_convertible(self, *args) -> 'bool'
 |      is_convertible(self) -> bool
 |  
 |  is_integral(self, *args) -> 'bool'
 |      is_integral(self) -> bool
 |  
 |  is_zero(self, *args) -> 'bool'
 |      is_zero(self) -> bool
 |  
 |  qstr(self, *args) -> 'qstring const &'
 |      qstr(self) -> qstring
 |      qstr(self) -> qstring const &
 |  
 |  set_float(self, *args) -> 'void'
 |      set_float(self, f)
 |  
 |  set_int64(self, *args) -> 'void'
 |      set_int64(self, v)
 |  
 |  set_long(self, *args) -> 'void'
 |      set_long(self, v)
 |  
 |  set_pvoid(self, *args) -> 'void'
 |      set_pvoid(self, p)
 |  
 |  set_string(self, *args) -> 'void'
 |      set_string(self, _str, len)
 |      set_string(self, _str)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, v)
 |  
 |  u_str(self, *args) -> 'uchar const *'
 |      u_str(self) -> uchar const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  e
 |      __get_e(self) -> wrapped_array_t< ushort,6 >
 |  
 |  funcidx
 |      idc_value_t_funcidx_get(self) -> int
 |  
 |  i64
 |      idc_value_t_i64_get(self) -> int64
 |  
 |  num
 |      idc_value_t_num_get(self) -> sval_t
 |  
 |  obj
 |      idc_value_t_obj_get(self) -> idc_object_t *
 |  
 |  pvoid
 |      idc_value_t_pvoid_get(self) -> void *
 |  
 |  reserve
 |      idc_value_t_reserve_get(self) -> uchar [sizeof(qstring)]
 |  
 |  str
 |  
 |  thisown
 |      The membership flag
 |  
 |  vtype
 |      idc_value_t_vtype_get(self) -> char

Help on class idc_values_t in module ida_expr:

class idc_values_t(builtins.object)
 |  Proxy of C++ qvector< idc_value_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'idc_value_t const &'
 |      __getitem__(self, i) -> idc_value_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idc_values_t
 |      __init__(self, x) -> idc_values_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_idc_values_t(...)
 |      delete_idc_values_t(self)
 |  
 |  at(self, *args) -> 'idc_value_t const &'
 |      at(self, _idx) -> idc_value_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< idc_value_t >::const_iterator'
 |      begin(self) -> idc_value_t
 |      begin(self) -> idc_value_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< idc_value_t >::const_iterator'
 |      end(self) -> idc_value_t
 |      end(self) -> idc_value_t
 |  
 |  erase(self, *args) -> 'qvector< idc_value_t >::iterator'
 |      erase(self, it) -> idc_value_t
 |      erase(self, first, last) -> idc_value_t
 |  
 |  extract(self, *args) -> 'idc_value_t *'
 |      extract(self) -> idc_value_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=idc_value_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< idc_value_t >::iterator'
 |      insert(self, it, x) -> idc_value_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'idc_value_t &'
 |      push_back(self, x)
 |      push_back(self) -> idc_value_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function idcv_float in module ida_expr:

idcv_float(*args) -> 'error_t'
    idcv_float(v) -> error_t
    
    
    Convert IDC variable to a floating point.
    
    
    @param v (C++: idc_value_t  *)

Help on function idcv_int64 in module ida_expr:

idcv_int64(*args) -> 'error_t'
    idcv_int64(v) -> error_t
    
    
    Convert IDC variable to a 64bit number.
    
    @param v (C++: idc_value_t  *)
    @return: v = 0 if impossible to convert to int64

Help on function idcv_long in module ida_expr:

idcv_long(*args) -> 'error_t'
    idcv_long(v) -> error_t
    
    
    Convert IDC variable to a long (32/64bit) number.
    
    @param v (C++: idc_value_t  *)
    @return: v = 0 if impossible to convert to long

Help on function idcv_num in module ida_expr:

idcv_num(*args) -> 'error_t'
    idcv_num(v) -> error_t
    
    
    Convert IDC variable to a long number.
    
    @param v (C++: idc_value_t  *)
    @return: v = 0 if IDC variable = "false" string   v = 1 if IDC
             variable = "true" string   v = number if IDC variable is
             number or string containing a number   eTypeConflict if IDC
             variable = empty string

Help on function idcv_object in module ida_expr:

idcv_object(*args) -> 'error_t'
    idcv_object(v, icls=None) -> error_t
    
    
    Create an IDC object. The original value of 'v' is discarded (freed).
    
    @param v: variable to hold the object. any previous value will be
              cleaned (C++: idc_value_t  *)
    @param icls: ptr to the desired class. NULL means "object" class this
                 ptr must be returned by  add_idc_class()  or
                 find_idc_class() (C++: const idc_class_t *)
    @return: always eOk

Help on function idcv_string in module ida_expr:

idcv_string(*args) -> 'error_t'
    idcv_string(v) -> error_t
    
    
    Convert IDC variable to a text string.
    
    
    @param v (C++: idc_value_t  *)

Help on function last_idcv_attr in module ida_expr:

last_idcv_attr(*args) -> 'char const *'
    last_idcv_attr(obj) -> char const *

Help on function move_idcv in module ida_expr:

move_idcv(*args) -> 'error_t'
    move_idcv(dst, src) -> error_t
    
    
    Move 'src' to 'dst'. This function is more effective than copy_idcv
    since it never copies big amounts of data.
    
    @param dst (C++: idc_value_t  *)
    @param src (C++: idc_value_t  *)

Help on function next_idcv_attr in module ida_expr:

next_idcv_attr(*args) -> 'char const *'
    next_idcv_attr(obj, attr) -> char const *

Help on function prev_idcv_attr in module ida_expr:

prev_idcv_attr(*args) -> 'char const *'
    prev_idcv_attr(obj, attr) -> char const *

Help on function print_idcv in module ida_expr:

print_idcv(*args) -> 'qstring *'
    print_idcv(v, name=None, indent=0) -> str
    
    
    Get text representation of 'idc_value_t' .
    
    
    @param v (C++: const  idc_value_t  &)
    @param name (C++: const char *)
    @param indent (C++: int)

Help on function py_add_idc_func in module ida_expr:

py_add_idc_func(*args) -> 'bool'
    py_add_idc_func(name, fp_ptr, args, defvals, flags) -> bool

Help on function py_get_call_idc_func in module ida_expr:

py_get_call_idc_func(*args) -> 'size_t'
    py_get_call_idc_func() -> size_t

Help on function pyw_convert_defvals in module ida_expr:

pyw_convert_defvals(*args) -> 'bool'
    pyw_convert_defvals(out, py_seq) -> bool

Help on function pyw_register_idc_func in module ida_expr:

pyw_register_idc_func(*args) -> 'size_t'
    pyw_register_idc_func(name, args, py_fp) -> size_t

Help on function pyw_unregister_idc_func in module ida_expr:

pyw_unregister_idc_func(*args) -> 'bool'
    pyw_unregister_idc_func(ctxptr) -> bool

Help on function set_header_path in module ida_expr:

set_header_path(*args) -> 'bool'
    set_header_path(path, add) -> bool
    
    
    Set or append a header path. IDA looks for the include files in the
    appended header paths, then in the ida executable directory.
    
    @param path: list of directories to add (separated by ';') may be
                 NULL, in this case nothing is added (C++: const char *)
    @param add: true: append. false: remove old paths. (C++: bool)

Help on function set_idcv_attr in module ida_expr:

set_idcv_attr(*args) -> 'error_t'
    set_idcv_attr(obj, attr, value, may_use_setattr=False) -> error_t
    
    
    Set an object attribute.
    
    @param obj: variable that holds an object reference. if obj is NULL
                then it tries to modify a global variable with the
                attribute name (C++: idc_value_t  *)
    @param attr: attribute name (C++: const char *)
    @param value: new attribute value (C++: const  idc_value_t  &)
    @param may_use_setattr: may call setattr functions for the class (C++:
                            bool)
    @return: error code, eOk on success

Help on function set_idcv_slice in module ida_expr:

set_idcv_slice(*args) -> 'error_t'
    set_idcv_slice(v, i1, i2, _in, flags=0) -> error_t
    
    
    Set slice.
    
    @param v: variable to modify (string or object) (C++: idc_value_t  *)
    @param i1: slice start index (C++: uval_t)
    @param i2: slice end index (excluded) (C++: uval_t)
    @param flags: IDC variable slice flags  or 0 (C++: int)
    @return: eOk on success

Help on function swap_idcvs in module ida_expr:

swap_idcvs(*args) -> 'void'
    swap_idcvs(v1, v2)
    
    
    Swap 2 variables.
    
    
    @param v1 (C++: idc_value_t  *)
    @param v2 (C++: idc_value_t  *)

Help on function throw_idc_exception in module ida_expr:

throw_idc_exception(*args) -> 'error_t'
    throw_idc_exception(r, desc) -> error_t
    
    
    Create an idc execution exception object. This helper function can be
    used to return an exception from C++ code to IDC. In other words this
    function can be called from 'idc_func_t()' callbacks. Sample usage: if
    ( !ok ) return throw_idc_exception(r, "detailed error msg");
    
    @param r: object to hold the exception object (C++: idc_value_t  *)
    @param desc: exception description (C++: const char *)
    @return: eExecThrow

=== ida_expr EPYDOC INJECTIONS ===
ida_expr.CPL_DEL_MACROS
"""
delete macros at the end of compilation
"""

ida_expr.CPL_ONLY_SAFE
"""
allow calls of only thread-safe functions
"""

ida_expr.CPL_USE_LABELS
"""
allow program labels in the script
"""

ida_expr.IDC_LANG_EXT
"""
IDC script extension.
"""

ida_expr.VARSLICE_SINGLE
"""
return single index (i2 is ignored)
"""

ida_expr.VREF_COPY
"""
copy the result to the input var (v)
"""

ida_expr.VREF_LOOP
"""
dereference until we get a non 'VT_REF'
"""

ida_expr.VREF_ONCE
"""
dereference only once, do not loop
"""

ida_expr.VT_FLOAT
"""
Floating point (see 'idc_value_t::e' )
"""

ida_expr.VT_FUNC
"""
Function (see 'idc_value_t::funcidx' )
"""

ida_expr.VT_INT64
"""
i64
"""

ida_expr.VT_LONG
"""
Integer (see 'idc_value_t::num' )
"""

ida_expr.VT_OBJ
"""
Object (see idc_value_t::obj)
"""

ida_expr.VT_PVOID
"""
void *
"""

ida_expr.VT_REF
"""
Reference.
"""

ida_expr.VT_STR
"""
String (see qstr() and similar functions)
"""

ida_expr.VT_WILD
"""
Function with arbitrary number of arguments. The actual number of
arguments will be passed in 'idc_value_t::num' . This value should not
be used for 'idc_value_t' .
"""

ida_expr.eExecThrow
"""
See return value of 'idc_func_t' .
"""
=== ida_expr EPYDOC INJECTIONS END ===
Help on function calc_fixup_size in module ida_fixup:

calc_fixup_size(*args) -> 'int'
    calc_fixup_size(type) -> int
    
    
    Calculate size of fixup in bytes (the number of bytes the fixup
    patches)
    
    @param type (C++: fixup_type_t)

Help on function contains_fixups in module ida_fixup:

contains_fixups(*args) -> 'bool'
    contains_fixups(ea, size) -> bool
    
    
    Does the specified address range contain any fixup information?
    
    
    @param ea (C++: ea_t)
    @param size (C++: asize_t)

Help on function del_fixup in module ida_fixup:

del_fixup(*args) -> 'void'
    del_fixup(source)
    
    
    Delete fixup information.
    
    
    @param source (C++: ea_t)

Help on function exists_fixup in module ida_fixup:

exists_fixup(*args) -> 'bool'
    exists_fixup(source) -> bool
    
    
    Check that a fixup exists at the given address.
    
    
    @param source (C++: ea_t)

Help on function find_custom_fixup in module ida_fixup:

find_custom_fixup(*args) -> 'fixup_type_t'
    find_custom_fixup(name) -> fixup_type_t
    
    
    Get id of a custom fixup handler.
    
    @param name: name of the custom fixup handler (C++: const char *)
    @return: id with FIXUP_CUSTOM bit set or 0

Help on class fixup_data_t in module ida_fixup:

class fixup_data_t(builtins.object)
 |  Proxy of C++ fixup_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> fixup_data_t
 |      __init__(self, type_, flags_=0) -> fixup_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_fixup_data_t(...)
 |      delete_fixup_data_t(self)
 |  
 |  calc_size(self, *args) -> 'int'
 |      calc_size(self) -> int
 |  
 |  clr_extdef(self, *args) -> 'void'
 |      clr_extdef(self)
 |  
 |  clr_unused(self, *args) -> 'void'
 |      clr_unused(self)
 |  
 |  get(self, *args) -> 'bool'
 |      get(self, source) -> bool
 |  
 |  get_base(self, *args) -> 'ea_t'
 |      get_base(self) -> ea_t
 |  
 |  get_desc(self, *args) -> 'char const *'
 |      get_desc(self, source) -> char const *
 |  
 |  get_flags(self, *args) -> 'uint32'
 |      get_flags(self) -> uint32
 |  
 |  get_handler(self, *args) -> 'fixup_handler_t const *'
 |      get_handler(self) -> fixup_handler_t const *
 |  
 |  get_type(self, *args) -> 'fixup_type_t'
 |      get_type(self) -> fixup_type_t
 |  
 |  get_value(self, *args) -> 'uval_t'
 |      get_value(self, ea) -> uval_t
 |  
 |  has_base(self, *args) -> 'bool'
 |      has_base(self) -> bool
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |  
 |  is_extdef(self, *args) -> 'bool'
 |      is_extdef(self) -> bool
 |  
 |  is_unused(self, *args) -> 'bool'
 |      is_unused(self) -> bool
 |  
 |  patch_value(self, *args) -> 'bool'
 |      patch_value(self, ea) -> bool
 |  
 |  set(self, *args) -> 'void'
 |      set(self, source)
 |  
 |  set_base(self, *args) -> 'void'
 |      set_base(self, new_base)
 |  
 |  set_extdef(self, *args) -> 'void'
 |      set_extdef(self)
 |  
 |  set_sel(self, *args) -> 'void'
 |      set_sel(self, seg)
 |  
 |  set_target_sel(self, *args) -> 'void'
 |      set_target_sel(self)
 |  
 |  set_type(self, *args) -> 'void'
 |      set_type(self, type_)
 |  
 |  set_type_and_flags(self, *args) -> 'void'
 |      set_type_and_flags(self, type_, flags_=0)
 |  
 |  set_unused(self, *args) -> 'void'
 |      set_unused(self)
 |  
 |  was_created(self, *args) -> 'bool'
 |      was_created(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  displacement
 |      fixup_data_t_displacement_get(self) -> adiff_t
 |  
 |  off
 |      fixup_data_t_off_get(self) -> ea_t
 |  
 |  sel
 |      fixup_data_t_sel_get(self) -> sel_t
 |  
 |  thisown
 |      The membership flag

Help on class fixup_info_t in module ida_fixup:

class fixup_info_t(builtins.object)
 |  Proxy of C++ fixup_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> fixup_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_fixup_info_t(...)
 |      delete_fixup_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      fixup_info_t_ea_get(self) -> ea_t
 |  
 |  fd
 |      fixup_info_t_fd_get(self) -> fixup_data_t
 |  
 |  thisown
 |      The membership flag

Help on function gen_fix_fixups in module ida_fixup:

gen_fix_fixups(*args) -> 'void'
    gen_fix_fixups(_from, to, size)
    
    
    Relocate the bytes with fixup information once more (generic
    function). This function may be called from 'loader_t::move_segm()' if
    it suits the goal. If 'loader_t::move_segm' is not defined then this
    function will be called automatically when moving segments or rebasing
    the entire program. Special parameter values (from = BADADDR, size =
    0, to = delta) are used when the function is called from
    rebase_program(delta).
    
    @param _from (C++: ea_t)
    @param to (C++: ea_t)
    @param size (C++: asize_t)

Help on function get_first_fixup_ea in module ida_fixup:

get_first_fixup_ea(*args) -> 'ea_t'
    get_first_fixup_ea() -> ea_t
    
    
    Get the first address with fixup information
    
    @return: the first address with fixup information, or BADADDR

Help on function get_fixup in module ida_fixup:

get_fixup(*args) -> 'bool'
    get_fixup(fd, source) -> bool
    
    
    Get fixup information.
    
    
    @param fd (C++: fixup_data_t  *)
    @param source (C++: ea_t)

Help on function get_fixup_desc in module ida_fixup:

get_fixup_desc(*args) -> 'fixup_data_t const &'
    get_fixup_desc(source, fd) -> str
    
    
    Get FIXUP description comment.
    
    
    @param source (C++: ea_t)
    @param fd (C++: const  fixup_data_t  &)

Help on function get_fixup_handler in module ida_fixup:

get_fixup_handler(*args) -> 'fixup_handler_t const *'
    get_fixup_handler(type) -> fixup_handler_t const *
    
    
    Get handler of standard or custom fixup.
    
    
    @param type (C++: fixup_type_t)

Help on function get_fixup_value in module ida_fixup:

get_fixup_value(*args) -> 'uval_t'
    get_fixup_value(ea, type) -> uval_t
    
    
    Get the operand value. This function get fixup bytes from data or an
    instruction at `ea' and convert them to the operand value (maybe
    partially). It is opposite in meaning to the 'patch_fixup_value()' .
    For example, FIXUP_HI8 read a byte at 'patch_fixup_value()'  `ea' and
    shifts it left by 8 bits, or AArch64's custom fixup BRANCH26 get low
    26 bits of the insn at `ea' and shifts it left by 2 bits. This
    function is mainly used to get a relocation addend.
    'fixup_handler_t::size'
    
    @param ea: address to get fixup bytes from, the size of the fixup
               bytes depends on the fixup type. (C++: ea_t)
    @param type (C++: fixup_type_t)

Help on function get_fixups in module ida_fixup:

get_fixups(*args) -> 'bool'
    get_fixups(out, ea, size) -> bool

Help on function get_next_fixup_ea in module ida_fixup:

get_next_fixup_ea(*args) -> 'ea_t'
    get_next_fixup_ea(ea) -> ea_t
    
    
    Find next address with fixup information
    
    @param ea: current address (C++: ea_t)
    @return: the next address with fixup information, or BADADDR

Help on function get_prev_fixup_ea in module ida_fixup:

get_prev_fixup_ea(*args) -> 'ea_t'
    get_prev_fixup_ea(ea) -> ea_t
    
    
    Find previous address with fixup information
    
    @param ea: current address (C++: ea_t)
    @return: the previous address with fixup information, or BADADDR

Help on function is_fixup_custom in module ida_fixup:

is_fixup_custom(*args) -> 'bool'
    is_fixup_custom(type) -> bool
    
    
    Is fixup processed by processor module?
    
    
    @param type (C++: fixup_type_t)

Help on function patch_fixup_value in module ida_fixup:

patch_fixup_value(*args) -> 'bool'
    patch_fixup_value(ea, fd) -> bool
    
    
    Patch the fixup bytes. This function updates data or an instruction at
    `ea' to the fixup bytes. For example, FIXUP_HI8 updates a byte at `ea'
    to the high byte of `fd->off' , or AArch64's custom fixup BRANCH26
    updates low 26 bits of the insn at `ea' to the value of `fd->off'
    shifted right by 2. 'fixup_handler_t::size'
    
    @param ea: address where data are changed, the size of the changed
               data depends on the fixup type. (C++: ea_t)
    @param fd (C++: const  fixup_data_t  &)

Help on function set_fixup in module ida_fixup:

set_fixup(*args) -> 'void'
    set_fixup(source, fd)
    
    
    Set fixup information. You should fill 'fixup_data_t' and call this
    function and the kernel will remember information in the database.
    
    @param source: the fixup source address, i.e. the address modified by
                   the fixup (C++: ea_t)
    @param fd: fixup data (C++: const  fixup_data_t  &)

=== ida_fixup EPYDOC INJECTIONS ===
ida_fixup.FIXUPF_CREATED
"""
fixup was not present in the input file
"""

ida_fixup.FIXUPF_EXTDEF
"""
target is a location (otherwise - segment). Use this bit if the target
is a symbol rather than an offset from the beginning of a segment.
"""

ida_fixup.FIXUPF_LOADER_MASK
"""
additional flags. The bits from this mask are not stored in the
database and can be used by the loader at its discretion.
"""

ida_fixup.FIXUPF_REL
"""
fixup is relative to the linear address `base' . Otherwise fixup is
relative to the start of the segment with `sel' selector.
"""

ida_fixup.FIXUPF_UNUSED
"""
fixup is ignored by IDAdisallows the kernel to convert operandsthis
fixup is not used during output
"""
=== ida_fixup EPYDOC INJECTIONS END ===
Help on class qfile_t in module ida_fpro:

class qfile_t(builtins.object)
 |  Proxy of C++ qfile_t class.
 |  
 |  
 |  A helper class to work with FILE related functions.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, rhs) -> qfile_t
 |      __init__(self, pycapsule=None) -> qfile_t
 |      
 |      
 |      Closes the file
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qfile_t(...)
 |      delete_qfile_t(self)
 |  
 |  close(self, *args) -> 'void'
 |      close(self)
 |  
 |  filename(self, *args) -> 'PyObject *'
 |      filename(self) -> PyObject *
 |  
 |  flush(self, *args) -> 'int'
 |      flush(self) -> int
 |      
 |      
 |      Reads a single byte from the file. Returns None if EOF or the read byte
 |  
 |  get_byte(self, *args) -> 'PyObject *'
 |      get_byte(self) -> PyObject *
 |  
 |  get_fp(self, *args) -> 'FILE *'
 |      get_fp(self) -> FILE *
 |  
 |  gets(self, *args) -> 'PyObject *'
 |      gets(self, size) -> PyObject *
 |      
 |      
 |      Reads a line from the input file. Returns the read line or None
 |  
 |  open(self, *args) -> 'bool'
 |      open(self, filename, mode) -> bool
 |      
 |      
 |      Opens a file
 |      
 |      @param filename: the file name
 |      @param mode: The mode string, ala fopen() style
 |      @return: Boolean
 |  
 |  opened(self, *args) -> 'bool'
 |      opened(self) -> bool
 |      
 |      
 |      Checks if the file is opened or not
 |  
 |  put_byte(self, *args) -> 'int'
 |      put_byte(self, chr) -> int
 |      
 |      
 |      Writes a single byte to the file
 |  
 |  puts(self, *args) -> 'int'
 |      puts(self, str) -> int
 |  
 |  read(self, *args) -> 'PyObject *'
 |      read(self, size) -> PyObject *
 |      
 |      
 |      Reads from the file. Returns the buffer or None
 |  
 |  readbytes(self, *args) -> 'PyObject *'
 |      readbytes(self, size, big_endian) -> PyObject *
 |      
 |      
 |      Similar to read() but it respect the endianness
 |  
 |  seek(self, *args) -> 'int'
 |      seek(self, offset, whence=SEEK_SET) -> int
 |      
 |      
 |      Set input source position
 |      @return: the new position (not 0 as fseek!)
 |  
 |  size(self, *args) -> 'int64'
 |      size(self) -> int64
 |  
 |  tell(self, *args) -> 'int64'
 |      tell(self) -> int64
 |      
 |      
 |      Returns the current position
 |  
 |  write(self, *args) -> 'int'
 |      write(self, py_buf) -> int
 |      
 |      
 |      Writes to the file. Returns 0 or the number of bytes written
 |  
 |  writebytes(self, *args) -> 'int'
 |      writebytes(self, py_buf, big_endian) -> int
 |      
 |      
 |      Similar to write() but it respect the endianness
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  from_capsule(*args) -> 'qfile_t *'
 |      from_capsule(pycapsule) -> qfile_t
 |  
 |  from_fp(*args) -> 'qfile_t *'
 |      from_fp(fp) -> qfile_t
 |  
 |  tmpfile(*args) -> 'qfile_t *'
 |      tmpfile() -> qfile_t
 |      
 |      
 |      A static method to construct an instance using a temporary file
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __idc_cvt_id__
 |      qfile_t___idc_cvt_id___get(self) -> int
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function qfile_t_from_capsule in module ida_fpro:

qfile_t_from_capsule(*args) -> 'qfile_t *'
    qfile_t_from_capsule(pycapsule) -> qfile_t

Help on function qfile_t_from_fp in module ida_fpro:

qfile_t_from_fp(*args) -> 'qfile_t *'
    qfile_t_from_fp(fp) -> qfile_t

Help on function qfile_t_tmpfile in module ida_fpro:

qfile_t_tmpfile(*args) -> 'qfile_t *'
    qfile_t_tmpfile() -> qfile_t

Help on function add_auto_stkpnt in module ida_frame:

add_auto_stkpnt(*args) -> 'bool'
    add_auto_stkpnt(pfn, ea, delta) -> bool
    
    
    Add automatic SP register change point.
    
    @param pfn: pointer to function. may be NULL. (C++: func_t  *)
    @param ea: linear address where SP changes. usually this is the end of
               the instruction which modifies the stack pointer
               (\cmd{ea}+\cmd{size}) (C++: ea_t)
    @param delta: difference between old and new values of SP (C++:
                  sval_t)
    @return: success

Help on function add_frame in module ida_frame:

add_frame(*args) -> 'bool'
    add_frame(pfn, frsize, frregs, argsize) -> bool
    
    
    Add function frame.
    
    @param pfn: pointer to function structure (C++: func_t  *)
    @param frsize: size of function local variables (C++: sval_t)
    @param frregs: size of saved registers (C++: ushort)
    @param argsize: size of function arguments range which will be purged
                    upon return. this parameter is used for __stdcall and
                    __pascal calling conventions. for other calling
                    conventions please pass 0. (C++: asize_t)

Help on function add_regvar in module ida_frame:

add_regvar(*args) -> 'int'
    add_regvar(pfn, ea1, ea2, canon, user, cmt) -> int
    
    
    Define a register variable.
    
    @param pfn: function in which the definition will be created (C++:
                func_t  *)
    @param ea1: range of addresses within the function where the
                definition will be used (C++: ea_t)
    @param ea2: range of addresses within the function where the
                definition will be used (C++: ea_t)
    @param canon: name of a general register (C++: const char *)
    @param user: user-defined name for the register (C++: const char *)
    @param cmt: comment for the definition (C++: const char *)
    @return: Register variable error codes

Help on function add_user_stkpnt in module ida_frame:

add_user_stkpnt(*args) -> 'bool'
    add_user_stkpnt(ea, delta) -> bool
    
    
    Add user-defined SP register change point.
    
    @param ea: linear address where SP changes (C++: ea_t)
    @param delta: difference between old and new values of SP (C++:
                  sval_t)
    @return: success

Help on function build_stkvar_name in module ida_frame:

build_stkvar_name(*args) -> 'qstring *'
    build_stkvar_name(pfn, v) -> str
    
    
    Build automatic stack variable name.
    
    @param pfn: pointer to function (can't be NULL!) (C++: const  func_t
                *)
    @param v: value of variable offset (C++: sval_t)
    @return: length of stack variable name or -1

Help on function build_stkvar_xrefs in module ida_frame:

build_stkvar_xrefs(*args) -> 'void'
    build_stkvar_xrefs(out, pfn, mptr)
    
    
    Fill 'out' with a list of all the xrefs made from function 'pfn', to
    the argument or variable 'mptr' in 'pfn's stack frame.
    
    @param out: the list of xrefs to fill. (C++: xreflist_t  *)
    @param pfn: the function to scan. (C++: func_t  *)
    @param mptr: the argument/variable in pfn's stack frame. (C++: const
                 member_t  *)

Help on function calc_stkvar_struc_offset in module ida_frame:

calc_stkvar_struc_offset(*args) -> 'ea_t'
    calc_stkvar_struc_offset(pfn, insn, n) -> ea_t
    
    
    Calculate offset of stack variable in the frame structure.
    
    @param pfn: pointer to function (can't be NULL!) (C++: func_t  *)
    @param insn: the instruction (C++: const  insn_t  &)
    @param n: number of operand: (0.. UA_MAXOP -1) -1 if error, return
              BADADDR (C++: int)
    @return: BADADDR  if some error (issue a warning if stack frame is
             bad)

Help on function define_stkvar in module ida_frame:

define_stkvar(*args) -> 'bool'
    define_stkvar(pfn, name, off, flags, ti, nbytes) -> bool
    
    
    Define/redefine a stack variable.
    
    @param pfn: pointer to function (C++: func_t  *)
    @param name: variable name, NULL means autogenerate a name (C++: const
                 char *)
    @param off: offset of the stack variable in the frame. negative values
                denote local variables, positive - function arguments.
                (C++: sval_t)
    @param flags: variable type flags ( byte_flag()  for a byte variable,
                  for example) (C++: flags_t)
    @param ti: additional type information (like offsets, structs, etc)
               (C++: const  opinfo_t  *)
    @param nbytes: number of bytes occupied by the variable (C++: asize_t)
    @return: success

Help on function del_frame in module ida_frame:

del_frame(*args) -> 'bool'
    del_frame(pfn) -> bool
    
    
    Delete a function frame.
    
    @param pfn: pointer to function structure (C++: func_t  *)
    @return: success

Help on function del_regvar in module ida_frame:

del_regvar(*args) -> 'int'
    del_regvar(pfn, ea1, ea2, canon) -> int
    
    
    Delete a register variable definition.
    
    @param pfn: function in question (C++: func_t  *)
    @param ea1: range of addresses within the function where the
                definition holds (C++: ea_t)
    @param ea2: range of addresses within the function where the
                definition holds (C++: ea_t)
    @param canon: name of a general register (C++: const char *)
    @return: Register variable error codes

Help on function del_stkpnt in module ida_frame:

del_stkpnt(*args) -> 'bool'
    del_stkpnt(pfn, ea) -> bool
    
    
    Delete SP register change point.
    
    @param pfn: pointer to function. may be NULL. (C++: func_t  *)
    @param ea: linear address (C++: ea_t)
    @return: success

Help on function delete_unreferenced_stkvars in module ida_frame:

delete_unreferenced_stkvars(*args) -> 'int'
    delete_unreferenced_stkvars(pfn) -> int

Help on function delete_wrong_stkvar_ops in module ida_frame:

delete_wrong_stkvar_ops(*args) -> 'int'
    delete_wrong_stkvar_ops(pfn) -> int

Help on function find_regvar in module ida_frame:

find_regvar(*args) -> 'regvar_t *'
    find_regvar(pfn, ea1, ea2, canon, user) -> regvar_t
    find_regvar(pfn, ea, canon) -> regvar_t
    
    
    Find a register variable definition (powerful version). One of 'canon'
    and 'user' should be NULL. If both 'canon' and 'user' are NULL it
    returns the first regvar definition in the range.
    
    @param pfn: function in question (C++: func_t  *)
    @param ea1: range of addresses to search. ea1==BADADDR means the
                entire function (C++: ea_t)
    @param ea2: range of addresses to search. ea1==BADADDR means the
                entire function (C++: ea_t)
    @param canon: name of a general register (C++: const char *)
    @param user: user-defined name for the register (C++: const char *)
    @return: NULL-not found, otherwise ptr to  regvar_t

Help on function frame_off_args in module ida_frame:

frame_off_args(*args) -> 'ea_t'
    frame_off_args(pfn) -> ea_t
    
    
    Get starting address of arguments section.
    
    
    @param pfn (C++: const  func_t  *)

Help on function frame_off_lvars in module ida_frame:

frame_off_lvars(*args) -> 'ea_t'
    frame_off_lvars(pfn) -> ea_t
    
    
    Get start address of local variables section.
    
    
    @param pfn (C++: const  func_t  *)

Help on function frame_off_retaddr in module ida_frame:

frame_off_retaddr(*args) -> 'ea_t'
    frame_off_retaddr(pfn) -> ea_t
    
    
    Get starting address of return address section.
    
    
    @param pfn (C++: const  func_t  *)

Help on function frame_off_savregs in module ida_frame:

frame_off_savregs(*args) -> 'ea_t'
    frame_off_savregs(pfn) -> ea_t
    
    
    Get starting address of saved registers section.
    
    
    @param pfn (C++: const  func_t  *)

Help on function get_effective_spd in module ida_frame:

get_effective_spd(*args) -> 'sval_t'
    get_effective_spd(pfn, ea) -> sval_t
    
    
    Get effective difference between the initial and current values of
    ESP. This function returns the sp-diff used by the instruction. The
    difference between 'get_spd()' and 'get_effective_spd()' is present
    only for instructions like "pop [esp+N]": they modify sp and use the
    modified value.
    
    @param pfn: pointer to function. may be NULL. (C++: func_t  *)
    @param ea: linear address (C++: ea_t)
    @return: 0 or the difference, usually a negative number

Help on function get_frame in module ida_frame:

get_frame(*args) -> 'struc_t *'
    get_frame(pfn) -> struc_t
    get_frame(ea) -> struc_t *
    
    
    Get pointer to function frame.
    
    @param pfn: pointer to function structure (C++: const  func_t  *)

Help on function get_frame_part in module ida_frame:

get_frame_part(*args) -> 'void'
    get_frame_part(range, pfn, part)
    
    
    Get offsets of the frame part in the frame.
    
    @param range: pointer to the output buffer with the frame part
                  start/end(exclusive) offsets, can't be NULL (C++:
                  range_t  *)
    @param pfn: pointer to function structure, can't be NULL (C++: const
                func_t  *)
    @param part: frame part (C++: frame_part_t)

Help on function get_frame_retsize in module ida_frame:

get_frame_retsize(*args) -> 'int'
    get_frame_retsize(pfn) -> int
    
    
    Get size of function return address.
    
    @param pfn: pointer to function structure, can't be NULL (C++: const
                func_t  *)

Help on function get_frame_size in module ida_frame:

get_frame_size(*args) -> 'asize_t'
    get_frame_size(pfn) -> asize_t
    
    
    Get full size of a function frame. This function takes into account
    size of local variables + size of saved registers + size of return
    address + number of purged bytes. The purged bytes correspond to the
    arguments of the functions with __stdcall and __fastcall calling
    conventions.
    
    @param pfn: pointer to function structure, may be NULL (C++: const
                func_t  *)
    @return: size of frame in bytes or zero

Help on function get_func_by_frame in module ida_frame:

get_func_by_frame(*args) -> 'ea_t'
    get_func_by_frame(frame_id) -> ea_t
    
    
    Get function by its frame id.this function works only with databases
    created by IDA > 5.6
    
    @param frame_id: id of the function frame (C++: tid_t)
    @return: start address of the function or  BADADDR

Help on function get_min_spd_ea in module ida_frame:

get_min_spd_ea(*args) -> 'ea_t'
    get_min_spd_ea(pfn) -> ea_t

Help on function get_sp_delta in module ida_frame:

get_sp_delta(*args) -> 'sval_t'
    get_sp_delta(pfn, ea) -> sval_t
    
    
    Get modification of SP made at the specified location
    
    @param pfn: pointer to function. may be NULL. (C++: func_t  *)
    @param ea: linear address (C++: ea_t)
    @return: 0 if the specified location doesn't contain a SP change
             point. otherwise return delta of SP modification.

Help on function get_spd in module ida_frame:

get_spd(*args) -> 'sval_t'
    get_spd(pfn, ea) -> sval_t
    
    
    Get difference between the initial and current values of ESP.
    
    @param pfn: pointer to function. may be NULL. (C++: func_t  *)
    @param ea: linear address of an instruction (C++: ea_t)
    @return: 0 or the difference, usually a negative number. returns the
             sp-diff before executing the instruction.

Help on function get_stkvar in module ida_frame:

get_stkvar(*args) -> 'PyObject *'
    get_stkvar(insn, op, v) -> PyObject *
    
    
    Get pointer to stack variable
    @param op: reference to instruction operand
    @param v: immediate value in the operand (usually op.addr)
    @return:
        - None on failure
        - tuple(member_t, actval)
          where actval: actual value used to fetch stack variable

Help on function has_regvar in module ida_frame:

has_regvar(*args) -> 'bool'
    has_regvar(pfn, ea) -> bool
    
    
    Is there a register variable definition?
    
    @param pfn: function in question (C++: func_t  *)
    @param ea: current address (C++: ea_t)

Help on function is_funcarg_off in module ida_frame:

is_funcarg_off(*args) -> 'bool'
    is_funcarg_off(pfn, frameoff) -> bool
    
    
    Does the given offset lie within the arguments section?
    
    
    @param pfn (C++: const  func_t  *)
    @param frameoff (C++: uval_t)

Help on class llabel_t in module ida_frame:

class llabel_t(builtins.object)
 |  Proxy of C++ llabel_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> llabel_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_llabel_t(...)
 |      delete_llabel_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      llabel_t_ea_get(self) -> ea_t
 |  
 |  name
 |      llabel_t_name_get(self) -> char *
 |  
 |  thisown
 |      The membership flag

Help on function lvar_off in module ida_frame:

lvar_off(*args) -> 'sval_t'
    lvar_off(pfn, frameoff) -> sval_t
    
    
    Does the given offset lie within the local variables section?
    
    
    @param pfn (C++: const  func_t  *)
    @param frameoff (C++: uval_t)

Help on function recalc_spd in module ida_frame:

recalc_spd(*args) -> 'bool'
    recalc_spd(cur_ea) -> bool
    
    
    Recalculate SP delta for an instruction that stops execution. The next
    instruction is not reached from the current instruction. We need to
    recalculate SP for the next instruction.This function will create a
    new automatic SP register change point if necessary. It should be
    called from the emulator (emu.cpp) when auto_state == 'AU_USED' if the
    current instruction doesn't pass the execution flow to the next
    instruction.
    
    @param cur_ea: linear address of the current instruction (C++: ea_t)

Help on class regvar_t in module ida_frame:

class regvar_t(ida_range.range_t)
 |  Proxy of C++ regvar_t class.
 |  
 |  Method resolution order:
 |      regvar_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regvar_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_regvar_t(...)
 |      delete_regvar_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  canon
 |      regvar_t_canon_get(self) -> char *
 |  
 |  cmt
 |      regvar_t_cmt_get(self) -> char *
 |  
 |  thisown
 |      The membership flag
 |  
 |  user
 |      regvar_t_user_get(self) -> char *
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      contains(self, r) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on function rename_regvar in module ida_frame:

rename_regvar(*args) -> 'int'
    rename_regvar(pfn, v, user) -> int
    
    
    Rename a register variable.
    
    @param pfn: function in question (C++: func_t  *)
    @param v: variable to rename (C++: regvar_t  *)
    @param user: new user-defined name for the register (C++: const char
                 *)
    @return: Register variable error codes

Help on function set_frame_size in module ida_frame:

set_frame_size(*args) -> 'bool'
    set_frame_size(pfn, frsize, frregs, argsize) -> bool
    
    
    Set size of function frame. Note: The returned size may not include
    all stack arguments. It does so only for __stdcall and __fastcall
    calling conventions. To get the entire frame size for all cases use
    get_struc_size(get_frame(pfn)).
    
    @param pfn: pointer to function structure (C++: func_t  *)
    @param frsize: size of function local variables (C++: asize_t)
    @param frregs: size of saved registers (C++: ushort)
    @param argsize: size of function arguments that will be purged from
                    the stack upon return (C++: asize_t)
    @return: success

Help on function set_purged in module ida_frame:

set_purged(*args) -> 'bool'
    set_purged(ea, nbytes, override_old_value) -> bool
    
    
    Set the number of purged bytes for a function or data item (funcptr).
    This function will update the database and plan to reanalyze items
    referencing the specified address. It works only for processors with
    'PR_PURGING' bit in 16 and 32 bit modes.
    
    @param ea: address of the function of item (C++: ea_t)
    @param nbytes: number of purged bytes (C++: int)
    @param override_old_value: may overwrite old information about purged
                               bytes (C++: bool)
    @return: success

Help on function set_regvar_cmt in module ida_frame:

set_regvar_cmt(*args) -> 'int'
    set_regvar_cmt(pfn, v, cmt) -> int
    
    
    Set comment for a register variable.
    
    @param pfn: function in question (C++: func_t  *)
    @param v: variable to rename (C++: regvar_t  *)
    @param cmt: new comment (C++: const char *)
    @return: Register variable error codes

Help on function soff_to_fpoff in module ida_frame:

soff_to_fpoff(*args) -> 'sval_t'
    soff_to_fpoff(pfn, soff) -> sval_t
    
    
    Convert struct offsets into fp-relative offsets. This function
    converts the offsets inside the 'struc_t' object into the frame
    pointer offsets (for example, EBP-relative).
    
    @param pfn (C++: func_t  *)
    @param soff (C++: uval_t)

Help on class stkpnt_t in module ida_frame:

class stkpnt_t(builtins.object)
 |  Proxy of C++ stkpnt_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> stkpnt_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_stkpnt_t(...)
 |      delete_stkpnt_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      stkpnt_t_ea_get(self) -> ea_t
 |  
 |  spd
 |      stkpnt_t_spd_get(self) -> sval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class stkpnts_t in module ida_frame:

class stkpnts_t(builtins.object)
 |  Proxy of C++ stkpnts_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> stkpnts_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_stkpnts_t(...)
 |      delete_stkpnts_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function update_fpd in module ida_frame:

update_fpd(*args) -> 'bool'
    update_fpd(pfn, fpd) -> bool
    
    
    Update frame pointer delta.
    
    @param pfn: pointer to function structure (C++: func_t  *)
    @param fpd: new fpd value. cannot be bigger than the local variable
                range size. (C++: asize_t)
    @return: success

Help on class xreflist_entry_t in module ida_frame:

class xreflist_entry_t(builtins.object)
 |  Proxy of C++ xreflist_entry_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> xreflist_entry_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_xreflist_entry_t(...)
 |      delete_xreflist_entry_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      xreflist_entry_t_ea_get(self) -> ea_t
 |  
 |  opnum
 |      xreflist_entry_t_opnum_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      xreflist_entry_t_type_get(self) -> uchar
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class xreflist_t in module ida_frame:

class xreflist_t(builtins.object)
 |  Proxy of C++ qvector< xreflist_entry_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'xreflist_entry_t const &'
 |      __getitem__(self, i) -> xreflist_entry_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> xreflist_t
 |      __init__(self, x) -> xreflist_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_xreflist_t(...)
 |      delete_xreflist_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'xreflist_entry_t const &'
 |      at(self, _idx) -> xreflist_entry_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< xreflist_entry_t >::const_iterator'
 |      begin(self) -> xreflist_entry_t
 |      begin(self) -> xreflist_entry_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< xreflist_entry_t >::const_iterator'
 |      end(self) -> xreflist_entry_t
 |      end(self) -> xreflist_entry_t
 |  
 |  erase(self, *args) -> 'qvector< xreflist_entry_t >::iterator'
 |      erase(self, it) -> xreflist_entry_t
 |      erase(self, first, last) -> xreflist_entry_t
 |  
 |  extract(self, *args) -> 'xreflist_entry_t *'
 |      extract(self) -> xreflist_entry_t
 |  
 |  find(self, *args) -> 'qvector< xreflist_entry_t >::const_iterator'
 |      find(self, x) -> xreflist_entry_t
 |      find(self, x) -> xreflist_entry_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=xreflist_entry_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< xreflist_entry_t >::iterator'
 |      insert(self, it, x) -> xreflist_entry_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'xreflist_entry_t &'
 |      push_back(self, x)
 |      push_back(self) -> xreflist_entry_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

=== ida_frame EPYDOC INJECTIONS ===
ida_frame.REGVAR_ERROR_ARG
"""
function arguments are bad
"""

ida_frame.REGVAR_ERROR_NAME
"""
the provided name(s) can't be accepted
"""

ida_frame.REGVAR_ERROR_OK
"""
all ok
"""

ida_frame.REGVAR_ERROR_RANGE
"""
the definition range is bad
"""

ida_frame.STKVAR_VALID_SIZE
"""
x.dtyp contains correct variable type (for insns like 'lea' this bit
must be off) in general, dr_O references do not allow to determine the
variable size
"""
=== ida_frame EPYDOC INJECTIONS END ===
Help on function add_func in module ida_funcs:

add_func(*args) -> 'bool'
    add_func(ea1, ea2=BADADDR) -> bool
    
    
    Add a new function. If the function end address is 'BADADDR' , then
    IDA will try to determine the function bounds by calling
    find_func_bounds(..., 'FIND_FUNC_DEFINE' ).
    
    @param ea1: start address (C++: ea_t)
    @param ea2: end address (C++: ea_t)
    @return: success

Help on function add_func_ex in module ida_funcs:

add_func_ex(*args) -> 'bool'
    add_func_ex(pfn) -> bool
    
    
    Add a new function. If the fn->end_ea is 'BADADDR' , then IDA will try
    to determine the function bounds by calling find_func_bounds(...,
    'FIND_FUNC_DEFINE' ).
    
    @param pfn: ptr to filled function structure (C++: func_t  *)
    @return: success

Help on function add_regarg in module ida_funcs:

add_regarg(*args) -> 'void'
    add_regarg(pfn, reg, tif, name)

Help on function append_func_tail in module ida_funcs:

append_func_tail(*args) -> 'bool'
    append_func_tail(pfn, ea1, ea2) -> bool
    
    
    Append a new tail chunk to the function definition. If the tail
    already exists, then it will simply be added to the function tail list
    Otherwise a new tail will be created and its owner will be set to be
    our function If a new tail cannot be created, then this function will
    fail.
    
    @param pfn (C++: func_t  *)
    @param ea1: start of the tail. If a tail already exists at the
                specified address it must start at 'ea1' (C++: ea_t)
    @param ea2: end of the tail. If a tail already exists at the specified
                address it must end at 'ea2'. If specified as BADADDR, IDA
                will determine the end address itself. (C++: ea_t)

Help on function apply_idasgn_to in module ida_funcs:

apply_idasgn_to(*args) -> 'int'
    apply_idasgn_to(signame, ea, is_startup) -> int
    
    
    Apply a signature file to the specified address.
    
    @param signame: short name of signature file (the file name without
                    path) (C++: const char *)
    @param ea: address to apply the signature (C++: ea_t)
    @param is_startup: if set, then the signature is treated as a startup
                       one for startup signature ida doesn't rename the
                       first function of the applied module. (C++: bool)
    @return: Library function codes

Help on function apply_startup_sig in module ida_funcs:

apply_startup_sig(*args) -> 'bool'
    apply_startup_sig(ea, startup) -> bool
    
    
    Apply a startup signature file to the specified address.
    
    @param ea: address to apply the signature to; usually \inf{start_ea}
               (C++: ea_t)
    @param startup: the name of the signature file without path and
                    extension (C++: const char *)
    @return: true if successfully applied the signature

Help on function calc_func_size in module ida_funcs:

calc_func_size(*args) -> 'asize_t'
    calc_func_size(pfn) -> asize_t
    
    
    Calculate function size. This function takes into account all
    fragments of the function.
    
    @param pfn: ptr to function structure (C++: func_t  *)

Help on function calc_idasgn_state in module ida_funcs:

calc_idasgn_state(*args) -> 'int'
    calc_idasgn_state(n) -> int
    
    
    Get state of a signature in the list of planned signatures
    
    @param n: number of signature in the list (0.. get_idasgn_qty() -1)
              (C++: int)
    @return: state of signature or  IDASGN_BADARG

Help on function calc_thunk_func_target in module ida_funcs:

calc_thunk_func_target(*args)
    calc_thunk_func_target(pfn) -> ea_t
    
    
    Calculate target of a thunk function.
    
    @param pfn: pointer to function (may not be NULL) (C++: func_t  *)
    @return: the target function or  BADADDR

Help on function del_func in module ida_funcs:

del_func(*args) -> 'bool'
    del_func(ea) -> bool
    
    
    Delete a function.
    
    @param ea: any address in the function entry chunk (C++: ea_t)
    @return: success

Help on function del_idasgn in module ida_funcs:

del_idasgn(*args) -> 'int'
    del_idasgn(n) -> int
    
    
    Remove signature from the list of planned signatures.
    
    @param n: number of signature in the list (0.. get_idasgn_qty() -1)
              (C++: int)
    @return: IDASGN_OK ,  IDASGN_BADARG ,  IDASGN_APPLIED

Help on function f_any in module ida_funcs:

f_any(*args) -> 'bool'
    f_any(arg1, arg2) -> bool
    
    
    Helper function to accept any address.

Help on function find_func_bounds in module ida_funcs:

find_func_bounds(*args) -> 'int'
    find_func_bounds(nfn, flags) -> int
    
    
    Determine the boundaries of a new function. This function tries to
    find the start and end addresses of a new function. It calls the
    module with \ph{func_bounds} in order to fine tune the function
    boundaries.
    
    @param nfn: structure to fill with information \ nfn->start_ea points
                to the start address of the new function. (C++: func_t  *)
    @param flags: Find function bounds flags (C++: int)
    @return: Find function bounds result codes

Help on function func_contains in module ida_funcs:

func_contains(*args) -> 'bool'
    func_contains(pfn, ea) -> bool
    
    
    Does the given function contain the given address?
    
    
    @param pfn (C++: func_t  *)
    @param ea (C++: ea_t)

Help on function func_does_return in module ida_funcs:

func_does_return(*args) -> 'bool'
    func_does_return(callee) -> bool
    
    
    Does the function return?. To calculate the answer, 'FUNC_NORET' flag
    and is_noret() are consulted The latter is required for imported
    functions in the .idata section. Since in .idata we have only function
    pointers but not functions, we have to introduce a special flag for
    them.
    
    @param callee (C++: ea_t)

Help on function func_item_iterator_decode_preceding_insn in module ida_funcs:

func_item_iterator_decode_preceding_insn(*args) -> 'bool'
    func_item_iterator_decode_preceding_insn(fii, visited, p_farref, out) -> bool

Help on function func_item_iterator_decode_prev_insn in module ida_funcs:

func_item_iterator_decode_prev_insn(*args) -> 'bool'
    func_item_iterator_decode_prev_insn(fii, out) -> bool

Help on function func_item_iterator_next in module ida_funcs:

func_item_iterator_next(*args) -> 'bool'
    func_item_iterator_next(fii, testf, ud) -> bool

Help on function func_item_iterator_prev in module ida_funcs:

func_item_iterator_prev(*args) -> 'bool'
    func_item_iterator_prev(fii, testf, ud) -> bool

Help on class func_item_iterator_t in module ida_funcs:

class func_item_iterator_t(builtins.object)
 |  Proxy of C++ func_item_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_item_iterator_t
 |      __init__(self, pfn, _ea=BADADDR) -> func_item_iterator_t
 |  
 |  __next__(self, *args) -> 'bool'
 |      __next__(self, func, ud) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_item_iterator_t(...)
 |      delete_func_item_iterator_t(self)
 |  
 |  chunk(self, *args) -> 'range_t const &'
 |      chunk(self) -> range_t
 |  
 |  current(self, *args) -> 'ea_t'
 |      current(self) -> ea_t
 |  
 |  decode_preceding_insn(self, *args) -> 'bool'
 |      decode_preceding_insn(self, visited, p_farref, out) -> bool
 |  
 |  decode_prev_insn(self, *args) -> 'bool'
 |      decode_prev_insn(self, out) -> bool
 |  
 |  first(self, *args) -> 'bool'
 |      first(self) -> bool
 |  
 |  last(self, *args) -> 'bool'
 |      last(self) -> bool
 |  
 |  next = __next__(self, *args) -> 'bool'
 |  
 |  next_addr(self, *args) -> 'bool'
 |      next_addr(self) -> bool
 |  
 |  next_code(self, *args) -> 'bool'
 |      next_code(self) -> bool
 |  
 |  next_data(self, *args) -> 'bool'
 |      next_data(self) -> bool
 |  
 |  next_head(self, *args) -> 'bool'
 |      next_head(self) -> bool
 |  
 |  next_not_tail(self, *args) -> 'bool'
 |      next_not_tail(self) -> bool
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, func, ud) -> bool
 |  
 |  prev_addr(self, *args) -> 'bool'
 |      prev_addr(self) -> bool
 |  
 |  prev_code(self, *args) -> 'bool'
 |      prev_code(self) -> bool
 |  
 |  prev_data(self, *args) -> 'bool'
 |      prev_data(self) -> bool
 |  
 |  prev_head(self, *args) -> 'bool'
 |      prev_head(self) -> bool
 |  
 |  prev_not_tail(self, *args) -> 'bool'
 |      prev_not_tail(self) -> bool
 |  
 |  set(self, *args) -> 'bool'
 |      set(self, pfn, _ea=BADADDR) -> bool
 |  
 |  set_range(self, *args) -> 'bool'
 |      set_range(self, ea1, ea2) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function func_parent_iterator_set in module ida_funcs:

func_parent_iterator_set(*args) -> 'bool'
    func_parent_iterator_set(fpi, pfn) -> bool

Help on class func_parent_iterator_t in module ida_funcs:

class func_parent_iterator_t(builtins.object)
 |  Proxy of C++ func_parent_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_parent_iterator_t
 |      __init__(self, _fnt) -> func_parent_iterator_t
 |  
 |  __next__(self, *args) -> 'bool'
 |      __next__(self) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_parent_iterator_t(...)
 |      delete_func_parent_iterator_t(self)
 |  
 |  first(self, *args) -> 'bool'
 |      first(self) -> bool
 |  
 |  last(self, *args) -> 'bool'
 |      last(self) -> bool
 |  
 |  next = __next__(self, *args) -> 'bool'
 |  
 |  parent(self, *args) -> 'ea_t'
 |      parent(self) -> ea_t
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self) -> bool
 |  
 |  reset_fnt(self, *args) -> 'void'
 |      reset_fnt(self, _fnt)
 |  
 |  set(self, *args) -> 'bool'
 |      set(self, _fnt) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class func_t in module ida_funcs:

class func_t(ida_range.range_t)
 |  Proxy of C++ func_t class.
 |  
 |  Method resolution order:
 |      func_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __get_points__(self, *args) -> 'dynamic_wrapped_array_t< stkpnt_t >'
 |      __get_points__(self) -> stkpnt_array
 |  
 |  __get_regvars__(self, *args) -> 'dynamic_wrapped_array_t< regvar_t >'
 |      __get_regvars__(self) -> regvar_array
 |  
 |  __get_tails__(self, *args) -> 'dynamic_wrapped_array_t< range_t >'
 |      __get_tails__(self) -> range_array
 |  
 |  __init__(self, *args)
 |      __init__(self, start=0, end=0, f=0) -> func_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_t(...)
 |      delete_func_t(self)
 |  
 |  analyzed_sp(self, *args) -> 'bool'
 |      analyzed_sp(self) -> bool
 |  
 |  does_return(self, *args) -> 'bool'
 |      does_return(self) -> bool
 |  
 |  is_far(self, *args) -> 'bool'
 |      is_far(self) -> bool
 |  
 |  need_prolog_analysis(self, *args) -> 'bool'
 |      need_prolog_analysis(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  argsize
 |      func_t_argsize_get(self) -> asize_t
 |  
 |  color
 |      func_t_color_get(self) -> bgcolor_t
 |  
 |  flags
 |      func_t_flags_get(self) -> uint64
 |  
 |  fpd
 |      func_t_fpd_get(self) -> asize_t
 |  
 |  frame
 |      func_t_frame_get(self) -> uval_t
 |  
 |  frregs
 |      func_t_frregs_get(self) -> ushort
 |  
 |  frsize
 |      func_t_frsize_get(self) -> asize_t
 |  
 |  llabelqty
 |      func_t_llabelqty_get(self) -> int
 |  
 |  llabels
 |      func_t_llabels_get(self) -> llabel_t *
 |  
 |  owner
 |      func_t_owner_get(self) -> ea_t
 |  
 |  pntqty
 |      func_t_pntqty_get(self) -> uint32
 |  
 |  points
 |      __get_points__(self) -> stkpnt_array
 |  
 |  referers
 |      func_t_referers_get(self) -> ea_t *
 |  
 |  refqty
 |      func_t_refqty_get(self) -> int
 |  
 |  regargqty
 |      func_t_regargqty_get(self) -> int
 |  
 |  regargs
 |      func_t_regargs_get(self) -> regarg_t
 |  
 |  regvarqty
 |      func_t_regvarqty_get(self) -> int
 |  
 |  regvars
 |      __get_regvars__(self) -> regvar_array
 |  
 |  tailqty
 |      func_t_tailqty_get(self) -> int
 |  
 |  tails
 |      __get_tails__(self) -> range_array
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      contains(self, r) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on function func_t__from_ptrval__ in module ida_funcs:

func_t__from_ptrval__(*args) -> 'func_t *'
    func_t__from_ptrval__(ptrval) -> func_t

Help on function func_tail_iterator_set in module ida_funcs:

func_tail_iterator_set(*args) -> 'bool'
    func_tail_iterator_set(fti, pfn, ea) -> bool

Help on function func_tail_iterator_set_ea in module ida_funcs:

func_tail_iterator_set_ea(*args) -> 'bool'
    func_tail_iterator_set_ea(fti, ea) -> bool

Help on class func_tail_iterator_t in module ida_funcs:

class func_tail_iterator_t(builtins.object)
 |  Proxy of C++ func_tail_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_tail_iterator_t
 |      __init__(self, _pfn, ea=BADADDR) -> func_tail_iterator_t
 |  
 |  __next__(self, *args) -> 'bool'
 |      __next__(self) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_tail_iterator_t(...)
 |      delete_func_tail_iterator_t(self)
 |  
 |  chunk(self, *args) -> 'range_t const &'
 |      chunk(self) -> range_t
 |  
 |  first(self, *args) -> 'bool'
 |      first(self) -> bool
 |  
 |  last(self, *args) -> 'bool'
 |      last(self) -> bool
 |  
 |  main(self, *args) -> 'bool'
 |      main(self) -> bool
 |  
 |  next = __next__(self, *args) -> 'bool'
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self) -> bool
 |  
 |  set(self, *args) -> 'bool'
 |      set(self, _pfn, ea=BADADDR) -> bool
 |  
 |  set_ea(self, *args) -> 'bool'
 |      set_ea(self, ea) -> bool
 |  
 |  set_range(self, *args) -> 'bool'
 |      set_range(self, ea1, ea2) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function get_current_idasgn in module ida_funcs:

get_current_idasgn(*args) -> 'int'
    get_current_idasgn() -> int
    
    
    Get number of the the current signature.
    
    @return: 0..n-1

Help on function get_fchunk in module ida_funcs:

get_fchunk(*args) -> 'func_t *'
    get_fchunk(ea) -> func_t
    
    
    Get pointer to function chunk structure by address.
    
    @param ea: any address in a function chunk (C++: ea_t)
    @return: ptr to a function chunk or NULL. This function may return a
             function entry as well as a function tail.

Help on function get_fchunk_num in module ida_funcs:

get_fchunk_num(*args) -> 'int'
    get_fchunk_num(ea) -> int
    
    
    Get ordinal number of a function chunk in the global list of function
    chunks.
    
    @param ea: any address in the function chunk (C++: ea_t)
    @return: number of function chunk (0.. get_fchunk_qty() -1). -1 means
             'no function chunk at the specified address'.

Help on function get_fchunk_qty in module ida_funcs:

get_fchunk_qty(*args) -> 'size_t'
    get_fchunk_qty() -> size_t
    
    
    Get total number of function chunks in the program.

Help on function get_fchunk_referer in module ida_funcs:

get_fchunk_referer(*args) -> 'ea_t'
    get_fchunk_referer(ea, idx) -> ea_t

Help on function get_func in module ida_funcs:

get_func(*args) -> 'func_t *'
    get_func(ea) -> func_t
    
    
    Get pointer to function structure by address.
    
    @param ea: any address in a function (C++: ea_t)
    @return: ptr to a function or NULL. This function returns a function
             entry chunk.

Help on function get_func_bitness in module ida_funcs:

get_func_bitness(*args) -> 'int'
    get_func_bitness(pfn) -> int
    
    
    Get function bitness (which is equal to the function segment bitness).
    pfn==NULL => returns 0
    
    @param pfn (C++: const  func_t  *)

Help on function get_func_bits in module ida_funcs:

get_func_bits(*args) -> 'int'
    get_func_bits(pfn) -> int
    
    
    Get number of bits in the function addressing.
    
    
    @param pfn (C++: const  func_t  *)

Help on function get_func_bytes in module ida_funcs:

get_func_bytes(*args) -> 'int'
    get_func_bytes(pfn) -> int
    
    
    Get number of bytes in the function addressing.
    
    
    @param pfn (C++: const  func_t  *)

Help on function get_func_chunknum in module ida_funcs:

get_func_chunknum(*args) -> 'int'
    get_func_chunknum(pfn, ea) -> int
    
    
    Get the containing tail chunk of 'ea'.
    
    @param pfn (C++: func_t  *)
    @param ea (C++: ea_t)

Help on function get_func_cmt in module ida_funcs:

get_func_cmt(*args) -> 'qstring *'
    get_func_cmt(pfn, repeatable) -> str
    
    
    Get function comment.
    
    @param pfn: ptr to function structure (C++: const  func_t  *)
    @param repeatable: get repeatable comment? (C++: bool)
    @return: size of comment or -1 In fact this function works with
             function chunks too.

Help on function get_func_name in module ida_funcs:

get_func_name(*args) -> 'qstring *'
    get_func_name(ea) -> str
    
    
    Get function name.
    
    @param ea: any address in the function (C++: ea_t)
    @return: length of the function name

Help on function get_func_num in module ida_funcs:

get_func_num(*args) -> 'int'
    get_func_num(ea) -> int
    
    
    Get ordinal number of a function.
    
    @param ea: any address in the function (C++: ea_t)
    @return: number of function (0.. get_func_qty() -1). -1 means 'no
             function at the specified address'.

Help on function get_func_qty in module ida_funcs:

get_func_qty(*args) -> 'size_t'
    get_func_qty() -> size_t
    
    
    Get total number of functions in the program.

Help on function get_func_ranges in module ida_funcs:

get_func_ranges(*args) -> 'ea_t'
    get_func_ranges(ranges, pfn) -> ea_t
    
    
    Get function ranges.
    
    @param ranges: buffer to receive the range info (C++: rangeset_t  *)
    @param pfn: ptr to function structure (C++: func_t  *)
    @return: end address of the last function range (BADADDR-error)

Help on function get_idasgn_desc in module ida_funcs:

get_idasgn_desc(*args) -> 'PyObject *'
    get_idasgn_desc(n) -> PyObject *
    
    
    Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries)
    
    See also: get_idasgn_desc_with_matches
    
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @return: None on failure or tuple(signame, optlibs)

Help on function get_idasgn_desc_with_matches in module ida_funcs:

get_idasgn_desc_with_matches(*args) -> 'PyObject *'
    get_idasgn_desc_with_matches(n) -> PyObject *
    
    
    Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries, number of matches)
    
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @return: None on failure or tuple(signame, optlibs, nmatches)

Help on function get_idasgn_qty in module ida_funcs:

get_idasgn_qty(*args) -> 'int'
    get_idasgn_qty() -> int
    
    
    Get number of signatures in the list of planned and applied
    signatures.
    
    @return: 0..n

Help on function get_idasgn_title in module ida_funcs:

get_idasgn_title(*args) -> 'qstring *'
    get_idasgn_title(name) -> str
    
    
    Get full description of the signature by its short name.
    
    @param name: short name of a signature (C++: const char *)
    @return: size of signature description or -1

Help on function get_next_fchunk in module ida_funcs:

get_next_fchunk(*args) -> 'func_t *'
    get_next_fchunk(ea) -> func_t
    
    
    Get pointer to the next function chunk in the global list.
    
    @param ea: any address in the program (C++: ea_t)
    @return: ptr to function chunk or NULL if next function chunk doesn't
             exist

Help on function get_next_func in module ida_funcs:

get_next_func(*args) -> 'func_t *'
    get_next_func(ea) -> func_t
    
    
    Get pointer to the next function.
    
    @param ea: any address in the program (C++: ea_t)
    @return: ptr to function or NULL if next function doesn't exist

Help on function get_next_func_addr in module ida_funcs:

get_next_func_addr(*args) -> 'ea_t'
    get_next_func_addr(pfn, ea) -> ea_t

Help on function get_prev_fchunk in module ida_funcs:

get_prev_fchunk(*args) -> 'func_t *'
    get_prev_fchunk(ea) -> func_t
    
    
    Get pointer to the previous function chunk in the global list.
    
    @param ea: any address in the program (C++: ea_t)
    @return: ptr to function chunk or NULL if previous function chunk
             doesn't exist

Help on function get_prev_func in module ida_funcs:

get_prev_func(*args) -> 'func_t *'
    get_prev_func(ea) -> func_t
    
    
    Get pointer to the previous function.
    
    @param ea: any address in the program (C++: ea_t)
    @return: ptr to function or NULL if previous function doesn't exist

Help on function get_prev_func_addr in module ida_funcs:

get_prev_func_addr(*args) -> 'ea_t'
    get_prev_func_addr(pfn, ea) -> ea_t

Help on function getn_fchunk in module ida_funcs:

getn_fchunk(*args) -> 'func_t *'
    getn_fchunk(n) -> func_t
    
    
    Get pointer to function chunk structure by number.
    
    @param n: number of function chunk, is in range 0.. get_fchunk_qty()
              -1 (C++: int)
    @return: ptr to a function chunk or NULL. This function may return a
             function entry as well as a function tail.

Help on function getn_func in module ida_funcs:

getn_func(*args) -> 'func_t *'
    getn_func(n) -> func_t
    
    
    Get pointer to function structure by number.
    
    @param n: number of function, is in range 0.. get_func_qty() -1 (C++:
              size_t)
    @return: ptr to a function or NULL. This function returns a function
             entry chunk.

Help on function is_finally_visible_func in module ida_funcs:

is_finally_visible_func(*args) -> 'bool'
    is_finally_visible_func(pfn) -> bool
    
    
    Is the function visible (event after considering 'SCF_SHHID_FUNC' )?
    
    
    @param pfn (C++: func_t  *)

Help on function is_func_entry in module ida_funcs:

is_func_entry(*args) -> 'bool'
    is_func_entry(pfn) -> bool
    
    
    Does function describe a function entry chunk?
    
    
    @param pfn (C++: const  func_t  *)

Help on function is_func_locked in module ida_funcs:

is_func_locked(*args) -> 'bool'
    is_func_locked(pfn) -> bool
    
    
    Is the function pointer locked?
    
    
    @param pfn (C++: const  func_t  *)

Help on function is_func_tail in module ida_funcs:

is_func_tail(*args) -> 'bool'
    is_func_tail(pfn) -> bool
    
    
    Does function describe a function tail chunk?
    
    
    @param pfn (C++: const  func_t  *)

Help on function is_same_func in module ida_funcs:

is_same_func(*args) -> 'bool'
    is_same_func(ea1, ea2) -> bool
    
    
    Do two addresses belong to the same function?
    
    
    @param ea1 (C++: ea_t)
    @param ea2 (C++: ea_t)

Help on function is_visible_func in module ida_funcs:

is_visible_func(*args) -> 'bool'
    is_visible_func(pfn) -> bool
    
    
    Is the function visible (not hidden)?
    
    
    @param pfn (C++: func_t  *)

Help on class lock_func in module ida_funcs:

class lock_func(builtins.object)
 |  Proxy of C++ lock_func class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _pfn) -> lock_func
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lock_func(...)
 |      delete_lock_func(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function lock_func_range in module ida_funcs:

lock_func_range(*args) -> 'void'
    lock_func_range(pfn, lock)
    
    
    Lock function pointer Locked pointers are guaranteed to remain valid
    until they are unlocked. Ranges with locked pointers cannot be deleted
    or moved.
    
    @param pfn (C++: const  func_t  *)
    @param lock (C++: bool)

Help on function plan_to_apply_idasgn in module ida_funcs:

plan_to_apply_idasgn(*args) -> 'int'
    plan_to_apply_idasgn(fname) -> int
    
    
    Add a signature file to the list of planned signature files.
    
    @param fname: file name. should not contain directory part. (C++:
                  const char *)
    @return: 0 if failed, otherwise number of planned (and applied)
             signatures

Help on class range_array in module ida_funcs:

class range_array(builtins.object)
 |  Proxy of C++ dynamic_wrapped_array_t< range_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> range_array
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_range_array(...)
 |      delete_range_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      range_array_count_get(self) -> size_t
 |  
 |  data
 |      range_array_data_get(self) -> range_t
 |  
 |  thisown
 |      The membership flag

Help on function read_regargs in module ida_funcs:

read_regargs(*args) -> 'void'
    read_regargs(pfn)

Help on function reanalyze_function in module ida_funcs:

reanalyze_function(*args) -> 'void'
    reanalyze_function(pfn, ea1=0, ea2=BADADDR, analyze_parents=False)
    
    
    Reanalyze a function. This function plans to analyzes all chunks of
    the given function. Optional parameters (ea1, ea2) may be used to
    narrow the analyzed range.
    
    @param pfn: pointer to a function (C++: func_t  *)
    @param ea1: start of the range to analyze (C++: ea_t)
    @param ea2: end of range to analyze (C++: ea_t)
    @param analyze_parents: meaningful only if pfn points to a function
                            tail. if true, all tail parents will be
                            reanalyzed. if false, only the given tail will
                            be reanalyzed. (C++: bool)

Help on function reanalyze_noret_flag in module ida_funcs:

reanalyze_noret_flag(*args) -> 'bool'
    reanalyze_noret_flag(ea) -> bool
    
    
    Plan to reanalyze noret flag. This function does not remove FUNC_NORET
    if it is already present. It just plans to reanalysis.
    
    @param ea (C++: ea_t)

Help on class regarg_t in module ida_funcs:

class regarg_t(builtins.object)
 |  Proxy of C++ regarg_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regarg_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_regarg_t(...)
 |      delete_regarg_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      regarg_t_name_get(self) -> char *
 |  
 |  reg
 |      regarg_t_reg_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      regarg_t_type_get(self) -> type_t *

Help on class regvar_array in module ida_funcs:

class regvar_array(builtins.object)
 |  Proxy of C++ dynamic_wrapped_array_t< regvar_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'regvar_t const &'
 |      __getitem__(self, i) -> regvar_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> regvar_array
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_regvar_array(...)
 |      delete_regvar_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      regvar_array_count_get(self) -> size_t
 |  
 |  data
 |      regvar_array_data_get(self) -> regvar_t *
 |  
 |  thisown
 |      The membership flag

Help on function remove_func_tail in module ida_funcs:

remove_func_tail(*args) -> 'bool'
    remove_func_tail(pfn, tail_ea) -> bool
    
    
    Remove a function tail. If the tail belongs only to one function, it
    will be completely removed. Otherwise if the function was the tail
    owner, the first function using this tail becomes the owner of the
    tail.
    
    @param pfn (C++: func_t  *)
    @param tail_ea (C++: ea_t)

Help on function set_func_cmt in module ida_funcs:

set_func_cmt(*args) -> 'bool'
    set_func_cmt(pfn, cmt, repeatable) -> bool
    
    
    Set function comment. This function works with function chunks too.
    
    @param pfn: ptr to function structure (C++: const  func_t  *)
    @param cmt: comment string, may be multiline (with '  '). Use empty
                str ("") to delete comment (C++: const char *)
    @param repeatable: set repeatable comment? (C++: bool)

Help on function set_func_end in module ida_funcs:

set_func_end(*args) -> 'bool'
    set_func_end(ea, newend) -> bool
    
    
    Move function chunk end address.
    
    @param ea: any address in the function (C++: ea_t)
    @param newend: new end address of the function (C++: ea_t)
    @return: success

Help on function set_func_name_if_jumpfunc in module ida_funcs:

set_func_name_if_jumpfunc(*args) -> 'int'
    set_func_name_if_jumpfunc(pfn, oldname) -> int
    
    
    Give a meaningful name to function if it consists of only 'jump'
    instruction.
    
    @param pfn: pointer to function (may be NULL) (C++: func_t  *)
    @param oldname: old name of function. if old name was in "j_..." form,
                    then we may discard it and set a new name. if oldname
                    is not known, you may pass NULL. (C++: const char *)
    @return: success

Help on function set_func_start in module ida_funcs:

set_func_start(*args) -> 'int'
    set_func_start(ea, newstart) -> int
    
    
    Move function chunk start address.
    
    @param ea: any address in the function (C++: ea_t)
    @param newstart: new end address of the function (C++: ea_t)
    @return: Function move result codes

Help on function set_noret_insn in module ida_funcs:

set_noret_insn(*args) -> 'bool'
    set_noret_insn(insn_ea, noret) -> bool
    
    
    Signal a non-returning instruction. This function can be used by the
    processor module to tell the kernel about non-returning instructions
    (like call exit). The kernel will perform the global function analysis
    and find out if the function returns at all. This analysis will be
    done at the first call to 'func_does_return()'
    
    @param insn_ea (C++: ea_t)
    @param noret (C++: bool)
    @return: true if the instruction 'noret' flag has been changed

Help on function set_tail_owner in module ida_funcs:

set_tail_owner(*args) -> 'bool'
    set_tail_owner(fnt, func_start) -> bool
    
    
    Set a function as the possessing function of a function tail. The
    function should already refer to the tail (after append_func_tail).
    
    @param fnt (C++: func_t  *)
    @param func_start (C++: ea_t)

Help on function set_visible_func in module ida_funcs:

set_visible_func(*args) -> 'void'
    set_visible_func(pfn, visible)
    
    
    Set visibility of function.
    
    
    @param pfn (C++: func_t  *)
    @param visible (C++: bool)

Help on class stkpnt_array in module ida_funcs:

class stkpnt_array(builtins.object)
 |  Proxy of C++ dynamic_wrapped_array_t< stkpnt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'stkpnt_t const &'
 |      __getitem__(self, i) -> stkpnt_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> stkpnt_array
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_stkpnt_array(...)
 |      delete_stkpnt_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      stkpnt_array_count_get(self) -> size_t
 |  
 |  data
 |      stkpnt_array_data_get(self) -> stkpnt_t *
 |  
 |  thisown
 |      The membership flag

Help on function try_to_add_libfunc in module ida_funcs:

try_to_add_libfunc(*args) -> 'int'
    try_to_add_libfunc(ea) -> int
    
    
    Apply the currently loaded signature file to the specified address. If
    a library function is found, then create a function and name it
    accordingly.
    
    @param ea: any address in the program (C++: ea_t)
    @return: Library function codes

Help on function update_func in module ida_funcs:

update_func(*args) -> 'bool'
    update_func(pfn) -> bool
    
    
    Update information about a function in the database ( 'func_t' ). You
    must not change the function start and end addresses using this
    function. Use 'set_func_start()' and 'set_func_end()' for it.
    
    @param pfn: ptr to function structure (C++: func_t  *)
    @return: success

=== ida_funcs EPYDOC INJECTIONS ===
ida_funcs.FIND_FUNC_DEFINE
"""
create instruction if undefined byte is encountered
"""

ida_funcs.FIND_FUNC_EXIST
"""
its bounds are returned in 'nfn'.

function exists already.
"""

ida_funcs.FIND_FUNC_IGNOREFN
"""
ignore existing function boundaries. by default the function returns
function boundaries if ea belongs to a function.
"""

ida_funcs.FIND_FUNC_KEEPBD
"""
just create instructions inside the boundaries.

do not modify incoming function boundaries,
"""

ida_funcs.FIND_FUNC_NORMAL
"""
stop processing if undefined byte is encountered
"""

ida_funcs.FIND_FUNC_OK
"""
ok, 'nfn' is ready for 'add_func()'
"""

ida_funcs.FIND_FUNC_UNDEF
"""
nfn->end_ea will have the address of the unexplored byte.

function has instructions that pass execution flow to unexplored
bytes.
"""

ida_funcs.FUNC_BOTTOMBP
"""
BP points to the bottom of the stack frame.
"""

ida_funcs.FUNC_FAR
"""
Far function.
"""

ida_funcs.FUNC_FRAME
"""
Function uses frame pointer (BP)
"""

ida_funcs.FUNC_FUZZY_SP
"""
for example: and esp, 0FFFFFFF0h

Function changes SP in untraceable way,
"""

ida_funcs.FUNC_HIDDEN
"""
A hidden function chunk.
"""

ida_funcs.FUNC_LIB
"""
Library function.
"""

ida_funcs.FUNC_LUMINA
"""
Function info is provided by Lumina.
"""

ida_funcs.FUNC_NORET
"""
Function doesn't return.
"""

ida_funcs.FUNC_NORET_PENDING
"""
This flag is verified upon 'func_does_return()'

Function 'non-return' analysis must be performed.
"""

ida_funcs.FUNC_PROLOG_OK
"""
by last SP-analysis

Prolog analysis has be performed
"""

ida_funcs.FUNC_PURGED_OK
"""
'argsize' field has been validated. If this bit is clear and 'argsize'
is 0, then we do not known the real number of bytes removed from the
stack. This bit is handled by the processor module.
"""

ida_funcs.FUNC_SP_READY
"""
SP-analysis has been performed. If this flag is on, the stack change
points should not be not modified anymore. Currently this analysis is
performed only for PC
"""

ida_funcs.FUNC_STATICDEF
"""
Static function.
"""

ida_funcs.FUNC_TAIL
"""
This is a function tail. Other bits must be clear (except
'FUNC_HIDDEN' ).
"""

ida_funcs.FUNC_THUNK
"""
Thunk (jump) function.
"""

ida_funcs.FUNC_USERFAR
"""
of the function

User has specified far-ness
"""

ida_funcs.IDASGN_APPLIED
"""
signature is already applied
"""

ida_funcs.IDASGN_BADARG
"""
bad number of signature
"""

ida_funcs.IDASGN_CURRENT
"""
signature is currently being applied
"""

ida_funcs.IDASGN_OK
"""
ok
"""

ida_funcs.IDASGN_PLANNED
"""
signature is planned to be applied
"""

ida_funcs.LIBFUNC_DELAY
"""
no decision because of lack of information
"""

ida_funcs.LIBFUNC_FOUND
"""
ok, library function is found
"""

ida_funcs.LIBFUNC_NONE
"""
no, this is not a library function
"""

ida_funcs.MOVE_FUNC_BADSTART
"""
bad new start address
"""

ida_funcs.MOVE_FUNC_NOCODE
"""
no instruction at 'newstart'
"""

ida_funcs.MOVE_FUNC_NOFUNC
"""
no function at 'ea'
"""

ida_funcs.MOVE_FUNC_OK
"""
ok
"""

ida_funcs.MOVE_FUNC_REFUSED
"""
a plugin refused the action
"""
=== ida_funcs EPYDOC INJECTIONS END ===
Help on class BasicBlock in module ida_gdl:

class BasicBlock(builtins.object)
 |  Basic block class. It is returned by the Flowchart class
 |  
 |  Methods defined here:
 |  
 |  __init__(self, id, bb, fc)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  preds(self)
 |      Iterates the predecessors list
 |  
 |  succs(self)
 |      Iterates the successors list
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  startEA

Help on class FlowChart in module ida_gdl:

class FlowChart(builtins.object)
 |  Flowchart class used to determine basic blocks.
 |  Check ex_gdl_qflow_chart.py for sample usage.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, index)
 |      Returns a basic block
 |      
 |      @return: BasicBlock
 |  
 |  __init__(self, f=None, bounds=None, flags=0)
 |      Constructor
 |      @param f: A func_t type, use get_func(ea) to get a reference
 |      @param bounds: A tuple of the form (start, end). Used if "f" is None
 |      @param flags: one of the FC_xxxx flags. One interesting flag is FC_PREDS
 |  
 |  __iter__(self)
 |  
 |  _getitem(self, index)
 |  
 |  refresh(self)
 |      Refreshes the flow chart
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  size

Help on function display_gdl in module ida_gdl:

display_gdl(*args) -> 'int'
    display_gdl(fname) -> int
    
    
    Display GDL file by calling wingraph32. The exact name of the grapher
    is taken from the configuration file and set up by
    'setup_graph_subsystem()' .
    
    @param fname (C++: const char *)
    @return: error code from os, 0 if ok

Help on function gen_complex_call_chart in module ida_gdl:

gen_complex_call_chart(*args) -> 'bool'
    gen_complex_call_chart(filename, wait, title, ea1, ea2, flags, recursion_depth=-1) -> bool
    
    
    Build and display a complex xref graph.
    
    @param filename: output file name. the file extension is not used.
                     maybe NULL. (C++: const char *)
    @param wait: message to display during graph building (C++: const char
                 *)
    @param title: graph title (C++: const char *)
    @param ea1: address range (C++: ea_t)
    @param ea2: address range (C++: ea_t)
    @param flags: combination of  Call chart building flags  and  Flow
                  graph building flags . if none of  CHART_GEN_DOT ,
                  CHART_GEN_GDL ,  CHART_WINGRAPH  is specified, the
                  function will return false. (C++: int)
    @param recursion_depth: optional limit of recursion (C++: int32)
    @return: success. if fails, a warning message is displayed on the
             screen

Help on function gen_flow_graph in module ida_gdl:

gen_flow_graph(*args) -> 'bool'
    gen_flow_graph(filename, title, pfn, ea1, ea2, gflags) -> bool
    
    
    Build and display a flow graph.
    
    @param filename: output file name. the file extension is not used.
                     maybe NULL. (C++: const char *)
    @param title: graph title (C++: const char *)
    @param pfn: function to graph (C++: func_t  *)
    @param ea1: if pfn == NULL, then the address range (C++: ea_t)
    @param ea2: if pfn == NULL, then the address range (C++: ea_t)
    @param gflags: combination of  Flow graph building flags . if none of
                   CHART_GEN_DOT ,  CHART_GEN_GDL ,  CHART_WINGRAPH  is
                   specified, the function will return false (C++: int)
    @return: success. if fails, a warning message is displayed on the
             screen

Help on function gen_gdl in module ida_gdl:

gen_gdl(*args) -> 'void'
    gen_gdl(g, fname)
    
    
    Create GDL file for graph.
    
    
    @param g (C++: const  gdl_graph_t  *)
    @param fname (C++: const char *)

Help on function gen_simple_call_chart in module ida_gdl:

gen_simple_call_chart(*args) -> 'bool'
    gen_simple_call_chart(filename, wait, title, gflags) -> bool
    
    
    Build and display a simple function call graph.
    
    @param filename: output file name. the file extension is not used.
                     maybe NULL. (C++: const char *)
    @param wait: message to display during graph building (C++: const char
                 *)
    @param title: graph title (C++: const char *)
    @param gflags: combination of  CHART_NOLIBFUNCS  and  Flow graph
                   building flags . if none of  CHART_GEN_DOT ,
                   CHART_GEN_GDL ,  CHART_WINGRAPH  is specified, the
                   function will return false. (C++: int)
    @return: success. if fails, a warning message is displayed on the
             screen

Help on function is_noret_block in module ida_gdl:

is_noret_block(*args) -> 'bool'
    is_noret_block(btype) -> bool
    
    
    Does this block never return?
    
    
    @param btype (C++: fc_block_type_t)

Help on function is_ret_block in module ida_gdl:

is_ret_block(*args) -> 'bool'
    is_ret_block(btype) -> bool
    
    
    Does this block return?
    
    
    @param btype (C++: fc_block_type_t)

Help on class node_iterator in module ida_gdl:

class node_iterator(builtins.object)
 |  Proxy of C++ node_iterator class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, n) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, _g, n) -> node_iterator
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, n) -> bool
 |  
 |  __ref__(self, *args) -> 'int'
 |      __ref__(self) -> int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_node_iterator(...)
 |      delete_node_iterator(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class qbasic_block_t in module ida_gdl:

class qbasic_block_t(ida_range.range_t)
 |  Proxy of C++ qbasic_block_t class.
 |  
 |  Method resolution order:
 |      qbasic_block_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qbasic_block_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qbasic_block_t(...)
 |      delete_qbasic_block_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      contains(self, r) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on class qflow_chart_t in module ida_gdl:

class qflow_chart_t(builtins.object)
 |  Proxy of C++ qflow_chart_t class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'qbasic_block_t *'
 |      __getitem__(self, n) -> qbasic_block_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qflow_chart_t
 |      __init__(self, _title, _pfn, _ea1, _ea2, _flags) -> qflow_chart_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qflow_chart_t(...)
 |      delete_qflow_chart_t(self)
 |  
 |  append_to_flowchart(self, *args) -> 'void'
 |      append_to_flowchart(self, ea1, ea2)
 |  
 |  calc_block_type(self, *args) -> 'fc_block_type_t'
 |      calc_block_type(self, blknum) -> fc_block_type_t
 |  
 |  create(self, *args) -> 'void'
 |      create(self, _title, _pfn, _ea1, _ea2, _flags)
 |      create(self, _title, ranges, _flags)
 |  
 |  get_node_label(self, *args) -> 'char *'
 |      get_node_label(self, arg2, arg3, arg4) -> char *
 |  
 |  is_noret_block(self, *args) -> 'bool'
 |      is_noret_block(self, blknum) -> bool
 |  
 |  is_ret_block(self, *args) -> 'bool'
 |      is_ret_block(self, blknum) -> bool
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self, node) -> int
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self, node) -> int
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, node, i) -> int
 |  
 |  print_names(self, *args) -> 'bool'
 |      print_names(self) -> bool
 |  
 |  print_node_attributes(self, *args) -> 'void'
 |      print_node_attributes(self, arg2, arg3)
 |  
 |  refresh(self, *args) -> 'void'
 |      refresh(self)
 |  
 |  size(self, *args) -> 'int'
 |      size(self) -> int
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, node, i) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bounds
 |      qflow_chart_t_bounds_get(self) -> range_t
 |  
 |  flags
 |      qflow_chart_t_flags_get(self) -> int
 |  
 |  nproper
 |      qflow_chart_t_nproper_get(self) -> int
 |  
 |  pfn
 |      qflow_chart_t_pfn_get(self) -> func_t *
 |  
 |  thisown
 |      The membership flag
 |  
 |  title
 |      qflow_chart_t_title_get(self) -> qstring *

=== ida_gdl EPYDOC INJECTIONS ===
ida_gdl.CHART_FOLLOW_DIRECTION
"""
analyze references to added blocks only in the direction of the
reference who discovered the current block
"""

ida_gdl.CHART_GEN_DOT
"""
generate .dot file (file extension is forced to .dot)
"""

ida_gdl.CHART_GEN_GDL
"""
generate .gdl file (file extension is forced to .gdl)
"""

ida_gdl.CHART_IGNORE_LIB_FROM
"""
ignore references from library functions
"""

ida_gdl.CHART_IGNORE_LIB_TO
"""
ignore references to library functions
"""

ida_gdl.CHART_NOLIBFUNCS
"""
don't include library functions in the graph
"""

ida_gdl.CHART_PRINT_DOTS
"""
print dots if xrefs exist outside of the range recursion depth
"""

ida_gdl.CHART_PRINT_NAMES
"""
print labels for each block?
"""

ida_gdl.CHART_RECURSIVE
"""
analyze added blocks
"""

ida_gdl.CHART_REFERENCED
"""
references from the addresses in the list
"""

ida_gdl.CHART_REFERENCING
"""
references to the addresses in the list
"""

ida_gdl.CHART_WINGRAPH
"""
call grapher to display the graph
"""

ida_gdl.FC_APPND
"""
multirange flowchart (set by append_to_flowchart)
"""

ida_gdl.FC_CHKBREAK
"""
build_qflow_chart() may be aborted by user
"""

ida_gdl.FC_NOEXT
"""
do not compute external blocks. Use this to prevent jumps leaving the
function from appearing in the flow chart. Unless specified, the
targets of those outgoing jumps will be present in the flow chart
under the form of one-instruction blocks
"""

ida_gdl.FC_PREDS
"""
compute predecessor lists
"""

ida_gdl.FC_PRINT
"""
print names (used only by display_flow_chart())
"""
=== ida_gdl EPYDOC INJECTIONS END ===
Help on class GraphViewer in module ida_graph:

class GraphViewer(ida_kernwin.CustomIDAMemo)
 |  Proxy of C++ View_Hooks class.
 |  
 |  Method resolution order:
 |      GraphViewer
 |      ida_kernwin.CustomIDAMemo
 |      ida_kernwin.View_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  AddCommand(self, title, shortcut)
 |  
 |  AddEdge(self, src_node, dest_node)
 |      Creates an edge between two given node ids
 |  
 |  AddNode(self, obj)
 |      Creates a node associated with the given object and returns the node id
 |  
 |  Clear(self)
 |      Clears all the nodes and edges
 |  
 |  Close(self)
 |      Closes the graph.
 |      It is possible to call Show() again (which will recreate the graph)
 |  
 |  Count(self)
 |      Returns the node count
 |  
 |  OnCommand(self, cmd_id)
 |  
 |  OnPopup(self, widget, popup_handle)
 |  
 |  OnRefresh(self)
 |      Event called when the graph is refreshed or first created.
 |      From this event you are supposed to create nodes and edges.
 |      This callback is mandatory.
 |      
 |      @note: ***It is important to clear previous nodes before adding nodes.***
 |      @return: Returning True tells the graph viewer to use the items. Otherwise old items will be used.
 |  
 |  Select(self, node_id)
 |      Selects a node on the graph
 |  
 |  Show(self)
 |      Shows an existing graph or creates a new one
 |      
 |      @return: Boolean
 |  
 |  __getitem__(self, idx)
 |      Returns a reference to the object associated with this node id
 |  
 |  __init__(self, title, close_open=False)
 |      Constructs the GraphView object.
 |      Please do not remove or rename the private fields
 |      
 |      @param title: The title of the graph window
 |      @param close_open: Should it attempt to close an existing graph (with same title) before creating this graph?
 |  
 |  __iter__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  UI_Hooks_Trampoline = <class 'ida_graph.GraphViewer.UI_Hooks_Trampolin...
 |      Proxy of C++ UI_Hooks class.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_kernwin.CustomIDAMemo:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |      view_activated(self, view)
 |  
 |  view_click(self, view, ve)
 |      view_click(self, view, event)
 |  
 |  view_close(self, view, *args)
 |      view_close(self, view)
 |  
 |  view_curpos(self, view, *args)
 |      view_curpos(self, view)
 |  
 |  view_dblclick(self, view, ve)
 |      view_dblclick(self, view, event)
 |  
 |  view_deactivated(self, view)
 |      view_deactivated(self, view)
 |  
 |  view_keydown(self, view, key, state)
 |      view_keydown(self, view, key, state)
 |  
 |  view_loc_changed(self, view, now, was)
 |      view_loc_changed(self, view, now, was)
 |  
 |  view_mouse_moved(self, view, ve)
 |      view_mouse_moved(self, view, event)
 |  
 |  view_mouse_over(self, view, ve)
 |      view_mouse_over(self, view, event)
 |  
 |  view_switched(self, view, rt)
 |      view_switched(self, view, rt)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from ida_kernwin.CustomIDAMemo:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_kernwin.View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_View_Hooks(...)
 |      delete_View_Hooks(self)
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args) -> 'void'
 |      view_created(self, view)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_kernwin.View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class TPointDouble in module ida_graph:

class TPointDouble(builtins.object)
 |  Proxy of C++ TPointDouble class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> TPointDouble
 |      __init__(self, a, b) -> TPointDouble
 |      __init__(self, r) -> TPointDouble
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_TPointDouble(...)
 |      delete_TPointDouble(self)
 |  
 |  add(self, *args) -> 'void'
 |      add(self, r)
 |  
 |  negate(self, *args) -> 'void'
 |      negate(self)
 |  
 |  sub(self, *args) -> 'void'
 |      sub(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      TPointDouble_x_get(self) -> double
 |  
 |  y
 |      TPointDouble_y_get(self) -> double
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function calc_dist in module ida_graph:

calc_dist(*args) -> 'double'
    calc_dist(p, q) -> double
    
    
    Calculate distance between p and q.
    
    
    @param p (C++: point_t)
    @param q (C++: point_t)

Help on function clr_node_info in module ida_graph:

clr_node_info(*args) -> 'void'
    clr_node_info(gid, node, flags)
    
    
    Clear node info for the given node.
    
    @param gid: id of desired graph (C++: graph_id_t)
    @param node: node number (C++: int)
    @param flags: combination of  Node info flags , identifying which
                  fields of  node_info_t  will be cleared (C++: uint32)

Help on function create_disasm_graph in module ida_graph:

create_disasm_graph(*args) -> 'mutable_graph_t *'
    create_disasm_graph(ea) -> mutable_graph_t
    create_disasm_graph(ranges) -> mutable_graph_t
    
    
    Create a graph for the function that contains 'ea'.
    
    
    @param ea (C++: ea_t)

Help on function create_graph_viewer in module ida_graph:

create_graph_viewer(*args) -> 'graph_viewer_t *'
    create_graph_viewer(title, id, callback, ud, title_height, parent=None) -> graph_viewer_t *
    
    
    Create a custom graph viewer.
    
    @param title: the widget title (C++: const char *)
    @param id: graph id (C++: uval_t)
    @param callback: callback to handle graph notifications (
                     graph_notification_t ) (C++: hook_cb_t  *)
    @param ud: user data passed to callback (C++: void *)
    @param title_height: node title height (C++: int)
    @param parent (C++: TWidget *)
    @return: new viewer

Help on function create_mutable_graph in module ida_graph:

create_mutable_graph(*args) -> 'mutable_graph_t *'
    create_mutable_graph(id) -> mutable_graph_t
    
    
    Create a new empty graph with given id.
    
    
    @param id (C++: uval_t)

Help on function create_user_graph_place in module ida_graph:

create_user_graph_place(*args) -> 'user_graph_place_t *'
    create_user_graph_place(node, lnnum) -> user_graph_place_t
    
    
    Get a copy of a 'user_graph_place_t' (returns a pointer to static
    storage)
    
    
    @param node (C++: int)
    @param lnnum (C++: int)

Help on function del_node_info in module ida_graph:

del_node_info(*args) -> 'void'
    del_node_info(gid, node)
    
    
    Delete the 'node_info_t' for the given node.
    
    
    @param gid (C++: graph_id_t)
    @param node (C++: int)

Help on function delete_mutable_graph in module ida_graph:

delete_mutable_graph(*args) -> 'void'
    delete_mutable_graph(g)
    
    
    Delete graph object.use this only if you are dealing with
    'mutable_graph_t' instances that have not been used together with a
    'graph_viewer_t' . If you have called 'set_viewer_graph()' with your
    graph, the graph's lifecycle will be managed by the viewer, and you
    shouldn't interfere with it
    
    @param g (C++: mutable_graph_t  *)

Help on class edge_info_t in module ida_graph:

class edge_info_t(builtins.object)
 |  Proxy of C++ edge_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_edge_info_t(...)
 |      delete_edge_info_t(self)
 |  
 |  reverse_layout(self, *args) -> 'void'
 |      reverse_layout(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  color
 |      edge_info_t_color_get(self) -> bgcolor_t
 |  
 |  dstoff
 |      edge_info_t_dstoff_get(self) -> int
 |  
 |  layout
 |      edge_info_t_layout_get(self) -> pointseq_t
 |  
 |  srcoff
 |      edge_info_t_srcoff_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  width
 |      edge_info_t_width_get(self) -> int

Help on class edge_infos_wrapper_t in module ida_graph:

class edge_infos_wrapper_t(builtins.object)
 |  Proxy of C++ edge_infos_wrapper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ptr
 |      edge_infos_wrapper_t_ptr_get(self) -> edge_infos_t *
 |  
 |  thisown
 |      The membership flag

Help on class edge_layout_point_t in module ida_graph:

class edge_layout_point_t(builtins.object)
 |  Proxy of C++ edge_layout_point_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_layout_point_t
 |      __init__(self, r) -> edge_layout_point_t
 |      __init__(self, _e, _pidx) -> edge_layout_point_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_edge_layout_point_t(...)
 |      delete_edge_layout_point_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  e
 |      edge_layout_point_t_e_get(self) -> edge_t
 |  
 |  pidx
 |      edge_layout_point_t_pidx_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class edge_segment_t in module ida_graph:

class edge_segment_t(builtins.object)
 |  Proxy of C++ edge_segment_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_segment_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_edge_segment_t(...)
 |      delete_edge_segment_t(self)
 |  
 |  length(self, *args) -> 'size_t'
 |      length(self) -> size_t
 |  
 |  toright(self, *args) -> 'bool'
 |      toright(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  e
 |      edge_segment_t_e_get(self) -> edge_t
 |  
 |  nseg
 |      edge_segment_t_nseg_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  x0
 |      edge_segment_t_x0_get(self) -> int
 |  
 |  x1
 |      edge_segment_t_x1_get(self) -> int

Help on class edge_t in module ida_graph:

class edge_t(builtins.object)
 |  Proxy of C++ edge_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, y) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_t
 |      __init__(self, x, y) -> edge_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, y) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, y) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_edge_t(...)
 |      delete_edge_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dst
 |      edge_t_dst_get(self) -> int
 |  
 |  src
 |      edge_t_src_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function get_graph_viewer in module ida_graph:

get_graph_viewer(*args) -> 'graph_viewer_t *'
    get_graph_viewer(parent) -> graph_viewer_t *
    
    
    Get custom graph viewer for given form.
    
    
    @param parent (C++: TWidget *)

Help on function get_node_info in module ida_graph:

get_node_info(*args) -> 'bool'
    get_node_info(out, gid, node) -> bool
    
    
    Get node info.
    
    @param out: result (C++: node_info_t  *)
    @param gid: id of desired graph (C++: graph_id_t)
    @param node: node number (C++: int)
    @return: success

Help on function get_viewer_graph in module ida_graph:

get_viewer_graph(*args) -> 'mutable_graph_t *'
    get_viewer_graph(gv) -> mutable_graph_t
    
    
    Get graph object for given custom graph viewer.
    
    
    @param gv (C++: graph_viewer_t  *)

Help on class graph_item_t in module ida_graph:

class graph_item_t(builtins.object)
 |  Proxy of C++ graph_item_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_item_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_item_t(...)
 |      delete_graph_item_t(self)
 |  
 |  is_edge(self, *args) -> 'bool'
 |      is_edge(self) -> bool
 |  
 |  is_node(self, *args) -> 'bool'
 |      is_node(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  b
 |      graph_item_t_b_get(self) -> int
 |  
 |  e
 |      graph_item_t_e_get(self) -> edge_t
 |  
 |  elp
 |      graph_item_t_elp_get(self) -> edge_layout_point_t
 |  
 |  n
 |      graph_item_t_n_get(self) -> int
 |  
 |  p
 |      graph_item_t_p_get(self) -> point_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      graph_item_t_type_get(self) -> graph_item_type_t

Help on class graph_node_visitor_t in module ida_graph:

class graph_node_visitor_t(builtins.object)
 |  Proxy of C++ graph_node_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_node_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_node_visitor_t(...)
 |      delete_graph_node_visitor_t(self)
 |  
 |  is_forbidden_edge(self, *args) -> 'bool'
 |      is_forbidden_edge(self, arg0, arg1) -> bool
 |  
 |  is_visited(self, *args) -> 'bool'
 |      is_visited(self, n) -> bool
 |  
 |  reinit(self, *args) -> 'void'
 |      reinit(self)
 |  
 |  set_visited(self, *args) -> 'void'
 |      set_visited(self, n)
 |  
 |  visit_node(self, *args) -> 'int'
 |      visit_node(self, arg0) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class graph_path_visitor_t in module ida_graph:

class graph_path_visitor_t(builtins.object)
 |  Proxy of C++ graph_path_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_path_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_path_visitor_t(...)
 |      delete_graph_path_visitor_t(self)
 |  
 |  walk_backward(self, *args) -> 'int'
 |      walk_backward(self, arg0) -> int
 |  
 |  walk_forward(self, *args) -> 'int'
 |      walk_forward(self, arg0) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  path
 |      graph_path_visitor_t_path_get(self) -> intvec_t *
 |  
 |  prune
 |      graph_path_visitor_t_prune_get(self) -> bool
 |  
 |  thisown
 |      The membership flag

Help on class graph_visitor_t in module ida_graph:

class graph_visitor_t(builtins.object)
 |  Proxy of C++ graph_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_visitor_t(...)
 |      delete_graph_visitor_t(self)
 |  
 |  visit_edge(self, *args) -> 'int'
 |      visit_edge(self, arg2, arg3) -> int
 |  
 |  visit_node(self, *args) -> 'int'
 |      visit_node(self, arg2, arg3) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class group_crinfo_t in module ida_graph:

class group_crinfo_t(builtins.object)
 |  Proxy of C++ group_crinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> group_crinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_group_crinfo_t(...)
 |      delete_group_crinfo_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  nodes
 |      group_crinfo_t_nodes_get(self) -> intvec_t *
 |  
 |  text
 |      group_crinfo_t_text_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on class interval_t in module ida_graph:

class interval_t(builtins.object)
 |  Proxy of C++ interval_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> interval_t
 |      __init__(self, y0, y1) -> interval_t
 |      __init__(self, s) -> interval_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_interval_t(...)
 |      delete_interval_t(self)
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, x) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  length(self, *args) -> 'int'
 |      length(self) -> int
 |  
 |  make_union(self, *args) -> 'void'
 |      make_union(self, r)
 |  
 |  move_by(self, *args) -> 'void'
 |      move_by(self, shift)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x0
 |      interval_t_x0_get(self) -> int
 |  
 |  x1
 |      interval_t_x1_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class mutable_graph_t in module ida_graph:

class mutable_graph_t(builtins.object)
 |  Proxy of C++ mutable_graph_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mutable_graph_t(...)
 |      delete_mutable_graph_t(self)
 |  
 |  calc_group_ea(self, *args) -> 'ea_t'
 |      calc_group_ea(self, arg0) -> ea_t
 |  
 |  change_group_visibility(self, *args) -> 'bool'
 |      change_group_visibility(self, group, expand) -> bool
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  create_digraph_layout(self, *args) -> 'bool'
 |      create_digraph_layout(self) -> bool
 |  
 |  create_group(self, *args) -> 'int'
 |      create_group(self, nodes) -> int
 |  
 |  del_custom_layout(self, *args) -> 'void'
 |      del_custom_layout(self)
 |  
 |  delete_group(self, *args) -> 'bool'
 |      delete_group(self, group) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  exists(self, *args) -> 'bool'
 |      exists(self, node) -> bool
 |  
 |  get_custom_layout(self, *args) -> 'bool'
 |      get_custom_layout(self) -> bool
 |  
 |  get_edge(self, *args) -> 'edge_info_t'
 |      get_edge(self, e) -> edge_info_t
 |  
 |  get_first_subgraph_node(self, *args) -> 'int'
 |      get_first_subgraph_node(self, group) -> int
 |  
 |  get_graph_groups(self, *args) -> 'bool'
 |      get_graph_groups(self) -> bool
 |  
 |  get_next_subgraph_node(self, *args) -> 'int'
 |      get_next_subgraph_node(self, group, current) -> int
 |  
 |  get_node_group(self, *args) -> 'int'
 |      get_node_group(self, node) -> int
 |  
 |  get_node_representative(self, *args) -> 'int'
 |      get_node_representative(self, node) -> int
 |  
 |  is_collapsed_node(self, *args) -> 'bool'
 |      is_collapsed_node(self, node) -> bool
 |  
 |  is_deleted_node(self, *args) -> 'bool'
 |      is_deleted_node(self, node) -> bool
 |  
 |  is_displayable_node(self, *args) -> 'bool'
 |      is_displayable_node(self, node) -> bool
 |  
 |  is_dot_node(self, *args) -> 'bool'
 |      is_dot_node(self, node) -> bool
 |  
 |  is_group_node(self, *args) -> 'bool'
 |      is_group_node(self, node) -> bool
 |  
 |  is_simple_node(self, *args) -> 'bool'
 |      is_simple_node(self, node) -> bool
 |  
 |  is_subgraph_node(self, *args) -> 'bool'
 |      is_subgraph_node(self, node) -> bool
 |  
 |  is_uncollapsed_node(self, *args) -> 'bool'
 |      is_uncollapsed_node(self, node) -> bool
 |  
 |  is_user_graph(self, *args) -> 'bool'
 |      is_user_graph(self) -> bool
 |  
 |  is_visible_node(self, *args) -> 'bool'
 |      is_visible_node(self, node) -> bool
 |  
 |  node_qty(self, *args) -> 'int'
 |      node_qty(self) -> int
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self, b) -> int
 |  
 |  nrect(self, *args) -> 'rect_t &'
 |      nrect(self, n) -> rect_t
 |      nrect(self, n) -> rect_t
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self, b) -> int
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, b, i) -> int
 |  
 |  predset(self, *args) -> 'intvec_t const &'
 |      predset(self, b) -> intvec_t const &
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |  
 |  set_custom_layout(self, *args) -> 'void'
 |      set_custom_layout(self)
 |  
 |  set_deleted_node(self, *args) -> 'void'
 |      set_deleted_node(self, node)
 |  
 |  set_edge(self, *args) -> 'bool'
 |      set_edge(self, e, ei) -> bool
 |  
 |  set_graph_groups(self, *args) -> 'void'
 |      set_graph_groups(self)
 |  
 |  set_node_group(self, *args) -> 'void'
 |      set_node_group(self, node, group)
 |  
 |  size(self, *args) -> 'int'
 |      size(self) -> int
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, b, i) -> int
 |  
 |  succset(self, *args) -> 'intvec_t const &'
 |      succset(self, b) -> intvec_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  belongs
 |      mutable_graph_t_belongs_get(self) -> intvec_t *
 |  
 |  edges
 |      mutable_graph_t_edges_get(self) -> edge_infos_wrapper_t
 |  
 |  gid
 |      mutable_graph_t_gid_get(self) -> uval_t
 |  
 |  node_flags
 |      mutable_graph_t_node_flags_get(self) -> bytevec_t *
 |  
 |  nodes
 |      mutable_graph_t_nodes_get(self) -> node_layout_t
 |  
 |  org_preds
 |      mutable_graph_t_org_preds_get(self) -> array_of_intvec_t
 |  
 |  org_succs
 |      mutable_graph_t_org_succs_get(self) -> array_of_intvec_t
 |  
 |  preds
 |      mutable_graph_t_preds_get(self) -> array_of_intvec_t
 |  
 |  succs
 |      mutable_graph_t_succs_get(self) -> array_of_intvec_t
 |  
 |  thisown
 |      The membership flag

Help on class node_info_t in module ida_graph:

class node_info_t(builtins.object)
 |  Proxy of C++ node_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> node_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_node_info_t(...)
 |      delete_node_info_t(self)
 |  
 |  get_flags_for_valid(self, *args) -> 'uint32'
 |      get_flags_for_valid(self) -> uint32
 |  
 |  valid_bg_color(self, *args) -> 'bool'
 |      valid_bg_color(self) -> bool
 |  
 |  valid_ea(self, *args) -> 'bool'
 |      valid_ea(self) -> bool
 |  
 |  valid_flags(self, *args) -> 'bool'
 |      valid_flags(self) -> bool
 |  
 |  valid_frame_color(self, *args) -> 'bool'
 |      valid_frame_color(self) -> bool
 |  
 |  valid_text(self, *args) -> 'bool'
 |      valid_text(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bg_color
 |      node_info_t_bg_color_get(self) -> bgcolor_t
 |  
 |  ea
 |      node_info_t_ea_get(self) -> ea_t
 |  
 |  flags
 |      node_info_t_flags_get(self) -> uint32
 |  
 |  frame_color
 |      node_info_t_frame_color_get(self) -> bgcolor_t
 |  
 |  text
 |      node_info_t_text_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on class node_layout_t in module ida_graph:

class node_layout_t(builtins.object)
 |  Proxy of C++ qvector< rect_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'rect_t const &'
 |      __getitem__(self, i) -> rect_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> node_layout_t
 |      __init__(self, x) -> node_layout_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_node_layout_t(...)
 |      delete_node_layout_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'rect_t const &'
 |      at(self, _idx) -> rect_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< rect_t >::const_iterator'
 |      begin(self) -> rect_t
 |      begin(self) -> rect_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< rect_t >::const_iterator'
 |      end(self) -> rect_t
 |      end(self) -> rect_t
 |  
 |  erase(self, *args) -> 'qvector< rect_t >::iterator'
 |      erase(self, it) -> rect_t
 |      erase(self, first, last) -> rect_t
 |  
 |  extract(self, *args) -> 'rect_t *'
 |      extract(self) -> rect_t
 |  
 |  find(self, *args) -> 'qvector< rect_t >::const_iterator'
 |      find(self, x) -> rect_t
 |      find(self, x) -> rect_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=rect_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< rect_t >::iterator'
 |      insert(self, it, x) -> rect_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'rect_t &'
 |      push_back(self, x)
 |      push_back(self) -> rect_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class node_ordering_t in module ida_graph:

class node_ordering_t(builtins.object)
 |  Proxy of C++ node_ordering_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> node_ordering_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_node_ordering_t(...)
 |      delete_node_ordering_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  node(self, *args) -> 'int'
 |      node(self, _order) -> int
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, n)
 |  
 |  set(self, *args) -> 'void'
 |      set(self, _node, num)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class point_t in module ida_graph:

class point_t(builtins.object)
 |  Proxy of C++ point_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> point_t
 |      __init__(self, _x, _y) -> point_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_point_t(...)
 |      delete_point_t(self)
 |  
 |  add(self, *args) -> 'point_t &'
 |      add(self, r) -> point_t
 |  
 |  negate(self, *args) -> 'void'
 |      negate(self)
 |  
 |  sub(self, *args) -> 'point_t &'
 |      sub(self, r) -> point_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      point_t_x_get(self) -> int
 |  
 |  y
 |      point_t_y_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class pointseq_t in module ida_graph:

class pointseq_t(pointvec_t)
 |  Proxy of C++ pointseq_t class.
 |  
 |  Method resolution order:
 |      pointseq_t
 |      pointvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pointseq_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pointseq_t(...)
 |      delete_pointseq_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from pointvec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'point_t const &'
 |      __getitem__(self, i) -> point_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'point_t const &'
 |      at(self, _idx) -> point_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< point_t >::const_iterator'
 |      begin(self) -> point_t
 |      begin(self) -> point_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< point_t >::const_iterator'
 |      end(self) -> point_t
 |      end(self) -> point_t
 |  
 |  erase(self, *args) -> 'qvector< point_t >::iterator'
 |      erase(self, it) -> point_t
 |      erase(self, first, last) -> point_t
 |  
 |  extract(self, *args) -> 'point_t *'
 |      extract(self) -> point_t
 |  
 |  find(self, *args) -> 'qvector< point_t >::const_iterator'
 |      find(self, x) -> point_t
 |      find(self, x) -> point_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=point_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< point_t >::iterator'
 |      insert(self, it, x) -> point_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'point_t &'
 |      push_back(self, x)
 |      push_back(self) -> point_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pointvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pointvec_t:
 |  
 |  __hash__ = None

Help on class pointvec_t in module ida_graph:

class pointvec_t(builtins.object)
 |  Proxy of C++ qvector< point_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'point_t const &'
 |      __getitem__(self, i) -> point_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pointvec_t
 |      __init__(self, x) -> pointvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_pointvec_t(...)
 |      delete_pointvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'point_t const &'
 |      at(self, _idx) -> point_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< point_t >::const_iterator'
 |      begin(self) -> point_t
 |      begin(self) -> point_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< point_t >::const_iterator'
 |      end(self) -> point_t
 |      end(self) -> point_t
 |  
 |  erase(self, *args) -> 'qvector< point_t >::iterator'
 |      erase(self, it) -> point_t
 |      erase(self, first, last) -> point_t
 |  
 |  extract(self, *args) -> 'point_t *'
 |      extract(self) -> point_t
 |  
 |  find(self, *args) -> 'qvector< point_t >::const_iterator'
 |      find(self, x) -> point_t
 |      find(self, x) -> point_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=point_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< point_t >::iterator'
 |      insert(self, it, x) -> point_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'point_t &'
 |      push_back(self, x)
 |      push_back(self) -> point_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function pyg_close in module ida_graph:

pyg_close(*args) -> 'void'
    pyg_close(_self)

Help on function pyg_select_node in module ida_graph:

pyg_select_node(*args) -> 'void'
    pyg_select_node(_self, nid)

Help on function pyg_show in module ida_graph:

pyg_show(*args) -> 'bool'
    pyg_show(_self) -> bool

Help on class rect_t in module ida_graph:

class rect_t(builtins.object)
 |  Proxy of C++ rect_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rect_t
 |      __init__(self, l, t, r, b) -> rect_t
 |      __init__(self, p0, p1) -> rect_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_rect_t(...)
 |      delete_rect_t(self)
 |  
 |  area(self, *args) -> 'int'
 |      area(self) -> int
 |  
 |  bottomright(self, *args) -> 'point_t'
 |      bottomright(self) -> point_t
 |  
 |  center(self, *args) -> 'point_t'
 |      center(self) -> point_t
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, p) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, delta)
 |  
 |  height(self, *args) -> 'int'
 |      height(self) -> int
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  is_intersection_empty(self, *args) -> 'bool'
 |      is_intersection_empty(self, r) -> bool
 |  
 |  make_union(self, *args) -> 'void'
 |      make_union(self, r)
 |  
 |  move_by(self, *args) -> 'void'
 |      move_by(self, p)
 |  
 |  move_to(self, *args) -> 'void'
 |      move_to(self, p)
 |  
 |  topleft(self, *args) -> 'point_t'
 |      topleft(self) -> point_t
 |  
 |  width(self, *args) -> 'int'
 |      width(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bottom
 |      rect_t_bottom_get(self) -> int
 |  
 |  left
 |      rect_t_left_get(self) -> int
 |  
 |  right
 |      rect_t_right_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  top
 |      rect_t_top_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function refresh_viewer in module ida_graph:

refresh_viewer(*args) -> 'void'
    refresh_viewer(gv)
    
    
    Redraw the graph in the given view.
    
    
    @param gv (C++: graph_viewer_t  *)

Help on class row_info_t in module ida_graph:

class row_info_t(builtins.object)
 |  Proxy of C++ row_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> row_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_row_info_t(...)
 |      delete_row_info_t(self)
 |  
 |  height(self, *args) -> 'int'
 |      height(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bottom
 |      row_info_t_bottom_get(self) -> int
 |  
 |  nodes
 |      row_info_t_nodes_get(self) -> intvec_t *
 |  
 |  thisown
 |      The membership flag
 |  
 |  top
 |      row_info_t_top_get(self) -> int

Help on class screen_graph_selection_base_t in module ida_graph:

class screen_graph_selection_base_t(builtins.object)
 |  Proxy of C++ qvector< selection_item_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'selection_item_t const &'
 |      __getitem__(self, i) -> selection_item_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> screen_graph_selection_base_t
 |      __init__(self, x) -> screen_graph_selection_base_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_screen_graph_selection_base_t(...)
 |      delete_screen_graph_selection_base_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'selection_item_t const &'
 |      at(self, _idx) -> selection_item_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      begin(self) -> selection_item_t
 |      begin(self) -> selection_item_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      end(self) -> selection_item_t
 |      end(self) -> selection_item_t
 |  
 |  erase(self, *args) -> 'qvector< selection_item_t >::iterator'
 |      erase(self, it) -> selection_item_t
 |      erase(self, first, last) -> selection_item_t
 |  
 |  extract(self, *args) -> 'selection_item_t *'
 |      extract(self) -> selection_item_t
 |  
 |  find(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      find(self, x) -> selection_item_t
 |      find(self, x) -> selection_item_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=selection_item_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< selection_item_t >::iterator'
 |      insert(self, it, x) -> selection_item_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'selection_item_t &'
 |      push_back(self, x)
 |      push_back(self) -> selection_item_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class screen_graph_selection_t in module ida_graph:

class screen_graph_selection_t(screen_graph_selection_base_t)
 |  Proxy of C++ screen_graph_selection_t class.
 |  
 |  Method resolution order:
 |      screen_graph_selection_t
 |      screen_graph_selection_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> screen_graph_selection_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_screen_graph_selection_t(...)
 |      delete_screen_graph_selection_t(self)
 |  
 |  add(self, *args) -> 'void'
 |      add(self, s)
 |  
 |  add_node(self, *args) -> 'void'
 |      add_node(self, node)
 |  
 |  add_point(self, *args) -> 'void'
 |      add_point(self, e, idx)
 |  
 |  del_node(self, *args) -> 'void'
 |      del_node(self, node)
 |  
 |  del_point(self, *args) -> 'void'
 |      del_point(self, e, idx)
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, item) -> bool
 |  
 |  items_count(self, *args) -> 'size_t'
 |      items_count(self, look_for_nodes) -> size_t
 |  
 |  nodes_count(self, *args) -> 'size_t'
 |      nodes_count(self) -> size_t
 |  
 |  points_count(self, *args) -> 'size_t'
 |      points_count(self) -> size_t
 |  
 |  sub(self, *args) -> 'void'
 |      sub(self, s)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from screen_graph_selection_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'selection_item_t const &'
 |      __getitem__(self, i) -> selection_item_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'selection_item_t const &'
 |      at(self, _idx) -> selection_item_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      begin(self) -> selection_item_t
 |      begin(self) -> selection_item_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      end(self) -> selection_item_t
 |      end(self) -> selection_item_t
 |  
 |  erase(self, *args) -> 'qvector< selection_item_t >::iterator'
 |      erase(self, it) -> selection_item_t
 |      erase(self, first, last) -> selection_item_t
 |  
 |  extract(self, *args) -> 'selection_item_t *'
 |      extract(self) -> selection_item_t
 |  
 |  find(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      find(self, x) -> selection_item_t
 |      find(self, x) -> selection_item_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=selection_item_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< selection_item_t >::iterator'
 |      insert(self, it, x) -> selection_item_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'selection_item_t &'
 |      push_back(self, x)
 |      push_back(self) -> selection_item_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from screen_graph_selection_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from screen_graph_selection_base_t:
 |  
 |  __hash__ = None

Help on class selection_item_t in module ida_graph:

class selection_item_t(builtins.object)
 |  Proxy of C++ selection_item_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> selection_item_t
 |      __init__(self, n) -> selection_item_t
 |      __init__(self, _elp) -> selection_item_t
 |      __init__(self, e, idx) -> selection_item_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_selection_item_t(...)
 |      delete_selection_item_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  elp
 |      selection_item_t_elp_get(self) -> edge_layout_point_t
 |  
 |  is_node
 |      selection_item_t_is_node_get(self) -> bool
 |  
 |  node
 |      selection_item_t_node_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function set_node_info in module ida_graph:

set_node_info(*args) -> 'void'
    set_node_info(gid, node, ni, flags)
    
    
    Set node info.
    
    @param gid: id of desired graph (C++: graph_id_t)
    @param node: node number (C++: int)
    @param ni: node info to use (C++: const  node_info_t  &)
    @param flags: combination of  Node info flags , identifying which
                  fields of 'ni' will be used (C++: uint32)

Help on function set_viewer_graph in module ida_graph:

set_viewer_graph(*args) -> 'void'
    set_viewer_graph(gv, g)
    
    
    Set the underlying graph object for the given viewer.
    
    
    @param gv (C++: graph_viewer_t  *)
    @param g (C++: mutable_graph_t  *)

Help on class user_graph_place_t in module ida_graph:

class user_graph_place_t(builtins.object)
 |  Proxy of C++ user_graph_place_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_graph_place_t(...)
 |      delete_user_graph_place_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  node
 |      user_graph_place_t_node_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on function viewer_attach_menu_item in module ida_graph:

viewer_attach_menu_item(*args) -> 'bool'
    viewer_attach_menu_item(g, name) -> bool
    
    
    Attach a previously-registered action to the view's context menu. See
    'kernwin.hpp' for how to register actions.
    
    @param g (C++: graph_viewer_t  *)
    @param name: action name (C++: const char *)
    @return: success

Help on function viewer_center_on in module ida_graph:

viewer_center_on(*args) -> 'void'
    viewer_center_on(gv, node)
    
    
    Center the graph view on the given node.
    
    
    @param gv (C++: graph_viewer_t  *)
    @param node (C++: int)

Help on function viewer_create_groups in module ida_graph:

viewer_create_groups(*args) -> 'bool'
    viewer_create_groups(gv, out_group_nodes, gi) -> bool
    
    
    This will perform an operation similar to what happens when a user
    manually selects a set of nodes, right-clicks and selects "Create
    group". This is a wrapper around mutable_graph_t::create_group that
    will, in essence:clone the current graphfor each 'group_crinfo_t' ,
    attempt creating group in that new graphif all were successful,
    animate to that new graph.this accepts parameters that allow creating
    of multiple groups at once; which means only one graph animation will
    be triggered.
    
    @param gv (C++: graph_viewer_t  *)
    @param out_group_nodes (C++: intvec_t  *)
    @param gi (C++: const  groups_crinfos_t  &)

Help on function viewer_del_node_info in module ida_graph:

viewer_del_node_info(*args) -> 'void'
    viewer_del_node_info(gv, n)
    
    
    Delete node info for node in given viewer (see 'del_node_info()' )
    
    
    @param gv (C++: graph_viewer_t  *)
    @param n (C++: int)

Help on function viewer_delete_groups in module ida_graph:

viewer_delete_groups(*args) -> 'bool'
    viewer_delete_groups(gv, groups, new_current=-1) -> bool
    
    
    Wrapper around mutable_graph_t::delete_group. This function will:clone
    the current graphattempt deleting the groups in that new graphif
    successful, animate to that new graph.
    
    @param gv (C++: graph_viewer_t  *)
    @param groups (C++: const  intvec_t  &)
    @param new_current (C++: int)

Help on function viewer_fit_window in module ida_graph:

viewer_fit_window(*args) -> 'void'
    viewer_fit_window(gv)
    
    
    Fit graph viewer to its parent form.
    
    
    @param gv (C++: graph_viewer_t  *)

Help on function viewer_get_curnode in module ida_graph:

viewer_get_curnode(*args) -> 'int'
    viewer_get_curnode(gv) -> int
    
    
    Get number of currently selected node (-1 if none)
    
    
    @param gv (C++: graph_viewer_t  *)

Help on function viewer_get_gli in module ida_graph:

viewer_get_gli(*args) -> 'bool'
    viewer_get_gli(out, gv, flags=0) -> bool
    
    
    Get location info for given graph view If flags contains
    GLICTL_CENTER, then the gli that will be retrieved, will be the one at
    the center of the view. Otherwise it will be the top-left.
    
    @param out (C++: graph_location_info_t  *)
    @param gv (C++: graph_viewer_t  *)
    @param flags (C++: uint32)

Help on function viewer_get_node_info in module ida_graph:

viewer_get_node_info(*args) -> 'bool'
    viewer_get_node_info(gv, out, n) -> bool
    
    
    Get node info for node in given viewer (see 'get_node_info()' )
    
    
    @param gv (C++: graph_viewer_t  *)
    @param out (C++: node_info_t  *)
    @param n (C++: int)

Help on function viewer_get_selection in module ida_graph:

viewer_get_selection(*args) -> 'bool'
    viewer_get_selection(gv, sgs) -> bool
    
    
    Get currently selected items for graph viewer.
    
    
    @param gv (C++: graph_viewer_t  *)
    @param sgs (C++: screen_graph_selection_t  *)

Help on function viewer_set_gli in module ida_graph:

viewer_set_gli(*args) -> 'void'
    viewer_set_gli(gv, gli, flags=0)
    
    
    Set location info for given graph view If flags contains
    GLICTL_CENTER, then the gli will be set to be the center of the view.
    Otherwise it will be the top-left.
    
    @param gv (C++: graph_viewer_t  *)
    @param gli (C++: const  graph_location_info_t  *)
    @param flags (C++: uint32)

Help on function viewer_set_groups_visibility in module ida_graph:

viewer_set_groups_visibility(*args) -> 'bool'
    viewer_set_groups_visibility(gv, groups, expand, new_current=-1) -> bool
    
    
    Wrapper around mutable_graph_t::change_visibility. This function
    will:clone the current graphattempt changing visibility of the groups
    in that new graphif successful, animate to that new graph.
    
    @param gv (C++: graph_viewer_t  *)
    @param groups (C++: const  intvec_t  &)
    @param expand (C++: bool)
    @param new_current (C++: int)

Help on function viewer_set_node_info in module ida_graph:

viewer_set_node_info(*args) -> 'void'
    viewer_set_node_info(gv, n, ni, flags)
    
    
    Set node info for node in given viewer (see 'set_node_info()' )
    
    
    @param gv (C++: graph_viewer_t  *)
    @param n (C++: int)
    @param ni (C++: const  node_info_t  &)
    @param flags (C++: uint32)

Help on function viewer_set_titlebar_height in module ida_graph:

viewer_set_titlebar_height(*args) -> 'int'
    viewer_set_titlebar_height(gv, height) -> int
    
    
    Set height of node title bars ( 'grcode_set_titlebar_height' )
    
    
    @param gv (C++: graph_viewer_t  *)
    @param height (C++: int)

=== ida_graph EPYDOC INJECTIONS ===
ida_graph.GLICTL_CENTER
"""
the gli should be set/get as center
"""

ida_graph.MTG_DOT_NODE
"""
is dot node?
"""

ida_graph.MTG_GROUP_NODE
"""
is group node?
"""

ida_graph.MTG_NON_DISPLAYABLE_NODE
"""
for disassembly graphs - non-displayable nodes have a visible area
that is too large to generate disassembly lines for without IDA
slowing down significantly (see MAX_VISIBLE_NODE_AREA)
"""

ida_graph.NIF_BG_COLOR
"""
 'node_info_t::bg_color'
"""

ida_graph.NIF_EA
"""
 'node_info_t::ea'
"""

ida_graph.NIF_FLAGS
"""
 'node_info_t::flags'
"""

ida_graph.NIF_FRAME_COLOR
"""
 'node_info_t::frame_color'
"""

ida_graph.NIF_TEXT
"""
 'node_info_t::text'
"""
=== ida_graph EPYDOC INJECTIONS END ===
Help on class DecompilationFailure in module ida_hexrays:

class DecompilationFailure(builtins.Exception)
 |  Raised on a decompilation error.
 |  
 |  The associated hexrays_failure_t object is stored in the
 |  'info' member of this exception.
 |  
 |  Method resolution order:
 |      DecompilationFailure
 |      builtins.Exception
 |      builtins.BaseException
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, info)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.Exception:
 |  
 |  __new__(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.BaseException:
 |  
 |  __delattr__(self, name, /)
 |      Implement delattr(self, name).
 |  
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |  
 |  __reduce__(...)
 |      helper for pickle
 |  
 |  __repr__(self, /)
 |      Return repr(self).
 |  
 |  __setattr__(self, name, value, /)
 |      Implement setattr(self, name, value).
 |  
 |  __setstate__(...)
 |  
 |  __str__(self, /)
 |      Return str(self).
 |  
 |  with_traceback(...)
 |      Exception.with_traceback(tb) --
 |      set self.__traceback__ to tb and return self.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from builtins.BaseException:
 |  
 |  __cause__
 |      exception cause
 |  
 |  __context__
 |      exception context
 |  
 |  __dict__
 |  
 |  __suppress_context__
 |  
 |  __traceback__
 |  
 |  args

Help on class Hexrays_Hooks in module ida_hexrays:

class Hexrays_Hooks(builtins.object)
 |  Proxy of C++ Hexrays_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> Hexrays_Hooks
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_Hexrays_Hooks(...)
 |      delete_Hexrays_Hooks(self)
 |  
 |  close_pseudocode(self, *args) -> 'int'
 |      close_pseudocode(self, vu) -> int
 |  
 |  cmt_changed(self, *args) -> 'int'
 |      cmt_changed(self, cfunc, loc, cmt) -> int
 |  
 |  combine(self, *args) -> 'int'
 |      combine(self, blk, insn) -> int
 |  
 |  create_hint(self, *args) -> 'PyObject *'
 |      create_hint(self, vu) -> PyObject *
 |  
 |  curpos(self, *args) -> 'int'
 |      curpos(self, vu) -> int
 |  
 |  double_click(self, *args) -> 'int'
 |      double_click(self, vu, shift_state) -> int
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  flowchart(self, *args) -> 'int'
 |      flowchart(self, fc) -> int
 |  
 |  func_printed(self, *args) -> 'int'
 |      func_printed(self, cfunc) -> int
 |  
 |  glbopt(self, *args) -> 'int'
 |      glbopt(self, mba) -> int
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  interr(self, *args) -> 'int'
 |      interr(self, errcode) -> int
 |  
 |  keyboard(self, *args) -> 'int'
 |      keyboard(self, vu, key_code, shift_state) -> int
 |  
 |  locopt(self, *args) -> 'int'
 |      locopt(self, mba) -> int
 |  
 |  lvar_cmt_changed(self, *args) -> 'int'
 |      lvar_cmt_changed(self, vu, v, cmt) -> int
 |  
 |  lvar_mapping_changed(self, *args) -> 'int'
 |      lvar_mapping_changed(self, vu, frm, to) -> int
 |  
 |  lvar_name_changed(self, *args) -> 'int'
 |      lvar_name_changed(self, vu, v, name, is_user_name) -> int
 |  
 |  lvar_type_changed(self, *args) -> 'int'
 |      lvar_type_changed(self, vu, v, tinfo) -> int
 |  
 |  maturity(self, *args) -> 'int'
 |      maturity(self, cfunc, new_maturity) -> int
 |  
 |  microcode(self, *args) -> 'int'
 |      microcode(self, mba) -> int
 |  
 |  open_pseudocode(self, *args) -> 'int'
 |      open_pseudocode(self, vu) -> int
 |  
 |  populating_popup(self, *args) -> 'int'
 |      populating_popup(self, widget, popup_handle, vu) -> int
 |  
 |  prealloc(self, *args) -> 'int'
 |      prealloc(self, mba) -> int
 |  
 |  preoptimized(self, *args) -> 'int'
 |      preoptimized(self, mba) -> int
 |  
 |  print_func(self, *args) -> 'int'
 |      print_func(self, cfunc, vp) -> int
 |  
 |  prolog(self, *args) -> 'int'
 |      prolog(self, mba, fc, reachable_blocks, decomp_flags) -> int
 |  
 |  refresh_pseudocode(self, *args) -> 'int'
 |      refresh_pseudocode(self, vu) -> int
 |  
 |  resolve_stkaddrs(self, *args) -> 'int'
 |      resolve_stkaddrs(self, mba) -> int
 |  
 |  right_click(self, *args) -> 'int'
 |      right_click(self, vu) -> int
 |  
 |  stkpnts(self, *args) -> 'int'
 |      stkpnts(self, mba, _sps) -> int
 |  
 |  structural(self, *args) -> 'int'
 |      structural(self, ct) -> int
 |  
 |  switch_pseudocode(self, *args) -> 'int'
 |      switch_pseudocode(self, vu) -> int
 |  
 |  text_ready(self, *args) -> 'int'
 |      text_ready(self, vu) -> int
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class __cbhooks_t in module ida_hexrays:

class __cbhooks_t(Hexrays_Hooks)
 |  Proxy of C++ Hexrays_Hooks class.
 |  
 |  Method resolution order:
 |      __cbhooks_t
 |      Hexrays_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, callback)
 |      __init__(self, _flags=0) -> Hexrays_Hooks
 |  
 |  close_pseudocode(self, *args)
 |      close_pseudocode(self, vu) -> int
 |  
 |  create_hint(self, *args)
 |      create_hint(self, vu) -> PyObject *
 |  
 |  curpos(self, *args)
 |      curpos(self, vu) -> int
 |  
 |  double_click(self, *args)
 |      double_click(self, vu, shift_state) -> int
 |  
 |  func_printed(self, *args)
 |      func_printed(self, cfunc) -> int
 |  
 |  interr(self, *args)
 |      interr(self, errcode) -> int
 |  
 |  keyboard(self, *args)
 |      keyboard(self, vu, key_code, shift_state) -> int
 |  
 |  maturity(self, *args)
 |      maturity(self, cfunc, new_maturity) -> int
 |  
 |  open_pseudocode(self, *args)
 |      open_pseudocode(self, vu) -> int
 |  
 |  populating_popup(self, *args)
 |      populating_popup(self, widget, popup_handle, vu) -> int
 |  
 |  print_func(self, *args)
 |      print_func(self, cfunc, vp) -> int
 |  
 |  refresh_pseudocode(self, *args)
 |      refresh_pseudocode(self, vu) -> int
 |  
 |  right_click(self, *args)
 |      right_click(self, vu) -> int
 |  
 |  switch_pseudocode(self, *args)
 |      switch_pseudocode(self, vu) -> int
 |  
 |  text_ready(self, *args)
 |      text_ready(self, vu) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  instances = []
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from Hexrays_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_Hexrays_Hooks(...)
 |      delete_Hexrays_Hooks(self)
 |  
 |  cmt_changed(self, *args) -> 'int'
 |      cmt_changed(self, cfunc, loc, cmt) -> int
 |  
 |  combine(self, *args) -> 'int'
 |      combine(self, blk, insn) -> int
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  flowchart(self, *args) -> 'int'
 |      flowchart(self, fc) -> int
 |  
 |  glbopt(self, *args) -> 'int'
 |      glbopt(self, mba) -> int
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  locopt(self, *args) -> 'int'
 |      locopt(self, mba) -> int
 |  
 |  lvar_cmt_changed(self, *args) -> 'int'
 |      lvar_cmt_changed(self, vu, v, cmt) -> int
 |  
 |  lvar_mapping_changed(self, *args) -> 'int'
 |      lvar_mapping_changed(self, vu, frm, to) -> int
 |  
 |  lvar_name_changed(self, *args) -> 'int'
 |      lvar_name_changed(self, vu, v, name, is_user_name) -> int
 |  
 |  lvar_type_changed(self, *args) -> 'int'
 |      lvar_type_changed(self, vu, v, tinfo) -> int
 |  
 |  microcode(self, *args) -> 'int'
 |      microcode(self, mba) -> int
 |  
 |  prealloc(self, *args) -> 'int'
 |      prealloc(self, mba) -> int
 |  
 |  preoptimized(self, *args) -> 'int'
 |      preoptimized(self, mba) -> int
 |  
 |  prolog(self, *args) -> 'int'
 |      prolog(self, mba, fc, reachable_blocks, decomp_flags) -> int
 |  
 |  resolve_stkaddrs(self, *args) -> 'int'
 |      resolve_stkaddrs(self, mba) -> int
 |  
 |  stkpnts(self, *args) -> 'int'
 |      stkpnts(self, mba, _sps) -> int
 |  
 |  structural(self, *args) -> 'int'
 |      structural(self, ct) -> int
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from Hexrays_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function _call_with_transferrable_ownership in module ida_hexrays:

_call_with_transferrable_ownership(fun, *args)
    # Object ownership

Help on function _kludge_use_TPopupMenu in module ida_hexrays:

_kludge_use_TPopupMenu(*args) -> 'void'
    _kludge_use_TPopupMenu(m)

Help on function _ll_call_helper in module ida_hexrays:

_ll_call_helper(*args) -> 'cexpr_t *'
    _ll_call_helper(rettype, args, format) -> cexpr_t

Help on function _ll_create_helper in module ida_hexrays:

_ll_create_helper(*args) -> 'cexpr_t *'
    _ll_create_helper(standalone, type, format) -> cexpr_t

Help on function _ll_dereference in module ida_hexrays:

_ll_dereference(*args) -> 'cexpr_t *'
    _ll_dereference(e, ptrsize, is_flt=False) -> cexpr_t

Help on function _ll_lnot in module ida_hexrays:

_ll_lnot(*args) -> 'cexpr_t *'
    _ll_lnot(e) -> cexpr_t

Help on function _ll_make_num in module ida_hexrays:

_ll_make_num(*args) -> 'cexpr_t *'
    _ll_make_num(n, func=None, ea=BADADDR, opnum=0, sign=no_sign, size=0) -> cexpr_t

Help on function _ll_make_ref in module ida_hexrays:

_ll_make_ref(*args) -> 'cexpr_t *'
    _ll_make_ref(e) -> cexpr_t

Help on function _ll_new_block in module ida_hexrays:

_ll_new_block(*args) -> 'cinsn_t *'
    _ll_new_block() -> cinsn_t

Help on function _map_as_dict in module ida_hexrays:

_map_as_dict(maptype, name, keytype, valuetype)
    # dictify all dict-like types

Help on function accepts_small_udts in module ida_hexrays:

accepts_small_udts(*args) -> 'bool'
    accepts_small_udts(op) -> bool
    
    
    Is the operator allowed on small structure or union?
    
    
    @param op (C++: ctype_t)

Help on function accepts_udts in module ida_hexrays:

accepts_udts(*args) -> 'bool'
    accepts_udts(op) -> bool

Help on function arglocs_overlap in module ida_hexrays:

arglocs_overlap(*args) -> 'bool'
    arglocs_overlap(loc1, w1, loc2, w2) -> bool
    
    
    Do two arglocs overlap?
    
    
    @param loc1 (C++: const  vdloc_t  &)
    @param w1 (C++: size_t)
    @param loc2 (C++: const  vdloc_t  &)
    @param w2 (C++: size_t)

Help on class array_of_bitsets in module ida_hexrays:

class array_of_bitsets(builtins.object)
 |  Proxy of C++ qvector< bitset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'bitset_t const &'
 |      __getitem__(self, i) -> bitset_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_of_bitsets
 |      __init__(self, x) -> array_of_bitsets
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_array_of_bitsets(...)
 |      delete_array_of_bitsets(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'bitset_t const &'
 |      at(self, _idx) -> bitset_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< bitset_t >::const_iterator'
 |      begin(self) -> bitset_t
 |      begin(self) -> bitset_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< bitset_t >::const_iterator'
 |      end(self) -> bitset_t
 |      end(self) -> bitset_t
 |  
 |  erase(self, *args) -> 'qvector< bitset_t >::iterator'
 |      erase(self, it) -> bitset_t
 |      erase(self, first, last) -> bitset_t
 |  
 |  extract(self, *args) -> 'bitset_t *'
 |      extract(self) -> bitset_t
 |  
 |  find(self, *args) -> 'qvector< bitset_t >::const_iterator'
 |      find(self, x) -> bitset_t
 |      find(self, x) -> bitset_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=bitset_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< bitset_t >::iterator'
 |      insert(self, it, x) -> bitset_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'bitset_t &'
 |      push_back(self, x)
 |      push_back(self) -> bitset_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class array_of_ivlsets in module ida_hexrays:

class array_of_ivlsets(builtins.object)
 |  Proxy of C++ qvector< ivlset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'ivlset_t const &'
 |      __getitem__(self, i) -> ivlset_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_of_ivlsets
 |      __init__(self, x) -> array_of_ivlsets
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_array_of_ivlsets(...)
 |      delete_array_of_ivlsets(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'ivlset_t const &'
 |      at(self, _idx) -> ivlset_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< ivlset_t >::const_iterator'
 |      begin(self) -> ivlset_t
 |      begin(self) -> ivlset_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< ivlset_t >::const_iterator'
 |      end(self) -> ivlset_t
 |      end(self) -> ivlset_t
 |  
 |  erase(self, *args) -> 'qvector< ivlset_t >::iterator'
 |      erase(self, it) -> ivlset_t
 |      erase(self, first, last) -> ivlset_t
 |  
 |  extract(self, *args) -> 'ivlset_t *'
 |      extract(self) -> ivlset_t
 |  
 |  find(self, *args) -> 'qvector< ivlset_t >::const_iterator'
 |      find(self, x) -> ivlset_t
 |      find(self, x) -> ivlset_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=ivlset_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< ivlset_t >::iterator'
 |      insert(self, it, x) -> ivlset_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'ivlset_t &'
 |      push_back(self, x)
 |      push_back(self) -> ivlset_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function asgop in module ida_hexrays:

asgop(*args) -> 'ctype_t'
    asgop(cop) -> ctype_t
    
    
    Convert plain operator into assignment operator. For example, cot_add
    returns cot_asgadd.
    
    
    @param cop (C++: ctype_t)

Help on function asgop_revert in module ida_hexrays:

asgop_revert(*args) -> 'ctype_t'
    asgop_revert(cop) -> ctype_t
    
    
    Convert assignment operator into plain operator. For example,
    cot_asgadd returns cot_add
    
    @param cop (C++: ctype_t)
    @return: cot_empty is the input operator is not an assignment
             operator.

Help on class bit_bound_t in module ida_hexrays:

class bit_bound_t(builtins.object)
 |  Proxy of C++ bit_bound_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, n=0, s=0) -> bit_bound_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bit_bound_t(...)
 |      delete_bit_bound_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  nbits
 |      bit_bound_t_nbits_get(self) -> int16
 |  
 |  sbits
 |      bit_bound_t_sbits_get(self) -> int16
 |  
 |  thisown
 |      The membership flag

Help on class bitset_t in module ida_hexrays:

class bitset_t(builtins.object)
 |  Proxy of C++ bitset_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bitset_t
 |      __init__(self, m) -> bitset_t
 |  
 |  __iter__(self)
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __len__ = count(self, *args) -> 'int'
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bitset_t(...)
 |      delete_bitset_t(self)
 |  
 |  add(self, *args) -> 'bool'
 |      add(self, bit) -> bool
 |      add(self, bit, width) -> bool
 |      add(self, ml) -> bool
 |  
 |  back(self, *args) -> 'int'
 |      back(self) -> int
 |  
 |  begin(self, *args) -> 'bitset_t::iterator'
 |      begin(self) -> bitset_t::iterator
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  copy(self, *args) -> 'bitset_t &'
 |      copy(self, m) -> bitset_t
 |  
 |  count(self, *args) -> 'int'
 |      count(self) -> int
 |      count(self, bit) -> int
 |  
 |  cut_at(self, *args) -> 'bool'
 |      cut_at(self, maxbit) -> bool
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'bitset_t::iterator'
 |      end(self) -> bitset_t::iterator
 |  
 |  fill_with_ones(self, *args) -> 'void'
 |      fill_with_ones(self, maxbit)
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, bit) -> bool
 |  
 |  has_all(self, *args) -> 'bool'
 |      has_all(self, bit, width) -> bool
 |  
 |  has_any(self, *args) -> 'bool'
 |      has_any(self, bit, width) -> bool
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, ml) -> bool
 |  
 |  inc(self, *args) -> 'void'
 |      inc(self, p, n=1)
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, ml) -> bool
 |  
 |  intersect(self, *args) -> 'bool'
 |      intersect(self, ml) -> bool
 |  
 |  is_subset_of(self, *args) -> 'bool'
 |      is_subset_of(self, ml) -> bool
 |  
 |  itat(self, *args) -> 'bitset_t::iterator'
 |      itat(self, n) -> bitset_t::iterator
 |  
 |  itv(self, *args) -> 'int'
 |      itv(self, it) -> int
 |  
 |  last(self, *args) -> 'int'
 |      last(self) -> int
 |  
 |  shift_down(self, *args) -> 'void'
 |      shift_down(self, shift)
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, bit) -> bool
 |      sub(self, bit, width) -> bool
 |      sub(self, ml) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function block_chains_begin in module ida_hexrays:

block_chains_begin(*args) -> 'block_chains_iterator_t'
    block_chains_begin(set) -> block_chains_iterator_t
    
    
    Get iterator pointing to the beginning of 'block_chains_t' .
    
    
    @param set (C++: const  block_chains_t  *)

Help on function block_chains_clear in module ida_hexrays:

block_chains_clear(*args) -> 'void'
    block_chains_clear(set)
    
    
    Clear 'block_chains_t' .
    
    
    @param set (C++: block_chains_t  *)

Help on function block_chains_end in module ida_hexrays:

block_chains_end(*args) -> 'block_chains_iterator_t'
    block_chains_end(set) -> block_chains_iterator_t
    
    
    Get iterator pointing to the end of 'block_chains_t' .
    
    
    @param set (C++: const  block_chains_t  *)

Help on function block_chains_erase in module ida_hexrays:

block_chains_erase(*args) -> 'void'
    block_chains_erase(set, p)
    
    
    Erase current element from 'block_chains_t' .
    
    
    @param set (C++: block_chains_t  *)
    @param p (C++: block_chains_iterator_t)

Help on function block_chains_find in module ida_hexrays:

block_chains_find(*args) -> 'block_chains_iterator_t'
    block_chains_find(set, val) -> block_chains_iterator_t
    
    
    Find the specified key in set 'block_chains_t' .
    
    
    @param set (C++: const  block_chains_t  *)
    @param val (C++: const  chain_t  &)

Help on function block_chains_free in module ida_hexrays:

block_chains_free(*args) -> 'void'
    block_chains_free(set)
    
    
    Delete 'block_chains_t' instance.
    
    
    @param set (C++: block_chains_t  *)

Help on function block_chains_get in module ida_hexrays:

block_chains_get(*args) -> 'chain_t &'
    block_chains_get(p) -> chain_t
    
    
    Get reference to the current set value.
    
    
    @param p (C++: block_chains_iterator_t)

Help on function block_chains_insert in module ida_hexrays:

block_chains_insert(*args) -> 'block_chains_iterator_t'
    block_chains_insert(set, val) -> block_chains_iterator_t
    
    
    Insert new ( 'chain_t' ) into set 'block_chains_t' .
    
    
    @param set (C++: block_chains_t  *)
    @param val (C++: const  chain_t  &)

Help on class block_chains_iterator_t in module ida_hexrays:

class block_chains_iterator_t(builtins.object)
 |  Proxy of C++ block_chains_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> block_chains_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_block_chains_iterator_t(...)
 |      delete_block_chains_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      block_chains_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function block_chains_new in module ida_hexrays:

block_chains_new(*args) -> 'block_chains_t *'
    block_chains_new() -> block_chains_t
    
    
    Create a new 'block_chains_t' instance.

Help on function block_chains_next in module ida_hexrays:

block_chains_next(*args) -> 'block_chains_iterator_t'
    block_chains_next(p) -> block_chains_iterator_t
    
    
    Move to the next element.
    
    
    @param p (C++: block_chains_iterator_t)

Help on function block_chains_prev in module ida_hexrays:

block_chains_prev(*args) -> 'block_chains_iterator_t'
    block_chains_prev(p) -> block_chains_iterator_t
    
    
    Move to the previous element.
    
    
    @param p (C++: block_chains_iterator_t)

Help on function block_chains_size in module ida_hexrays:

block_chains_size(*args) -> 'size_t'
    block_chains_size(set) -> size_t
    
    
    Get size of 'block_chains_t' .
    
    
    @param set (C++: block_chains_t  *)

Help on class block_chains_t in module ida_hexrays:

class block_chains_t(builtins.object)
 |  Proxy of C++ block_chains_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> block_chains_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_block_chains_t(...)
 |      delete_block_chains_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  get_chain(self, *args) -> 'chain_t *'
 |      get_chain(self, k, width=1) -> chain_t
 |      get_chain(self, k, width=1) -> chain_t
 |      get_chain(self, ch) -> chain_t
 |      get_chain(self, ch) -> chain_t
 |  
 |  get_reg_chain(self, *args) -> 'chain_t *'
 |      get_reg_chain(self, reg, width=1) -> chain_t
 |      get_reg_chain(self, reg, width=1) -> chain_t
 |  
 |  get_stk_chain(self, *args) -> 'chain_t *'
 |      get_stk_chain(self, off, width=1) -> chain_t
 |      get_stk_chain(self, off, width=1) -> chain_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class block_chains_vec_t in module ida_hexrays:

class block_chains_vec_t(builtins.object)
 |  Proxy of C++ qvector< block_chains_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'block_chains_t const &'
 |      __getitem__(self, i) -> block_chains_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> block_chains_vec_t
 |      __init__(self, x) -> block_chains_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_block_chains_vec_t(...)
 |      delete_block_chains_vec_t(self)
 |  
 |  at(self, *args) -> 'block_chains_t const &'
 |      at(self, _idx) -> block_chains_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< block_chains_t >::const_iterator'
 |      begin(self) -> block_chains_t
 |      begin(self) -> block_chains_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< block_chains_t >::const_iterator'
 |      end(self) -> block_chains_t
 |      end(self) -> block_chains_t
 |  
 |  erase(self, *args) -> 'qvector< block_chains_t >::iterator'
 |      erase(self, it) -> block_chains_t
 |      erase(self, first, last) -> block_chains_t
 |  
 |  extract(self, *args) -> 'block_chains_t *'
 |      extract(self) -> block_chains_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=block_chains_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< block_chains_t >::iterator'
 |      insert(self, it, x) -> block_chains_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'block_chains_t &'
 |      push_back(self, x)
 |      push_back(self) -> block_chains_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function boundaries_begin in module ida_hexrays:

boundaries_begin(*args) -> 'boundaries_iterator_t'
    boundaries_begin(map) -> boundaries_iterator_t
    
    
    Get iterator pointing to the beginning of boundaries_t.
    
    
    @param map (C++: const boundaries_t *)

Help on function boundaries_clear in module ida_hexrays:

boundaries_clear(*args) -> 'void'
    boundaries_clear(map)
    
    
    Clear boundaries_t.
    
    
    @param map (C++: boundaries_t *)

Help on function boundaries_end in module ida_hexrays:

boundaries_end(*args) -> 'boundaries_iterator_t'
    boundaries_end(map) -> boundaries_iterator_t
    
    
    Get iterator pointing to the end of boundaries_t.
    
    
    @param map (C++: const boundaries_t *)

Help on function boundaries_erase in module ida_hexrays:

boundaries_erase(*args) -> 'void'
    boundaries_erase(map, p)
    
    
    Erase current element from boundaries_t.
    
    
    @param map (C++: boundaries_t *)
    @param p (C++: boundaries_iterator_t)

Help on function boundaries_find in module ida_hexrays:

boundaries_find(*args) -> 'boundaries_iterator_t'
    boundaries_find(map, key) -> boundaries_iterator_t
    
    
    Find the specified key in boundaries_t.
    
    
    @param map (C++: const boundaries_t *)
    @param key (C++: const  cinsn_t  *&)

Help on function boundaries_first in module ida_hexrays:

boundaries_first(*args) -> 'cinsn_t *const &'
    boundaries_first(p) -> cinsn_t
    
    
    Get reference to the current map key.
    
    
    @param p (C++: boundaries_iterator_t)

Help on function boundaries_free in module ida_hexrays:

boundaries_free(*args) -> 'void'
    boundaries_free(map)
    
    
    Delete boundaries_t instance.
    
    
    @param map (C++: boundaries_t *)

Help on function boundaries_insert in module ida_hexrays:

boundaries_insert(*args) -> 'boundaries_iterator_t'
    boundaries_insert(map, key, val) -> boundaries_iterator_t
    
    
    Insert new ( 'cinsn_t' *, 'rangeset_t' ) pair into boundaries_t.
    
    
    @param map (C++: boundaries_t *)
    @param key (C++: const  cinsn_t  *&)
    @param val (C++: const  rangeset_t  &)

Help on class boundaries_iterator_t in module ida_hexrays:

class boundaries_iterator_t(builtins.object)
 |  Proxy of C++ boundaries_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> boundaries_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_boundaries_iterator_t(...)
 |      delete_boundaries_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      boundaries_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function boundaries_new in module ida_hexrays:

boundaries_new(*args) -> 'boundaries_t *'
    boundaries_new() -> boundaries_t
    
    
    Create a new boundaries_t instance.

Help on function boundaries_next in module ida_hexrays:

boundaries_next(*args) -> 'boundaries_iterator_t'
    boundaries_next(p) -> boundaries_iterator_t
    
    
    Move to the next element.
    
    
    @param p (C++: boundaries_iterator_t)

Help on function boundaries_prev in module ida_hexrays:

boundaries_prev(*args) -> 'boundaries_iterator_t'
    boundaries_prev(p) -> boundaries_iterator_t
    
    
    Move to the previous element.
    
    
    @param p (C++: boundaries_iterator_t)

Help on function boundaries_second in module ida_hexrays:

boundaries_second(*args) -> 'rangeset_t &'
    boundaries_second(p) -> rangeset_t
    
    
    Get reference to the current map value.
    
    
    @param p (C++: boundaries_iterator_t)

Help on function boundaries_size in module ida_hexrays:

boundaries_size(*args) -> 'size_t'
    boundaries_size(map) -> size_t
    
    
    Get size of boundaries_t.
    
    
    @param map (C++: boundaries_t *)

Help on class boundaries_t in module ida_hexrays:

class boundaries_t(builtins.object)
 |  Proxy of C++ std::map< cinsn_t *,rangeset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = boundaries_begin(...)
 |      boundaries_begin(map) -> boundaries_iterator_t
 |  
 |  __clear = boundaries_clear(...)
 |      boundaries_clear(map)
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = boundaries_end(...)
 |      boundaries_end(map) -> boundaries_iterator_t
 |  
 |  __erase = boundaries_erase(...)
 |      boundaries_erase(map, p)
 |  
 |  __find = boundaries_find(...)
 |      boundaries_find(map, key) -> boundaries_iterator_t
 |  
 |  __first = boundaries_first(...)
 |      boundaries_first(p) -> cinsn_t
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> boundaries_t
 |  
 |  __insert = boundaries_insert(...)
 |      boundaries_insert(map, key, val) -> boundaries_iterator_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = boundaries_next(...)
 |      boundaries_next(p) -> boundaries_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = boundaries_second(...)
 |      boundaries_second(p) -> rangeset_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = boundaries_size(...)
 |      boundaries_size(map) -> size_t
 |  
 |  __swig_destroy__ = delete_boundaries_t(...)
 |      delete_boundaries_t(self)
 |  
 |  at(self, *args) -> 'rangeset_t &'
 |      at(self, _Keyval) -> rangeset_t
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = <class 'ida_hexrays.cinsn_t'>
 |      Proxy of C++ cinsn_t class.
 |  
 |  valuetype = <class 'ida_range.rangeset_t'>
 |      Proxy of C++ rangeset_t class.

Help on function call_helper in module ida_hexrays:

call_helper(rettype, args, *rest)

Help on class carg_t in module ida_hexrays:

class carg_t(cexpr_t)
 |  Proxy of C++ carg_t class.
 |  
 |  Method resolution order:
 |      carg_t
 |      cexpr_t
 |      citem_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> carg_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_carg_t(...)
 |      delete_carg_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  consume_cexpr(self, *args) -> 'void'
 |      consume_cexpr(self, e)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  formal_type
 |      carg_t_formal_type_get(self) -> tinfo_t
 |  
 |  is_vararg
 |      carg_t_is_vararg_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cexpr_t:
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _get_a(self, *args) -> 'carglist_t *'
 |      _get_a(self) -> carglist_t
 |  
 |  _get_fpc(self, *args) -> 'fnumber_t *'
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_helper(self, *args) -> 'char *'
 |      _get_helper(self) -> char *
 |  
 |  _get_insn(self, *args) -> 'cinsn_t *'
 |      _get_insn(self) -> cinsn_t
 |  
 |  _get_m(self, *args) -> 'int'
 |      _get_m(self) -> int
 |  
 |  _get_n(self, *args) -> 'cnumber_t *'
 |      _get_n(self) -> cnumber_t
 |  
 |  _get_obj_ea(self, *args) -> 'ea_t'
 |      _get_obj_ea(self) -> ea_t
 |  
 |  _get_ptrsize(self, *args) -> 'int'
 |      _get_ptrsize(self) -> int
 |  
 |  _get_refwidth(self, *args) -> 'int'
 |      _get_refwidth(self) -> int
 |  
 |  _get_string(self, *args) -> 'char *'
 |      _get_string(self) -> char *
 |  
 |  _get_x(self, *args) -> 'cexpr_t *'
 |      _get_x(self) -> cexpr_t
 |  
 |  _get_y(self, *args) -> 'cexpr_t *'
 |      _get_y(self) -> cexpr_t
 |  
 |  _get_z(self, *args) -> 'cexpr_t *'
 |      _get_z(self) -> cexpr_t
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _replace_by(self, *args) -> 'void'
 |      _replace_by(self, r)
 |  
 |  _set_a(self, *args) -> 'void'
 |      _set_a(self, _v)
 |  
 |  _set_fpc(self, *args) -> 'void'
 |      _set_fpc(self, _v)
 |  
 |  _set_helper(self, *args) -> 'void'
 |      _set_helper(self, _v)
 |  
 |  _set_insn(self, *args) -> 'void'
 |      _set_insn(self, _v)
 |  
 |  _set_m(self, *args) -> 'void'
 |      _set_m(self, _v)
 |  
 |  _set_n(self, *args) -> 'void'
 |      _set_n(self, _v)
 |  
 |  _set_obj_ea(self, *args) -> 'void'
 |      _set_obj_ea(self, _v)
 |  
 |  _set_ptrsize(self, *args) -> 'void'
 |      _set_ptrsize(self, _v)
 |  
 |  _set_refwidth(self, *args) -> 'void'
 |      _set_refwidth(self, _v)
 |  
 |  _set_string(self, *args) -> 'void'
 |      _set_string(self, _v)
 |  
 |  _set_x(self, *args) -> 'void'
 |      _set_x(self, _v)
 |  
 |  _set_y(self, *args) -> 'void'
 |      _set_y(self, _v)
 |  
 |  _set_z(self, *args) -> 'void'
 |      _set_z(self, _v)
 |  
 |  assign(self, *args) -> 'cexpr_t &'
 |      assign(self, r) -> cexpr_t
 |  
 |  calc_type(self, *args) -> 'void'
 |      calc_type(self, recursive)
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  contains_comma(self, *args) -> 'bool'
 |      contains_comma(self, times=1) -> bool
 |  
 |  contains_comma_or_insn_or_label(self, *args) -> 'bool'
 |      contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
 |  
 |  contains_insn(self, *args) -> 'bool'
 |      contains_insn(self, times=1) -> bool
 |  
 |  contains_insn_or_label(self, *args) -> 'bool'
 |      contains_insn_or_label(self) -> bool
 |  
 |  contains_operator(self, *args) -> 'bool'
 |      contains_operator(self, needed_op, times=1) -> bool
 |  
 |  cpadone(self, *args) -> 'bool'
 |      cpadone(self) -> bool
 |  
 |  equal_effect(self, *args) -> 'bool'
 |      equal_effect(self, r) -> bool
 |  
 |  find_num_op(self, *args) -> 'cexpr_t *'
 |      find_num_op(self) -> cexpr_t
 |      find_num_op(self) -> cexpr_t
 |  
 |  find_op(self, *args) -> 'cexpr_t *'
 |      find_op(self, _op) -> cexpr_t
 |      find_op(self, _op) -> cexpr_t
 |  
 |  get_1num_op(self, *args) -> 'bool'
 |      get_1num_op(self, o1, o2) -> bool
 |  
 |  get_const_value(self, *args) -> 'bool'
 |      get_const_value(self) -> bool
 |  
 |  get_high_nbit_bound(self, *args) -> 'bit_bound_t'
 |      get_high_nbit_bound(self) -> bit_bound_t
 |  
 |  get_low_nbit_bound(self, *args) -> 'int'
 |      get_low_nbit_bound(self) -> int
 |  
 |  get_ptr_or_array(self, *args) -> 'cexpr_t *'
 |      get_ptr_or_array(self) -> cexpr_t
 |  
 |  get_type_sign(self, *args) -> 'type_sign_t'
 |      get_type_sign(self) -> type_sign_t
 |  
 |  get_v(self, *args) -> 'var_ref_t *'
 |      get_v(self) -> var_ref_t
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self) -> bool
 |  
 |  is_call_arg_of(self, *args) -> 'bool'
 |      is_call_arg_of(self, parent) -> bool
 |  
 |  is_call_object_of(self, *args) -> 'bool'
 |      is_call_object_of(self, parent) -> bool
 |  
 |  is_child_of(self, *args) -> 'bool'
 |      is_child_of(self, parent) -> bool
 |  
 |  is_const_value(self, *args) -> 'bool'
 |      is_const_value(self, _v) -> bool
 |  
 |  is_cstr(self, *args) -> 'bool'
 |      is_cstr(self) -> bool
 |  
 |  is_fpop(self, *args) -> 'bool'
 |      is_fpop(self) -> bool
 |  
 |  is_jumpout(self, *args) -> 'bool'
 |      is_jumpout(self) -> bool
 |  
 |  is_negative_const(self, *args) -> 'bool'
 |      is_negative_const(self) -> bool
 |  
 |  is_nice_cond(self, *args) -> 'bool'
 |      is_nice_cond(self) -> bool
 |  
 |  is_nice_expr(self, *args) -> 'bool'
 |      is_nice_expr(self) -> bool
 |  
 |  is_non_negative_const(self, *args) -> 'bool'
 |      is_non_negative_const(self) -> bool
 |  
 |  is_non_zero_const(self, *args) -> 'bool'
 |      is_non_zero_const(self) -> bool
 |  
 |  is_odd_lvalue(self, *args) -> 'bool'
 |      is_odd_lvalue(self) -> bool
 |  
 |  is_type_signed(self, *args) -> 'bool'
 |      is_type_signed(self) -> bool
 |  
 |  is_type_unsigned(self, *args) -> 'bool'
 |      is_type_unsigned(self) -> bool
 |  
 |  is_undef_val(self, *args) -> 'bool'
 |      is_undef_val(self) -> bool
 |  
 |  is_vftable(self, *args) -> 'bool'
 |      is_vftable(self) -> bool
 |  
 |  is_zero_const(self, *args) -> 'bool'
 |      is_zero_const(self) -> bool
 |  
 |  maybe_ptr(self, *args) -> 'bool'
 |      maybe_ptr(self) -> bool
 |  
 |  numval(self, *args) -> 'uint64'
 |      numval(self) -> uint64
 |  
 |  print1(self, *args) -> 'void'
 |      print1(self, func)
 |  
 |  put_number(self, *args) -> 'void'
 |      put_number(self, func, value, nbytes, sign=no_sign)
 |  
 |  requires_lvalue(self, *args) -> 'bool'
 |      requires_lvalue(self, child) -> bool
 |  
 |  set_cpadone(self, *args) -> 'void'
 |      set_cpadone(self)
 |  
 |  set_v(self, *args) -> 'void'
 |      set_v(self, v)
 |  
 |  set_vftable(self, *args) -> 'void'
 |      set_vftable(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  theother(self, *args) -> 'cexpr_t *'
 |      theother(self, what) -> cexpr_t
 |      theother(self, what) -> cexpr_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cexpr_t:
 |  
 |  a
 |  
 |  exflags
 |      cexpr_t_exflags_get(self) -> uint32
 |  
 |  fpc
 |  
 |  helper
 |  
 |  insn
 |  
 |  m
 |  
 |  n
 |  
 |  obj_ea
 |  
 |  operands
 |      return a dictionary with the operands of a cexpr_t.
 |  
 |  opname
 |  
 |  ptrsize
 |  
 |  refwidth
 |  
 |  string
 |  
 |  type
 |      cexpr_t_type_get(self) -> tinfo_t
 |  
 |  v
 |  
 |  x
 |  
 |  y
 |  
 |  z
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from cexpr_t:
 |  
 |  op_to_typename = {0: 'empty', 1: 'comma', 2: 'asg', 3: 'asgbor', 4: 'a...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _get_op(self, *args) -> 'ctype_t'
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args) -> 'void'
 |      _set_op(self, v)
 |  
 |  contains_expr(self, *args) -> 'bool'
 |      contains_expr(self, e) -> bool
 |  
 |  contains_label(self, *args) -> 'bool'
 |      contains_label(self) -> bool
 |  
 |  find_closest_addr(self, *args) -> 'citem_t *'
 |      find_closest_addr(self, _ea) -> citem_t
 |  
 |  find_parent_of(self, *args) -> 'citem_t *'
 |      find_parent_of(self, sitem) -> citem_t
 |      find_parent_of(self, item) -> citem_t
 |  
 |  is_expr(self, *args) -> 'bool'
 |      is_expr(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cexpr
 |      citem_t_cexpr_get(self) -> cexpr_t
 |  
 |  cinsn
 |      citem_t_cinsn_get(self) -> cinsn_t
 |  
 |  ea
 |      citem_t_ea_get(self) -> ea_t
 |  
 |  index
 |      citem_t_index_get(self) -> int
 |  
 |  label_num
 |      citem_t_label_num_get(self) -> int
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on class carglist_t in module ida_hexrays:

class carglist_t(qvector_carg_t)
 |  Proxy of C++ carglist_t class.
 |  
 |  Method resolution order:
 |      carglist_t
 |      qvector_carg_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> carglist_t
 |      __init__(self, ftype, fl=0) -> carglist_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_carglist_t(...)
 |      delete_carglist_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  flags
 |      carglist_t_flags_get(self) -> int
 |  
 |  functype
 |      carglist_t_functype_get(self) -> tinfo_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_carg_t:
 |  
 |  __getitem__(self, *args) -> 'carg_t const &'
 |      __getitem__(self, i) -> carg_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'carg_t &'
 |      push_back(self, x)
 |      push_back(self) -> carg_t
 |  
 |  at = __getitem__(self, *args) -> 'carg_t const &'
 |      __getitem__(self, i) -> carg_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      begin(self) -> carg_t
 |      begin(self) -> carg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      end(self) -> carg_t
 |      end(self) -> carg_t
 |  
 |  erase(self, *args) -> 'qvector< carg_t >::iterator'
 |      erase(self, it) -> carg_t
 |      erase(self, first, last) -> carg_t
 |  
 |  extract(self, *args) -> 'carg_t *'
 |      extract(self) -> carg_t
 |  
 |  find(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      find(self, x) -> carg_t
 |      find(self, x) -> carg_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=carg_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< carg_t >::iterator'
 |      insert(self, it, x) -> carg_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'carg_t &'
 |      push_back(self, x)
 |      push_back(self) -> carg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_carg_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class casm_t in module ida_hexrays:

class casm_t(ida_pro.eavec_t)↗
 |  Proxy of C++ casm_t class.
 |  
 |  Method resolution order:
 |      casm_t
 |      ida_pro.eavec_t↗
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, ea) -> casm_t
 |      __init__(self, r) -> casm_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_casm_t(...)
 |      delete_casm_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  one_insn(self, *args) -> 'bool'
 |      one_insn(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_pro.eavec_t:↗
 |  
 |  __getitem__(self, *args) -> 'unsigned-ea-like-numeric-type const &'↗
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &↗
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'unsigned-ea-like-numeric-type &'↗
 |      push_back(self, x)
 |      push_back(self) -> unsigned-ea-like-numeric-type &↗
 |  
 |  at = __getitem__(self, *args) -> 'unsigned-ea-like-numeric-type const &'↗
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &↗
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< unsigned-ea-like-numeric-type >::const_iterator'↗
 |      begin(self) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |      begin(self) -> qvector< unsigned-ea-like-numeric-type >::const_iterator↗
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< unsigned-ea-like-numeric-type >::const_iterator'↗
 |      end(self) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |      end(self) -> qvector< unsigned-ea-like-numeric-type >::const_iterator↗
 |  
 |  erase(self, *args) -> 'qvector< unsigned-ea-like-numeric-type >::iterator'↗
 |      erase(self, it) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |      erase(self, first, last) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  extract(self, *args) -> 'unsigned-ea-like-numeric-type *'↗
 |      extract(self) -> unsigned-ea-like-numeric-type *↗
 |  
 |  find(self, *args) -> 'qvector< unsigned-ea-like-numeric-type >::const_iterator'↗
 |      find(self, x) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |      find(self, x) -> qvector< unsigned-ea-like-numeric-type >::const_iterator↗
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< unsigned-ea-like-numeric-type >::iterator'↗
 |      insert(self, it, x) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'unsigned-ea-like-numeric-type &'↗
 |      push_back(self, x)
 |      push_back(self) -> unsigned-ea-like-numeric-type &↗
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_pro.eavec_t:↗
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function cblock_at in module ida_hexrays:

cblock_at(self, index)
    # cblock.at(int) -> returns the item at the given index index

Help on function cblock_find in module ida_hexrays:

cblock_find(self, item)
    # cblock.find(cinsn_t) -> returns the iterator positioned at the given item

Help on function cblock_index in module ida_hexrays:

cblock_index(self, item)
    # cblock.index(cinsn_t) -> returns the index of the given item

Help on function cblock_insert in module ida_hexrays:

cblock_insert(self, index, item)
    # cblock.insert(index, cinsn_t)

Help on function cblock_iter in module ida_hexrays:

cblock_iter(self)

Help on function cblock_remove in module ida_hexrays:

cblock_remove(self, item)
    # cblock.remove(cinsn_t)

Help on class cblock_t in module ida_hexrays:

class cblock_t(qlist_cinsn_t)
 |  Proxy of C++ cblock_t class.
 |  
 |  Method resolution order:
 |      cblock_t
 |      qlist_cinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cblock_t
 |  
 |  __iter__ = cblock_iter(self)
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cblock_t(...)
 |      delete_cblock_t(self)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  at = cblock_at(self, index)
 |      # cblock.at(int) -> returns the item at the given index index
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  find = cblock_find(self, item)
 |      # cblock.find(cinsn_t) -> returns the iterator positioned at the given item
 |  
 |  index = cblock_index(self, item)
 |      # cblock.index(cinsn_t) -> returns the index of the given item
 |  
 |  insert = cblock_insert(self, index, item)
 |      # cblock.insert(index, cinsn_t)
 |  
 |  remove = cblock_remove(self, item)
 |      # cblock.remove(cinsn_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qlist_cinsn_t:
 |  
 |  back(self, *args) -> 'cinsn_t const &'
 |      back(self) -> cinsn_t
 |      back(self) -> cinsn_t
 |  
 |  begin(self, *args) -> 'qlist_cinsn_t_iterator'
 |      begin(self) -> qlist_cinsn_t_iterator
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qlist_cinsn_t_iterator'
 |      end(self) -> qlist_cinsn_t_iterator
 |  
 |  erase(self, *args) -> 'void'
 |      erase(self, p) -> qlist< cinsn_t >::iterator
 |      erase(self, p1, p2)
 |      erase(self, p)
 |  
 |  front(self, *args) -> 'cinsn_t const &'
 |      front(self) -> cinsn_t
 |      front(self) -> cinsn_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  pop_front(self, *args) -> 'void'
 |      pop_front(self)
 |  
 |  push_back(self, *args) -> 'cinsn_t &'
 |      push_back(self, x)
 |      push_back(self) -> cinsn_t
 |  
 |  push_front(self, *args) -> 'void'
 |      push_front(self, x)
 |  
 |  rbegin(self, *args) -> 'qlist< cinsn_t >::const_reverse_iterator'
 |      rbegin(self) -> qlist< cinsn_t >::reverse_iterator
 |      rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  rend(self, *args) -> 'qlist< cinsn_t >::const_reverse_iterator'
 |      rend(self) -> qlist< cinsn_t >::reverse_iterator
 |      rend(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, x)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qlist_cinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class ccase_t in module ida_hexrays:

class ccase_t(cinsn_t)
 |  Proxy of C++ ccase_t class.
 |  
 |  Method resolution order:
 |      ccase_t
 |      cinsn_t
 |      citem_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ccase_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ccase_t(...)
 |      delete_ccase_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  value(self, *args) -> 'uint64 const &'
 |      value(self, i) -> uint64 const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  values
 |      ccase_t_values_get(self) -> ulonglongvec_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cinsn_t:
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _get_casm(self, *args) -> 'casm_t *'
 |      _get_casm(self) -> casm_t
 |  
 |  _get_cblock(self, *args) -> 'cblock_t *'
 |      _get_cblock(self) -> cblock_t
 |  
 |  _get_cdo(self, *args) -> 'cdo_t *'
 |      _get_cdo(self) -> cdo_t
 |  
 |  _get_cexpr(self, *args) -> 'cexpr_t *'
 |      _get_cexpr(self) -> cexpr_t
 |  
 |  _get_cfor(self, *args) -> 'cfor_t *'
 |      _get_cfor(self) -> cfor_t
 |  
 |  _get_cgoto(self, *args) -> 'cgoto_t *'
 |      _get_cgoto(self) -> cgoto_t
 |  
 |  _get_cif(self, *args) -> 'cif_t *'
 |      _get_cif(self) -> cif_t
 |  
 |  _get_creturn(self, *args) -> 'creturn_t *'
 |      _get_creturn(self) -> creturn_t
 |  
 |  _get_cswitch(self, *args) -> 'cswitch_t *'
 |      _get_cswitch(self) -> cswitch_t
 |  
 |  _get_cwhile(self, *args) -> 'cwhile_t *'
 |      _get_cwhile(self) -> cwhile_t
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _replace_by(self, *args) -> 'void'
 |      _replace_by(self, r)
 |  
 |  _set_casm(self, *args) -> 'void'
 |      _set_casm(self, _v)
 |  
 |  _set_cblock(self, *args) -> 'void'
 |      _set_cblock(self, _v)
 |  
 |  _set_cdo(self, *args) -> 'void'
 |      _set_cdo(self, _v)
 |  
 |  _set_cexpr(self, *args) -> 'void'
 |      _set_cexpr(self, _v)
 |  
 |  _set_cfor(self, *args) -> 'void'
 |      _set_cfor(self, _v)
 |  
 |  _set_cgoto(self, *args) -> 'void'
 |      _set_cgoto(self, _v)
 |  
 |  _set_cif(self, *args) -> 'void'
 |      _set_cif(self, _v)
 |  
 |  _set_creturn(self, *args) -> 'void'
 |      _set_creturn(self, _v)
 |  
 |  _set_cswitch(self, *args) -> 'void'
 |      _set_cswitch(self, _v)
 |  
 |  _set_cwhile(self, *args) -> 'void'
 |      _set_cwhile(self, _v)
 |  
 |  assign(self, *args) -> 'cinsn_t &'
 |      assign(self, r) -> cinsn_t
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  collect_free_breaks(self, *args) -> 'bool'
 |      collect_free_breaks(self, breaks) -> bool
 |  
 |  collect_free_continues(self, *args) -> 'bool'
 |      collect_free_continues(self, continues) -> bool
 |  
 |  contains_free_break(self, *args) -> 'bool'
 |      contains_free_break(self) -> bool
 |  
 |  contains_free_continue(self, *args) -> 'bool'
 |      contains_free_continue(self) -> bool
 |  
 |  contains_insn(self, *args) -> 'bool'
 |      contains_insn(self, type, times=1) -> bool
 |  
 |  create_if(self, *args) -> 'cif_t &'
 |      create_if(self, cnd) -> cif_t
 |  
 |  is_epilog(self)
 |  
 |  is_ordinary_flow(self, *args) -> 'bool'
 |      is_ordinary_flow(self) -> bool
 |  
 |  new_insn(self, *args) -> 'cinsn_t &'
 |      new_insn(self, insn_ea) -> cinsn_t
 |  
 |  print1(self, *args) -> 'void'
 |      print1(self, func)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  zero(self, *args) -> 'void'
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from cinsn_t:
 |  
 |  insn_is_epilog(*args) -> 'bool'
 |      insn_is_epilog(insn) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cinsn_t:
 |  
 |  casm
 |  
 |  cblock
 |  
 |  cdo
 |  
 |  cexpr
 |  
 |  cfor
 |  
 |  cgoto
 |  
 |  cif
 |  
 |  creturn
 |  
 |  cswitch
 |  
 |  cwhile
 |  
 |  details
 |      return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.
 |  
 |  opname
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from cinsn_t:
 |  
 |  op_to_typename = {70: 'empty', 71: 'block', 72: 'expr', 73: 'if', 74: ...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _get_op(self, *args) -> 'ctype_t'
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args) -> 'void'
 |      _set_op(self, v)
 |  
 |  contains_expr(self, *args) -> 'bool'
 |      contains_expr(self, e) -> bool
 |  
 |  contains_label(self, *args) -> 'bool'
 |      contains_label(self) -> bool
 |  
 |  find_closest_addr(self, *args) -> 'citem_t *'
 |      find_closest_addr(self, _ea) -> citem_t
 |  
 |  find_parent_of(self, *args) -> 'citem_t *'
 |      find_parent_of(self, sitem) -> citem_t
 |      find_parent_of(self, item) -> citem_t
 |  
 |  is_expr(self, *args) -> 'bool'
 |      is_expr(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cinsn
 |      citem_t_cinsn_get(self) -> cinsn_t
 |  
 |  ea
 |      citem_t_ea_get(self) -> ea_t
 |  
 |  index
 |      citem_t_index_get(self) -> int
 |  
 |  label_num
 |      citem_t_label_num_get(self) -> int
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on class ccases_t in module ida_hexrays:

class ccases_t(qvector_ccase_t)
 |  Proxy of C++ ccases_t class.
 |  
 |  Method resolution order:
 |      ccases_t
 |      qvector_ccase_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ccases_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ccases_t(...)
 |      delete_ccases_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_ccase_t:
 |  
 |  __getitem__(self, *args) -> 'ccase_t const &'
 |      __getitem__(self, i) -> ccase_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'ccase_t &'
 |      push_back(self, x)
 |      push_back(self) -> ccase_t
 |  
 |  at = __getitem__(self, *args) -> 'ccase_t const &'
 |      __getitem__(self, i) -> ccase_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      begin(self) -> ccase_t
 |      begin(self) -> ccase_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      end(self) -> ccase_t
 |      end(self) -> ccase_t
 |  
 |  erase(self, *args) -> 'qvector< ccase_t >::iterator'
 |      erase(self, it) -> ccase_t
 |      erase(self, first, last) -> ccase_t
 |  
 |  extract(self, *args) -> 'ccase_t *'
 |      extract(self) -> ccase_t
 |  
 |  find(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      find(self, x) -> ccase_t
 |      find(self, x) -> ccase_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=ccase_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< ccase_t >::iterator'
 |      insert(self, it, x) -> ccase_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'ccase_t &'
 |      push_back(self, x)
 |      push_back(self) -> ccase_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_ccase_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class cdg_insn_iterator_t in module ida_hexrays:

class cdg_insn_iterator_t(builtins.object)
 |  Proxy of C++ cdg_insn_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cdg_insn_iterator_t
 |      __init__(self, r) -> cdg_insn_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cdg_insn_iterator_t(...)
 |      delete_cdg_insn_iterator_t(self)
 |  
 |  dslot_with_xrefs(self, *args) -> 'bool'
 |      dslot_with_xrefs(self) -> bool
 |  
 |  has_dslot(self, *args) -> 'bool'
 |      has_dslot(self) -> bool
 |  
 |  next(self, *args) -> 'merror_t'
 |      next(self, ins) -> merror_t
 |  
 |  ok(self, *args) -> 'bool'
 |      ok(self) -> bool
 |  
 |  start(self, *args) -> 'void'
 |      start(self, rng)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dslot
 |      cdg_insn_iterator_t_dslot_get(self) -> ea_t
 |  
 |  dslot_insn
 |      cdg_insn_iterator_t_dslot_insn_get(self) -> insn_t *
 |  
 |  ea
 |      cdg_insn_iterator_t_ea_get(self) -> ea_t
 |  
 |  end
 |      cdg_insn_iterator_t_end_get(self) -> ea_t
 |  
 |  is_likely_dslot
 |      cdg_insn_iterator_t_is_likely_dslot_get(self) -> bool
 |  
 |  is_separate_dslot
 |      cdg_insn_iterator_t_is_separate_dslot_get(self) -> bool
 |  
 |  thisown
 |      The membership flag

Help on class cdo_t in module ida_hexrays:

class cdo_t(cloop_t)
 |  Proxy of C++ cdo_t class.
 |  
 |  Method resolution order:
 |      cdo_t
 |      cloop_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cdo_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cdo_t(...)
 |      delete_cdo_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cloop_t:
 |  
 |  assign(self, *args) -> 'cloop_t &'
 |      assign(self, r) -> cloop_t
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cloop_t:
 |  
 |  body
 |      cloop_t_body_get(self) -> cinsn_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on class ceinsn_t in module ida_hexrays:

class ceinsn_t(builtins.object)
 |  Proxy of C++ ceinsn_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ceinsn_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ceinsn_t(...)
 |      delete_ceinsn_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t
 |  
 |  thisown
 |      The membership flag

Help on function cexpr_operands in module ida_hexrays:

cexpr_operands(self)
    return a dictionary with the operands of a cexpr_t.

Help on class cexpr_t in module ida_hexrays:

class cexpr_t(citem_t)
 |  Proxy of C++ cexpr_t class.
 |  
 |  Method resolution order:
 |      cexpr_t
 |      citem_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cexpr_t
 |      __init__(self, cop, _x) -> cexpr_t
 |      __init__(self, cop, _x, _y) -> cexpr_t
 |      __init__(self, cop, _x, _y, _z) -> cexpr_t
 |      __init__(self, r) -> cexpr_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cexpr_t(...)
 |      delete_cexpr_t(self)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _get_a(self, *args) -> 'carglist_t *'
 |      _get_a(self) -> carglist_t
 |  
 |  _get_fpc(self, *args) -> 'fnumber_t *'
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_helper(self, *args) -> 'char *'
 |      _get_helper(self) -> char *
 |  
 |  _get_insn(self, *args) -> 'cinsn_t *'
 |      _get_insn(self) -> cinsn_t
 |  
 |  _get_m(self, *args) -> 'int'
 |      _get_m(self) -> int
 |  
 |  _get_n(self, *args) -> 'cnumber_t *'
 |      _get_n(self) -> cnumber_t
 |  
 |  _get_obj_ea(self, *args) -> 'ea_t'
 |      _get_obj_ea(self) -> ea_t
 |  
 |  _get_ptrsize(self, *args) -> 'int'
 |      _get_ptrsize(self) -> int
 |  
 |  _get_refwidth(self, *args) -> 'int'
 |      _get_refwidth(self) -> int
 |  
 |  _get_string(self, *args) -> 'char *'
 |      _get_string(self) -> char *
 |  
 |  _get_x(self, *args) -> 'cexpr_t *'
 |      _get_x(self) -> cexpr_t
 |  
 |  _get_y(self, *args) -> 'cexpr_t *'
 |      _get_y(self) -> cexpr_t
 |  
 |  _get_z(self, *args) -> 'cexpr_t *'
 |      _get_z(self) -> cexpr_t
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _replace_by(self, *args) -> 'void'
 |      _replace_by(self, r)
 |  
 |  _set_a(self, *args) -> 'void'
 |      _set_a(self, _v)
 |  
 |  _set_fpc(self, *args) -> 'void'
 |      _set_fpc(self, _v)
 |  
 |  _set_helper(self, *args) -> 'void'
 |      _set_helper(self, _v)
 |  
 |  _set_insn(self, *args) -> 'void'
 |      _set_insn(self, _v)
 |  
 |  _set_m(self, *args) -> 'void'
 |      _set_m(self, _v)
 |  
 |  _set_n(self, *args) -> 'void'
 |      _set_n(self, _v)
 |  
 |  _set_obj_ea(self, *args) -> 'void'
 |      _set_obj_ea(self, _v)
 |  
 |  _set_ptrsize(self, *args) -> 'void'
 |      _set_ptrsize(self, _v)
 |  
 |  _set_refwidth(self, *args) -> 'void'
 |      _set_refwidth(self, _v)
 |  
 |  _set_string(self, *args) -> 'void'
 |      _set_string(self, _v)
 |  
 |  _set_x(self, *args) -> 'void'
 |      _set_x(self, _v)
 |  
 |  _set_y(self, *args) -> 'void'
 |      _set_y(self, _v)
 |  
 |  _set_z(self, *args) -> 'void'
 |      _set_z(self, _v)
 |  
 |  assign(self, *args) -> 'cexpr_t &'
 |      assign(self, r) -> cexpr_t
 |  
 |  calc_type(self, *args) -> 'void'
 |      calc_type(self, recursive)
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains_comma(self, *args) -> 'bool'
 |      contains_comma(self, times=1) -> bool
 |  
 |  contains_comma_or_insn_or_label(self, *args) -> 'bool'
 |      contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
 |  
 |  contains_insn(self, *args) -> 'bool'
 |      contains_insn(self, times=1) -> bool
 |  
 |  contains_insn_or_label(self, *args) -> 'bool'
 |      contains_insn_or_label(self) -> bool
 |  
 |  contains_operator(self, *args) -> 'bool'
 |      contains_operator(self, needed_op, times=1) -> bool
 |  
 |  cpadone(self, *args) -> 'bool'
 |      cpadone(self) -> bool
 |  
 |  equal_effect(self, *args) -> 'bool'
 |      equal_effect(self, r) -> bool
 |  
 |  find_num_op(self, *args) -> 'cexpr_t *'
 |      find_num_op(self) -> cexpr_t
 |      find_num_op(self) -> cexpr_t
 |  
 |  find_op(self, *args) -> 'cexpr_t *'
 |      find_op(self, _op) -> cexpr_t
 |      find_op(self, _op) -> cexpr_t
 |  
 |  get_1num_op(self, *args) -> 'bool'
 |      get_1num_op(self, o1, o2) -> bool
 |  
 |  get_const_value(self, *args) -> 'bool'
 |      get_const_value(self) -> bool
 |  
 |  get_high_nbit_bound(self, *args) -> 'bit_bound_t'
 |      get_high_nbit_bound(self) -> bit_bound_t
 |  
 |  get_low_nbit_bound(self, *args) -> 'int'
 |      get_low_nbit_bound(self) -> int
 |  
 |  get_ptr_or_array(self, *args) -> 'cexpr_t *'
 |      get_ptr_or_array(self) -> cexpr_t
 |  
 |  get_type_sign(self, *args) -> 'type_sign_t'
 |      get_type_sign(self) -> type_sign_t
 |  
 |  get_v(self, *args) -> 'var_ref_t *'
 |      get_v(self) -> var_ref_t
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self) -> bool
 |  
 |  is_call_arg_of(self, *args) -> 'bool'
 |      is_call_arg_of(self, parent) -> bool
 |  
 |  is_call_object_of(self, *args) -> 'bool'
 |      is_call_object_of(self, parent) -> bool
 |  
 |  is_child_of(self, *args) -> 'bool'
 |      is_child_of(self, parent) -> bool
 |  
 |  is_const_value(self, *args) -> 'bool'
 |      is_const_value(self, _v) -> bool
 |  
 |  is_cstr(self, *args) -> 'bool'
 |      is_cstr(self) -> bool
 |  
 |  is_fpop(self, *args) -> 'bool'
 |      is_fpop(self) -> bool
 |  
 |  is_jumpout(self, *args) -> 'bool'
 |      is_jumpout(self) -> bool
 |  
 |  is_negative_const(self, *args) -> 'bool'
 |      is_negative_const(self) -> bool
 |  
 |  is_nice_cond(self, *args) -> 'bool'
 |      is_nice_cond(self) -> bool
 |  
 |  is_nice_expr(self, *args) -> 'bool'
 |      is_nice_expr(self) -> bool
 |  
 |  is_non_negative_const(self, *args) -> 'bool'
 |      is_non_negative_const(self) -> bool
 |  
 |  is_non_zero_const(self, *args) -> 'bool'
 |      is_non_zero_const(self) -> bool
 |  
 |  is_odd_lvalue(self, *args) -> 'bool'
 |      is_odd_lvalue(self) -> bool
 |  
 |  is_type_signed(self, *args) -> 'bool'
 |      is_type_signed(self) -> bool
 |  
 |  is_type_unsigned(self, *args) -> 'bool'
 |      is_type_unsigned(self) -> bool
 |  
 |  is_undef_val(self, *args) -> 'bool'
 |      is_undef_val(self) -> bool
 |  
 |  is_vftable(self, *args) -> 'bool'
 |      is_vftable(self) -> bool
 |  
 |  is_zero_const(self, *args) -> 'bool'
 |      is_zero_const(self) -> bool
 |  
 |  maybe_ptr(self, *args) -> 'bool'
 |      maybe_ptr(self) -> bool
 |  
 |  numval(self, *args) -> 'uint64'
 |      numval(self) -> uint64
 |  
 |  print1(self, *args) -> 'void'
 |      print1(self, func)
 |  
 |  put_number(self, *args) -> 'void'
 |      put_number(self, func, value, nbytes, sign=no_sign)
 |  
 |  requires_lvalue(self, *args) -> 'bool'
 |      requires_lvalue(self, child) -> bool
 |  
 |  set_cpadone(self, *args) -> 'void'
 |      set_cpadone(self)
 |  
 |  set_v(self, *args) -> 'void'
 |      set_v(self, v)
 |  
 |  set_vftable(self, *args) -> 'void'
 |      set_vftable(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  theother(self, *args) -> 'cexpr_t *'
 |      theother(self, what) -> cexpr_t
 |      theother(self, what) -> cexpr_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  a
 |  
 |  exflags
 |      cexpr_t_exflags_get(self) -> uint32
 |  
 |  fpc
 |  
 |  helper
 |  
 |  insn
 |  
 |  m
 |  
 |  n
 |  
 |  obj_ea
 |  
 |  operands
 |      return a dictionary with the operands of a cexpr_t.
 |  
 |  opname
 |  
 |  ptrsize
 |  
 |  refwidth
 |  
 |  string
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      cexpr_t_type_get(self) -> tinfo_t
 |  
 |  v
 |  
 |  x
 |  
 |  y
 |  
 |  z
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  op_to_typename = {0: 'empty', 1: 'comma', 2: 'asg', 3: 'asgbor', 4: 'a...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _get_op(self, *args) -> 'ctype_t'
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args) -> 'void'
 |      _set_op(self, v)
 |  
 |  contains_expr(self, *args) -> 'bool'
 |      contains_expr(self, e) -> bool
 |  
 |  contains_label(self, *args) -> 'bool'
 |      contains_label(self) -> bool
 |  
 |  find_closest_addr(self, *args) -> 'citem_t *'
 |      find_closest_addr(self, _ea) -> citem_t
 |  
 |  find_parent_of(self, *args) -> 'citem_t *'
 |      find_parent_of(self, sitem) -> citem_t
 |      find_parent_of(self, item) -> citem_t
 |  
 |  is_expr(self, *args) -> 'bool'
 |      is_expr(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cexpr
 |      citem_t_cexpr_get(self) -> cexpr_t
 |  
 |  cinsn
 |      citem_t_cinsn_get(self) -> cinsn_t
 |  
 |  ea
 |      citem_t_ea_get(self) -> ea_t
 |  
 |  index
 |      citem_t_index_get(self) -> int
 |  
 |  label_num
 |      citem_t_label_num_get(self) -> int
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on class cfor_t in module ida_hexrays:

class cfor_t(cloop_t)
 |  Proxy of C++ cfor_t class.
 |  
 |  Method resolution order:
 |      cfor_t
 |      cloop_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cfor_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cfor_t(...)
 |      delete_cfor_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  init
 |      cfor_t_init_get(self) -> cexpr_t
 |  
 |  step
 |      cfor_t_step_get(self) -> cexpr_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cloop_t:
 |  
 |  assign(self, *args) -> 'cloop_t &'
 |      assign(self, r) -> cloop_t
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cloop_t:
 |  
 |  body
 |      cloop_t_body_get(self) -> cinsn_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on class cfunc_parentee_t in module ida_hexrays:

class cfunc_parentee_t(ctree_parentee_t)
 |  Proxy of C++ cfunc_parentee_t class.
 |  
 |  Method resolution order:
 |      cfunc_parentee_t
 |      ctree_parentee_t
 |      ctree_visitor_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, f, post=False) -> cfunc_parentee_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cfunc_parentee_t(...)
 |      delete_cfunc_parentee_t(self)
 |  
 |  calc_rvalue_type(self, *args) -> 'bool'
 |      calc_rvalue_type(self, target, e) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  func
 |      cfunc_parentee_t_func_get(self) -> cfunc_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctree_parentee_t:
 |  
 |  recalc_parent_types(self, *args) -> 'bool'
 |      recalc_parent_types(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctree_visitor_t:
 |  
 |  apply_to(self, *args) -> 'int'
 |      apply_to(self, item, parent) -> int
 |  
 |  apply_to_exprs(self, *args) -> 'int'
 |      apply_to_exprs(self, item, parent) -> int
 |  
 |  clr_prune(self, *args) -> 'void'
 |      clr_prune(self)
 |  
 |  clr_restart(self, *args) -> 'void'
 |      clr_restart(self)
 |  
 |  is_postorder(self, *args) -> 'bool'
 |      is_postorder(self) -> bool
 |  
 |  leave_expr(self, *args) -> 'int'
 |      leave_expr(self, arg0) -> int
 |  
 |  leave_insn(self, *args) -> 'int'
 |      leave_insn(self, arg0) -> int
 |  
 |  maintain_parents(self, *args) -> 'bool'
 |      maintain_parents(self) -> bool
 |  
 |  must_prune(self, *args) -> 'bool'
 |      must_prune(self) -> bool
 |  
 |  must_restart(self, *args) -> 'bool'
 |      must_restart(self) -> bool
 |  
 |  only_insns(self, *args) -> 'bool'
 |      only_insns(self) -> bool
 |  
 |  parent_expr(self, *args) -> 'cexpr_t *'
 |      parent_expr(self) -> cexpr_t
 |  
 |  parent_insn(self, *args) -> 'cinsn_t *'
 |      parent_insn(self) -> cinsn_t
 |  
 |  prune_now(self, *args) -> 'void'
 |      prune_now(self)
 |  
 |  set_restart(self, *args) -> 'void'
 |      set_restart(self)
 |  
 |  visit_expr(self, *args) -> 'int'
 |      visit_expr(self, arg0) -> int
 |  
 |  visit_insn(self, *args) -> 'int'
 |      visit_insn(self, arg0) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ctree_visitor_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cv_flags
 |      ctree_visitor_t_cv_flags_get(self) -> int
 |  
 |  parents
 |      ctree_visitor_t_parents_get(self) -> ctree_items_t

Help on class cfunc_t in module ida_hexrays:

class cfunc_t(builtins.object)
 |  Proxy of C++ cfunc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args) -> 'qstring'
 |      __str__(self) -> qstring
 |  
 |  __swig_destroy__ = delete_cfunc_t(...)
 |      delete_cfunc_t(self)
 |  
 |  build_c_tree(self, *args) -> 'void'
 |      build_c_tree(self)
 |  
 |  del_orphan_cmts(self, *args) -> 'int'
 |      del_orphan_cmts(self) -> int
 |  
 |  find_item_coords(self, *args) -> 'PyObject *'
 |      find_item_coords(self, item, px, py) -> bool
 |      find_item_coords(self, item) -> PyObject *
 |  
 |  find_label(self, *args) -> 'citem_t *'
 |      find_label(self, label) -> citem_t
 |  
 |  gather_derefs(self, *args) -> 'bool'
 |      gather_derefs(self, ci, udm=None) -> bool
 |  
 |  get_boundaries(self, *args) -> 'boundaries_t &'
 |      get_boundaries(self) -> boundaries_t
 |  
 |  get_eamap(self, *args) -> 'eamap_t &'
 |      get_eamap(self) -> eamap_t
 |  
 |  get_func_type(self, *args) -> 'bool'
 |      get_func_type(self, type) -> bool
 |  
 |  get_line_item(self, *args) -> 'bool'
 |      get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
 |  
 |  get_lvars(self, *args) -> 'lvars_t *'
 |      get_lvars(self) -> lvars_t
 |  
 |  get_pseudocode(self, *args) -> 'strvec_t const &'
 |      get_pseudocode(self) -> strvec_t
 |  
 |  get_stkoff_delta(self, *args) -> 'sval_t'
 |      get_stkoff_delta(self) -> sval_t
 |  
 |  get_user_cmt(self, *args) -> 'char const *'
 |      get_user_cmt(self, loc, rt) -> char const *
 |  
 |  get_user_iflags(self, *args) -> 'int32'
 |      get_user_iflags(self, loc) -> int32
 |  
 |  get_user_union_selection(self, *args) -> 'bool'
 |      get_user_union_selection(self, ea, path) -> bool
 |  
 |  get_warnings(self, *args) -> 'hexwarns_t &'
 |      get_warnings(self) -> hexwarns_t
 |  
 |  has_orphan_cmts(self, *args) -> 'bool'
 |      has_orphan_cmts(self) -> bool
 |  
 |  print_dcl(self, *args) -> 'void'
 |      print_dcl(self)
 |  
 |  print_func(self, *args) -> 'void'
 |      print_func(self, vp)
 |  
 |  refresh_func_ctext(self, *args) -> 'void'
 |      refresh_func_ctext(self)
 |  
 |  release(self, *args) -> 'void'
 |      release(self)
 |  
 |  remove_unused_labels(self, *args) -> 'void'
 |      remove_unused_labels(self)
 |  
 |  save_user_cmts(self, *args) -> 'void'
 |      save_user_cmts(self)
 |  
 |  save_user_iflags(self, *args) -> 'void'
 |      save_user_iflags(self)
 |  
 |  save_user_labels(self, *args) -> 'void'
 |      save_user_labels(self)
 |  
 |  save_user_numforms(self, *args) -> 'void'
 |      save_user_numforms(self)
 |  
 |  save_user_unions(self, *args) -> 'void'
 |      save_user_unions(self)
 |  
 |  set_user_cmt(self, *args) -> 'void'
 |      set_user_cmt(self, loc, cmt)
 |  
 |  set_user_iflags(self, *args) -> 'void'
 |      set_user_iflags(self, loc, iflags)
 |  
 |  set_user_union_selection(self, *args) -> 'void'
 |      set_user_union_selection(self, ea, path)
 |  
 |  verify(self, *args) -> 'void'
 |      verify(self, aul, even_without_debugger)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  argidx
 |      cfunc_t_argidx_get(self) -> intvec_t
 |  
 |  arguments
 |  
 |  body
 |      cfunc_t_body_get(self) -> cinsn_t
 |  
 |  boundaries
 |      get_boundaries(self) -> boundaries_t
 |  
 |  eamap
 |      get_eamap(self) -> eamap_t
 |  
 |  entry_ea
 |      cfunc_t_entry_ea_get(self) -> ea_t
 |  
 |  hdrlines
 |      cfunc_t_hdrlines_get(self) -> int
 |  
 |  lvars
 |      get_lvars(self) -> lvars_t
 |  
 |  maturity
 |      cfunc_t_maturity_get(self) -> ctree_maturity_t
 |  
 |  mba
 |      cfunc_t_mba_get(self) -> mbl_array_t
 |  
 |  numforms
 |      cfunc_t_numforms_get(self) -> user_numforms_t
 |  
 |  pseudocode
 |      get_pseudocode(self) -> strvec_t
 |  
 |  refcnt
 |      cfunc_t_refcnt_get(self) -> int
 |  
 |  statebits
 |      cfunc_t_statebits_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  treeitems
 |      cfunc_t_treeitems_get(self) -> ctree_items_t
 |  
 |  type
 |      Get the function's return type tinfo_t object.
 |  
 |  user_cmts
 |      cfunc_t_user_cmts_get(self) -> user_cmts_t
 |  
 |  user_iflags
 |      cfunc_t_user_iflags_get(self) -> user_iflags_t
 |  
 |  user_labels
 |      cfunc_t_user_labels_get(self) -> user_labels_t
 |  
 |  user_unions
 |      cfunc_t_user_unions_get(self) -> user_unions_t
 |  
 |  warnings
 |      get_warnings(self) -> hexwarns_t

Help on function cfunc_type in module ida_hexrays:

cfunc_type(self)
    Get the function's return type tinfo_t object.

Help on class cfuncptr_t in module ida_hexrays:

class cfuncptr_t(builtins.object)
 |  Proxy of C++ qrefcnt_t< cfunc_t > class.
 |  
 |  Methods defined here:
 |  
 |  __deref__(self, *args) -> 'cfunc_t *'
 |      __deref__(self) -> cfunc_t
 |  
 |  __eq__ lambda self, other
 |  
 |  __init__(self, *args)
 |      __init__(self, p) -> cfuncptr_t
 |      __init__(self, r) -> cfuncptr_t
 |  
 |  __ptrval__(self, *args) -> 'size_t'
 |      __ptrval__(self) -> size_t
 |  
 |  __ref__(self, *args) -> 'cfunc_t &'
 |      __ref__(self) -> cfunc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__ lambda self
 |  
 |  __swig_destroy__ = delete_cfuncptr_t(...)
 |      delete_cfuncptr_t(self)
 |  
 |  build_c_tree(self, *args) -> 'void'
 |      build_c_tree(self)
 |  
 |  del_orphan_cmts(self, *args) -> 'int'
 |      del_orphan_cmts(self) -> int
 |  
 |  find_item_coords(self, *args) -> 'PyObject *'
 |      find_item_coords(self, item, px, py) -> bool
 |      find_item_coords(self, item) -> PyObject *
 |  
 |  find_label(self, *args) -> 'citem_t *'
 |      find_label(self, label) -> citem_t
 |  
 |  gather_derefs(self, *args) -> 'bool'
 |      gather_derefs(self, ci, udm=None) -> bool
 |  
 |  get_boundaries(self, *args) -> 'boundaries_t &'
 |      get_boundaries(self) -> boundaries_t
 |  
 |  get_eamap(self, *args) -> 'eamap_t &'
 |      get_eamap(self) -> eamap_t
 |  
 |  get_func_type(self, *args) -> 'bool'
 |      get_func_type(self, type) -> bool
 |  
 |  get_line_item(self, *args) -> 'bool'
 |      get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
 |  
 |  get_lvars(self, *args) -> 'lvars_t *'
 |      get_lvars(self) -> lvars_t
 |  
 |  get_pseudocode(self, *args) -> 'strvec_t const &'
 |      get_pseudocode(self) -> strvec_t
 |  
 |  get_stkoff_delta(self, *args) -> 'sval_t'
 |      get_stkoff_delta(self) -> sval_t
 |  
 |  get_user_cmt(self, *args) -> 'char const *'
 |      get_user_cmt(self, loc, rt) -> char const *
 |  
 |  get_user_iflags(self, *args) -> 'int32'
 |      get_user_iflags(self, loc) -> int32
 |  
 |  get_user_union_selection(self, *args) -> 'bool'
 |      get_user_union_selection(self, ea, path) -> bool
 |  
 |  get_warnings(self, *args) -> 'hexwarns_t &'
 |      get_warnings(self) -> hexwarns_t
 |  
 |  has_orphan_cmts(self, *args) -> 'bool'
 |      has_orphan_cmts(self) -> bool
 |  
 |  print_dcl(self, *args) -> 'void'
 |      print_dcl(self)
 |  
 |  print_func(self, *args) -> 'void'
 |      print_func(self, vp)
 |  
 |  refresh_func_ctext(self, *args) -> 'void'
 |      refresh_func_ctext(self)
 |  
 |  release(self, *args) -> 'void'
 |      release(self)
 |  
 |  remove_unused_labels(self, *args) -> 'void'
 |      remove_unused_labels(self)
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |  
 |  save_user_cmts(self, *args) -> 'void'
 |      save_user_cmts(self)
 |  
 |  save_user_iflags(self, *args) -> 'void'
 |      save_user_iflags(self)
 |  
 |  save_user_labels(self, *args) -> 'void'
 |      save_user_labels(self)
 |  
 |  save_user_numforms(self, *args) -> 'void'
 |      save_user_numforms(self)
 |  
 |  save_user_unions(self, *args) -> 'void'
 |      save_user_unions(self)
 |  
 |  set_user_cmt(self, *args) -> 'void'
 |      set_user_cmt(self, loc, cmt)
 |  
 |  set_user_iflags(self, *args) -> 'void'
 |      set_user_iflags(self, loc, iflags)
 |  
 |  set_user_union_selection(self, *args) -> 'void'
 |      set_user_union_selection(self, ea, path)
 |  
 |  verify(self, *args) -> 'void'
 |      verify(self, aul, even_without_debugger)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  argidx
 |      cfuncptr_t_argidx_get(self) -> intvec_t
 |  
 |  arguments
 |  
 |  body
 |      cfuncptr_t_body_get(self) -> cinsn_t
 |  
 |  boundaries
 |  
 |  eamap
 |  
 |  entry_ea
 |      cfuncptr_t_entry_ea_get(self) -> ea_t
 |  
 |  hdrlines
 |      cfuncptr_t_hdrlines_get(self) -> int
 |  
 |  lvars
 |  
 |  maturity
 |      cfuncptr_t_maturity_get(self) -> ctree_maturity_t
 |  
 |  mba
 |      cfuncptr_t_mba_get(self) -> mbl_array_t
 |  
 |  numforms
 |      cfuncptr_t_numforms_get(self) -> user_numforms_t
 |  
 |  pseudocode
 |  
 |  refcnt
 |      cfuncptr_t_refcnt_get(self) -> int
 |  
 |  statebits
 |      cfuncptr_t_statebits_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  treeitems
 |      cfuncptr_t_treeitems_get(self) -> ctree_items_t
 |  
 |  type
 |  
 |  user_cmts
 |      cfuncptr_t_user_cmts_get(self) -> user_cmts_t
 |  
 |  user_iflags
 |      cfuncptr_t_user_iflags_get(self) -> user_iflags_t
 |  
 |  user_labels
 |      cfuncptr_t_user_labels_get(self) -> user_labels_t
 |  
 |  user_unions
 |      cfuncptr_t_user_unions_get(self) -> user_unions_t
 |  
 |  warnings

Help on class cgoto_t in module ida_hexrays:

class cgoto_t(builtins.object)
 |  Proxy of C++ cgoto_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cgoto_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cgoto_t(...)
 |      delete_cgoto_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  label_num
 |      cgoto_t_label_num_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class chain_keeper_t in module ida_hexrays:

class chain_keeper_t(builtins.object)
 |  Proxy of C++ chain_keeper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _gc) -> chain_keeper_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_chain_keeper_t(...)
 |      delete_chain_keeper_t(self)
 |  
 |  back(self, *args) -> 'block_chains_t &'
 |      back(self) -> block_chains_t
 |  
 |  for_all_chains(self, *args) -> 'int'
 |      for_all_chains(self, cv, gca) -> int
 |  
 |  front(self, *args) -> 'block_chains_t &'
 |      front(self) -> block_chains_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class chain_t in module ida_hexrays:

class chain_t(ida_pro.intvec_t)
 |  Proxy of C++ chain_t class.
 |  
 |  Method resolution order:
 |      chain_t
 |      ida_pro.intvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> chain_t
 |      __init__(self, t, off, w=1, v=-1) -> chain_t
 |      __init__(self, _k, w=1) -> chain_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_chain_t(...)
 |      delete_chain_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  append_list(self, *args) -> 'void'
 |      append_list(self, list)
 |  
 |  clear_varnum(self, *args) -> 'void'
 |      clear_varnum(self)
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  endoff(self, *args) -> 'voff_t const'
 |      endoff(self) -> voff_t
 |  
 |  get_reg(self, *args) -> 'mreg_t'
 |      get_reg(self) -> mreg_t
 |  
 |  get_stkoff(self, *args) -> 'sval_t'
 |      get_stkoff(self) -> sval_t
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, r) -> bool
 |  
 |  is_fake(self, *args) -> 'bool'
 |      is_fake(self) -> bool
 |  
 |  is_inited(self, *args) -> 'bool'
 |      is_inited(self) -> bool
 |  
 |  is_overlapped(self, *args) -> 'bool'
 |      is_overlapped(self) -> bool
 |  
 |  is_passreg(self, *args) -> 'bool'
 |      is_passreg(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_replaced(self, *args) -> 'bool'
 |      is_replaced(self) -> bool
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |  
 |  is_term(self, *args) -> 'bool'
 |      is_term(self) -> bool
 |  
 |  key(self, *args) -> 'voff_t const &'
 |      key(self) -> voff_t
 |  
 |  overlap(self, *args) -> 'bool'
 |      overlap(self, r) -> bool
 |  
 |  set_inited(self, *args) -> 'void'
 |      set_inited(self, b)
 |  
 |  set_overlapped(self, *args) -> 'void'
 |      set_overlapped(self, b)
 |  
 |  set_replaced(self, *args) -> 'void'
 |      set_replaced(self, b)
 |  
 |  set_term(self, *args) -> 'void'
 |      set_term(self, b)
 |  
 |  set_value(self, *args) -> 'void'
 |      set_value(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  flags
 |      chain_t_flags_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  varnum
 |      chain_t_varnum_get(self) -> int
 |  
 |  width
 |      chain_t_width_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_pro.intvec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'int const &'
 |      __getitem__(self, i) -> int const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'int &'
 |      push_back(self, x)
 |      push_back(self) -> int &
 |  
 |  at = __getitem__(self, *args) -> 'int const &'
 |      __getitem__(self, i) -> int const &
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< int >::const_iterator'
 |      begin(self) -> qvector< int >::iterator
 |      begin(self) -> qvector< int >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< int >::const_iterator'
 |      end(self) -> qvector< int >::iterator
 |      end(self) -> qvector< int >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< int >::iterator'
 |      erase(self, it) -> qvector< int >::iterator
 |      erase(self, first, last) -> qvector< int >::iterator
 |  
 |  extract(self, *args) -> 'int *'
 |      extract(self) -> int *
 |  
 |  find(self, *args) -> 'qvector< int >::const_iterator'
 |      find(self, x) -> qvector< int >::iterator
 |      find(self, x) -> qvector< int >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< int >::iterator'
 |      insert(self, it, x) -> qvector< int >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'int &'
 |      push_back(self, x)
 |      push_back(self) -> int &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_pro.intvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_pro.intvec_t:
 |  
 |  __hash__ = None

Help on class chain_visitor_t in module ida_hexrays:

class chain_visitor_t(builtins.object)
 |  Proxy of C++ chain_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> chain_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_chain_visitor_t(...)
 |      delete_chain_visitor_t(self)
 |  
 |  visit_chain(self, *args) -> 'int'
 |      visit_chain(self, nblock, ch) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  parent
 |      chain_visitor_t_parent_get(self) -> block_chains_t
 |  
 |  thisown
 |      The membership flag

Help on function checkout_hexrays_license in module ida_hexrays:

checkout_hexrays_license(*args) -> 'bool'
    checkout_hexrays_license(silent) -> bool
    
    
    Check out a floating decompiler license. This function will display a
    dialog box if the license is not available. For non-floating licenses
    this function is effectively no-op. It is not necessary to call this
    function before decompiling. If the license was not checked out, the
    decompiler will automatically do it. This function can be used to
    check out a license in advance and ensure that a license is available.
    
    @param silent: silently fail if the license can not be checked out.
                   (C++: bool)
    @return: false if failed

Help on class cif_t in module ida_hexrays:

class cif_t(ceinsn_t)
 |  Proxy of C++ cif_t class.
 |  
 |  Method resolution order:
 |      cif_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cif_t
 |      __init__(self, r) -> cif_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cif_t(...)
 |      delete_cif_t(self)
 |  
 |  assign(self, *args) -> 'cif_t &'
 |      assign(self, r) -> cif_t
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ielse
 |      cif_t_ielse_get(self) -> cinsn_t
 |  
 |  ithen
 |      cif_t_ithen_get(self) -> cinsn_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on function cinsn_details in module ida_hexrays:

cinsn_details(self)
    return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.

Help on class cinsn_t in module ida_hexrays:

class cinsn_t(citem_t)
 |  Proxy of C++ cinsn_t class.
 |  
 |  Method resolution order:
 |      cinsn_t
 |      citem_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cinsn_t
 |      __init__(self, r) -> cinsn_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cinsn_t(...)
 |      delete_cinsn_t(self)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _get_casm(self, *args) -> 'casm_t *'
 |      _get_casm(self) -> casm_t
 |  
 |  _get_cblock(self, *args) -> 'cblock_t *'
 |      _get_cblock(self) -> cblock_t
 |  
 |  _get_cdo(self, *args) -> 'cdo_t *'
 |      _get_cdo(self) -> cdo_t
 |  
 |  _get_cexpr(self, *args) -> 'cexpr_t *'
 |      _get_cexpr(self) -> cexpr_t
 |  
 |  _get_cfor(self, *args) -> 'cfor_t *'
 |      _get_cfor(self) -> cfor_t
 |  
 |  _get_cgoto(self, *args) -> 'cgoto_t *'
 |      _get_cgoto(self) -> cgoto_t
 |  
 |  _get_cif(self, *args) -> 'cif_t *'
 |      _get_cif(self) -> cif_t
 |  
 |  _get_creturn(self, *args) -> 'creturn_t *'
 |      _get_creturn(self) -> creturn_t
 |  
 |  _get_cswitch(self, *args) -> 'cswitch_t *'
 |      _get_cswitch(self) -> cswitch_t
 |  
 |  _get_cwhile(self, *args) -> 'cwhile_t *'
 |      _get_cwhile(self) -> cwhile_t
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _replace_by(self, *args) -> 'void'
 |      _replace_by(self, r)
 |  
 |  _set_casm(self, *args) -> 'void'
 |      _set_casm(self, _v)
 |  
 |  _set_cblock(self, *args) -> 'void'
 |      _set_cblock(self, _v)
 |  
 |  _set_cdo(self, *args) -> 'void'
 |      _set_cdo(self, _v)
 |  
 |  _set_cexpr(self, *args) -> 'void'
 |      _set_cexpr(self, _v)
 |  
 |  _set_cfor(self, *args) -> 'void'
 |      _set_cfor(self, _v)
 |  
 |  _set_cgoto(self, *args) -> 'void'
 |      _set_cgoto(self, _v)
 |  
 |  _set_cif(self, *args) -> 'void'
 |      _set_cif(self, _v)
 |  
 |  _set_creturn(self, *args) -> 'void'
 |      _set_creturn(self, _v)
 |  
 |  _set_cswitch(self, *args) -> 'void'
 |      _set_cswitch(self, _v)
 |  
 |  _set_cwhile(self, *args) -> 'void'
 |      _set_cwhile(self, _v)
 |  
 |  assign(self, *args) -> 'cinsn_t &'
 |      assign(self, r) -> cinsn_t
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  collect_free_breaks(self, *args) -> 'bool'
 |      collect_free_breaks(self, breaks) -> bool
 |  
 |  collect_free_continues(self, *args) -> 'bool'
 |      collect_free_continues(self, continues) -> bool
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains_free_break(self, *args) -> 'bool'
 |      contains_free_break(self) -> bool
 |  
 |  contains_free_continue(self, *args) -> 'bool'
 |      contains_free_continue(self) -> bool
 |  
 |  contains_insn(self, *args) -> 'bool'
 |      contains_insn(self, type, times=1) -> bool
 |  
 |  create_if(self, *args) -> 'cif_t &'
 |      create_if(self, cnd) -> cif_t
 |  
 |  is_epilog(self)
 |  
 |  is_ordinary_flow(self, *args) -> 'bool'
 |      is_ordinary_flow(self) -> bool
 |  
 |  new_insn(self, *args) -> 'cinsn_t &'
 |      new_insn(self, insn_ea) -> cinsn_t
 |  
 |  print1(self, *args) -> 'void'
 |      print1(self, func)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  zero(self, *args) -> 'void'
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  insn_is_epilog(*args) -> 'bool'
 |      insn_is_epilog(insn) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  casm
 |  
 |  cblock
 |  
 |  cdo
 |  
 |  cexpr
 |  
 |  cfor
 |  
 |  cgoto
 |  
 |  cif
 |  
 |  creturn
 |  
 |  cswitch
 |  
 |  cwhile
 |  
 |  details
 |      return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.
 |  
 |  opname
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  op_to_typename = {70: 'empty', 71: 'block', 72: 'expr', 73: 'if', 74: ...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _get_op(self, *args) -> 'ctype_t'
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args) -> 'void'
 |      _set_op(self, v)
 |  
 |  contains_expr(self, *args) -> 'bool'
 |      contains_expr(self, e) -> bool
 |  
 |  contains_label(self, *args) -> 'bool'
 |      contains_label(self) -> bool
 |  
 |  find_closest_addr(self, *args) -> 'citem_t *'
 |      find_closest_addr(self, _ea) -> citem_t
 |  
 |  find_parent_of(self, *args) -> 'citem_t *'
 |      find_parent_of(self, sitem) -> citem_t
 |      find_parent_of(self, item) -> citem_t
 |  
 |  is_expr(self, *args) -> 'bool'
 |      is_expr(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cinsn
 |      citem_t_cinsn_get(self) -> cinsn_t
 |  
 |  ea
 |      citem_t_ea_get(self) -> ea_t
 |  
 |  index
 |      citem_t_index_get(self) -> int
 |  
 |  label_num
 |      citem_t_label_num_get(self) -> int
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on function cinsn_t_insn_is_epilog in module ida_hexrays:

cinsn_t_insn_is_epilog(*args) -> 'bool'
    cinsn_t_insn_is_epilog(insn) -> bool

Help on class cinsnptrvec_t in module ida_hexrays:

class cinsnptrvec_t(builtins.object)
 |  Proxy of C++ qvector< cinsn_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'cinsn_t *const &'
 |      __getitem__(self, i) -> cinsn_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cinsnptrvec_t
 |      __init__(self, x) -> cinsnptrvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_cinsnptrvec_t(...)
 |      delete_cinsnptrvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'cinsn_t *&'
 |  
 |  at = __getitem__(self, *args) -> 'cinsn_t *const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< cinsn_t * >::const_iterator'
 |      begin(self) -> qvector< cinsn_t * >::iterator
 |      begin(self) -> qvector< cinsn_t * >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< cinsn_t * >::const_iterator'
 |      end(self) -> qvector< cinsn_t * >::iterator
 |      end(self) -> qvector< cinsn_t * >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< cinsn_t * >::iterator'
 |      erase(self, it) -> qvector< cinsn_t * >::iterator
 |      erase(self, first, last) -> qvector< cinsn_t * >::iterator
 |  
 |  extract(self, *args) -> 'cinsn_t **'
 |      extract(self) -> cinsn_t **
 |  
 |  find(self, *args) -> 'qvector< cinsn_t * >::const_iterator'
 |      find(self, x) -> qvector< cinsn_t * >::iterator
 |      find(self, x) -> qvector< cinsn_t * >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< cinsn_t * >::iterator'
 |      insert(self, it, x) -> qvector< cinsn_t * >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'cinsn_t *&'
 |      push_back(self, x)
 |      push_back(self) -> cinsn_t *&
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class citem_cmt_t in module ida_hexrays:

class citem_cmt_t(builtins.object)
 |  Proxy of C++ citem_cmt_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> citem_cmt_t
 |      __init__(self, s) -> citem_cmt_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args) -> 'char const *'
 |      __str__(self) -> char const *
 |  
 |  __swig_destroy__ = delete_citem_cmt_t(...)
 |      delete_citem_cmt_t(self)
 |  
 |  c_str(self, *args) -> 'char const *'
 |      c_str(self) -> char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  used
 |      citem_cmt_t_used_get(self) -> bool

Help on class citem_locator_t in module ida_hexrays:

class citem_locator_t(builtins.object)
 |  Proxy of C++ citem_locator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea, _op) -> citem_locator_t
 |      __init__(self, i) -> citem_locator_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_citem_locator_t(...)
 |      delete_citem_locator_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      citem_locator_t_ea_get(self) -> ea_t
 |  
 |  op
 |      citem_locator_t_op_get(self) -> ctype_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class citem_t in module ida_hexrays:

class citem_t(builtins.object)
 |  Proxy of C++ citem_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> citem_t
 |      __init__(self, o) -> citem_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_citem_t(...)
 |      delete_citem_t(self)
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _get_op(self, *args) -> 'ctype_t'
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args) -> 'void'
 |      _set_op(self, v)
 |  
 |  contains_expr(self, *args) -> 'bool'
 |      contains_expr(self, e) -> bool
 |  
 |  contains_label(self, *args) -> 'bool'
 |      contains_label(self) -> bool
 |  
 |  find_closest_addr(self, *args) -> 'citem_t *'
 |      find_closest_addr(self, _ea) -> citem_t
 |  
 |  find_parent_of(self, *args) -> 'citem_t *'
 |      find_parent_of(self, sitem) -> citem_t
 |      find_parent_of(self, item) -> citem_t
 |  
 |  is_expr(self, *args) -> 'bool'
 |      is_expr(self) -> bool
 |  
 |  print1(self, *args) -> 'void'
 |      print1(self, func)
 |  
 |  replace_by(self, o)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cexpr
 |      citem_t_cexpr_get(self) -> cexpr_t
 |  
 |  cinsn
 |      citem_t_cinsn_get(self) -> cinsn_t
 |  
 |  ea
 |      citem_t_ea_get(self) -> ea_t
 |  
 |  index
 |      citem_t_index_get(self) -> int
 |  
 |  label_num
 |      citem_t_label_num_get(self) -> int
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on function citem_to_specific_type in module ida_hexrays:

citem_to_specific_type(self)
    cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on function clear_cached_cfuncs in module ida_hexrays:

clear_cached_cfuncs(*args) -> 'void'
    clear_cached_cfuncs()
    
    
    Flush all cached decompilation results.

Help on class cloop_t in module ida_hexrays:

class cloop_t(ceinsn_t)
 |  Proxy of C++ cloop_t class.
 |  
 |  Method resolution order:
 |      cloop_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cloop_t
 |      __init__(self, b) -> cloop_t
 |      __init__(self, r) -> cloop_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cloop_t(...)
 |      delete_cloop_t(self)
 |  
 |  assign(self, *args) -> 'cloop_t &'
 |      assign(self, r) -> cloop_t
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  body
 |      cloop_t_body_get(self) -> cinsn_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on function close_pseudocode in module ida_hexrays:

close_pseudocode(*args) -> 'bool'
    close_pseudocode(f) -> bool
    
    
    Close pseudocode window.
    
    @param f: pointer to window (C++: TWidget *)
    @return: false if failed

Help on class cnumber_t in module ida_hexrays:

class cnumber_t(builtins.object)
 |  Proxy of C++ cnumber_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, _opnum=0) -> cnumber_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cnumber_t(...)
 |      delete_cnumber_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, type, parent=None, nice_stroff=None)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, v, nbytes, sign)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  value(self, *args) -> 'uint64'
 |      value(self, type) -> uint64
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  _value
 |      cnumber_t__value_get(self) -> uint64
 |  
 |  nf
 |      cnumber_t_nf_get(self) -> number_format_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class codegen_t in module ida_hexrays:

class codegen_t(builtins.object)
 |  Proxy of C++ codegen_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, m) -> codegen_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_codegen_t(...)
 |      delete_codegen_t(self)
 |  
 |  analyze_prolog(self, *args) -> 'merror_t'
 |      analyze_prolog(self, fc, reachable) -> merror_t
 |  
 |  emit(self, *args) -> 'minsn_t *'
 |      emit(self, code, width, l, r, d, offsize) -> minsn_t
 |      emit(self, code, l, r, d) -> minsn_t
 |  
 |  emit_micro_mvm(self, *args) -> 'minsn_t *'
 |      emit_micro_mvm(self, code, dtype, l, r, d, offsize) -> minsn_t
 |  
 |  gen_micro(self, *args) -> 'merror_t'
 |      gen_micro(self) -> merror_t
 |  
 |  load_operand(self, *args) -> 'mreg_t'
 |      load_operand(self, opnum) -> mreg_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ignore_micro
 |      codegen_t_ignore_micro_get(self) -> char
 |  
 |  ii
 |      codegen_t_ii_get(self) -> cdg_insn_iterator_t
 |  
 |  insn
 |      codegen_t_insn_get(self) -> insn_t *
 |  
 |  mb
 |      codegen_t_mb_get(self) -> mblock_t
 |  
 |  mba
 |      codegen_t_mba_get(self) -> mbl_array_t
 |  
 |  thisown
 |      The membership flag

Help on function convert_to_user_call in module ida_hexrays:

convert_to_user_call(*args) -> 'merror_t'
    convert_to_user_call(udc, cdg) -> merror_t
    
    
    try to generate user-defined call for an instruction
    
    @param udc (C++: const  udcall_t  &)
    @param cdg (C++: codegen_t  &)
    @return: Microcode error codes  code: MERR_OK - user-defined call
             generated else - error (MERR_INSN == inacceptable udc.tif)

Help on function create_field_name in module ida_hexrays:

create_field_name(*args) -> 'qstring'
    create_field_name(type, offset=BADADDR) -> qstring

Help on function create_helper in module ida_hexrays:

create_helper(*args)

Help on function create_typedef in module ida_hexrays:

create_typedef(*args) -> 'tinfo_t'
    create_typedef(name) -> tinfo_t
    create_typedef(n) -> tinfo_t
    
    
    Create a reference to a named type.
    
    @param name: type name (C++: const char *)
    @return: type which refers to the specified name. For example, if name
             is "DWORD", the type info which refers to "DWORD" is created.

Help on class creturn_t in module ida_hexrays:

class creturn_t(ceinsn_t)
 |  Proxy of C++ creturn_t class.
 |  
 |  Method resolution order:
 |      creturn_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> creturn_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_creturn_t(...)
 |      delete_creturn_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on class cswitch_t in module ida_hexrays:

class cswitch_t(ceinsn_t)
 |  Proxy of C++ cswitch_t class.
 |  
 |  Method resolution order:
 |      cswitch_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cswitch_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cswitch_t(...)
 |      delete_cswitch_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cases
 |      cswitch_t_cases_get(self) -> ccases_t
 |  
 |  mvnf
 |      cswitch_t_mvnf_get(self) -> cnumber_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on class ctext_position_t in module ida_hexrays:

class ctext_position_t(builtins.object)
 |  Proxy of C++ ctext_position_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, _lnnum=-1, _x=0, _y=0) -> ctext_position_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ctext_position_t(...)
 |      delete_ctext_position_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  in_ctree(self, *args) -> 'bool'
 |      in_ctree(self, hdrlines) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      ctext_position_t_lnnum_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      ctext_position_t_x_get(self) -> int
 |  
 |  y
 |      ctext_position_t_y_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class ctree_anchor_t in module ida_hexrays:

class ctree_anchor_t(builtins.object)
 |  Proxy of C++ ctree_anchor_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ctree_anchor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ctree_anchor_t(...)
 |      delete_ctree_anchor_t(self)
 |  
 |  get_index(self, *args) -> 'int'
 |      get_index(self) -> int
 |  
 |  get_itp(self, *args) -> 'item_preciser_t'
 |      get_itp(self) -> item_preciser_t
 |  
 |  is_blkcmt_anchor(self, *args) -> 'bool'
 |      is_blkcmt_anchor(self) -> bool
 |  
 |  is_citem_anchor(self, *args) -> 'bool'
 |      is_citem_anchor(self) -> bool
 |  
 |  is_itp_anchor(self, *args) -> 'bool'
 |      is_itp_anchor(self) -> bool
 |  
 |  is_lvar_anchor(self, *args) -> 'bool'
 |      is_lvar_anchor(self) -> bool
 |  
 |  is_valid_anchor(self, *args) -> 'bool'
 |      is_valid_anchor(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      ctree_anchor_t_value_get(self) -> uval_t

Help on class ctree_item_t in module ida_hexrays:

class ctree_item_t(builtins.object)
 |  Proxy of C++ ctree_item_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ctree_item_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ctree_item_t(...)
 |      delete_ctree_item_t(self)
 |  
 |  _get_e(self, *args) -> 'cexpr_t *'
 |      _get_e(self) -> cexpr_t
 |  
 |  _get_f(self, *args) -> 'cfunc_t *'
 |      _get_f(self) -> cfunc_t
 |  
 |  _get_i(self, *args) -> 'cinsn_t *'
 |      _get_i(self) -> cinsn_t
 |  
 |  _get_it(self, *args) -> 'citem_t *'
 |      _get_it(self) -> citem_t
 |  
 |  _get_l(self, *args) -> 'lvar_t *'
 |      _get_l(self) -> lvar_t
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self) -> ea_t
 |  
 |  get_label_num(self, *args) -> 'int'
 |      get_label_num(self, gln_flags) -> int
 |  
 |  get_lvar(self, *args) -> 'lvar_t *'
 |      get_lvar(self) -> lvar_t
 |  
 |  get_memptr(self, *args) -> 'member_t *'
 |      get_memptr(self, p_sptr=None) -> member_t *
 |  
 |  is_citem(self, *args) -> 'bool'
 |      is_citem(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  citype
 |      ctree_item_t_citype_get(self) -> cursor_item_type_t
 |  
 |  e
 |  
 |  f
 |  
 |  i
 |  
 |  it
 |  
 |  l
 |  
 |  loc
 |      ctree_item_t_loc_get(self) -> treeloc_t
 |  
 |  thisown
 |      The membership flag

Help on class ctree_items_t in module ida_hexrays:

class ctree_items_t(builtins.object)
 |  Proxy of C++ qvector< citem_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'citem_t *const &'
 |      __getitem__(self, i) -> citem_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ctree_items_t
 |      __init__(self, x) -> ctree_items_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_ctree_items_t(...)
 |      delete_ctree_items_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'citem_t *&'
 |  
 |  at = __getitem__(self, *args) -> 'citem_t *const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< citem_t * >::const_iterator'
 |      begin(self) -> qvector< citem_t * >::iterator
 |      begin(self) -> qvector< citem_t * >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< citem_t * >::const_iterator'
 |      end(self) -> qvector< citem_t * >::iterator
 |      end(self) -> qvector< citem_t * >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< citem_t * >::iterator'
 |      erase(self, it) -> qvector< citem_t * >::iterator
 |      erase(self, first, last) -> qvector< citem_t * >::iterator
 |  
 |  extract(self, *args) -> 'citem_t **'
 |      extract(self) -> citem_t **
 |  
 |  find(self, *args) -> 'qvector< citem_t * >::const_iterator'
 |      find(self, x) -> qvector< citem_t * >::iterator
 |      find(self, x) -> qvector< citem_t * >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< citem_t * >::iterator'
 |      insert(self, it, x) -> qvector< citem_t * >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'citem_t *&'
 |      push_back(self, x)
 |      push_back(self) -> citem_t *&
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class ctree_parentee_t in module ida_hexrays:

class ctree_parentee_t(ctree_visitor_t)
 |  Proxy of C++ ctree_parentee_t class.
 |  
 |  Method resolution order:
 |      ctree_parentee_t
 |      ctree_visitor_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, post=False) -> ctree_parentee_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ctree_parentee_t(...)
 |      delete_ctree_parentee_t(self)
 |  
 |  recalc_parent_types(self, *args) -> 'bool'
 |      recalc_parent_types(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctree_visitor_t:
 |  
 |  apply_to(self, *args) -> 'int'
 |      apply_to(self, item, parent) -> int
 |  
 |  apply_to_exprs(self, *args) -> 'int'
 |      apply_to_exprs(self, item, parent) -> int
 |  
 |  clr_prune(self, *args) -> 'void'
 |      clr_prune(self)
 |  
 |  clr_restart(self, *args) -> 'void'
 |      clr_restart(self)
 |  
 |  is_postorder(self, *args) -> 'bool'
 |      is_postorder(self) -> bool
 |  
 |  leave_expr(self, *args) -> 'int'
 |      leave_expr(self, arg0) -> int
 |  
 |  leave_insn(self, *args) -> 'int'
 |      leave_insn(self, arg0) -> int
 |  
 |  maintain_parents(self, *args) -> 'bool'
 |      maintain_parents(self) -> bool
 |  
 |  must_prune(self, *args) -> 'bool'
 |      must_prune(self) -> bool
 |  
 |  must_restart(self, *args) -> 'bool'
 |      must_restart(self) -> bool
 |  
 |  only_insns(self, *args) -> 'bool'
 |      only_insns(self) -> bool
 |  
 |  parent_expr(self, *args) -> 'cexpr_t *'
 |      parent_expr(self) -> cexpr_t
 |  
 |  parent_insn(self, *args) -> 'cinsn_t *'
 |      parent_insn(self) -> cinsn_t
 |  
 |  prune_now(self, *args) -> 'void'
 |      prune_now(self)
 |  
 |  set_restart(self, *args) -> 'void'
 |      set_restart(self)
 |  
 |  visit_expr(self, *args) -> 'int'
 |      visit_expr(self, arg0) -> int
 |  
 |  visit_insn(self, *args) -> 'int'
 |      visit_insn(self, arg0) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ctree_visitor_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cv_flags
 |      ctree_visitor_t_cv_flags_get(self) -> int
 |  
 |  parents
 |      ctree_visitor_t_parents_get(self) -> ctree_items_t

Help on class ctree_visitor_t in module ida_hexrays:

class ctree_visitor_t(builtins.object)
 |  Proxy of C++ ctree_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags) -> ctree_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ctree_visitor_t(...)
 |      delete_ctree_visitor_t(self)
 |  
 |  apply_to(self, *args) -> 'int'
 |      apply_to(self, item, parent) -> int
 |  
 |  apply_to_exprs(self, *args) -> 'int'
 |      apply_to_exprs(self, item, parent) -> int
 |  
 |  clr_prune(self, *args) -> 'void'
 |      clr_prune(self)
 |  
 |  clr_restart(self, *args) -> 'void'
 |      clr_restart(self)
 |  
 |  is_postorder(self, *args) -> 'bool'
 |      is_postorder(self) -> bool
 |  
 |  leave_expr(self, *args) -> 'int'
 |      leave_expr(self, arg0) -> int
 |  
 |  leave_insn(self, *args) -> 'int'
 |      leave_insn(self, arg0) -> int
 |  
 |  maintain_parents(self, *args) -> 'bool'
 |      maintain_parents(self) -> bool
 |  
 |  must_prune(self, *args) -> 'bool'
 |      must_prune(self) -> bool
 |  
 |  must_restart(self, *args) -> 'bool'
 |      must_restart(self) -> bool
 |  
 |  only_insns(self, *args) -> 'bool'
 |      only_insns(self) -> bool
 |  
 |  parent_expr(self, *args) -> 'cexpr_t *'
 |      parent_expr(self) -> cexpr_t
 |  
 |  parent_insn(self, *args) -> 'cinsn_t *'
 |      parent_insn(self) -> cinsn_t
 |  
 |  prune_now(self, *args) -> 'void'
 |      prune_now(self)
 |  
 |  set_restart(self, *args) -> 'void'
 |      set_restart(self)
 |  
 |  visit_expr(self, *args) -> 'int'
 |      visit_expr(self, arg0) -> int
 |  
 |  visit_insn(self, *args) -> 'int'
 |      visit_insn(self, arg0) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cv_flags
 |      ctree_visitor_t_cv_flags_get(self) -> int
 |  
 |  parents
 |      ctree_visitor_t_parents_get(self) -> ctree_items_t
 |  
 |  thisown
 |      The membership flag

Help on class cwhile_t in module ida_hexrays:

class cwhile_t(cloop_t)
 |  Proxy of C++ cwhile_t class.
 |  
 |  Method resolution order:
 |      cwhile_t
 |      cloop_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cwhile_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cwhile_t(...)
 |      delete_cwhile_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cloop_t:
 |  
 |  assign(self, *args) -> 'cloop_t &'
 |      assign(self, r) -> cloop_t
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cloop_t:
 |  
 |  body
 |      cloop_t_body_get(self) -> cinsn_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on function debug_hexrays_ctree in module ida_hexrays:

debug_hexrays_ctree(*args) -> 'void'
    debug_hexrays_ctree(msg)

Help on function decompile in module ida_hexrays:

decompile(ea, hf=None, flags=0)
    # ---------------------------------------------------------------------

Help on function decompile_func in module ida_hexrays:

decompile_func(*args) -> 'cfuncptr_t'
    decompile_func(pfn, hf, flags=0) -> cfuncptr_t
    
    
    Decompile a function. Multiple decompilations of the same function
    return the same object.
    
    @param pfn: pointer to function to decompile (C++: func_t  *)
    @param hf: extended error information (if failed) (C++:
               hexrays_failure_t  *)
    @param flags: bitwise combination of  decompile() flags ... bits (C++:
                  int)
    @return: pointer to the decompilation result (a reference counted
             pointer). NULL if failed.

Help on function decompile_many in module ida_hexrays:

decompile_many(*args) -> 'bool'
    decompile_many(outfile, funcaddrs, flags) -> bool
    
    
    Batch decompilation. Decompile all or the specified functions
    
    @param outfile: name of the output file (C++: const char *)
    @param funcaddrs: list of functions to decompile. If NULL or empty,
                      then decompile all nonlib functions (C++: const
                      eavec_t  *)
    @param flags: Batch decompilation bits (C++: int)
    @return: true if no internal error occurred and the user has not
             cancelled decompilation

Help on function dereference in module ida_hexrays:

dereference(e, ptrsize, is_float=False)

Help on function dstr in module ida_hexrays:

dstr(*args) -> 'char const *'
    dstr(tif) -> char const *
    
    
    Print the specified type info. This function can be used from a
    debugger by typing "tif->dstr()"
    
    @param tif (C++: const  tinfo_t  *)

Help on function dummy_ptrtype in module ida_hexrays:

dummy_ptrtype(*args) -> 'tinfo_t'
    dummy_ptrtype(ptrsize, isfp) -> tinfo_t
    
    
    Generate a dummy pointer type
    
    @param ptrsize: size of pointed object (C++: int)
    @param isfp: is floating point object? (C++: bool)

Help on function eamap_begin in module ida_hexrays:

eamap_begin(*args) -> 'eamap_iterator_t'
    eamap_begin(map) -> eamap_iterator_t
    
    
    Get iterator pointing to the beginning of eamap_t.
    
    
    @param map (C++: const eamap_t *)

Help on function eamap_clear in module ida_hexrays:

eamap_clear(*args) -> 'void'
    eamap_clear(map)
    
    
    Clear eamap_t.
    
    
    @param map (C++: eamap_t *)

Help on function eamap_end in module ida_hexrays:

eamap_end(*args) -> 'eamap_iterator_t'
    eamap_end(map) -> eamap_iterator_t
    
    
    Get iterator pointing to the end of eamap_t.
    
    
    @param map (C++: const eamap_t *)

Help on function eamap_erase in module ida_hexrays:

eamap_erase(*args) -> 'void'
    eamap_erase(map, p)
    
    
    Erase current element from eamap_t.
    
    
    @param map (C++: eamap_t *)
    @param p (C++: eamap_iterator_t)

Help on function eamap_find in module ida_hexrays:

eamap_find(*args) -> 'eamap_iterator_t'
    eamap_find(map, key) -> eamap_iterator_t
    
    
    Find the specified key in eamap_t.
    
    
    @param map (C++: const eamap_t *)
    @param key (C++: const ea_t &)

Help on function eamap_first in module ida_hexrays:

eamap_first(*args) -> 'ea_t const &'
    eamap_first(p) -> ea_t const &
    
    
    Get reference to the current map key.
    
    
    @param p (C++: eamap_iterator_t)

Help on function eamap_free in module ida_hexrays:

eamap_free(*args) -> 'void'
    eamap_free(map)
    
    
    Delete eamap_t instance.
    
    
    @param map (C++: eamap_t *)

Help on function eamap_insert in module ida_hexrays:

eamap_insert(*args) -> 'eamap_iterator_t'
    eamap_insert(map, key, val) -> eamap_iterator_t
    
    
    Insert new (ea_t, cinsnptrvec_t) pair into eamap_t.
    
    
    @param map (C++: eamap_t *)
    @param key (C++: const ea_t &)
    @param val (C++: const  cinsnptrvec_t  &)

Help on class eamap_iterator_t in module ida_hexrays:

class eamap_iterator_t(builtins.object)
 |  Proxy of C++ eamap_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> eamap_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_eamap_iterator_t(...)
 |      delete_eamap_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      eamap_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function eamap_new in module ida_hexrays:

eamap_new(*args) -> 'eamap_t *'
    eamap_new() -> eamap_t
    
    
    Create a new eamap_t instance.

Help on function eamap_next in module ida_hexrays:

eamap_next(*args) -> 'eamap_iterator_t'
    eamap_next(p) -> eamap_iterator_t
    
    
    Move to the next element.
    
    
    @param p (C++: eamap_iterator_t)

Help on function eamap_prev in module ida_hexrays:

eamap_prev(*args) -> 'eamap_iterator_t'
    eamap_prev(p) -> eamap_iterator_t
    
    
    Move to the previous element.
    
    
    @param p (C++: eamap_iterator_t)

Help on function eamap_second in module ida_hexrays:

eamap_second(*args) -> 'cinsnptrvec_t &'
    eamap_second(p) -> cinsnptrvec_t
    
    
    Get reference to the current map value.
    
    
    @param p (C++: eamap_iterator_t)

Help on function eamap_size in module ida_hexrays:

eamap_size(*args) -> 'size_t'
    eamap_size(map) -> size_t
    
    
    Get size of eamap_t.
    
    
    @param map (C++: eamap_t *)

Help on class eamap_t in module ida_hexrays:

class eamap_t(builtins.object)
 |  Proxy of C++ std::map< ea_t,cinsnptrvec_t > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = eamap_begin(...)
 |      eamap_begin(map) -> eamap_iterator_t
 |  
 |  __clear = eamap_clear(...)
 |      eamap_clear(map)
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = eamap_end(...)
 |      eamap_end(map) -> eamap_iterator_t
 |  
 |  __erase = eamap_erase(...)
 |      eamap_erase(map, p)
 |  
 |  __find = eamap_find(...)
 |      eamap_find(map, key) -> eamap_iterator_t
 |  
 |  __first = eamap_first(...)
 |      eamap_first(p) -> ea_t const &
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> eamap_t
 |  
 |  __insert = eamap_insert(...)
 |      eamap_insert(map, key, val) -> eamap_iterator_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = eamap_next(...)
 |      eamap_next(p) -> eamap_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = eamap_second(...)
 |      eamap_second(p) -> cinsnptrvec_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = eamap_size(...)
 |      eamap_size(map) -> size_t
 |  
 |  __swig_destroy__ = delete_eamap_t(...)
 |      delete_eamap_t(self)
 |  
 |  at(self, *args) -> 'cinsnptrvec_t &'
 |      at(self, _Keyval) -> cinsnptrvec_t
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = <class 'int'>
 |      int(x=0) -> integer
 |      int(x, base=10) -> integer
 |      
 |      Convert a number or string to an integer, or return 0 if no arguments
 |      are given.  If x is a number, return x.__int__().  For floating point
 |      numbers, this truncates towards zero.
 |      
 |      If x is not a number or if base is given, then x must be a string,
 |      bytes, or bytearray instance representing an integer literal in the
 |      given base.  The literal can be preceded by '+' or '-' and be surrounded
 |      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
 |      Base 0 means to interpret the base from the string as an integer literal.
 |      >>> int('0b100', base=0)
 |      4
 |  
 |  valuetype = <class 'ida_hexrays.cinsnptrvec_t'>
 |      Proxy of C++ qvector< cinsn_t * > class.

Help on class fnum_array in module ida_hexrays:

class fnum_array(builtins.object)
 |  Proxy of C++ wrapped_array_t< uint16,6 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'unsigned short const &'
 |      __getitem__(self, i) -> unsigned short const &
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> fnum_array
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_fnum_array(...)
 |      delete_fnum_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  data
 |      fnum_array_data_get(self) -> unsigned short (&)[6]
 |  
 |  thisown
 |      The membership flag

Help on class fnumber_t in module ida_hexrays:

class fnumber_t(builtins.object)
 |  Proxy of C++ fnumber_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> fnumber_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_fnumber_t(...)
 |      delete_fnumber_t(self)
 |  
 |  _fnumber_t__get_fnum = __get_fnum(self, *args) -> 'wrapped_array_t< uint16,6 >'
 |      __get_fnum(self) -> fnum_array
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  dereference_const_uint16(self, *args) -> 'uint16 const *'
 |      dereference_const_uint16(self) -> uint16 const *
 |  
 |  dereference_uint16(self, *args) -> 'uint16 *'
 |      dereference_uint16(self) -> uint16 *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fnum
 |      __get_fnum(self) -> fnum_array
 |  
 |  nbytes
 |      fnumber_t_nbytes_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class gco_info_t in module ida_hexrays:

class gco_info_t(builtins.object)
 |  Proxy of C++ gco_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> gco_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_gco_info_t(...)
 |      delete_gco_info_t(self)
 |  
 |  append_to_list(self, *args) -> 'bool'
 |      append_to_list(self, list, mba) -> bool
 |  
 |  is_def(self, *args) -> 'bool'
 |      is_def(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_use(self, *args) -> 'bool'
 |      is_use(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      gco_info_t_flags_get(self) -> int
 |  
 |  name
 |      gco_info_t_name_get(self) -> qstring *
 |  
 |  size
 |      gco_info_t_size_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on function gen_microcode in module ida_hexrays:

gen_microcode(*args) -> 'mbl_array_t *'
    gen_microcode(mbr, hf, retlist=None, flags=0, reqmat=MMAT_GLBOPT3) -> mbl_array_t
    
    
    Generate microcode of an arbitrary code snippet
    
    @param mbr: snippet ranges (C++: const  mba_ranges_t  &)
    @param hf: extended error information (if failed) (C++:
               hexrays_failure_t  *)
    @param retlist: list of registers the snippet returns (C++: const
                    mlist_t  *)
    @param flags: bitwise combination of  decompile() flags ... bits (C++:
                  int)
    @param reqmat: required microcode maturity (C++: mba_maturity_t)
    @return: pointer to the microcode, NULL if failed.

Help on function get_ctype_name in module ida_hexrays:

get_ctype_name(*args) -> 'char const *'
    get_ctype_name(op) -> char const *

Help on function get_current_operand in module ida_hexrays:

get_current_operand(*args) -> 'bool'
    get_current_operand(out) -> bool
    
    
    Get the instruction operand under the cursor. This function determines
    the operand that is under the cursor in the active disassembly
    listing. If the operand refers to a register or stack variable, it
    return true.
    
    @param out (C++: gco_info_t  *)

Help on function get_float_type in module ida_hexrays:

get_float_type(*args) -> 'tinfo_t'
    get_float_type(width) -> tinfo_t
    
    
    Get a type of a floating point value with the specified width
    
    @param width: width of the desired type (C++: int)
    @return: type info object

Help on function get_hexrays_version in module ida_hexrays:

get_hexrays_version(*args) -> 'char const *'
    get_hexrays_version() -> char const *
    
    
    Get decompiler version. The returned string is of the form
    <major>.<minor>.<revision>.<build-date>
    
    @return: pointer to version string. For example: "2.0.0.140605"

Help on function get_int_type_by_width_and_sign in module ida_hexrays:

get_int_type_by_width_and_sign(*args) -> 'tinfo_t'
    get_int_type_by_width_and_sign(srcwidth, sign) -> tinfo_t
    
    
    Create a type info by width and sign. Returns a simple type (examples:
    int, short) with the given width and sign.
    
    @param srcwidth: size of the type in bytes (C++: int)
    @param sign: sign of the type (C++: type_sign_t)

Help on function get_member_type in module ida_hexrays:

get_member_type(*args) -> 'bool'
    get_member_type(mptr, type) -> bool
    
    
    Get type of a structure field. This function performs validity checks
    of the field type. Wrong types are rejected.
    
    @param mptr: structure field (C++: const  member_t  *)
    @param type: pointer to the variable where the type is returned. This
                 parameter can be NULL. (C++: tinfo_t  *)
    @return: false if failed

Help on function get_merror_desc in module ida_hexrays:

get_merror_desc(*args) -> 'qstring *'
    get_merror_desc(code, mba) -> str
    
    
    Get textual description of an error code
    
    @param code: Microcode error codes (C++: merror_t)
    @param mba: the microcode array (C++: mbl_array_t  *)
    @return: the error address

Help on function get_mreg_name in module ida_hexrays:

get_mreg_name(*args) -> 'qstring *'
    get_mreg_name(reg, width, ud=None) -> str
    
    
    Get the microregister name
    
    @param reg (C++: mreg_t)
    @param width: size of microregister in bytes. may be bigger than the
                  real register size. (C++: int)
    @param ud: reserved, must be nullptr (C++: void *)
    @return: width of the printed register. this value may be less than
             the WIDTH argument.

Help on function get_op_signness in module ida_hexrays:

get_op_signness(*args) -> 'type_sign_t'
    get_op_signness(op) -> type_sign_t
    
    
    Get operator sign. Meaningful for sign-dependent operators, like
    cot_sdiv.
    
    
    @param op (C++: ctype_t)

Help on function get_signed_mcode in module ida_hexrays:

get_signed_mcode(*args) -> 'mcode_t'
    get_signed_mcode(code) -> mcode_t

Help on function get_temp_regs in module ida_hexrays:

get_temp_regs(*args) -> 'mlist_t const &'
    get_temp_regs() -> mlist_t
    
    
    Get list of temporary registers. Tempregs are temporary registers that
    are used during code generation. They do not map to regular processor
    registers. They are used only to store temporary values during
    execution of one instruction. Tempregs may not be used to pass a value
    from one block to another. In other words, at the end of a block all
    tempregs must be dead.

Help on function get_type in module ida_hexrays:

get_type(*args) -> 'bool'
    get_type(id, tif, guess) -> bool
    
    
    Get a global type. Global types are types of addressable objects and
    struct/union/enum types
    
    @param id: address or id of the object (C++: uval_t)
    @param tif: buffer for the answer (C++: tinfo_t  *)
    @param guess: what kind of types to consider (C++: type_source_t)
    @return: success

Help on function get_unk_type in module ida_hexrays:

get_unk_type(*args) -> 'tinfo_t'
    get_unk_type(size) -> tinfo_t
    
    
    Create a partial type info by width. Returns a partially defined type
    (examples: _DWORD, _BYTE) with the given width.
    
    @param size: size of the type in bytes (C++: int)

Help on function get_unsigned_mcode in module ida_hexrays:

get_unsigned_mcode(*args) -> 'mcode_t'
    get_unsigned_mcode(code) -> mcode_t

Help on function get_widget_vdui in module ida_hexrays:

get_widget_vdui(*args) -> 'vdui_t *'
    get_widget_vdui(f) -> vdui_t
    
    
    Get the 'vdui_t' instance associated to the TWidget
    
    @param f: pointer to window (C++: TWidget *)
    @return: a  vdui_t  *, or NULL

Help on function getb_reginsn in module ida_hexrays:

getb_reginsn(*args) -> 'minsn_t *'
    getb_reginsn(ins) -> minsn_t
    
    
    Skip assertions backward.
    
    
    @param ins (C++: const  minsn_t  *)

Help on function getf_reginsn in module ida_hexrays:

getf_reginsn(*args) -> 'minsn_t *'
    getf_reginsn(ins) -> minsn_t
    
    
    Skip assertions forward.
    
    
    @param ins (C++: const  minsn_t  *)

Help on class graph_chains_t in module ida_hexrays:

class graph_chains_t(block_chains_vec_t)
 |  Proxy of C++ graph_chains_t class.
 |  
 |  Method resolution order:
 |      graph_chains_t
 |      block_chains_vec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_chains_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_chains_t(...)
 |      delete_graph_chains_t(self)
 |  
 |  acquire(self, *args) -> 'void'
 |      acquire(self)
 |  
 |  for_all_chains(self, *args) -> 'int'
 |      for_all_chains(self, cv, gca_flags) -> int
 |  
 |  is_locked(self, *args) -> 'bool'
 |      is_locked(self) -> bool
 |  
 |  release(self, *args) -> 'void'
 |      release(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from block_chains_vec_t:
 |  
 |  __getitem__(self, *args) -> 'block_chains_t const &'
 |      __getitem__(self, i) -> block_chains_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  at(self, *args) -> 'block_chains_t const &'
 |      at(self, _idx) -> block_chains_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< block_chains_t >::const_iterator'
 |      begin(self) -> block_chains_t
 |      begin(self) -> block_chains_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< block_chains_t >::const_iterator'
 |      end(self) -> block_chains_t
 |      end(self) -> block_chains_t
 |  
 |  erase(self, *args) -> 'qvector< block_chains_t >::iterator'
 |      erase(self, it) -> block_chains_t
 |      erase(self, first, last) -> block_chains_t
 |  
 |  extract(self, *args) -> 'block_chains_t *'
 |      extract(self) -> block_chains_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=block_chains_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< block_chains_t >::iterator'
 |      insert(self, it, x) -> block_chains_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'block_chains_t &'
 |      push_back(self, x)
 |      push_back(self) -> block_chains_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from block_chains_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function has_cached_cfunc in module ida_hexrays:

has_cached_cfunc(*args) -> 'bool'
    has_cached_cfunc(ea) -> bool
    
    
    Do we have a cached decompilation result for 'ea'?
    
    
    @param ea (C++: ea_t)

Help on function hexrays_alloc in module ida_hexrays:

hexrays_alloc(*args) -> 'void *'
    hexrays_alloc(size) -> void *

Help on class hexrays_failure_t in module ida_hexrays:

class hexrays_failure_t(builtins.object)
 |  Proxy of C++ hexrays_failure_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hexrays_failure_t
 |      __init__(self, c, ea, buf=None) -> hexrays_failure_t
 |      __init__(self, c, ea, buf) -> hexrays_failure_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__ lambda self
 |  
 |  __swig_destroy__ = delete_hexrays_failure_t(...)
 |      delete_hexrays_failure_t(self)
 |  
 |  desc(self, *args) -> 'qstring'
 |      desc(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  code
 |      hexrays_failure_t_code_get(self) -> merror_t
 |  
 |  errea
 |      hexrays_failure_t_errea_get(self) -> ea_t
 |  
 |  str
 |      hexrays_failure_t_str_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on function hexrays_free in module ida_hexrays:

hexrays_free(*args) -> 'void'
    hexrays_free(ptr)

Help on class hexwarn_t in module ida_hexrays:

class hexwarn_t(builtins.object)
 |  Proxy of C++ hexwarn_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hexwarn_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_hexwarn_t(...)
 |      delete_hexwarn_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      hexwarn_t_ea_get(self) -> ea_t
 |  
 |  id
 |      hexwarn_t_id_get(self) -> warnid_t
 |  
 |  text
 |      hexwarn_t_text_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class hexwarns_t in module ida_hexrays:

class hexwarns_t(builtins.object)
 |  Proxy of C++ qvector< hexwarn_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'hexwarn_t const &'
 |      __getitem__(self, i) -> hexwarn_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hexwarns_t
 |      __init__(self, x) -> hexwarns_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_hexwarns_t(...)
 |      delete_hexwarns_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'hexwarn_t &'
 |  
 |  at = __getitem__(self, *args) -> 'hexwarn_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< hexwarn_t >::const_iterator'
 |      begin(self) -> hexwarn_t
 |      begin(self) -> hexwarn_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< hexwarn_t >::const_iterator'
 |      end(self) -> hexwarn_t
 |      end(self) -> hexwarn_t
 |  
 |  erase(self, *args) -> 'qvector< hexwarn_t >::iterator'
 |      erase(self, it) -> hexwarn_t
 |      erase(self, first, last) -> hexwarn_t
 |  
 |  extract(self, *args) -> 'hexwarn_t *'
 |      extract(self) -> hexwarn_t
 |  
 |  find(self, *args) -> 'qvector< hexwarn_t >::const_iterator'
 |      find(self, x) -> hexwarn_t
 |      find(self, x) -> hexwarn_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=hexwarn_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< hexwarn_t >::iterator'
 |      insert(self, it, x) -> hexwarn_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'hexwarn_t &'
 |      push_back(self, x)
 |      push_back(self) -> hexwarn_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class history_item_t in module ida_hexrays:

class history_item_t(ctext_position_t)
 |  Proxy of C++ history_item_t class.
 |  
 |  Method resolution order:
 |      history_item_t
 |      ctext_position_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea=BADADDR, _lnnum=-1, _x=0, _y=0) -> history_item_t
 |      __init__(self, _ea, p) -> history_item_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_history_item_t(...)
 |      delete_history_item_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ea
 |      history_item_t_ea_get(self) -> ea_t
 |  
 |  end
 |      history_item_t_end_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctext_position_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  in_ctree(self, *args) -> 'bool'
 |      in_ctree(self, hdrlines) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ctext_position_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      ctext_position_t_lnnum_get(self) -> int
 |  
 |  x
 |      ctext_position_t_x_get(self) -> int
 |  
 |  y
 |      ctext_position_t_y_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ctext_position_t:
 |  
 |  __hash__ = None

Help on class history_t in module ida_hexrays:

class history_t(qvector_history_t)
 |  Proxy of C++ qstack< history_item_t > class.
 |  
 |  Method resolution order:
 |      history_t
 |      qvector_history_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> history_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_history_t(...)
 |      delete_history_t(self)
 |  
 |  append = push_back(self, *args) -> 'history_item_t &'
 |      push_back(self, x)
 |      push_back(self) -> history_item_t
 |  
 |  at = __getitem__(self, *args) -> 'history_item_t const &'
 |      __getitem__(self, i) -> history_item_t
 |  
 |  pop(self, *args) -> 'history_item_t'
 |      pop(self) -> history_item_t
 |  
 |  push(self, *args) -> 'void'
 |      push(self, v)
 |  
 |  top(self, *args) -> 'history_item_t &'
 |      top(self) -> history_item_t
 |      top(self) -> history_item_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_history_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'history_item_t const &'
 |      __getitem__(self, i) -> history_item_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      begin(self) -> history_item_t
 |      begin(self) -> history_item_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      end(self) -> history_item_t
 |      end(self) -> history_item_t
 |  
 |  erase(self, *args) -> 'qvector< history_item_t >::iterator'
 |      erase(self, it) -> history_item_t
 |      erase(self, first, last) -> history_item_t
 |  
 |  extract(self, *args) -> 'history_item_t *'
 |      extract(self) -> history_item_t
 |  
 |  find(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      find(self, x) -> history_item_t
 |      find(self, x) -> history_item_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=history_item_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< history_item_t >::iterator'
 |      insert(self, it, x) -> history_item_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'history_item_t &'
 |      push_back(self, x)
 |      push_back(self) -> history_item_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_history_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from qvector_history_t:
 |  
 |  __hash__ = None

Help on function init_hexrays_plugin in module ida_hexrays:

init_hexrays_plugin(*args) -> 'bool'
    init_hexrays_plugin(flags=0) -> bool
    
    
    Initialize your plugin for hex-rays decompiler. This function must be
    called before calling any other decompiler function. It initializes
    the pointer to the dispatcher.
    
    @param flags: reserved, must be 0 (C++: int)
    @return: true if the decompiler exists and the dispatcher pointer is
             ready to use.

Help on function install_hexrays_callback in module ida_hexrays:

install_hexrays_callback(callback)
    Deprecated. Please use Hexrays_Hooks instead

Help on function install_microcode_filter in module ida_hexrays:

install_microcode_filter(*args) -> 'void'
    install_microcode_filter(filter, install=True)
    
    
    register/unregister non-standard microcode generator
    
    @param filter: - microcode generator object (C++: microcode_filter_t
                   *)
    @param install: - TRUE - register the object, FALSE - unregister (C++:
                    bool)

Help on function is_additive in module ida_hexrays:

is_additive(*args) -> 'bool'
    is_additive(op) -> bool
    
    
    Is additive operator?
    
    
    @param op (C++: ctype_t)

Help on function is_assignment in module ida_hexrays:

is_assignment(*args) -> 'bool'
    is_assignment(op) -> bool
    
    
    Is assignment operator?
    
    
    @param op (C++: ctype_t)

Help on function is_binary in module ida_hexrays:

is_binary(*args) -> 'bool'
    is_binary(op) -> bool
    
    
    Is binary operator?
    
    
    @param op (C++: ctype_t)

Help on function is_bitop in module ida_hexrays:

is_bitop(*args) -> 'bool'
    is_bitop(op) -> bool
    
    
    Is bit related operator?
    
    
    @param op (C++: ctype_t)

Help on function is_bool_type in module ida_hexrays:

is_bool_type(*args) -> 'bool'
    is_bool_type(type) -> bool
    
    
    Is a boolean type?
    
    @param type (C++: const  tinfo_t  &)
    @return: true if the type is a boolean type

Help on function is_break_consumer in module ida_hexrays:

is_break_consumer(*args) -> 'bool'
    is_break_consumer(op) -> bool
    
    
    Does a break statement influence the specified statement code?
    
    
    @param op (C++: ctype_t)

Help on function is_commutative in module ida_hexrays:

is_commutative(*args) -> 'bool'
    is_commutative(op) -> bool
    
    
    Is commutative operator?
    
    
    @param op (C++: ctype_t)

Help on function is_inplace_def in module ida_hexrays:

is_inplace_def(*args) -> 'bool'
    is_inplace_def(type) -> bool
    
    
    Is struct/union/enum definition (not declaration)?
    
    
    @param type (C++: const  tinfo_t  &)

Help on function is_kreg in module ida_hexrays:

is_kreg(*args) -> 'bool'
    is_kreg(r) -> bool
    
    
    Is a kernel register?
    
    
    @param r (C++: mreg_t)

Help on function is_logical in module ida_hexrays:

is_logical(*args) -> 'bool'
    is_logical(op) -> bool
    
    
    Is logical operator?
    
    
    @param op (C++: ctype_t)

Help on function is_loop in module ida_hexrays:

is_loop(*args) -> 'bool'
    is_loop(op) -> bool
    
    
    Is loop statement code?
    
    
    @param op (C++: ctype_t)

Help on function is_lvalue in module ida_hexrays:

is_lvalue(*args) -> 'bool'
    is_lvalue(op) -> bool
    
    
    Is Lvalue operator?
    
    
    @param op (C++: ctype_t)

Help on function is_may_access in module ida_hexrays:

is_may_access(*args) -> 'bool'
    is_may_access(maymust) -> bool

Help on function is_mcode_addsub in module ida_hexrays:

is_mcode_addsub(*args) -> 'bool'
    is_mcode_addsub(mcode) -> bool

Help on function is_mcode_call in module ida_hexrays:

is_mcode_call(*args) -> 'bool'
    is_mcode_call(mcode) -> bool

Help on function is_mcode_commutative in module ida_hexrays:

is_mcode_commutative(*args) -> 'bool'
    is_mcode_commutative(mcode) -> bool

Help on function is_mcode_convertible_to_jmp in module ida_hexrays:

is_mcode_convertible_to_jmp(*args) -> 'bool'
    is_mcode_convertible_to_jmp(mcode) -> bool

Help on function is_mcode_convertible_to_set in module ida_hexrays:

is_mcode_convertible_to_set(*args) -> 'bool'
    is_mcode_convertible_to_set(mcode) -> bool

Help on function is_mcode_divmod in module ida_hexrays:

is_mcode_divmod(*args) -> 'bool'
    is_mcode_divmod(op) -> bool

Help on function is_mcode_fpu in module ida_hexrays:

is_mcode_fpu(*args) -> 'bool'
    is_mcode_fpu(mcode) -> bool

Help on function is_mcode_j1 in module ida_hexrays:

is_mcode_j1(*args) -> 'bool'
    is_mcode_j1(mcode) -> bool

Help on function is_mcode_jcond in module ida_hexrays:

is_mcode_jcond(*args) -> 'bool'
    is_mcode_jcond(mcode) -> bool

Help on function is_mcode_propagatable in module ida_hexrays:

is_mcode_propagatable(*args) -> 'bool'
    is_mcode_propagatable(mcode) -> bool
    
    
    May opcode be propagated? Such opcodes can be used in sub-instructions
    (nested instructions) There is a handful of non-propagatable opcodes,
    like jumps, ret, nop, etc All other regular opcodes are propagatable
    and may appear in a nested instruction.
    
    @param mcode (C++: mcode_t)

Help on function is_mcode_set in module ida_hexrays:

is_mcode_set(*args) -> 'bool'
    is_mcode_set(mcode) -> bool

Help on function is_mcode_set1 in module ida_hexrays:

is_mcode_set1(*args) -> 'bool'
    is_mcode_set1(mcode) -> bool

Help on function is_mcode_shift in module ida_hexrays:

is_mcode_shift(*args) -> 'bool'
    is_mcode_shift(mcode) -> bool

Help on function is_mcode_xdsu in module ida_hexrays:

is_mcode_xdsu(*args) -> 'bool'
    is_mcode_xdsu(mcode) -> bool

Help on function is_multiplicative in module ida_hexrays:

is_multiplicative(*args) -> 'bool'
    is_multiplicative(op) -> bool
    
    
    Is multiplicative operator?
    
    
    @param op (C++: ctype_t)

Help on function is_nonbool_type in module ida_hexrays:

is_nonbool_type(*args) -> 'bool'
    is_nonbool_type(type) -> bool
    
    
    Is definitely a non-boolean type?
    
    @param type (C++: const  tinfo_t  &)
    @return: true if the type is a non-boolean type (non bool and well
             defined)

Help on function is_paf in module ida_hexrays:

is_paf(*args) -> 'bool'
    is_paf(t) -> bool
    
    
    Is a pointer, array, or function type?
    
    
    @param t (C++: type_t)

Help on function is_prepost in module ida_hexrays:

is_prepost(*args) -> 'bool'
    is_prepost(op) -> bool
    
    
    Is pre/post increment/decrement operator?
    
    
    @param op (C++: ctype_t)

Help on function is_ptr_or_array in module ida_hexrays:

is_ptr_or_array(*args) -> 'bool'
    is_ptr_or_array(t) -> bool
    
    
    Is a pointer or array type?
    
    
    @param t (C++: type_t)

Help on function is_relational in module ida_hexrays:

is_relational(*args) -> 'bool'
    is_relational(op) -> bool
    
    
    Is comparison operator?
    
    
    @param op (C++: ctype_t)

Help on function is_signed_mcode in module ida_hexrays:

is_signed_mcode(*args) -> 'bool'
    is_signed_mcode(code) -> bool

Help on function is_small_udt in module ida_hexrays:

is_small_udt(*args) -> 'bool'
    is_small_udt(tif) -> bool
    
    
    Is a small structure or union?
    
    @param tif (C++: const  tinfo_t  &)
    @return: true if the type is a small UDT (user defined type). Small
             UDTs fit into a register (or pair or registers) as a rule.

Help on function is_type_correct in module ida_hexrays:

is_type_correct(*args) -> 'bool'
    is_type_correct(ptr) -> bool
    
    
    Verify a type string.
    
    @param ptr (C++: const  type_t  *)
    @return: true if type string is correct

Help on function is_unary in module ida_hexrays:

is_unary(*args) -> 'bool'
    is_unary(op) -> bool
    
    
    Is unary operator?
    
    
    @param op (C++: ctype_t)

Help on function is_unsigned_mcode in module ida_hexrays:

is_unsigned_mcode(*args) -> 'bool'
    is_unsigned_mcode(code) -> bool

Help on class ivl_t in module ida_hexrays:

class ivl_t(uval_ivl_t)
 |  Proxy of C++ ivl_t class.
 |  
 |  Method resolution order:
 |      ivl_t
 |      uval_ivl_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, _off, _size) -> ivl_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ivl_t(...)
 |      delete_ivl_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, off2) -> bool
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend_to_cover(self, *args) -> 'bool'
 |      extend_to_cover(self, r) -> bool
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, ivl) -> bool
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  overlap(self, *args) -> 'bool'
 |      overlap(self, ivl) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from uval_ivl_t:
 |  
 |  end(self, *args) -> 'unsigned-ea-like-numeric-type'↗
 |      end(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  last(self, *args) -> 'unsigned-ea-like-numeric-type'↗
 |      last(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  valid(self, *args) -> 'bool'
 |      valid(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from uval_ivl_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      uval_ivl_t_off_get(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  size
 |      uval_ivl_t_size_get(self) -> unsigned-ea-like-numeric-type↗

Help on class ivl_with_name_t in module ida_hexrays:

class ivl_with_name_t(builtins.object)
 |  Proxy of C++ ivl_with_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ivl_with_name_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ivl_with_name_t(...)
 |      delete_ivl_with_name_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ivl
 |      ivl_with_name_t_ivl_get(self) -> ivl_t
 |  
 |  part
 |      ivl_with_name_t_part_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  whole
 |      ivl_with_name_t_whole_get(self) -> char const *

Help on class ivlset_t in module ida_hexrays:

class ivlset_t(uval_ivl_ivlset_t)
 |  Proxy of C++ ivlset_t class.
 |  
 |  Method resolution order:
 |      ivlset_t
 |      uval_ivl_ivlset_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ivlset_t
 |      __init__(self, ivl) -> ivlset_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ivlset_t(...)
 |      delete_ivlset_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  add(self, *args) -> 'bool'
 |      add(self, ivl) -> bool
 |      add(self, ea, size) -> bool
 |      add(self, ivs) -> bool
 |  
 |  addmasked(self, *args) -> 'bool'
 |      addmasked(self, ivs, mask) -> bool
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, off) -> bool
 |  
 |  count(self, *args) -> 'asize_t'
 |      count(self) -> asize_t
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, ivl, strict=False) -> bool
 |      has_common(self, ivs) -> bool
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, ivs) -> bool
 |  
 |  intersect(self, *args) -> 'bool'
 |      intersect(self, ivs) -> bool
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, ivl) -> bool
 |      sub(self, ea, size) -> bool
 |      sub(self, ivs) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from uval_ivl_ivlset_t:
 |  
 |  all_values(self, *args) -> 'bool'
 |      all_values(self) -> bool
 |  
 |  begin(self, *args) -> 'ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator'↗
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator↗
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator'↗
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator↗
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  getivl(self, *args) -> 'ivl_t const &'
 |      getivl(self, idx) -> ivl_t
 |  
 |  lastivl(self, *args) -> 'ivl_t const &'
 |      lastivl(self) -> ivl_t
 |  
 |  nivls(self, *args) -> 'size_t'
 |      nivls(self) -> size_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  set_all_values(self, *args) -> 'void'
 |      set_all_values(self)
 |  
 |  single_value(self, *args) -> 'bool'
 |      single_value(self, v) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from uval_ivl_ivlset_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function jcnd2set in module ida_hexrays:

jcnd2set(*args) -> 'mcode_t'
    jcnd2set(code) -> mcode_t

Help on function lexcompare in module ida_hexrays:

lexcompare(*args) -> 'int'
    lexcompare(a, b) -> int

Help on function lnot in module ida_hexrays:

lnot(e)

Help on class lvar_locator_t in module ida_hexrays:

class lvar_locator_t(builtins.object)
 |  Proxy of C++ lvar_locator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_locator_t
 |      __init__(self, loc, ea) -> lvar_locator_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_locator_t(...)
 |      delete_lvar_locator_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  get_reg1(self, *args) -> 'mreg_t'
 |      get_reg1(self) -> mreg_t
 |  
 |  get_reg2(self, *args) -> 'mreg_t'
 |      get_reg2(self) -> mreg_t
 |  
 |  get_scattered(self, *args) -> 'scattered_aloc_t &'
 |      get_scattered(self) -> scattered_aloc_t
 |      get_scattered(self) -> scattered_aloc_t
 |  
 |  get_stkoff(self, *args) -> 'sval_t'
 |      get_stkoff(self) -> sval_t
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |  
 |  is_reg_var(self, *args) -> 'bool'
 |      is_reg_var(self) -> bool
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |  
 |  is_stk_var(self, *args) -> 'bool'
 |      is_stk_var(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  defea
 |      lvar_locator_t_defea_get(self) -> ea_t
 |  
 |  location
 |      lvar_locator_t_location_get(self) -> vdloc_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function lvar_mapping_begin in module ida_hexrays:

lvar_mapping_begin(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_begin(map) -> lvar_mapping_iterator_t
    
    
    Get iterator pointing to the beginning of lvar_mapping_t.
    
    
    @param map (C++: const lvar_mapping_t *)

Help on function lvar_mapping_clear in module ida_hexrays:

lvar_mapping_clear(*args) -> 'void'
    lvar_mapping_clear(map)
    
    
    Clear lvar_mapping_t.
    
    
    @param map (C++: lvar_mapping_t *)

Help on function lvar_mapping_end in module ida_hexrays:

lvar_mapping_end(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_end(map) -> lvar_mapping_iterator_t
    
    
    Get iterator pointing to the end of lvar_mapping_t.
    
    
    @param map (C++: const lvar_mapping_t *)

Help on function lvar_mapping_erase in module ida_hexrays:

lvar_mapping_erase(*args) -> 'void'
    lvar_mapping_erase(map, p)
    
    
    Erase current element from lvar_mapping_t.
    
    
    @param map (C++: lvar_mapping_t *)
    @param p (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_find in module ida_hexrays:

lvar_mapping_find(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_find(map, key) -> lvar_mapping_iterator_t
    
    
    Find the specified key in lvar_mapping_t.
    
    
    @param map (C++: const lvar_mapping_t *)
    @param key (C++: const  lvar_locator_t  &)

Help on function lvar_mapping_first in module ida_hexrays:

lvar_mapping_first(*args) -> 'lvar_locator_t const &'
    lvar_mapping_first(p) -> lvar_locator_t
    
    
    Get reference to the current map key.
    
    
    @param p (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_free in module ida_hexrays:

lvar_mapping_free(*args) -> 'void'
    lvar_mapping_free(map)
    
    
    Delete lvar_mapping_t instance.
    
    
    @param map (C++: lvar_mapping_t *)

Help on function lvar_mapping_insert in module ida_hexrays:

lvar_mapping_insert(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_insert(map, key, val) -> lvar_mapping_iterator_t
    
    
    Insert new ( 'lvar_locator_t' , 'lvar_locator_t' ) pair into
    lvar_mapping_t.
    
    
    @param map (C++: lvar_mapping_t *)
    @param key (C++: const  lvar_locator_t  &)
    @param val (C++: const  lvar_locator_t  &)

Help on class lvar_mapping_iterator_t in module ida_hexrays:

class lvar_mapping_iterator_t(builtins.object)
 |  Proxy of C++ lvar_mapping_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_mapping_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_mapping_iterator_t(...)
 |      delete_lvar_mapping_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      lvar_mapping_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function lvar_mapping_new in module ida_hexrays:

lvar_mapping_new(*args) -> 'lvar_mapping_t *'
    lvar_mapping_new() -> lvar_mapping_t
    
    
    Create a new lvar_mapping_t instance.

Help on function lvar_mapping_next in module ida_hexrays:

lvar_mapping_next(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_next(p) -> lvar_mapping_iterator_t
    
    
    Move to the next element.
    
    
    @param p (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_prev in module ida_hexrays:

lvar_mapping_prev(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_prev(p) -> lvar_mapping_iterator_t
    
    
    Move to the previous element.
    
    
    @param p (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_second in module ida_hexrays:

lvar_mapping_second(*args) -> 'lvar_locator_t &'
    lvar_mapping_second(p) -> lvar_locator_t
    
    
    Get reference to the current map value.
    
    
    @param p (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_size in module ida_hexrays:

lvar_mapping_size(*args) -> 'size_t'
    lvar_mapping_size(map) -> size_t
    
    
    Get size of lvar_mapping_t.
    
    
    @param map (C++: lvar_mapping_t *)

Help on class lvar_mapping_t in module ida_hexrays:

class lvar_mapping_t(builtins.object)
 |  Proxy of C++ std::map< lvar_locator_t,lvar_locator_t > class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_mapping_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_mapping_t(...)
 |      delete_lvar_mapping_t(self)
 |  
 |  at(self, *args) -> 'lvar_locator_t &'
 |      at(self, _Keyval) -> lvar_locator_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class lvar_ref_t in module ida_hexrays:

class lvar_ref_t(builtins.object)
 |  Proxy of C++ lvar_ref_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, m, i, o=0) -> lvar_ref_t
 |      __init__(self, r) -> lvar_ref_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_ref_t(...)
 |      delete_lvar_ref_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  var(self, *args) -> 'lvar_t &'
 |      var(self) -> lvar_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  idx
 |      lvar_ref_t_idx_get(self) -> int
 |  
 |  mba
 |      lvar_ref_t_mba_get(self) -> mbl_array_t
 |  
 |  off
 |      lvar_ref_t_off_get(self) -> sval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class lvar_saved_info_t in module ida_hexrays:

class lvar_saved_info_t(builtins.object)
 |  Proxy of C++ lvar_saved_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_saved_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_saved_info_t(...)
 |      delete_lvar_saved_info_t(self)
 |  
 |  clear_keep(self, *args) -> 'void'
 |      clear_keep(self)
 |  
 |  clr_forced_lvar(self, *args) -> 'void'
 |      clr_forced_lvar(self)
 |  
 |  clr_nomap_lvar(self, *args) -> 'void'
 |      clr_nomap_lvar(self)
 |  
 |  clr_noptr_lvar(self, *args) -> 'void'
 |      clr_noptr_lvar(self)
 |  
 |  has_info(self, *args) -> 'bool'
 |      has_info(self) -> bool
 |  
 |  is_forced_lvar(self, *args) -> 'bool'
 |      is_forced_lvar(self) -> bool
 |  
 |  is_kept(self, *args) -> 'bool'
 |      is_kept(self) -> bool
 |  
 |  is_nomap_lvar(self, *args) -> 'bool'
 |      is_nomap_lvar(self) -> bool
 |  
 |  is_noptr_lvar(self, *args) -> 'bool'
 |      is_noptr_lvar(self) -> bool
 |  
 |  set_forced_lvar(self, *args) -> 'void'
 |      set_forced_lvar(self)
 |  
 |  set_keep(self, *args) -> 'void'
 |      set_keep(self)
 |  
 |  set_nomap_lvar(self, *args) -> 'void'
 |      set_nomap_lvar(self)
 |  
 |  set_noptr_lvar(self, *args) -> 'void'
 |      set_noptr_lvar(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      lvar_saved_info_t_cmt_get(self) -> qstring *
 |  
 |  flags
 |      lvar_saved_info_t_flags_get(self) -> int
 |  
 |  ll
 |      lvar_saved_info_t_ll_get(self) -> lvar_locator_t
 |  
 |  name
 |      lvar_saved_info_t_name_get(self) -> qstring *
 |  
 |  size
 |      lvar_saved_info_t_size_get(self) -> ssize_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      lvar_saved_info_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class lvar_saved_infos_t in module ida_hexrays:

class lvar_saved_infos_t(builtins.object)
 |  Proxy of C++ qvector< lvar_saved_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'lvar_saved_info_t const &'
 |      __getitem__(self, i) -> lvar_saved_info_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_saved_infos_t
 |      __init__(self, x) -> lvar_saved_infos_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_lvar_saved_infos_t(...)
 |      delete_lvar_saved_infos_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'lvar_saved_info_t &'
 |  
 |  at = __getitem__(self, *args) -> 'lvar_saved_info_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< lvar_saved_info_t >::const_iterator'
 |      begin(self) -> lvar_saved_info_t
 |      begin(self) -> lvar_saved_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< lvar_saved_info_t >::const_iterator'
 |      end(self) -> lvar_saved_info_t
 |      end(self) -> lvar_saved_info_t
 |  
 |  erase(self, *args) -> 'qvector< lvar_saved_info_t >::iterator'
 |      erase(self, it) -> lvar_saved_info_t
 |      erase(self, first, last) -> lvar_saved_info_t
 |  
 |  extract(self, *args) -> 'lvar_saved_info_t *'
 |      extract(self) -> lvar_saved_info_t
 |  
 |  find(self, *args) -> 'qvector< lvar_saved_info_t >::const_iterator'
 |      find(self, x) -> lvar_saved_info_t
 |      find(self, x) -> lvar_saved_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=lvar_saved_info_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< lvar_saved_info_t >::iterator'
 |      insert(self, it, x) -> lvar_saved_info_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'lvar_saved_info_t &'
 |      push_back(self, x)
 |      push_back(self) -> lvar_saved_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class lvar_t in module ida_hexrays:

class lvar_t(lvar_locator_t)
 |  Proxy of C++ lvar_t class.
 |  
 |  Method resolution order:
 |      lvar_t
 |      lvar_locator_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      __init__(self) -> lvar_locator_t
 |      __init__(self, loc, ea) -> lvar_locator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_t(...)
 |      delete_lvar_t(self)
 |  
 |  accepts_type(self, *args) -> 'bool'
 |      accepts_type(self, t, may_change_thisarg=False) -> bool
 |  
 |  append_list(self, *args) -> 'void'
 |      append_list(self, lst, pad_if_scattered=False)
 |  
 |  clear_used(self, *args) -> 'void'
 |      clear_used(self)
 |  
 |  clr_arg_var(self, *args) -> 'void'
 |      clr_arg_var(self)
 |  
 |  clr_automapped(self, *args) -> 'void'
 |      clr_automapped(self)
 |  
 |  clr_dummy_arg(self, *args) -> 'void'
 |      clr_dummy_arg(self)
 |  
 |  clr_fake_var(self, *args) -> 'void'
 |      clr_fake_var(self)
 |  
 |  clr_floating_var(self, *args) -> 'void'
 |      clr_floating_var(self)
 |  
 |  clr_forced_var(self, *args) -> 'void'
 |      clr_forced_var(self)
 |  
 |  clr_mapdst_var(self, *args) -> 'void'
 |      clr_mapdst_var(self)
 |  
 |  clr_mreg_done(self, *args) -> 'void'
 |      clr_mreg_done(self)
 |  
 |  clr_noptr_var(self, *args) -> 'void'
 |      clr_noptr_var(self)
 |  
 |  clr_notarg(self, *args) -> 'void'
 |      clr_notarg(self)
 |  
 |  clr_overlapped_var(self, *args) -> 'void'
 |      clr_overlapped_var(self)
 |  
 |  clr_spoiled_var(self, *args) -> 'void'
 |      clr_spoiled_var(self)
 |  
 |  clr_thisarg(self, *args) -> 'void'
 |      clr_thisarg(self)
 |  
 |  clr_unknown_width(self, *args) -> 'void'
 |      clr_unknown_width(self)
 |  
 |  clr_user_info(self, *args) -> 'void'
 |      clr_user_info(self)
 |  
 |  clr_user_name(self, *args) -> 'void'
 |      clr_user_name(self)
 |  
 |  clr_user_type(self, *args) -> 'void'
 |      clr_user_type(self)
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, v) -> bool
 |  
 |  has_common_bit(self, *args) -> 'bool'
 |      has_common_bit(self, loc, width2) -> bool
 |  
 |  has_regname(self, *args) -> 'bool'
 |      has_regname(self) -> bool
 |  
 |  is_aliasable(self, *args) -> 'bool'
 |      is_aliasable(self, mba) -> bool
 |  
 |  is_automapped(self, *args) -> 'bool'
 |      is_automapped(self) -> bool
 |  
 |  is_dummy_arg(self, *args) -> 'bool'
 |      is_dummy_arg(self) -> bool
 |  
 |  is_forced_var(self, *args) -> 'bool'
 |      is_forced_var(self) -> bool
 |  
 |  is_noptr_var(self, *args) -> 'bool'
 |      is_noptr_var(self) -> bool
 |  
 |  is_notarg(self, *args) -> 'bool'
 |      is_notarg(self) -> bool
 |  
 |  is_thisarg(self, *args) -> 'bool'
 |      is_thisarg(self) -> bool
 |  
 |  set_arg_var(self, *args) -> 'void'
 |      set_arg_var(self)
 |  
 |  set_automapped(self, *args) -> 'void'
 |      set_automapped(self)
 |  
 |  set_dummy_arg(self, *args) -> 'void'
 |      set_dummy_arg(self)
 |  
 |  set_fake_var(self, *args) -> 'void'
 |      set_fake_var(self)
 |  
 |  set_final_lvar_type(self, *args) -> 'void'
 |      set_final_lvar_type(self, t)
 |  
 |  set_floating_var(self, *args) -> 'void'
 |      set_floating_var(self)
 |  
 |  set_forced_var(self, *args) -> 'void'
 |      set_forced_var(self)
 |  
 |  set_lvar_type(self, *args) -> 'bool'
 |      set_lvar_type(self, t, may_fail=False) -> bool
 |  
 |  set_mapdst_var(self, *args) -> 'void'
 |      set_mapdst_var(self)
 |  
 |  set_mreg_done(self, *args) -> 'void'
 |      set_mreg_done(self)
 |  
 |  set_non_typed(self, *args) -> 'void'
 |      set_non_typed(self)
 |  
 |  set_noptr_var(self, *args) -> 'void'
 |      set_noptr_var(self)
 |  
 |  set_notarg(self, *args) -> 'void'
 |      set_notarg(self)
 |  
 |  set_overlapped_var(self, *args) -> 'void'
 |      set_overlapped_var(self)
 |  
 |  set_spoiled_var(self, *args) -> 'void'
 |      set_spoiled_var(self)
 |  
 |  set_thisarg(self, *args) -> 'void'
 |      set_thisarg(self)
 |  
 |  set_typed(self, *args) -> 'void'
 |      set_typed(self)
 |  
 |  set_unknown_width(self, *args) -> 'void'
 |      set_unknown_width(self)
 |  
 |  set_used(self, *args) -> 'void'
 |      set_used(self)
 |  
 |  set_user_name(self, *args) -> 'void'
 |      set_user_name(self)
 |  
 |  set_user_type(self, *args) -> 'void'
 |      set_user_type(self)
 |  
 |  set_width(self, *args) -> 'bool'
 |      set_width(self, w, svw_flags=0) -> bool
 |  
 |  type(self, *args) -> 'tinfo_t &'
 |      type(self) -> tinfo_t
 |      type(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cmt
 |      lvar_t_cmt_get(self) -> qstring *
 |  
 |  defblk
 |      lvar_t_defblk_get(self) -> int
 |  
 |  divisor
 |      lvar_t_divisor_get(self) -> uint64
 |  
 |  has_nice_name
 |      has_nice_name(self) -> bool
 |  
 |  has_user_info
 |      has_user_info(self) -> bool
 |  
 |  has_user_name
 |      has_user_name(self) -> bool
 |  
 |  has_user_type
 |      has_user_type(self) -> bool
 |  
 |  is_arg_var
 |      is_arg_var(self) -> bool
 |  
 |  is_fake_var
 |      is_fake_var(self) -> bool
 |  
 |  is_floating_var
 |      is_floating_var(self) -> bool
 |  
 |  is_mapdst_var
 |      is_mapdst_var(self) -> bool
 |  
 |  is_overlapped_var
 |      is_overlapped_var(self) -> bool
 |  
 |  is_result_var
 |      is_result_var(self) -> bool
 |  
 |  is_spoiled_var
 |      is_spoiled_var(self) -> bool
 |  
 |  is_unknown_width
 |      is_unknown_width(self) -> bool
 |  
 |  mreg_done
 |      mreg_done(self) -> bool
 |  
 |  name
 |      lvar_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  tif
 |      lvar_t_tif_get(self) -> tinfo_t
 |  
 |  typed
 |      typed(self) -> bool
 |  
 |  used
 |      used(self) -> bool
 |  
 |  width
 |      lvar_t_width_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from lvar_locator_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  get_reg1(self, *args) -> 'mreg_t'
 |      get_reg1(self) -> mreg_t
 |  
 |  get_reg2(self, *args) -> 'mreg_t'
 |      get_reg2(self) -> mreg_t
 |  
 |  get_scattered(self, *args) -> 'scattered_aloc_t &'
 |      get_scattered(self) -> scattered_aloc_t
 |      get_scattered(self) -> scattered_aloc_t
 |  
 |  get_stkoff(self, *args) -> 'sval_t'
 |      get_stkoff(self) -> sval_t
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |  
 |  is_reg_var(self, *args) -> 'bool'
 |      is_reg_var(self) -> bool
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |  
 |  is_stk_var(self, *args) -> 'bool'
 |      is_stk_var(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from lvar_locator_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  defea
 |      lvar_locator_t_defea_get(self) -> ea_t
 |  
 |  location
 |      lvar_locator_t_location_get(self) -> vdloc_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from lvar_locator_t:
 |  
 |  __hash__ = None

Help on class lvar_uservec_t in module ida_hexrays:

class lvar_uservec_t(builtins.object)
 |  Proxy of C++ lvar_uservec_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_uservec_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_uservec_t(...)
 |      delete_lvar_uservec_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  find_info(self, *args) -> 'lvar_saved_info_t *'
 |      find_info(self, vloc) -> lvar_saved_info_t
 |  
 |  keep_info(self, *args) -> 'void'
 |      keep_info(self, v)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lmaps
 |      lvar_uservec_t_lmaps_get(self) -> lvar_mapping_t
 |  
 |  lvvec
 |      lvar_uservec_t_lvvec_get(self) -> lvar_saved_infos_t
 |  
 |  stkoff_delta
 |      lvar_uservec_t_stkoff_delta_get(self) -> uval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ulv_flags
 |      lvar_uservec_t_ulv_flags_get(self) -> int

Help on class lvars_t in module ida_hexrays:

class lvars_t(qvector_lvar_t)
 |  Proxy of C++ lvars_t class.
 |  
 |  Method resolution order:
 |      lvars_t
 |      qvector_lvar_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvars_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvars_t(...)
 |      delete_lvars_t(self)
 |  
 |  find(self, *args) -> 'lvar_t *'
 |      find(self, ll) -> lvar_t
 |  
 |  find_input_lvar(self, *args) -> 'int'
 |      find_input_lvar(self, argloc, _size) -> int
 |  
 |  find_lvar(self, *args) -> 'int'
 |      find_lvar(self, location, width, defblk=-1) -> int
 |  
 |  find_stkvar(self, *args) -> 'int'
 |      find_stkvar(self, spoff, width) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_lvar_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'lvar_t const &'
 |      __getitem__(self, i) -> lvar_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'lvar_t &'
 |      push_back(self, x)
 |      push_back(self) -> lvar_t
 |  
 |  at = __getitem__(self, *args) -> 'lvar_t const &'
 |      __getitem__(self, i) -> lvar_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< lvar_t >::const_iterator'
 |      begin(self) -> lvar_t
 |      begin(self) -> lvar_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< lvar_t >::const_iterator'
 |      end(self) -> lvar_t
 |      end(self) -> lvar_t
 |  
 |  erase(self, *args) -> 'qvector< lvar_t >::iterator'
 |      erase(self, it) -> lvar_t
 |      erase(self, first, last) -> lvar_t
 |  
 |  extract(self, *args) -> 'lvar_t *'
 |      extract(self) -> lvar_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=lvar_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< lvar_t >::iterator'
 |      insert(self, it, x) -> lvar_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'lvar_t &'
 |      push_back(self, x)
 |      push_back(self) -> lvar_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_lvar_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from qvector_lvar_t:
 |  
 |  __hash__ = None

Help on function make_num in module ida_hexrays:

make_num(*args)

Help on function make_pointer in module ida_hexrays:

make_pointer(*args) -> 'tinfo_t'
    make_pointer(type) -> tinfo_t
    
    
    Create a pointer type. This function performs the following
    conversion: "type" -> "type*"
    
    @param type: object type. (C++: const  tinfo_t  &)
    @return: "type*". for example, if 'char' is passed as the argument,

Help on function make_ref in module ida_hexrays:

make_ref(e)

Help on function mark_cfunc_dirty in module ida_hexrays:

mark_cfunc_dirty(*args) -> 'bool'
    mark_cfunc_dirty(ea, close_views=False) -> bool
    
    
    Flush the cached decompilation results. Erases a cache entry for the
    specified function.
    
    @param ea: function to erase from the cache (C++: ea_t)
    @param close_views: close pseudocode windows that show the function
                        (C++: bool)
    @return: if a cache entry existed.

Help on class mba_range_iterator_t in module ida_hexrays:

class mba_range_iterator_t(builtins.object)
 |  Proxy of C++ mba_range_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mba_range_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mba_range_iterator_t(...)
 |      delete_mba_range_iterator_t(self)
 |  
 |  chunk(self, *args) -> 'range_t const &'
 |      chunk(self) -> range_t
 |  
 |  is_snippet(self, *args) -> 'bool'
 |      is_snippet(self) -> bool
 |  
 |  next(self, *args) -> 'bool'
 |      next(self) -> bool
 |  
 |  set(self, *args) -> 'bool'
 |      set(self, mbr) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fii
 |      mba_range_iterator_t_fii_get(self) -> func_tail_iterator_t
 |  
 |  rii
 |      mba_range_iterator_t_rii_get(self) -> range_chunk_iterator_t *
 |  
 |  thisown
 |      The membership flag

Help on class mba_ranges_t in module ida_hexrays:

class mba_ranges_t(builtins.object)
 |  Proxy of C++ mba_ranges_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _pfn=None) -> mba_ranges_t
 |      __init__(self, r) -> mba_ranges_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mba_ranges_t(...)
 |      delete_mba_ranges_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  is_fragmented(self, *args) -> 'bool'
 |      is_fragmented(self) -> bool
 |  
 |  is_snippet(self, *args) -> 'bool'
 |      is_snippet(self) -> bool
 |  
 |  start(self, *args) -> 'ea_t'
 |      start(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  pfn
 |      mba_ranges_t_pfn_get(self) -> func_t *
 |  
 |  ranges
 |      mba_ranges_t_ranges_get(self) -> rangevec_t
 |  
 |  thisown
 |      The membership flag

Help on class mbl_array_t in module ida_hexrays:

class mbl_array_t(builtins.object)
 |  Proxy of C++ mbl_array_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mbl_array_t(...)
 |      delete_mbl_array_t(self)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, vp)
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  alloc_lvars(self, *args) -> 'void'
 |      alloc_lvars(self)
 |  
 |  analyze_calls(self, *args) -> 'int'
 |      analyze_calls(self, acflags) -> int
 |  
 |  arg(self, *args) -> 'lvar_t const &'
 |      arg(self, n) -> lvar_t
 |      arg(self, n) -> lvar_t
 |  
 |  argbase(self, *args) -> 'sval_t'
 |      argbase(self) -> sval_t
 |  
 |  argidx_ok(self, *args) -> 'bool'
 |      argidx_ok(self) -> bool
 |  
 |  argidx_sorted(self, *args) -> 'bool'
 |      argidx_sorted(self) -> bool
 |  
 |  bad_call_sp_detected(self, *args) -> 'bool'
 |      bad_call_sp_detected(self) -> bool
 |  
 |  build_graph(self, *args) -> 'merror_t'
 |      build_graph(self) -> merror_t
 |  
 |  calc_shins_flags(self, *args) -> 'int'
 |      calc_shins_flags(self) -> int
 |  
 |  callinfo_built(self, *args) -> 'bool'
 |      callinfo_built(self) -> bool
 |  
 |  chain_varnums_ok(self, *args) -> 'bool'
 |      chain_varnums_ok(self) -> bool
 |  
 |  clr_cdtr(self, *args) -> 'void'
 |      clr_cdtr(self)
 |  
 |  clr_mba_flags(self, *args) -> 'void'
 |      clr_mba_flags(self, f)
 |  
 |  clr_mba_flags2(self, *args) -> 'void'
 |      clr_mba_flags2(self, f)
 |  
 |  combine_blocks(self, *args) -> 'bool'
 |      combine_blocks(self) -> bool
 |  
 |  common_stkvars_stkargs(self, *args) -> 'bool'
 |      common_stkvars_stkargs(self) -> bool
 |  
 |  copy_block(self, *args) -> 'mblock_t *'
 |      copy_block(self, blk, new_serial, cpblk_flags=3) -> mblock_t
 |  
 |  deleted_pairs(self, *args) -> 'bool'
 |      deleted_pairs(self) -> bool
 |  
 |  display_numaddrs(self, *args) -> 'bool'
 |      display_numaddrs(self) -> bool
 |  
 |  display_valnums(self, *args) -> 'bool'
 |      display_valnums(self) -> bool
 |  
 |  dump(self, *args) -> 'void'
 |      dump(self)
 |  
 |  dump_mba(self, *args) -> 'void'
 |      dump_mba(self, _verify, title)
 |  
 |  find_mop(self, *args) -> 'mop_t *'
 |      find_mop(self, ctx, ea, is_dest, list) -> mop_t
 |  
 |  for_all_insns(self, *args) -> 'int'
 |      for_all_insns(self, mv) -> int
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv) -> int
 |  
 |  for_all_topinsns(self, *args) -> 'int'
 |      for_all_topinsns(self, mv) -> int
 |  
 |  generated_asserts(self, *args) -> 'bool'
 |      generated_asserts(self) -> bool
 |  
 |  get_args_region(self, *args) -> 'ivl_t const &'
 |      get_args_region(self) -> ivl_t
 |  
 |  get_curfunc(self, *args) -> 'func_t *'
 |      get_curfunc(self) -> func_t *
 |  
 |  get_graph(self, *args) -> 'mbl_graph_t *'
 |      get_graph(self) -> mbl_graph_t
 |  
 |  get_ida_argloc(self, *args) -> 'argloc_t'
 |      get_ida_argloc(self, v) -> argloc_t
 |  
 |  get_lvars_region(self, *args) -> 'ivl_t const &'
 |      get_lvars_region(self) -> ivl_t
 |  
 |  get_mba_flags(self, *args) -> 'int'
 |      get_mba_flags(self) -> int
 |  
 |  get_mba_flags2(self, *args) -> 'int'
 |      get_mba_flags2(self) -> int
 |  
 |  get_mblock(self, *args) -> 'mblock_t *'
 |      get_mblock(self, n) -> mblock_t
 |      get_mblock(self, n) -> mblock_t
 |  
 |  get_shadow_region(self, *args) -> 'ivl_t const &'
 |      get_shadow_region(self) -> ivl_t
 |  
 |  get_stack_region(self, *args) -> 'ivl_t'
 |      get_stack_region(self) -> ivl_t
 |  
 |  get_std_region(self, *args) -> 'ivl_t const &'
 |      get_std_region(self, idx) -> ivl_t
 |  
 |  graph_insns(self, *args) -> 'bool'
 |      graph_insns(self) -> bool
 |  
 |  has_bad_sp(self, *args) -> 'bool'
 |      has_bad_sp(self) -> bool
 |  
 |  has_over_chains(self, *args) -> 'bool'
 |      has_over_chains(self) -> bool
 |  
 |  has_passregs(self, *args) -> 'bool'
 |      has_passregs(self) -> bool
 |  
 |  idaloc2vd(self, *args) -> 'vdloc_t'
 |      idaloc2vd(self, loc, width) -> vdloc_t
 |  
 |  insert_block(self, *args) -> 'mblock_t *'
 |      insert_block(self, bblk) -> mblock_t
 |  
 |  is_cdtr(self, *args) -> 'bool'
 |      is_cdtr(self) -> bool
 |  
 |  is_ctr(self, *args) -> 'bool'
 |      is_ctr(self) -> bool
 |  
 |  is_dtr(self, *args) -> 'bool'
 |      is_dtr(self) -> bool
 |  
 |  is_pattern(self, *args) -> 'bool'
 |      is_pattern(self) -> bool
 |  
 |  is_snippet(self, *args) -> 'bool'
 |      is_snippet(self) -> bool
 |  
 |  is_stkarg(self, *args) -> 'bool'
 |      is_stkarg(self, v) -> bool
 |  
 |  is_thunk(self, *args) -> 'bool'
 |      is_thunk(self) -> bool
 |  
 |  loaded_gdl(self, *args) -> 'bool'
 |      loaded_gdl(self) -> bool
 |  
 |  lvar_names_ok(self, *args) -> 'bool'
 |      lvar_names_ok(self) -> bool
 |  
 |  lvars_allocated(self, *args) -> 'bool'
 |      lvars_allocated(self) -> bool
 |  
 |  lvars_renamed(self, *args) -> 'bool'
 |      lvars_renamed(self) -> bool
 |  
 |  mark_chains_dirty(self, *args) -> 'void'
 |      mark_chains_dirty(self)
 |  
 |  may_refine_rettype(self, *args) -> 'bool'
 |      may_refine_rettype(self) -> bool
 |  
 |  optimize_global(self, *args) -> 'merror_t'
 |      optimize_global(self) -> merror_t
 |  
 |  optimize_local(self, *args) -> 'int'
 |      optimize_local(self, locopt_bits) -> int
 |  
 |  optimized(self, *args) -> 'bool'
 |      optimized(self) -> bool
 |  
 |  precise_defeas(self, *args) -> 'bool'
 |      precise_defeas(self) -> bool
 |  
 |  propagated_asserts(self, *args) -> 'bool'
 |      propagated_asserts(self) -> bool
 |  
 |  really_alloc(self, *args) -> 'bool'
 |      really_alloc(self) -> bool
 |  
 |  regargs_is_not_aligned(self, *args) -> 'bool'
 |      regargs_is_not_aligned(self) -> bool
 |  
 |  remove_block(self, *args) -> 'bool'
 |      remove_block(self, blk) -> bool
 |  
 |  remove_empty_blocks(self, *args) -> 'bool'
 |      remove_empty_blocks(self) -> bool
 |  
 |  returns_fpval(self, *args) -> 'bool'
 |      returns_fpval(self) -> bool
 |  
 |  rtype_refined(self, *args) -> 'bool'
 |      rtype_refined(self) -> bool
 |  
 |  saverest_done(self, *args) -> 'bool'
 |      saverest_done(self) -> bool
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |  
 |  set_mba_flags(self, *args) -> 'void'
 |      set_mba_flags(self, f)
 |  
 |  set_mba_flags2(self, *args) -> 'void'
 |      set_mba_flags2(self, f)
 |  
 |  short_display(self, *args) -> 'bool'
 |      short_display(self) -> bool
 |  
 |  should_beautify(self, *args) -> 'bool'
 |      should_beautify(self) -> bool
 |  
 |  show_reduction(self, *args) -> 'bool'
 |      show_reduction(self) -> bool
 |  
 |  stkoff_ida2vd(self, *args) -> 'sval_t'
 |      stkoff_ida2vd(self, off) -> sval_t
 |  
 |  stkoff_vd2ida(self, *args) -> 'sval_t'
 |      stkoff_vd2ida(self, off) -> sval_t
 |  
 |  term(self, *args) -> 'void'
 |      term(self)
 |  
 |  use_frame(self, *args) -> 'bool'
 |      use_frame(self) -> bool
 |  
 |  use_wingraph32(self, *args) -> 'bool'
 |      use_wingraph32(self) -> bool
 |  
 |  valranges_done(self, *args) -> 'bool'
 |      valranges_done(self) -> bool
 |  
 |  vd2idaloc(self, *args) -> 'argloc_t'
 |      vd2idaloc(self, loc, width, spd) -> argloc_t
 |      vd2idaloc(self, loc, width) -> argloc_t
 |  
 |  verify(self, *args) -> 'void'
 |      verify(self, always)
 |  
 |  write_to_const_detected(self, *args) -> 'bool'
 |      write_to_const_detected(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  deserialize(*args) -> 'mbl_array_t *'
 |      deserialize(bytes) -> mbl_array_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  aliased_args
 |      mbl_array_t_aliased_args_get(self) -> ivl_t
 |  
 |  aliased_memory
 |      mbl_array_t_aliased_memory_get(self) -> ivlset_t
 |  
 |  aliased_vars
 |      mbl_array_t_aliased_vars_get(self) -> ivl_t
 |  
 |  argidx
 |      mbl_array_t_argidx_get(self) -> intvec_t
 |  
 |  blocks
 |      mbl_array_t_blocks_get(self) -> mblock_t
 |  
 |  cc
 |      mbl_array_t_cc_get(self) -> cm_t
 |  
 |  consumed_argregs
 |      mbl_array_t_consumed_argregs_get(self) -> rlist_t
 |  
 |  entry_ea
 |      mbl_array_t_entry_ea_get(self) -> ea_t
 |  
 |  error_ea
 |      mbl_array_t_error_ea_get(self) -> ea_t
 |  
 |  error_strarg
 |      mbl_array_t_error_strarg_get(self) -> qstring *
 |  
 |  final_type
 |      mbl_array_t_final_type_get(self) -> bool
 |  
 |  first_epilog_ea
 |      mbl_array_t_first_epilog_ea_get(self) -> ea_t
 |  
 |  fpd
 |      mbl_array_t_fpd_get(self) -> sval_t
 |  
 |  frregs
 |      mbl_array_t_frregs_get(self) -> sval_t
 |  
 |  frsize
 |      mbl_array_t_frsize_get(self) -> sval_t
 |  
 |  fti_flags
 |      mbl_array_t_fti_flags_get(self) -> int
 |  
 |  fullsize
 |      mbl_array_t_fullsize_get(self) -> sval_t
 |  
 |  gotoff_stkvars
 |      mbl_array_t_gotoff_stkvars_get(self) -> ivlset_t
 |  
 |  idb_node
 |      mbl_array_t_idb_node_get(self) -> netnode
 |  
 |  idb_spoiled
 |      mbl_array_t_idb_spoiled_get(self) -> reginfovec_t
 |  
 |  idb_type
 |      mbl_array_t_idb_type_get(self) -> tinfo_t
 |  
 |  inargoff
 |      mbl_array_t_inargoff_get(self) -> sval_t
 |  
 |  label
 |      mbl_array_t_label_get(self) -> qstring *
 |  
 |  last_prolog_ea
 |      mbl_array_t_last_prolog_ea_get(self) -> ea_t
 |  
 |  maturity
 |      mbl_array_t_maturity_get(self) -> mba_maturity_t
 |  
 |  mbr
 |      mbl_array_t_mbr_get(self) -> mba_ranges_t
 |  
 |  minargref
 |      mbl_array_t_minargref_get(self) -> sval_t
 |  
 |  minstkref
 |      mbl_array_t_minstkref_get(self) -> sval_t
 |  
 |  minstkref_ea
 |      mbl_array_t_minstkref_ea_get(self) -> ea_t
 |  
 |  natural
 |      mbl_array_t_natural_get(self) -> mblock_t **
 |  
 |  nodel_memory
 |      mbl_array_t_nodel_memory_get(self) -> mlist_t
 |  
 |  notes
 |      mbl_array_t_notes_get(self) -> hexwarns_t
 |  
 |  npurged
 |      mbl_array_t_npurged_get(self) -> int
 |  
 |  occurred_warns
 |      mbl_array_t_occurred_warns_get(self) -> uchar [32]
 |  
 |  pfn_flags
 |      mbl_array_t_pfn_flags_get(self) -> int
 |  
 |  qty
 |      mbl_array_t_qty_get(self) -> int
 |  
 |  reqmat
 |      mbl_array_t_reqmat_get(self) -> mba_maturity_t
 |  
 |  restricted_memory
 |      mbl_array_t_restricted_memory_get(self) -> ivlset_t
 |  
 |  retsize
 |      mbl_array_t_retsize_get(self) -> int
 |  
 |  retvaridx
 |      mbl_array_t_retvaridx_get(self) -> int
 |  
 |  shadow_args
 |      mbl_array_t_shadow_args_get(self) -> int
 |  
 |  spd_adjust
 |      mbl_array_t_spd_adjust_get(self) -> sval_t
 |  
 |  spoiled_list
 |      mbl_array_t_spoiled_list_get(self) -> mlist_t
 |  
 |  stacksize
 |      mbl_array_t_stacksize_get(self) -> sval_t
 |  
 |  std_ivls
 |      mbl_array_t_std_ivls_get(self) -> ivl_with_name_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  tmpstk_size
 |      mbl_array_t_tmpstk_size_get(self) -> sval_t
 |  
 |  vars
 |      mbl_array_t_vars_get(self) -> lvars_t

Help on function mbl_array_t_deserialize in module ida_hexrays:

mbl_array_t_deserialize(*args) -> 'mbl_array_t *'
    mbl_array_t_deserialize(bytes) -> mbl_array_t

Help on class mbl_graph_t in module ida_hexrays:

class mbl_graph_t(simple_graph_t)
 |  Proxy of C++ mbl_graph_t class.
 |  
 |  Method resolution order:
 |      mbl_graph_t
 |      simple_graph_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_chain_stamp(self, *args) -> 'int'
 |      get_chain_stamp(self) -> int
 |  
 |  get_du(self, *args) -> 'graph_chains_t *'
 |      get_du(self, gctype) -> graph_chains_t
 |  
 |  get_mblock(self, *args) -> 'mblock_t *'
 |      get_mblock(self, n) -> mblock_t
 |  
 |  get_ud(self, *args) -> 'graph_chains_t *'
 |      get_ud(self, gctype) -> graph_chains_t
 |  
 |  is_du_chain_dirty(self, *args) -> 'bool'
 |      is_du_chain_dirty(self, gctype) -> bool
 |  
 |  is_redefined_globally(self, *args) -> 'bool'
 |      is_redefined_globally(self, list, b1, b2, m1, m2, maymust=MAY_ACCESS) -> bool
 |  
 |  is_ud_chain_dirty(self, *args) -> 'bool'
 |      is_ud_chain_dirty(self, gctype) -> bool
 |  
 |  is_used_globally(self, *args) -> 'bool'
 |      is_used_globally(self, list, b1, b2, m1, m2, maymust=MAY_ACCESS) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from simple_graph_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  colored_gdl_edges
 |      simple_graph_t_colored_gdl_edges_get(self) -> bool
 |  
 |  title
 |      simple_graph_t_title_get(self) -> qstring *

Help on class mblock_t in module ida_hexrays:

class mblock_t(builtins.object)
 |  Proxy of C++ mblock_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mblock_t(...)
 |      delete_mblock_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, vp)
 |  
 |  append_def_list(self, *args) -> 'void'
 |      append_def_list(self, list, op, maymust)
 |  
 |  append_use_list(self, *args) -> 'void'
 |      append_use_list(self, list, op, maymust, mask=bitrange_t(0, USHRT_MAX))
 |  
 |  build_def_list(self, *args) -> 'mlist_t'
 |      build_def_list(self, ins, maymust) -> mlist_t
 |  
 |  build_lists(self, *args) -> 'int'
 |      build_lists(self, kill_deads) -> int
 |  
 |  build_use_list(self, *args) -> 'mlist_t'
 |      build_use_list(self, ins, maymust) -> mlist_t
 |  
 |  dump(self, *args) -> 'void'
 |      dump(self)
 |  
 |  dump_block(self, *args) -> 'void'
 |      dump_block(self, title)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  find_access(self, *args) -> 'minsn_t *'
 |      find_access(self, op, parent, mend, fdflags) -> minsn_t
 |  
 |  find_def(self, *args) -> 'minsn_t *'
 |      find_def(self, op, p_i1, i2, fdflags) -> minsn_t
 |  
 |  find_first_use(self, *args) -> 'minsn_t *'
 |      find_first_use(self, list, i1, i2, maymust=MAY_ACCESS) -> minsn_t
 |  
 |  find_redefinition(self, *args) -> 'minsn_t *'
 |      find_redefinition(self, list, i1, i2, maymust=MAY_ACCESS) -> minsn_t
 |  
 |  find_use(self, *args) -> 'minsn_t *'
 |      find_use(self, op, p_i1, i2, fdflags) -> minsn_t
 |  
 |  for_all_insns(self, *args) -> 'int'
 |      for_all_insns(self, mv) -> int
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv) -> int
 |  
 |  for_all_uses(self, *args) -> 'int'
 |      for_all_uses(self, list, i1, i2, mmv) -> int
 |  
 |  get_reginsn_qty(self, *args) -> 'size_t'
 |      get_reginsn_qty(self) -> size_t
 |  
 |  get_valranges(self, *args) -> 'bool'
 |      get_valranges(self, res, vivl, vrflags) -> bool
 |      get_valranges(self, res, vivl, m, vrflags) -> bool
 |  
 |  insert_into_block(self, *args) -> 'minsn_t *'
 |      insert_into_block(self, nm, om) -> minsn_t
 |  
 |  is_branch(self, *args) -> 'bool'
 |      is_branch(self) -> bool
 |  
 |  is_call_block(self, *args) -> 'bool'
 |      is_call_block(self) -> bool
 |  
 |  is_nway(self, *args) -> 'bool'
 |      is_nway(self) -> bool
 |  
 |  is_redefined(self, *args) -> 'bool'
 |      is_redefined(self, list, i1, i2, maymust=MAY_ACCESS) -> bool
 |  
 |  is_rhs_redefined(self, *args) -> 'bool'
 |      is_rhs_redefined(self, ins, i1, i2) -> bool
 |  
 |  is_simple_goto_block(self, *args) -> 'bool'
 |      is_simple_goto_block(self) -> bool
 |  
 |  is_simple_jcnd_block(self, *args) -> 'bool'
 |      is_simple_jcnd_block(self) -> bool
 |  
 |  is_unknown_call(self, *args) -> 'bool'
 |      is_unknown_call(self) -> bool
 |  
 |  is_used(self, *args) -> 'bool'
 |      is_used(self, list, i1, i2, maymust=MAY_ACCESS) -> bool
 |  
 |  lists_dirty(self, *args) -> 'bool'
 |      lists_dirty(self) -> bool
 |  
 |  lists_ready(self, *args) -> 'bool'
 |      lists_ready(self) -> bool
 |  
 |  make_lists_ready(self, *args) -> 'int'
 |      make_lists_ready(self) -> int
 |  
 |  make_nop(self, *args) -> 'void'
 |      make_nop(self, m)
 |  
 |  mark_lists_dirty(self, *args) -> 'void'
 |      mark_lists_dirty(self)
 |  
 |  needs_propagation(self, *args) -> 'bool'
 |      needs_propagation(self) -> bool
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self) -> int
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self) -> int
 |  
 |  optimize_block(self, *args) -> 'int'
 |      optimize_block(self) -> int
 |  
 |  optimize_insn(self, *args) -> 'int'
 |      optimize_insn(self, m, optflags=0x0002|0x0004) -> int
 |  
 |  optimize_useless_jump(self, *args) -> 'int'
 |      optimize_useless_jump(self) -> int
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, n) -> int
 |  
 |  preds(self)
 |      Iterates the list of predecessor blocks
 |  
 |  remove_from_block(self, *args) -> 'minsn_t *'
 |      remove_from_block(self, m) -> minsn_t
 |  
 |  request_demote64(self, *args) -> 'void'
 |      request_demote64(self)
 |  
 |  request_propagation(self, *args) -> 'void'
 |      request_propagation(self)
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, n) -> int
 |  
 |  succs(self)
 |      Iterates the list of successor blocks
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dead_at_start
 |      mblock_t_dead_at_start_get(self) -> mlist_t
 |  
 |  dnu
 |      mblock_t_dnu_get(self) -> mlist_t
 |  
 |  end
 |      mblock_t_end_get(self) -> ea_t
 |  
 |  flags
 |      mblock_t_flags_get(self) -> uint32
 |  
 |  head
 |      mblock_t_head_get(self) -> minsn_t
 |  
 |  maxbsp
 |      mblock_t_maxbsp_get(self) -> sval_t
 |  
 |  maybdef
 |      mblock_t_maybdef_get(self) -> mlist_t
 |  
 |  maybuse
 |      mblock_t_maybuse_get(self) -> mlist_t
 |  
 |  mba
 |      mblock_t_mba_get(self) -> mbl_array_t
 |  
 |  minbargref
 |      mblock_t_minbargref_get(self) -> sval_t
 |  
 |  minbstkref
 |      mblock_t_minbstkref_get(self) -> sval_t
 |  
 |  mustbdef
 |      mblock_t_mustbdef_get(self) -> mlist_t
 |  
 |  mustbuse
 |      mblock_t_mustbuse_get(self) -> mlist_t
 |  
 |  nextb
 |      mblock_t_nextb_get(self) -> mblock_t
 |  
 |  predset
 |      mblock_t_predset_get(self) -> intvec_t
 |  
 |  prevb
 |      mblock_t_prevb_get(self) -> mblock_t
 |  
 |  serial
 |      mblock_t_serial_get(self) -> int
 |  
 |  start
 |      mblock_t_start_get(self) -> ea_t
 |  
 |  succset
 |      mblock_t_succset_get(self) -> intvec_t
 |  
 |  tail
 |      mblock_t_tail_get(self) -> minsn_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      mblock_t_type_get(self) -> mblock_type_t

Help on class mcallarg_t in module ida_hexrays:

class mcallarg_t(mop_t)
 |  Proxy of C++ mcallarg_t class.
 |  
 |  Method resolution order:
 |      mcallarg_t
 |      mop_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mcallarg_t
 |      __init__(self, rarg) -> mcallarg_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mcallarg_t(...)
 |      delete_mcallarg_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, shins_flags=0x04|0x02)
 |  
 |  copy_mop(self, *args) -> 'void'
 |      copy_mop(self, op)
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  make_int(self, *args) -> 'void'
 |      make_int(self, val, val_ea, opno=0)
 |  
 |  make_uint(self, *args) -> 'void'
 |      make_uint(self, val, val_ea, opno=0)
 |  
 |  set_regarg(self, *args) -> 'void'
 |      set_regarg(self, mr, sz, tif)
 |      set_regarg(self, mr, tif)
 |      set_regarg(self, mr, dt, sign=type_unsigned)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  argloc
 |      mcallarg_t_argloc_get(self) -> argloc_t
 |  
 |  ea
 |      mcallarg_t_ea_get(self) -> ea_t
 |  
 |  name
 |      mcallarg_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      mcallarg_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from mop_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, rop) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, rop) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, rop) -> bool
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_t(self)
 |  
 |  _get_a(self, *args) -> 'mop_addr_t *'
 |      _get_a(self) -> mop_addr_t
 |  
 |  _get_b(self, *args) -> 'int'
 |      _get_b(self) -> int
 |  
 |  _get_c(self, *args) -> 'mcases_t *'
 |      _get_c(self) -> mcases_t
 |  
 |  _get_cstr(self, *args) -> 'char const *'
 |      _get_cstr(self) -> char const *
 |  
 |  _get_d(self, *args) -> 'minsn_t *'
 |      _get_d(self) -> minsn_t
 |  
 |  _get_f(self, *args) -> 'mcallinfo_t *'
 |      _get_f(self) -> mcallinfo_t
 |  
 |  _get_fpc(self, *args) -> 'fnumber_t *'
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_g(self, *args) -> 'ea_t'
 |      _get_g(self) -> ea_t
 |  
 |  _get_helper(self, *args) -> 'char const *'
 |      _get_helper(self) -> char const *
 |  
 |  _get_l(self, *args) -> 'lvar_ref_t *'
 |      _get_l(self) -> lvar_ref_t
 |  
 |  _get_nnn(self, *args) -> 'mnumber_t *'
 |      _get_nnn(self) -> mnumber_t
 |  
 |  _get_pair(self, *args) -> 'mop_pair_t *'
 |      _get_pair(self) -> mop_pair_t
 |  
 |  _get_r(self, *args) -> 'mreg_t'
 |      _get_r(self) -> mreg_t
 |  
 |  _get_s(self, *args) -> 'stkvar_ref_t *'
 |      _get_s(self) -> stkvar_ref_t
 |  
 |  _get_scif(self, *args) -> 'scif_t *'
 |      _get_scif(self) -> scif_t
 |  
 |  _get_t(self, *args) -> 'mopt_t'
 |      _get_t(self) -> mopt_t
 |  
 |  _make_blkref(self, *args) -> 'void'
 |      _make_blkref(self, blknum)
 |  
 |  _make_callinfo(self, *args) -> 'void'
 |      _make_callinfo(self, fi)
 |  
 |  _make_cases(self, *args) -> 'void'
 |      _make_cases(self, _cases)
 |  
 |  _make_gvar(self, *args) -> 'void'
 |      _make_gvar(self, ea)
 |  
 |  _make_insn(self, *args) -> 'void'
 |      _make_insn(self, ins)
 |  
 |  _make_lvar(self, *args) -> 'void'
 |      _make_lvar(self, mba, idx, off=0)
 |  
 |  _make_pair(self, *args) -> 'void'
 |      _make_pair(self, _pair)
 |  
 |  _make_reg(self, *args) -> 'void'
 |      _make_reg(self, reg)
 |      _make_reg(self, reg, _size)
 |  
 |  _make_stkvar(self, *args) -> 'void'
 |      _make_stkvar(self, mba, off)
 |  
 |  _make_strlit(self, *args) -> 'void'
 |      _make_strlit(self, str)
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _mop_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _mop_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _set_a(self, *args) -> 'void'
 |      _set_a(self, _v)
 |  
 |  _set_b(self, *args) -> 'void'
 |      _set_b(self, _v)
 |  
 |  _set_c(self, *args) -> 'void'
 |      _set_c(self, _v)
 |  
 |  _set_cstr(self, *args) -> 'void'
 |      _set_cstr(self, _v)
 |  
 |  _set_d(self, *args) -> 'void'
 |      _set_d(self, _v)
 |  
 |  _set_f(self, *args) -> 'void'
 |      _set_f(self, _v)
 |  
 |  _set_fpc(self, *args) -> 'void'
 |      _set_fpc(self, _v)
 |  
 |  _set_g(self, *args) -> 'void'
 |      _set_g(self, _v)
 |  
 |  _set_helper(self, *args) -> 'void'
 |      _set_helper(self, _v)
 |  
 |  _set_l(self, *args) -> 'void'
 |      _set_l(self, _v)
 |  
 |  _set_nnn(self, *args) -> 'void'
 |      _set_nnn(self, _v)
 |  
 |  _set_pair(self, *args) -> 'void'
 |      _set_pair(self, _v)
 |  
 |  _set_r(self, *args) -> 'void'
 |      _set_r(self, _v)
 |  
 |  _set_s(self, *args) -> 'void'
 |      _set_s(self, _v)
 |  
 |  _set_scif(self, *args) -> 'void'
 |      _set_scif(self, _v)
 |  
 |  _set_t(self, *args) -> 'void'
 |      _set_t(self, v)
 |  
 |  apply_ld_mcode(self, *args) -> 'void'
 |      apply_ld_mcode(self, mcode, ea, newsize)
 |  
 |  apply_xds(self, *args) -> 'void'
 |      apply_xds(self, ea, newsize)
 |  
 |  apply_xdu(self, *args) -> 'void'
 |      apply_xdu(self, ea, newsize)
 |  
 |  assign(self, *args) -> 'mop_t &'
 |      assign(self, rop) -> mop_t
 |  
 |  change_size(self, *args) -> 'bool'
 |      change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
 |  
 |  create_from_insn(self, *args) -> 'void'
 |      create_from_insn(self, m)
 |  
 |  create_from_ivlset(self, *args) -> 'bool'
 |      create_from_ivlset(self, mba, ivs, fullsize) -> bool
 |  
 |  create_from_mlist(self, *args) -> 'bool'
 |      create_from_mlist(self, mba, lst, fullsize) -> bool
 |  
 |  create_from_scattered_vdloc(self, *args) -> 'void'
 |      create_from_scattered_vdloc(self, mba, name, type, loc)
 |  
 |  create_from_vdloc(self, *args) -> 'void'
 |      create_from_vdloc(self, mba, loc, _size)
 |  
 |  double_size(self, *args) -> 'bool'
 |      double_size(self, sideff=WITH_SIDEFF) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  equal_mops(self, *args) -> 'bool'
 |      equal_mops(self, rop, eqflags) -> bool
 |  
 |  erase(self, *args) -> 'void'
 |      erase(self)
 |  
 |  erase_but_keep_size(self, *args) -> 'void'
 |      erase_but_keep_size(self)
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv, type=None, is_target=False) -> int
 |  
 |  for_all_scattered_submops(self, *args) -> 'int'
 |      for_all_scattered_submops(self, sv) -> int
 |  
 |  get_insn(self, *args) -> 'minsn_t *'
 |      get_insn(self, code) -> minsn_t
 |      get_insn(self, code) -> minsn_t
 |  
 |  get_stkoff(self, *args) -> 'bool'
 |      get_stkoff(self, p_off) -> bool
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, p_off) -> member_t *
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |  
 |  is01(self, *args) -> 'bool'
 |      is01(self) -> bool
 |  
 |  is_arglist(self, *args) -> 'bool'
 |      is_arglist(self) -> bool
 |  
 |  is_bit_reg(self, *args) -> 'bool'
 |      is_bit_reg(self, reg) -> bool
 |      is_bit_reg(self) -> bool
 |  
 |  is_cc(self, *args) -> 'bool'
 |      is_cc(self) -> bool
 |  
 |  is_ccflags(self, *args) -> 'bool'
 |      is_ccflags(self) -> bool
 |  
 |  is_constant(self, *args) -> 'bool'
 |      is_constant(self, is_signed=True) -> bool
 |  
 |  is_equal_to(self, *args) -> 'bool'
 |      is_equal_to(self, n, is_signed=True) -> bool
 |  
 |  is_extended_from(self, *args) -> 'bool'
 |      is_extended_from(self, nbytes, is_signed) -> bool
 |  
 |  is_glbaddr(self, *args) -> 'bool'
 |      is_glbaddr(self) -> bool
 |      is_glbaddr(self, ea) -> bool
 |  
 |  is_impptr_done(self, *args) -> 'bool'
 |      is_impptr_done(self) -> bool
 |  
 |  is_insn(self, *args) -> 'bool'
 |      is_insn(self) -> bool
 |      is_insn(self, code) -> bool
 |  
 |  is_kreg(self, *args) -> 'bool'
 |      is_kreg(self) -> bool
 |  
 |  is_mob(self, *args) -> 'bool'
 |      is_mob(self, serial) -> bool
 |  
 |  is_negative_constant(self, *args) -> 'bool'
 |      is_negative_constant(self) -> bool
 |  
 |  is_one(self, *args) -> 'bool'
 |      is_one(self) -> bool
 |  
 |  is_positive_constant(self, *args) -> 'bool'
 |      is_positive_constant(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |      is_reg(self, _r) -> bool
 |      is_reg(self, _r, _size) -> bool
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |  
 |  is_sign_extended_from(self, *args) -> 'bool'
 |      is_sign_extended_from(self, nbytes) -> bool
 |  
 |  is_stkaddr(self, *args) -> 'bool'
 |      is_stkaddr(self) -> bool
 |  
 |  is_udt(self, *args) -> 'bool'
 |      is_udt(self) -> bool
 |  
 |  is_undef_val(self, *args) -> 'bool'
 |      is_undef_val(self) -> bool
 |  
 |  is_zero(self, *args) -> 'bool'
 |      is_zero(self) -> bool
 |  
 |  is_zero_extended_from(self, *args) -> 'bool'
 |      is_zero_extended_from(self, nbytes) -> bool
 |  
 |  lexcompare(self, *args) -> 'int'
 |      lexcompare(self, rop) -> int
 |  
 |  make_blkref(self, *args) -> 'void'
 |      make_blkref(self, blknum)
 |  
 |  make_first_half(self, *args) -> 'bool'
 |      make_first_half(self, width) -> bool
 |  
 |  make_fpnum(self, *args) -> 'bool'
 |      make_fpnum(self, bytes, _size) -> bool
 |  
 |  make_gvar(self, *args) -> 'void'
 |      make_gvar(self, ea)
 |  
 |  make_helper(self, *args) -> 'void'
 |      make_helper(self, name)
 |  
 |  make_high_half(self, *args) -> 'bool'
 |      make_high_half(self, width) -> bool
 |  
 |  make_insn(self, *args) -> 'void'
 |      make_insn(self, ins)
 |  
 |  make_low_half(self, *args) -> 'bool'
 |      make_low_half(self, width) -> bool
 |  
 |  make_number(self, *args) -> 'void'
 |      make_number(self, _value, _size, _ea=BADADDR, opnum=0)
 |  
 |  make_reg(self, *args) -> 'void'
 |      make_reg(self, reg)
 |      make_reg(self, reg, _size)
 |  
 |  make_reg_pair(self, *args) -> 'void'
 |      make_reg_pair(self, loreg, hireg, halfsize)
 |  
 |  make_second_half(self, *args) -> 'bool'
 |      make_second_half(self, width) -> bool
 |  
 |  may_use_aliased_memory(self, *args) -> 'bool'
 |      may_use_aliased_memory(self) -> bool
 |  
 |  preserve_side_effects(self, *args) -> 'bool'
 |      preserve_side_effects(self, blk, top, moved_calls=None) -> bool
 |  
 |  probably_floating(self, *args) -> 'bool'
 |      probably_floating(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  set_impptr_done(self, *args) -> 'void'
 |      set_impptr_done(self)
 |  
 |  set_udt(self, *args) -> 'void'
 |      set_udt(self)
 |  
 |  set_undef_val(self, *args) -> 'void'
 |      set_undef_val(self)
 |  
 |  shift_mop(self, *args) -> 'bool'
 |      shift_mop(self, offset) -> bool
 |  
 |  signed_value(self, *args) -> 'int64'
 |      signed_value(self) -> int64
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, rop)
 |  
 |  unsigned_value(self, *args) -> 'uint64'
 |      unsigned_value(self) -> uint64
 |  
 |  value(self, *args) -> 'uint64'
 |      value(self, is_signed) -> uint64
 |  
 |  zero(self, *args) -> 'void'
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from mop_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a
 |  
 |  b
 |  
 |  c
 |  
 |  cstr
 |  
 |  d
 |  
 |  f
 |  
 |  fpc
 |  
 |  g
 |  
 |  helper
 |  
 |  l
 |  
 |  meminfo
 |  
 |  nnn
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  oprops
 |      mop_t_oprops_get(self) -> uint8
 |  
 |  pair
 |  
 |  r
 |  
 |  s
 |  
 |  scif
 |  
 |  size
 |      mop_t_size_get(self) -> int
 |  
 |  t
 |      _get_t(self) -> mopt_t
 |  
 |  valnum
 |      mop_t_valnum_get(self) -> uint16
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from mop_t:
 |  
 |  __hash__ = None

Help on class mcallargs_t in module ida_hexrays:

class mcallargs_t(builtins.object)
 |  Proxy of C++ qvector< mcallarg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'mcallarg_t const &'
 |      __getitem__(self, i) -> mcallarg_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mcallargs_t
 |      __init__(self, x) -> mcallargs_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_mcallargs_t(...)
 |      delete_mcallargs_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'mcallarg_t const &'
 |      at(self, _idx) -> mcallarg_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< mcallarg_t >::const_iterator'
 |      begin(self) -> mcallarg_t
 |      begin(self) -> mcallarg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< mcallarg_t >::const_iterator'
 |      end(self) -> mcallarg_t
 |      end(self) -> mcallarg_t
 |  
 |  erase(self, *args) -> 'qvector< mcallarg_t >::iterator'
 |      erase(self, it) -> mcallarg_t
 |      erase(self, first, last) -> mcallarg_t
 |  
 |  extract(self, *args) -> 'mcallarg_t *'
 |      extract(self) -> mcallarg_t
 |  
 |  find(self, *args) -> 'qvector< mcallarg_t >::const_iterator'
 |      find(self, x) -> mcallarg_t
 |      find(self, x) -> mcallarg_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=mcallarg_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< mcallarg_t >::iterator'
 |      insert(self, it, x) -> mcallarg_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'mcallarg_t &'
 |      push_back(self, x)
 |      push_back(self) -> mcallarg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class mcallinfo_t in module ida_hexrays:

class mcallinfo_t(builtins.object)
 |  Proxy of C++ mcallinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _callee=BADADDR, _sargs=0) -> mcallinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mcallinfo_t(...)
 |      delete_mcallinfo_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, size=-1, shins_flags=0x04|0x02)
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  get_type(self, *args) -> 'tinfo_t'
 |      get_type(self) -> tinfo_t
 |  
 |  is_vararg(self, *args) -> 'bool'
 |      is_vararg(self) -> bool
 |  
 |  lexcompare(self, *args) -> 'int'
 |      lexcompare(self, f) -> int
 |  
 |  set_type(self, *args) -> 'bool'
 |      set_type(self, type) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  args
 |      mcallinfo_t_args_get(self) -> mcallargs_t
 |  
 |  call_spd
 |      mcallinfo_t_call_spd_get(self) -> int
 |  
 |  callee
 |      mcallinfo_t_callee_get(self) -> ea_t
 |  
 |  cc
 |      mcallinfo_t_cc_get(self) -> cm_t
 |  
 |  dead_regs
 |      mcallinfo_t_dead_regs_get(self) -> mlist_t
 |  
 |  flags
 |      mcallinfo_t_flags_get(self) -> int
 |  
 |  fti_attrs
 |      mcallinfo_t_fti_attrs_get(self) -> type_attrs_t
 |  
 |  pass_regs
 |      mcallinfo_t_pass_regs_get(self) -> mlist_t
 |  
 |  retregs
 |      mcallinfo_t_retregs_get(self) -> mopvec_t
 |  
 |  return_argloc
 |      mcallinfo_t_return_argloc_get(self) -> argloc_t
 |  
 |  return_regs
 |      mcallinfo_t_return_regs_get(self) -> mlist_t
 |  
 |  return_type
 |      mcallinfo_t_return_type_get(self) -> tinfo_t
 |  
 |  role
 |      mcallinfo_t_role_get(self) -> funcrole_t
 |  
 |  solid_args
 |      mcallinfo_t_solid_args_get(self) -> int
 |  
 |  spoiled
 |      mcallinfo_t_spoiled_get(self) -> mlist_t
 |  
 |  stkargs_top
 |      mcallinfo_t_stkargs_top_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  visible_memory
 |      mcallinfo_t_visible_memory_get(self) -> ivlset_t

Help on class mcases_t in module ida_hexrays:

class mcases_t(builtins.object)
 |  Proxy of C++ mcases_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mcases_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mcases_t(...)
 |      delete_mcases_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, s)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  targets
 |      mcases_t_targets_get(self) -> intvec_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  values
 |      mcases_t_values_get(self) -> casevec_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function mcode_modifies_d in module ida_hexrays:

mcode_modifies_d(*args) -> 'bool'
    mcode_modifies_d(mcode) -> bool

Help on class microcode_filter_t in module ida_hexrays:

class microcode_filter_t(builtins.object)
 |  Proxy of C++ microcode_filter_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> microcode_filter_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_microcode_filter_t(...)
 |      delete_microcode_filter_t(self)
 |  
 |  apply(self, *args) -> 'merror_t'
 |      apply(self, cdg) -> merror_t
 |  
 |  match(self, *args) -> 'bool'
 |      match(self, cdg) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class minsn_t in module ida_hexrays:

class minsn_t(builtins.object)
 |  Proxy of C++ minsn_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea) -> minsn_t
 |      __init__(self, m) -> minsn_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, ri) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_minsn_t(...)
 |      delete_minsn_t(self)
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _make_nop(self, *args) -> 'void'
 |      _make_nop(self)
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _minsn_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _minsn_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, shins_flags=0x04|0x02)
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  clr_assert(self, *args) -> 'void'
 |      clr_assert(self)
 |  
 |  clr_combinable(self, *args) -> 'void'
 |      clr_combinable(self)
 |  
 |  clr_combined(self, *args) -> 'void'
 |      clr_combined(self)
 |  
 |  clr_fpinsn(self, *args) -> 'void'
 |      clr_fpinsn(self)
 |  
 |  clr_ignlowsrc(self, *args) -> 'void'
 |      clr_ignlowsrc(self)
 |  
 |  clr_multimov(self, *args) -> 'void'
 |      clr_multimov(self)
 |  
 |  clr_noret_icall(self, *args) -> 'void'
 |      clr_noret_icall(self)
 |  
 |  clr_propagatable(self, *args) -> 'void'
 |      clr_propagatable(self)
 |  
 |  clr_tailcall(self, *args) -> 'void'
 |      clr_tailcall(self)
 |  
 |  contains_call(self, *args) -> 'bool'
 |      contains_call(self, with_helpers=False) -> bool
 |  
 |  contains_opcode(self, *args) -> 'bool'
 |      contains_opcode(self, mcode) -> bool
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  equal_insns(self, *args) -> 'bool'
 |      equal_insns(self, m, eqflags) -> bool
 |  
 |  find_call(self, *args) -> 'minsn_t *'
 |      find_call(self, with_helpers=False) -> minsn_t
 |  
 |  find_ins_op(self, *args) -> 'minsn_t *'
 |      find_ins_op(self, op=m_nop) -> minsn_t
 |  
 |  find_num_op(self, *args) -> 'mop_t *'
 |      find_num_op(self) -> mop_t
 |  
 |  find_opcode(self, *args) -> 'minsn_t *'
 |      find_opcode(self, mcode) -> minsn_t
 |      find_opcode(self, mcode) -> minsn_t
 |  
 |  for_all_insns(self, *args) -> 'int'
 |      for_all_insns(self, mv) -> int
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv) -> int
 |  
 |  get_role(self, *args) -> 'funcrole_t'
 |      get_role(self) -> funcrole_t
 |  
 |  get_split_size(self, *args) -> 'int'
 |      get_split_size(self) -> int
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |  
 |  is_after(self, *args) -> 'bool'
 |      is_after(self, m) -> bool
 |  
 |  is_alloca(self, *args) -> 'bool'
 |      is_alloca(self) -> bool
 |  
 |  is_assert(self, *args) -> 'bool'
 |      is_assert(self) -> bool
 |  
 |  is_between(self, *args) -> 'bool'
 |      is_between(self, m1, m2) -> bool
 |  
 |  is_bswap(self, *args) -> 'bool'
 |      is_bswap(self) -> bool
 |  
 |  is_cleaning_pop(self, *args) -> 'bool'
 |      is_cleaning_pop(self) -> bool
 |  
 |  is_combinable(self, *args) -> 'bool'
 |      is_combinable(self) -> bool
 |  
 |  is_combined(self, *args) -> 'bool'
 |      is_combined(self) -> bool
 |  
 |  is_extstx(self, *args) -> 'bool'
 |      is_extstx(self) -> bool
 |  
 |  is_farcall(self, *args) -> 'bool'
 |      is_farcall(self) -> bool
 |  
 |  is_fpinsn(self, *args) -> 'bool'
 |      is_fpinsn(self) -> bool
 |  
 |  is_helper(self, *args) -> 'bool'
 |      is_helper(self, name) -> bool
 |  
 |  is_ignlowsrc(self, *args) -> 'bool'
 |      is_ignlowsrc(self) -> bool
 |  
 |  is_inverted_jx(self, *args) -> 'bool'
 |      is_inverted_jx(self) -> bool
 |  
 |  is_like_move(self, *args) -> 'bool'
 |      is_like_move(self) -> bool
 |  
 |  is_mbarrier(self, *args) -> 'bool'
 |      is_mbarrier(self) -> bool
 |  
 |  is_memcpy(self, *args) -> 'bool'
 |      is_memcpy(self) -> bool
 |  
 |  is_memset(self, *args) -> 'bool'
 |      is_memset(self) -> bool
 |  
 |  is_mov(self, *args) -> 'bool'
 |      is_mov(self) -> bool
 |  
 |  is_multimov(self, *args) -> 'bool'
 |      is_multimov(self) -> bool
 |  
 |  is_noret_call(self, *args) -> 'bool'
 |      is_noret_call(self, ignore_noret_icall=False) -> bool
 |  
 |  is_optional(self, *args) -> 'bool'
 |      is_optional(self) -> bool
 |  
 |  is_persistent(self, *args) -> 'bool'
 |      is_persistent(self) -> bool
 |  
 |  is_propagatable(self, *args) -> 'bool'
 |      is_propagatable(self) -> bool
 |  
 |  is_readflags(self, *args) -> 'bool'
 |      is_readflags(self) -> bool
 |  
 |  is_tailcall(self, *args) -> 'bool'
 |      is_tailcall(self) -> bool
 |  
 |  is_unknown_call(self, *args) -> 'bool'
 |      is_unknown_call(self) -> bool
 |  
 |  is_wild_match(self, *args) -> 'bool'
 |      is_wild_match(self) -> bool
 |  
 |  lexcompare(self, *args) -> 'int'
 |      lexcompare(self, ri) -> int
 |  
 |  may_use_aliased_memory(self, *args) -> 'bool'
 |      may_use_aliased_memory(self) -> bool
 |  
 |  modifes_d(self, *args) -> 'bool'
 |      modifes_d(self) -> bool
 |  
 |  modifies_pair_mop(self, *args) -> 'bool'
 |      modifies_pair_mop(self) -> bool
 |  
 |  optimize_solo(self, *args) -> 'int'
 |      optimize_solo(self, optflags=0) -> int
 |  
 |  optimize_subtree(self, *args) -> 'int'
 |      optimize_subtree(self, blk, top, parent, converted_call, optflags=0x0002) -> int
 |  
 |  replace_by(self, o)
 |  
 |  set_assert(self, *args) -> 'void'
 |      set_assert(self)
 |  
 |  set_cleaning_pop(self, *args) -> 'void'
 |      set_cleaning_pop(self)
 |  
 |  set_combinable(self, *args) -> 'void'
 |      set_combinable(self)
 |  
 |  set_extstx(self, *args) -> 'void'
 |      set_extstx(self)
 |  
 |  set_farcall(self, *args) -> 'void'
 |      set_farcall(self)
 |  
 |  set_fpinsn(self, *args) -> 'void'
 |      set_fpinsn(self)
 |  
 |  set_ignlowsrc(self, *args) -> 'void'
 |      set_ignlowsrc(self)
 |  
 |  set_inverted_jx(self, *args) -> 'void'
 |      set_inverted_jx(self)
 |  
 |  set_mbarrier(self, *args) -> 'void'
 |      set_mbarrier(self)
 |  
 |  set_multimov(self, *args) -> 'void'
 |      set_multimov(self)
 |  
 |  set_noret_icall(self, *args) -> 'void'
 |      set_noret_icall(self)
 |  
 |  set_optional(self, *args) -> 'void'
 |      set_optional(self)
 |  
 |  set_persistent(self, *args) -> 'void'
 |      set_persistent(self)
 |  
 |  set_split_size(self, *args) -> 'void'
 |      set_split_size(self, s)
 |  
 |  set_tailcall(self, *args) -> 'void'
 |      set_tailcall(self)
 |  
 |  set_wild_match(self, *args) -> 'void'
 |      set_wild_match(self)
 |  
 |  setaddr(self, *args) -> 'void'
 |      setaddr(self, new_ea)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, m)
 |  
 |  was_noret_icall(self, *args) -> 'bool'
 |      was_noret_icall(self) -> bool
 |  
 |  was_split(self, *args) -> 'bool'
 |      was_split(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  d
 |      minsn_t_d_get(self) -> mop_t
 |  
 |  ea
 |      minsn_t_ea_get(self) -> ea_t
 |  
 |  iprops
 |      minsn_t_iprops_get(self) -> int
 |  
 |  l
 |      minsn_t_l_get(self) -> mop_t
 |  
 |  meminfo
 |  
 |  next
 |      minsn_t_next_get(self) -> minsn_t
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  opcode
 |      minsn_t_opcode_get(self) -> mcode_t
 |  
 |  prev
 |      minsn_t_prev_get(self) -> minsn_t
 |  
 |  r
 |      minsn_t_r_get(self) -> mop_t
 |  
 |  thisown
 |      The membership flag

Help on class minsn_visitor_t in module ida_hexrays:

class minsn_visitor_t(op_parent_info_t)
 |  Proxy of C++ minsn_visitor_t class.
 |  
 |  Method resolution order:
 |      minsn_visitor_t
 |      op_parent_info_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba=None, _blk=None, _topins=None) -> minsn_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_minsn_visitor_t(...)
 |      delete_minsn_visitor_t(self)
 |  
 |  visit_minsn(self, *args) -> 'int'
 |      visit_minsn(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from op_parent_info_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blk
 |      op_parent_info_t_blk_get(self) -> mblock_t
 |  
 |  curins
 |      op_parent_info_t_curins_get(self) -> minsn_t
 |  
 |  mba
 |      op_parent_info_t_mba_get(self) -> mbl_array_t
 |  
 |  topins
 |      op_parent_info_t_topins_get(self) -> minsn_t

Help on class mlist_mop_visitor_t in module ida_hexrays:

class mlist_mop_visitor_t(builtins.object)
 |  Proxy of C++ mlist_mop_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mlist_mop_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mlist_mop_visitor_t(...)
 |      delete_mlist_mop_visitor_t(self)
 |  
 |  visit_mop(self, *args) -> 'int'
 |      visit_mop(self, op) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  changed
 |      mlist_mop_visitor_t_changed_get(self) -> bool
 |  
 |  curins
 |      mlist_mop_visitor_t_curins_get(self) -> minsn_t
 |  
 |  list
 |      mlist_mop_visitor_t_list_get(self) -> mlist_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  topins
 |      mlist_mop_visitor_t_topins_get(self) -> minsn_t

Help on class mlist_t in module ida_hexrays:

class mlist_t(builtins.object)
 |  Proxy of C++ mlist_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mlist_t
 |      __init__(self, ivl) -> mlist_t
 |      __init__(self, r, size) -> mlist_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mlist_t(...)
 |      delete_mlist_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  add(self, *args) -> 'bool'
 |      add(self, r, size) -> bool
 |      add(self, r) -> bool
 |      add(self, ivl) -> bool
 |      add(self, lst) -> bool
 |  
 |  addmem(self, *args) -> 'bool'
 |      addmem(self, ea, size) -> bool
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  count(self, *args) -> 'asize_t'
 |      count(self) -> asize_t
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, r) -> bool
 |  
 |  has_all(self, *args) -> 'bool'
 |      has_all(self, r, size) -> bool
 |  
 |  has_any(self, *args) -> 'bool'
 |      has_any(self, r, size) -> bool
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, lst) -> bool
 |  
 |  has_memory(self, *args) -> 'bool'
 |      has_memory(self) -> bool
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, lst) -> bool
 |  
 |  intersect(self, *args) -> 'bool'
 |      intersect(self, lst) -> bool
 |  
 |  is_subset_of(self, *args) -> 'bool'
 |      is_subset_of(self, lst) -> bool
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, r, size) -> bool
 |      sub(self, ivl) -> bool
 |      sub(self, lst) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  mem
 |      mlist_t_mem_get(self) -> ivlset_t
 |  
 |  reg
 |      mlist_t_reg_get(self) -> rlist_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class mnumber_t in module ida_hexrays:

class mnumber_t(operand_locator_t)
 |  Proxy of C++ mnumber_t class.
 |  
 |  Method resolution order:
 |      mnumber_t
 |      operand_locator_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, v, _ea=BADADDR, n=0) -> mnumber_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mnumber_t(...)
 |      delete_mnumber_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  update_value(self, *args) -> 'void'
 |      update_value(self, val64)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  org_value
 |      mnumber_t_org_value_get(self) -> uint64
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      mnumber_t_value_get(self) -> uint64
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from operand_locator_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      operand_locator_t_ea_get(self) -> ea_t
 |  
 |  opnum
 |      operand_locator_t_opnum_get(self) -> int

Help on function modify_user_lvar_info in module ida_hexrays:

modify_user_lvar_info(*args) -> 'bool'
    modify_user_lvar_info(func_ea, mli_flags, info) -> bool
    
    
    Modify saved local variable settings.
    
    @param func_ea (C++: ea_t)
    @param mli_flags: bits that specify which attrs defined by INFO are to
                      be set (C++: uint)
    @param info: local variable info attrs (C++: const  lvar_saved_info_t
                 &)
    @return: true if modified, false if invalid MLI_FLAGS passed

Help on function modify_user_lvars in module ida_hexrays:

modify_user_lvars(*args) -> 'bool'
    modify_user_lvars(entry_ea, mlv) -> bool
    
    
    Modify saved local variable settings.
    
    @param entry_ea: function start address (C++: ea_t)
    @param mlv: local variable modifier (C++: user_lvar_modifier_t  &)
    @return: true if modified variables

Help on class mop_addr_t in module ida_hexrays:

class mop_addr_t(mop_t)
 |  Proxy of C++ mop_addr_t class.
 |  
 |  Method resolution order:
 |      mop_addr_t
 |      mop_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mop_addr_t
 |      __init__(self, ra) -> mop_addr_t
 |      __init__(self, ra, isz, osz) -> mop_addr_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mop_addr_t(...)
 |      delete_mop_addr_t(self)
 |  
 |  lexcompare(self, *args) -> 'int'
 |      lexcompare(self, ra) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  insize
 |      mop_addr_t_insize_get(self) -> int
 |  
 |  outsize
 |      mop_addr_t_outsize_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from mop_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, rop) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, rop) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, rop) -> bool
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_t(self)
 |  
 |  _get_a(self, *args) -> 'mop_addr_t *'
 |      _get_a(self) -> mop_addr_t
 |  
 |  _get_b(self, *args) -> 'int'
 |      _get_b(self) -> int
 |  
 |  _get_c(self, *args) -> 'mcases_t *'
 |      _get_c(self) -> mcases_t
 |  
 |  _get_cstr(self, *args) -> 'char const *'
 |      _get_cstr(self) -> char const *
 |  
 |  _get_d(self, *args) -> 'minsn_t *'
 |      _get_d(self) -> minsn_t
 |  
 |  _get_f(self, *args) -> 'mcallinfo_t *'
 |      _get_f(self) -> mcallinfo_t
 |  
 |  _get_fpc(self, *args) -> 'fnumber_t *'
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_g(self, *args) -> 'ea_t'
 |      _get_g(self) -> ea_t
 |  
 |  _get_helper(self, *args) -> 'char const *'
 |      _get_helper(self) -> char const *
 |  
 |  _get_l(self, *args) -> 'lvar_ref_t *'
 |      _get_l(self) -> lvar_ref_t
 |  
 |  _get_nnn(self, *args) -> 'mnumber_t *'
 |      _get_nnn(self) -> mnumber_t
 |  
 |  _get_pair(self, *args) -> 'mop_pair_t *'
 |      _get_pair(self) -> mop_pair_t
 |  
 |  _get_r(self, *args) -> 'mreg_t'
 |      _get_r(self) -> mreg_t
 |  
 |  _get_s(self, *args) -> 'stkvar_ref_t *'
 |      _get_s(self) -> stkvar_ref_t
 |  
 |  _get_scif(self, *args) -> 'scif_t *'
 |      _get_scif(self) -> scif_t
 |  
 |  _get_t(self, *args) -> 'mopt_t'
 |      _get_t(self) -> mopt_t
 |  
 |  _make_blkref(self, *args) -> 'void'
 |      _make_blkref(self, blknum)
 |  
 |  _make_callinfo(self, *args) -> 'void'
 |      _make_callinfo(self, fi)
 |  
 |  _make_cases(self, *args) -> 'void'
 |      _make_cases(self, _cases)
 |  
 |  _make_gvar(self, *args) -> 'void'
 |      _make_gvar(self, ea)
 |  
 |  _make_insn(self, *args) -> 'void'
 |      _make_insn(self, ins)
 |  
 |  _make_lvar(self, *args) -> 'void'
 |      _make_lvar(self, mba, idx, off=0)
 |  
 |  _make_pair(self, *args) -> 'void'
 |      _make_pair(self, _pair)
 |  
 |  _make_reg(self, *args) -> 'void'
 |      _make_reg(self, reg)
 |      _make_reg(self, reg, _size)
 |  
 |  _make_stkvar(self, *args) -> 'void'
 |      _make_stkvar(self, mba, off)
 |  
 |  _make_strlit(self, *args) -> 'void'
 |      _make_strlit(self, str)
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _mop_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _mop_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, shins_flags=0x04|0x02)
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _set_a(self, *args) -> 'void'
 |      _set_a(self, _v)
 |  
 |  _set_b(self, *args) -> 'void'
 |      _set_b(self, _v)
 |  
 |  _set_c(self, *args) -> 'void'
 |      _set_c(self, _v)
 |  
 |  _set_cstr(self, *args) -> 'void'
 |      _set_cstr(self, _v)
 |  
 |  _set_d(self, *args) -> 'void'
 |      _set_d(self, _v)
 |  
 |  _set_f(self, *args) -> 'void'
 |      _set_f(self, _v)
 |  
 |  _set_fpc(self, *args) -> 'void'
 |      _set_fpc(self, _v)
 |  
 |  _set_g(self, *args) -> 'void'
 |      _set_g(self, _v)
 |  
 |  _set_helper(self, *args) -> 'void'
 |      _set_helper(self, _v)
 |  
 |  _set_l(self, *args) -> 'void'
 |      _set_l(self, _v)
 |  
 |  _set_nnn(self, *args) -> 'void'
 |      _set_nnn(self, _v)
 |  
 |  _set_pair(self, *args) -> 'void'
 |      _set_pair(self, _v)
 |  
 |  _set_r(self, *args) -> 'void'
 |      _set_r(self, _v)
 |  
 |  _set_s(self, *args) -> 'void'
 |      _set_s(self, _v)
 |  
 |  _set_scif(self, *args) -> 'void'
 |      _set_scif(self, _v)
 |  
 |  _set_t(self, *args) -> 'void'
 |      _set_t(self, v)
 |  
 |  apply_ld_mcode(self, *args) -> 'void'
 |      apply_ld_mcode(self, mcode, ea, newsize)
 |  
 |  apply_xds(self, *args) -> 'void'
 |      apply_xds(self, ea, newsize)
 |  
 |  apply_xdu(self, *args) -> 'void'
 |      apply_xdu(self, ea, newsize)
 |  
 |  assign(self, *args) -> 'mop_t &'
 |      assign(self, rop) -> mop_t
 |  
 |  change_size(self, *args) -> 'bool'
 |      change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
 |  
 |  create_from_insn(self, *args) -> 'void'
 |      create_from_insn(self, m)
 |  
 |  create_from_ivlset(self, *args) -> 'bool'
 |      create_from_ivlset(self, mba, ivs, fullsize) -> bool
 |  
 |  create_from_mlist(self, *args) -> 'bool'
 |      create_from_mlist(self, mba, lst, fullsize) -> bool
 |  
 |  create_from_scattered_vdloc(self, *args) -> 'void'
 |      create_from_scattered_vdloc(self, mba, name, type, loc)
 |  
 |  create_from_vdloc(self, *args) -> 'void'
 |      create_from_vdloc(self, mba, loc, _size)
 |  
 |  double_size(self, *args) -> 'bool'
 |      double_size(self, sideff=WITH_SIDEFF) -> bool
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  equal_mops(self, *args) -> 'bool'
 |      equal_mops(self, rop, eqflags) -> bool
 |  
 |  erase(self, *args) -> 'void'
 |      erase(self)
 |  
 |  erase_but_keep_size(self, *args) -> 'void'
 |      erase_but_keep_size(self)
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv, type=None, is_target=False) -> int
 |  
 |  for_all_scattered_submops(self, *args) -> 'int'
 |      for_all_scattered_submops(self, sv) -> int
 |  
 |  get_insn(self, *args) -> 'minsn_t *'
 |      get_insn(self, code) -> minsn_t
 |      get_insn(self, code) -> minsn_t
 |  
 |  get_stkoff(self, *args) -> 'bool'
 |      get_stkoff(self, p_off) -> bool
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, p_off) -> member_t *
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |  
 |  is01(self, *args) -> 'bool'
 |      is01(self) -> bool
 |  
 |  is_arglist(self, *args) -> 'bool'
 |      is_arglist(self) -> bool
 |  
 |  is_bit_reg(self, *args) -> 'bool'
 |      is_bit_reg(self, reg) -> bool
 |      is_bit_reg(self) -> bool
 |  
 |  is_cc(self, *args) -> 'bool'
 |      is_cc(self) -> bool
 |  
 |  is_ccflags(self, *args) -> 'bool'
 |      is_ccflags(self) -> bool
 |  
 |  is_constant(self, *args) -> 'bool'
 |      is_constant(self, is_signed=True) -> bool
 |  
 |  is_equal_to(self, *args) -> 'bool'
 |      is_equal_to(self, n, is_signed=True) -> bool
 |  
 |  is_extended_from(self, *args) -> 'bool'
 |      is_extended_from(self, nbytes, is_signed) -> bool
 |  
 |  is_glbaddr(self, *args) -> 'bool'
 |      is_glbaddr(self) -> bool
 |      is_glbaddr(self, ea) -> bool
 |  
 |  is_impptr_done(self, *args) -> 'bool'
 |      is_impptr_done(self) -> bool
 |  
 |  is_insn(self, *args) -> 'bool'
 |      is_insn(self) -> bool
 |      is_insn(self, code) -> bool
 |  
 |  is_kreg(self, *args) -> 'bool'
 |      is_kreg(self) -> bool
 |  
 |  is_mob(self, *args) -> 'bool'
 |      is_mob(self, serial) -> bool
 |  
 |  is_negative_constant(self, *args) -> 'bool'
 |      is_negative_constant(self) -> bool
 |  
 |  is_one(self, *args) -> 'bool'
 |      is_one(self) -> bool
 |  
 |  is_positive_constant(self, *args) -> 'bool'
 |      is_positive_constant(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |      is_reg(self, _r) -> bool
 |      is_reg(self, _r, _size) -> bool
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |  
 |  is_sign_extended_from(self, *args) -> 'bool'
 |      is_sign_extended_from(self, nbytes) -> bool
 |  
 |  is_stkaddr(self, *args) -> 'bool'
 |      is_stkaddr(self) -> bool
 |  
 |  is_udt(self, *args) -> 'bool'
 |      is_udt(self) -> bool
 |  
 |  is_undef_val(self, *args) -> 'bool'
 |      is_undef_val(self) -> bool
 |  
 |  is_zero(self, *args) -> 'bool'
 |      is_zero(self) -> bool
 |  
 |  is_zero_extended_from(self, *args) -> 'bool'
 |      is_zero_extended_from(self, nbytes) -> bool
 |  
 |  make_blkref(self, *args) -> 'void'
 |      make_blkref(self, blknum)
 |  
 |  make_first_half(self, *args) -> 'bool'
 |      make_first_half(self, width) -> bool
 |  
 |  make_fpnum(self, *args) -> 'bool'
 |      make_fpnum(self, bytes, _size) -> bool
 |  
 |  make_gvar(self, *args) -> 'void'
 |      make_gvar(self, ea)
 |  
 |  make_helper(self, *args) -> 'void'
 |      make_helper(self, name)
 |  
 |  make_high_half(self, *args) -> 'bool'
 |      make_high_half(self, width) -> bool
 |  
 |  make_insn(self, *args) -> 'void'
 |      make_insn(self, ins)
 |  
 |  make_low_half(self, *args) -> 'bool'
 |      make_low_half(self, width) -> bool
 |  
 |  make_number(self, *args) -> 'void'
 |      make_number(self, _value, _size, _ea=BADADDR, opnum=0)
 |  
 |  make_reg(self, *args) -> 'void'
 |      make_reg(self, reg)
 |      make_reg(self, reg, _size)
 |  
 |  make_reg_pair(self, *args) -> 'void'
 |      make_reg_pair(self, loreg, hireg, halfsize)
 |  
 |  make_second_half(self, *args) -> 'bool'
 |      make_second_half(self, width) -> bool
 |  
 |  may_use_aliased_memory(self, *args) -> 'bool'
 |      may_use_aliased_memory(self) -> bool
 |  
 |  preserve_side_effects(self, *args) -> 'bool'
 |      preserve_side_effects(self, blk, top, moved_calls=None) -> bool
 |  
 |  probably_floating(self, *args) -> 'bool'
 |      probably_floating(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  set_impptr_done(self, *args) -> 'void'
 |      set_impptr_done(self)
 |  
 |  set_udt(self, *args) -> 'void'
 |      set_udt(self)
 |  
 |  set_undef_val(self, *args) -> 'void'
 |      set_undef_val(self)
 |  
 |  shift_mop(self, *args) -> 'bool'
 |      shift_mop(self, offset) -> bool
 |  
 |  signed_value(self, *args) -> 'int64'
 |      signed_value(self) -> int64
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, rop)
 |  
 |  unsigned_value(self, *args) -> 'uint64'
 |      unsigned_value(self) -> uint64
 |  
 |  value(self, *args) -> 'uint64'
 |      value(self, is_signed) -> uint64
 |  
 |  zero(self, *args) -> 'void'
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from mop_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a
 |  
 |  b
 |  
 |  c
 |  
 |  cstr
 |  
 |  d
 |  
 |  f
 |  
 |  fpc
 |  
 |  g
 |  
 |  helper
 |  
 |  l
 |  
 |  meminfo
 |  
 |  nnn
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  oprops
 |      mop_t_oprops_get(self) -> uint8
 |  
 |  pair
 |  
 |  r
 |  
 |  s
 |  
 |  scif
 |  
 |  size
 |      mop_t_size_get(self) -> int
 |  
 |  t
 |      _get_t(self) -> mopt_t
 |  
 |  valnum
 |      mop_t_valnum_get(self) -> uint16
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from mop_t:
 |  
 |  __hash__ = None

Help on class mop_pair_t in module ida_hexrays:

class mop_pair_t(builtins.object)
 |  Proxy of C++ mop_pair_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mop_pair_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mop_pair_t(...)
 |      delete_mop_pair_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hop
 |      mop_pair_t_hop_get(self) -> mop_t
 |  
 |  lop
 |      mop_pair_t_lop_get(self) -> mop_t
 |  
 |  thisown
 |      The membership flag

Help on class mop_t in module ida_hexrays:

class mop_t(builtins.object)
 |  Proxy of C++ mop_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, rop) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mop_t
 |      __init__(self, rop) -> mop_t
 |      __init__(self, _r, _s) -> mop_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, rop) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, rop) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mop_t(...)
 |      delete_mop_t(self)
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_t(self)
 |  
 |  _get_a(self, *args) -> 'mop_addr_t *'
 |      _get_a(self) -> mop_addr_t
 |  
 |  _get_b(self, *args) -> 'int'
 |      _get_b(self) -> int
 |  
 |  _get_c(self, *args) -> 'mcases_t *'
 |      _get_c(self) -> mcases_t
 |  
 |  _get_cstr(self, *args) -> 'char const *'
 |      _get_cstr(self) -> char const *
 |  
 |  _get_d(self, *args) -> 'minsn_t *'
 |      _get_d(self) -> minsn_t
 |  
 |  _get_f(self, *args) -> 'mcallinfo_t *'
 |      _get_f(self) -> mcallinfo_t
 |  
 |  _get_fpc(self, *args) -> 'fnumber_t *'
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_g(self, *args) -> 'ea_t'
 |      _get_g(self) -> ea_t
 |  
 |  _get_helper(self, *args) -> 'char const *'
 |      _get_helper(self) -> char const *
 |  
 |  _get_l(self, *args) -> 'lvar_ref_t *'
 |      _get_l(self) -> lvar_ref_t
 |  
 |  _get_nnn(self, *args) -> 'mnumber_t *'
 |      _get_nnn(self) -> mnumber_t
 |  
 |  _get_pair(self, *args) -> 'mop_pair_t *'
 |      _get_pair(self) -> mop_pair_t
 |  
 |  _get_r(self, *args) -> 'mreg_t'
 |      _get_r(self) -> mreg_t
 |  
 |  _get_s(self, *args) -> 'stkvar_ref_t *'
 |      _get_s(self) -> stkvar_ref_t
 |  
 |  _get_scif(self, *args) -> 'scif_t *'
 |      _get_scif(self) -> scif_t
 |  
 |  _get_t(self, *args) -> 'mopt_t'
 |      _get_t(self) -> mopt_t
 |  
 |  _make_blkref(self, *args) -> 'void'
 |      _make_blkref(self, blknum)
 |  
 |  _make_callinfo(self, *args) -> 'void'
 |      _make_callinfo(self, fi)
 |  
 |  _make_cases(self, *args) -> 'void'
 |      _make_cases(self, _cases)
 |  
 |  _make_gvar(self, *args) -> 'void'
 |      _make_gvar(self, ea)
 |  
 |  _make_insn(self, *args) -> 'void'
 |      _make_insn(self, ins)
 |  
 |  _make_lvar(self, *args) -> 'void'
 |      _make_lvar(self, mba, idx, off=0)
 |  
 |  _make_pair(self, *args) -> 'void'
 |      _make_pair(self, _pair)
 |  
 |  _make_reg(self, *args) -> 'void'
 |      _make_reg(self, reg)
 |      _make_reg(self, reg, _size)
 |  
 |  _make_stkvar(self, *args) -> 'void'
 |      _make_stkvar(self, mba, off)
 |  
 |  _make_strlit(self, *args) -> 'void'
 |      _make_strlit(self, str)
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _mop_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _mop_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, shins_flags=0x04|0x02)
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _set_a(self, *args) -> 'void'
 |      _set_a(self, _v)
 |  
 |  _set_b(self, *args) -> 'void'
 |      _set_b(self, _v)
 |  
 |  _set_c(self, *args) -> 'void'
 |      _set_c(self, _v)
 |  
 |  _set_cstr(self, *args) -> 'void'
 |      _set_cstr(self, _v)
 |  
 |  _set_d(self, *args) -> 'void'
 |      _set_d(self, _v)
 |  
 |  _set_f(self, *args) -> 'void'
 |      _set_f(self, _v)
 |  
 |  _set_fpc(self, *args) -> 'void'
 |      _set_fpc(self, _v)
 |  
 |  _set_g(self, *args) -> 'void'
 |      _set_g(self, _v)
 |  
 |  _set_helper(self, *args) -> 'void'
 |      _set_helper(self, _v)
 |  
 |  _set_l(self, *args) -> 'void'
 |      _set_l(self, _v)
 |  
 |  _set_nnn(self, *args) -> 'void'
 |      _set_nnn(self, _v)
 |  
 |  _set_pair(self, *args) -> 'void'
 |      _set_pair(self, _v)
 |  
 |  _set_r(self, *args) -> 'void'
 |      _set_r(self, _v)
 |  
 |  _set_s(self, *args) -> 'void'
 |      _set_s(self, _v)
 |  
 |  _set_scif(self, *args) -> 'void'
 |      _set_scif(self, _v)
 |  
 |  _set_t(self, *args) -> 'void'
 |      _set_t(self, v)
 |  
 |  apply_ld_mcode(self, *args) -> 'void'
 |      apply_ld_mcode(self, mcode, ea, newsize)
 |  
 |  apply_xds(self, *args) -> 'void'
 |      apply_xds(self, ea, newsize)
 |  
 |  apply_xdu(self, *args) -> 'void'
 |      apply_xdu(self, ea, newsize)
 |  
 |  assign(self, *args) -> 'mop_t &'
 |      assign(self, rop) -> mop_t
 |  
 |  change_size(self, *args) -> 'bool'
 |      change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
 |  
 |  create_from_insn(self, *args) -> 'void'
 |      create_from_insn(self, m)
 |  
 |  create_from_ivlset(self, *args) -> 'bool'
 |      create_from_ivlset(self, mba, ivs, fullsize) -> bool
 |  
 |  create_from_mlist(self, *args) -> 'bool'
 |      create_from_mlist(self, mba, lst, fullsize) -> bool
 |  
 |  create_from_scattered_vdloc(self, *args) -> 'void'
 |      create_from_scattered_vdloc(self, mba, name, type, loc)
 |  
 |  create_from_vdloc(self, *args) -> 'void'
 |      create_from_vdloc(self, mba, loc, _size)
 |  
 |  double_size(self, *args) -> 'bool'
 |      double_size(self, sideff=WITH_SIDEFF) -> bool
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  equal_mops(self, *args) -> 'bool'
 |      equal_mops(self, rop, eqflags) -> bool
 |  
 |  erase(self, *args) -> 'void'
 |      erase(self)
 |  
 |  erase_but_keep_size(self, *args) -> 'void'
 |      erase_but_keep_size(self)
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv, type=None, is_target=False) -> int
 |  
 |  for_all_scattered_submops(self, *args) -> 'int'
 |      for_all_scattered_submops(self, sv) -> int
 |  
 |  get_insn(self, *args) -> 'minsn_t *'
 |      get_insn(self, code) -> minsn_t
 |      get_insn(self, code) -> minsn_t
 |  
 |  get_stkoff(self, *args) -> 'bool'
 |      get_stkoff(self, p_off) -> bool
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, p_off) -> member_t *
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |  
 |  is01(self, *args) -> 'bool'
 |      is01(self) -> bool
 |  
 |  is_arglist(self, *args) -> 'bool'
 |      is_arglist(self) -> bool
 |  
 |  is_bit_reg(self, *args) -> 'bool'
 |      is_bit_reg(self, reg) -> bool
 |      is_bit_reg(self) -> bool
 |  
 |  is_cc(self, *args) -> 'bool'
 |      is_cc(self) -> bool
 |  
 |  is_ccflags(self, *args) -> 'bool'
 |      is_ccflags(self) -> bool
 |  
 |  is_constant(self, *args) -> 'bool'
 |      is_constant(self, is_signed=True) -> bool
 |  
 |  is_equal_to(self, *args) -> 'bool'
 |      is_equal_to(self, n, is_signed=True) -> bool
 |  
 |  is_extended_from(self, *args) -> 'bool'
 |      is_extended_from(self, nbytes, is_signed) -> bool
 |  
 |  is_glbaddr(self, *args) -> 'bool'
 |      is_glbaddr(self) -> bool
 |      is_glbaddr(self, ea) -> bool
 |  
 |  is_impptr_done(self, *args) -> 'bool'
 |      is_impptr_done(self) -> bool
 |  
 |  is_insn(self, *args) -> 'bool'
 |      is_insn(self) -> bool
 |      is_insn(self, code) -> bool
 |  
 |  is_kreg(self, *args) -> 'bool'
 |      is_kreg(self) -> bool
 |  
 |  is_mob(self, *args) -> 'bool'
 |      is_mob(self, serial) -> bool
 |  
 |  is_negative_constant(self, *args) -> 'bool'
 |      is_negative_constant(self) -> bool
 |  
 |  is_one(self, *args) -> 'bool'
 |      is_one(self) -> bool
 |  
 |  is_positive_constant(self, *args) -> 'bool'
 |      is_positive_constant(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |      is_reg(self, _r) -> bool
 |      is_reg(self, _r, _size) -> bool
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |  
 |  is_sign_extended_from(self, *args) -> 'bool'
 |      is_sign_extended_from(self, nbytes) -> bool
 |  
 |  is_stkaddr(self, *args) -> 'bool'
 |      is_stkaddr(self) -> bool
 |  
 |  is_udt(self, *args) -> 'bool'
 |      is_udt(self) -> bool
 |  
 |  is_undef_val(self, *args) -> 'bool'
 |      is_undef_val(self) -> bool
 |  
 |  is_zero(self, *args) -> 'bool'
 |      is_zero(self) -> bool
 |  
 |  is_zero_extended_from(self, *args) -> 'bool'
 |      is_zero_extended_from(self, nbytes) -> bool
 |  
 |  lexcompare(self, *args) -> 'int'
 |      lexcompare(self, rop) -> int
 |  
 |  make_blkref(self, *args) -> 'void'
 |      make_blkref(self, blknum)
 |  
 |  make_first_half(self, *args) -> 'bool'
 |      make_first_half(self, width) -> bool
 |  
 |  make_fpnum(self, *args) -> 'bool'
 |      make_fpnum(self, bytes, _size) -> bool
 |  
 |  make_gvar(self, *args) -> 'void'
 |      make_gvar(self, ea)
 |  
 |  make_helper(self, *args) -> 'void'
 |      make_helper(self, name)
 |  
 |  make_high_half(self, *args) -> 'bool'
 |      make_high_half(self, width) -> bool
 |  
 |  make_insn(self, *args) -> 'void'
 |      make_insn(self, ins)
 |  
 |  make_low_half(self, *args) -> 'bool'
 |      make_low_half(self, width) -> bool
 |  
 |  make_number(self, *args) -> 'void'
 |      make_number(self, _value, _size, _ea=BADADDR, opnum=0)
 |  
 |  make_reg(self, *args) -> 'void'
 |      make_reg(self, reg)
 |      make_reg(self, reg, _size)
 |  
 |  make_reg_pair(self, *args) -> 'void'
 |      make_reg_pair(self, loreg, hireg, halfsize)
 |  
 |  make_second_half(self, *args) -> 'bool'
 |      make_second_half(self, width) -> bool
 |  
 |  may_use_aliased_memory(self, *args) -> 'bool'
 |      may_use_aliased_memory(self) -> bool
 |  
 |  preserve_side_effects(self, *args) -> 'bool'
 |      preserve_side_effects(self, blk, top, moved_calls=None) -> bool
 |  
 |  probably_floating(self, *args) -> 'bool'
 |      probably_floating(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  set_impptr_done(self, *args) -> 'void'
 |      set_impptr_done(self)
 |  
 |  set_udt(self, *args) -> 'void'
 |      set_udt(self)
 |  
 |  set_undef_val(self, *args) -> 'void'
 |      set_undef_val(self)
 |  
 |  shift_mop(self, *args) -> 'bool'
 |      shift_mop(self, offset) -> bool
 |  
 |  signed_value(self, *args) -> 'int64'
 |      signed_value(self) -> int64
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, rop)
 |  
 |  unsigned_value(self, *args) -> 'uint64'
 |      unsigned_value(self) -> uint64
 |  
 |  value(self, *args) -> 'uint64'
 |      value(self, is_signed) -> uint64
 |  
 |  zero(self, *args) -> 'void'
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a
 |  
 |  b
 |  
 |  c
 |  
 |  cstr
 |  
 |  d
 |  
 |  f
 |  
 |  fpc
 |  
 |  g
 |  
 |  helper
 |  
 |  l
 |  
 |  meminfo
 |  
 |  nnn
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  oprops
 |      mop_t_oprops_get(self) -> uint8
 |  
 |  pair
 |  
 |  r
 |  
 |  s
 |  
 |  scif
 |  
 |  size
 |      mop_t_size_get(self) -> int
 |  
 |  t
 |      _get_t(self) -> mopt_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  valnum
 |      mop_t_valnum_get(self) -> uint16
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class mop_visitor_t in module ida_hexrays:

class mop_visitor_t(op_parent_info_t)
 |  Proxy of C++ mop_visitor_t class.
 |  
 |  Method resolution order:
 |      mop_visitor_t
 |      op_parent_info_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba=None, _blk=None, _topins=None) -> mop_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mop_visitor_t(...)
 |      delete_mop_visitor_t(self)
 |  
 |  visit_mop(self, *args) -> 'int'
 |      visit_mop(self, op, type, is_target) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  prune
 |      mop_visitor_t_prune_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from op_parent_info_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blk
 |      op_parent_info_t_blk_get(self) -> mblock_t
 |  
 |  curins
 |      op_parent_info_t_curins_get(self) -> minsn_t
 |  
 |  mba
 |      op_parent_info_t_mba_get(self) -> mbl_array_t
 |  
 |  topins
 |      op_parent_info_t_topins_get(self) -> minsn_t

Help on class mopvec_t in module ida_hexrays:

class mopvec_t(builtins.object)
 |  Proxy of C++ qvector< mop_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'mop_t const &'
 |      __getitem__(self, i) -> mop_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mopvec_t
 |      __init__(self, x) -> mopvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_mopvec_t(...)
 |      delete_mopvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'mop_t const &'
 |      at(self, _idx) -> mop_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< mop_t >::const_iterator'
 |      begin(self) -> mop_t
 |      begin(self) -> mop_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< mop_t >::const_iterator'
 |      end(self) -> mop_t
 |      end(self) -> mop_t
 |  
 |  erase(self, *args) -> 'qvector< mop_t >::iterator'
 |      erase(self, it) -> mop_t
 |      erase(self, first, last) -> mop_t
 |  
 |  extract(self, *args) -> 'mop_t *'
 |      extract(self) -> mop_t
 |  
 |  find(self, *args) -> 'qvector< mop_t >::const_iterator'
 |      find(self, x) -> mop_t
 |      find(self, x) -> mop_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=mop_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< mop_t >::iterator'
 |      insert(self, it, x) -> mop_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'mop_t &'
 |      push_back(self, x)
 |      push_back(self) -> mop_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function mreg2reg in module ida_hexrays:

mreg2reg(*args) -> 'int'
    mreg2reg(reg, width) -> int
    
    
    Map a microregister to a processor register.
    
    @param reg: microregister number (C++: mreg_t)
    @param width: size of microregister in bytes (C++: int)
    @return: processor register id or -1

Help on function must_mcode_close_block in module ida_hexrays:

must_mcode_close_block(*args) -> 'bool'
    must_mcode_close_block(mcode, including_calls) -> bool
    
    
    Must an instruction with the given opcode be the last one in a block?
    Such opcodes are called closing opcodes.
    
    @param mcode: instruction opcode (C++: mcode_t)
    @param including_calls: should m_call/m_icall be considered as the
                            closing opcodes? If this function returns
                            true, the opcode cannot appear in the middle
                            of a block. Calls are a special case because
                            before MMAT_CALLS they are closing opcodes.
                            Afteer MMAT_CALLS that are not considered as
                            closing opcodes. (C++: bool)

Help on function negate_mcode_relation in module ida_hexrays:

negate_mcode_relation(*args) -> 'mcode_t'
    negate_mcode_relation(code) -> mcode_t

Help on function negated_relation in module ida_hexrays:

negated_relation(*args) -> 'ctype_t'
    negated_relation(op) -> ctype_t
    
    
    Negate a comparison operator. For example, cot_sge becomes cot_slt.
    
    
    @param op (C++: ctype_t)

Help on function new_block in module ida_hexrays:

new_block()

Help on class number_format_t in module ida_hexrays:

class number_format_t(builtins.object)
 |  Proxy of C++ number_format_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _opnum=0) -> number_format_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_number_format_t(...)
 |      delete_number_format_t(self)
 |  
 |  get_radix(self, *args) -> 'int'
 |      get_radix(self) -> int
 |  
 |  is_char(self, *args) -> 'bool'
 |      is_char(self) -> bool
 |  
 |  is_dec(self, *args) -> 'bool'
 |      is_dec(self) -> bool
 |  
 |  is_enum(self, *args) -> 'bool'
 |      is_enum(self) -> bool
 |  
 |  is_fixed(self, *args) -> 'bool'
 |      is_fixed(self) -> bool
 |  
 |  is_hex(self, *args) -> 'bool'
 |      is_hex(self) -> bool
 |  
 |  is_numop(self, *args) -> 'bool'
 |      is_numop(self) -> bool
 |  
 |  is_oct(self, *args) -> 'bool'
 |      is_oct(self) -> bool
 |  
 |  is_stroff(self, *args) -> 'bool'
 |      is_stroff(self) -> bool
 |  
 |  needs_to_be_inverted(self, *args) -> 'bool'
 |      needs_to_be_inverted(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      number_format_t_flags_get(self) -> flags_t
 |  
 |  opnum
 |      number_format_t_opnum_get(self) -> char
 |  
 |  org_nbytes
 |      number_format_t_org_nbytes_get(self) -> char
 |  
 |  props
 |      number_format_t_props_get(self) -> char
 |  
 |  serial
 |      number_format_t_serial_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  type_name
 |      number_format_t_type_name_get(self) -> qstring *

Help on class op_parent_info_t in module ida_hexrays:

class op_parent_info_t(builtins.object)
 |  Proxy of C++ op_parent_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba=None, _blk=None, _topins=None) -> op_parent_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_op_parent_info_t(...)
 |      delete_op_parent_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blk
 |      op_parent_info_t_blk_get(self) -> mblock_t
 |  
 |  curins
 |      op_parent_info_t_curins_get(self) -> minsn_t
 |  
 |  mba
 |      op_parent_info_t_mba_get(self) -> mbl_array_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  topins
 |      op_parent_info_t_topins_get(self) -> minsn_t

Help on function op_uses_x in module ida_hexrays:

op_uses_x(*args) -> 'bool'
    op_uses_x(op) -> bool
    
    
    Does operator use the 'x' field of 'cexpr_t' ?
    
    
    @param op (C++: ctype_t)

Help on function op_uses_y in module ida_hexrays:

op_uses_y(*args) -> 'bool'
    op_uses_y(op) -> bool
    
    
    Does operator use the 'y' field of 'cexpr_t' ?
    
    
    @param op (C++: ctype_t)

Help on function op_uses_z in module ida_hexrays:

op_uses_z(*args) -> 'bool'
    op_uses_z(op) -> bool
    
    
    Does operator use the 'z' field of 'cexpr_t' ?
    
    
    @param op (C++: ctype_t)

Help on function open_pseudocode in module ida_hexrays:

open_pseudocode(*args) -> 'vdui_t *'
    open_pseudocode(ea, new_window) -> vdui_t
    
    
    Open pseudocode window. The specified function is decompiled and the
    pseudocode window is opened.
    
    @param ea: function to decompile (C++: ea_t)
    @param new_window: 0:reuse existing window; 1:open new window; -1:
                       reuse existing window if the current view is
                       pseudocode (C++: int)
    @return: false if failed

Help on class operand_locator_t in module ida_hexrays:

class operand_locator_t(builtins.object)
 |  Proxy of C++ operand_locator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea, _opnum) -> operand_locator_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_operand_locator_t(...)
 |      delete_operand_locator_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      operand_locator_t_ea_get(self) -> ea_t
 |  
 |  opnum
 |      operand_locator_t_opnum_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class operator_info_t in module ida_hexrays:

class operator_info_t(builtins.object)
 |  Proxy of C++ operator_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> operator_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_operator_info_t(...)
 |      delete_operator_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fixtype
 |      operator_info_t_fixtype_get(self) -> uchar
 |  
 |  flags
 |      operator_info_t_flags_get(self) -> uchar
 |  
 |  precedence
 |      operator_info_t_precedence_get(self) -> uchar
 |  
 |  text
 |      operator_info_t_text_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  valency
 |      operator_info_t_valency_get(self) -> uchar

Help on class optblock_t in module ida_hexrays:

class optblock_t(builtins.object)
 |  Proxy of C++ optblock_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> optblock_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_optblock_t(...)
 |      delete_optblock_t(self)
 |  
 |  func(self, *args) -> 'int'
 |      func(self, blk) -> int
 |  
 |  install(self, *args) -> 'void'
 |      install(self)
 |  
 |  remove(self, *args) -> 'bool'
 |      remove(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class optinsn_t in module ida_hexrays:

class optinsn_t(builtins.object)
 |  Proxy of C++ optinsn_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> optinsn_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_optinsn_t(...)
 |      delete_optinsn_t(self)
 |  
 |  func(self, *args) -> 'int'
 |      func(self, blk, ins) -> int
 |  
 |  install(self, *args) -> 'void'
 |      install(self)
 |  
 |  remove(self, *args) -> 'bool'
 |      remove(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function parse_user_call in module ida_hexrays:

parse_user_call(*args) -> 'bool'
    parse_user_call(udc, decl, silent) -> bool
    
    
    Convert function type declaration into internal structure
    
    @param udc: - pointer to output structure (C++: udcall_t  *)
    @param decl: - function type declaration (C++: const char *)
    @param silent: - if TRUE: do not show warning in case of incorrect
                   type (C++: bool)
    @return: success

Help on function partial_type_num in module ida_hexrays:

partial_type_num(*args) -> 'int'
    partial_type_num(type) -> int
    
    
    Calculate number of partial subtypes.
    
    @param type (C++: const  tinfo_t  &)
    @return: number of partial subtypes. The bigger is this number, the
             uglier is the type.

Help on function print_vdloc in module ida_hexrays:

print_vdloc(*args) -> 'qstring *'
    print_vdloc(loc, nbytes)
    
    
    Print vdloc. Since vdloc does not always carry the size info, we pass
    it as NBYTES..
    
    @param loc (C++: const  vdloc_t  &)
    @param nbytes (C++: int)

Help on function property_op_to_typename in module ida_hexrays:

property_op_to_typename(self)

Help on class qlist_cinsn_t in module ida_hexrays:

class qlist_cinsn_t(builtins.object)
 |  Proxy of C++ qlist< cinsn_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, x) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qlist_cinsn_t
 |      __init__(self, x) -> qlist_cinsn_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, x) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qlist_cinsn_t(...)
 |      delete_qlist_cinsn_t(self)
 |  
 |  back(self, *args) -> 'cinsn_t const &'
 |      back(self) -> cinsn_t
 |      back(self) -> cinsn_t
 |  
 |  begin(self, *args) -> 'qlist_cinsn_t_iterator'
 |      begin(self) -> qlist_cinsn_t_iterator
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qlist_cinsn_t_iterator'
 |      end(self) -> qlist_cinsn_t_iterator
 |  
 |  erase(self, *args) -> 'void'
 |      erase(self, p) -> qlist< cinsn_t >::iterator
 |      erase(self, p1, p2)
 |      erase(self, p)
 |  
 |  front(self, *args) -> 'cinsn_t const &'
 |      front(self) -> cinsn_t
 |      front(self) -> cinsn_t
 |  
 |  insert(self, *args) -> 'qlist_cinsn_t_iterator'
 |      insert(self, p, x) -> qlist< cinsn_t >::iterator
 |      insert(self, p) -> qlist< cinsn_t >::iterator
 |      insert(self, p, x) -> qlist_cinsn_t_iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  pop_front(self, *args) -> 'void'
 |      pop_front(self)
 |  
 |  push_back(self, *args) -> 'cinsn_t &'
 |      push_back(self, x)
 |      push_back(self) -> cinsn_t
 |  
 |  push_front(self, *args) -> 'void'
 |      push_front(self, x)
 |  
 |  rbegin(self, *args) -> 'qlist< cinsn_t >::const_reverse_iterator'
 |      rbegin(self) -> qlist< cinsn_t >::reverse_iterator
 |      rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  rend(self, *args) -> 'qlist< cinsn_t >::const_reverse_iterator'
 |      rend(self) -> qlist< cinsn_t >::reverse_iterator
 |      rend(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, x)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class qlist_cinsn_t_iterator in module ida_hexrays:

class qlist_cinsn_t_iterator(builtins.object)
 |  Proxy of C++ qlist_cinsn_t_iterator class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, x) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qlist_cinsn_t_iterator
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, x) -> bool
 |  
 |  __next__(self, *args) -> 'void'
 |      __next__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qlist_cinsn_t_iterator(...)
 |      delete_qlist_cinsn_t_iterator(self)
 |  
 |  next = __next__(self, *args) -> 'void'
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cur
 |      qlist_cinsn_t_iterator_cur_get(self) -> cinsn_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class qstring_printer_t in module ida_hexrays:

class qstring_printer_t(vc_printer_t)
 |  Proxy of C++ qstring_printer_t class.
 |  
 |  Method resolution order:
 |      qstring_printer_t
 |      vc_printer_t
 |      vd_printer_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, f, tags) -> qstring_printer_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args) -> 'int'
 |      _print(self, indent, format) -> int
 |  
 |  get_s(self, *args) -> 'qstring'
 |      get_s(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  s
 |  
 |  thisown
 |      The membership flag
 |  
 |  with_tags
 |      qstring_printer_t_with_tags_get(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vc_printer_t:
 |  
 |  __disown__(self)
 |  
 |  __swig_destroy__ = delete_vc_printer_t(...)
 |      delete_vc_printer_t(self)
 |  
 |  oneliner(self, *args) -> 'bool'
 |      oneliner(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vc_printer_t:
 |  
 |  func
 |      vc_printer_t_func_get(self) -> cfunc_t
 |  
 |  lastchar
 |      vc_printer_t_lastchar_get(self) -> char
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vd_printer_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hdrlines
 |      vd_printer_t_hdrlines_get(self) -> int
 |  
 |  tmpbuf
 |      vd_printer_t_tmpbuf_get(self) -> qstring *

Help on function qswap in module ida_hexrays:

qswap(*args) -> 'void'
    qswap(a, b)

Help on class qvector_carg_t in module ida_hexrays:

class qvector_carg_t(builtins.object)
 |  Proxy of C++ qvector< carg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'carg_t const &'
 |      __getitem__(self, i) -> carg_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_carg_t
 |      __init__(self, x) -> qvector_carg_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_qvector_carg_t(...)
 |      delete_qvector_carg_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'carg_t &'
 |  
 |  at = __getitem__(self, *args) -> 'carg_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      begin(self) -> carg_t
 |      begin(self) -> carg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      end(self) -> carg_t
 |      end(self) -> carg_t
 |  
 |  erase(self, *args) -> 'qvector< carg_t >::iterator'
 |      erase(self, it) -> carg_t
 |      erase(self, first, last) -> carg_t
 |  
 |  extract(self, *args) -> 'carg_t *'
 |      extract(self) -> carg_t
 |  
 |  find(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      find(self, x) -> carg_t
 |      find(self, x) -> carg_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=carg_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< carg_t >::iterator'
 |      insert(self, it, x) -> carg_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'carg_t &'
 |      push_back(self, x)
 |      push_back(self) -> carg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class qvector_ccase_t in module ida_hexrays:

class qvector_ccase_t(builtins.object)
 |  Proxy of C++ qvector< ccase_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'ccase_t const &'
 |      __getitem__(self, i) -> ccase_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_ccase_t
 |      __init__(self, x) -> qvector_ccase_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_qvector_ccase_t(...)
 |      delete_qvector_ccase_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'ccase_t &'
 |  
 |  at = __getitem__(self, *args) -> 'ccase_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      begin(self) -> ccase_t
 |      begin(self) -> ccase_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      end(self) -> ccase_t
 |      end(self) -> ccase_t
 |  
 |  erase(self, *args) -> 'qvector< ccase_t >::iterator'
 |      erase(self, it) -> ccase_t
 |      erase(self, first, last) -> ccase_t
 |  
 |  extract(self, *args) -> 'ccase_t *'
 |      extract(self) -> ccase_t
 |  
 |  find(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      find(self, x) -> ccase_t
 |      find(self, x) -> ccase_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=ccase_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< ccase_t >::iterator'
 |      insert(self, it, x) -> ccase_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'ccase_t &'
 |      push_back(self, x)
 |      push_back(self) -> ccase_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class qvector_history_t in module ida_hexrays:

class qvector_history_t(builtins.object)
 |  Proxy of C++ qvector< history_item_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'history_item_t const &'
 |      __getitem__(self, i) -> history_item_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_history_t
 |      __init__(self, x) -> qvector_history_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_qvector_history_t(...)
 |      delete_qvector_history_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'history_item_t const &'
 |      at(self, _idx) -> history_item_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      begin(self) -> history_item_t
 |      begin(self) -> history_item_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      end(self) -> history_item_t
 |      end(self) -> history_item_t
 |  
 |  erase(self, *args) -> 'qvector< history_item_t >::iterator'
 |      erase(self, it) -> history_item_t
 |      erase(self, first, last) -> history_item_t
 |  
 |  extract(self, *args) -> 'history_item_t *'
 |      extract(self) -> history_item_t
 |  
 |  find(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      find(self, x) -> history_item_t
 |      find(self, x) -> history_item_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=history_item_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< history_item_t >::iterator'
 |      insert(self, it, x) -> history_item_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'history_item_t &'
 |      push_back(self, x)
 |      push_back(self) -> history_item_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class qvector_lvar_t in module ida_hexrays:

class qvector_lvar_t(builtins.object)
 |  Proxy of C++ qvector< lvar_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'lvar_t const &'
 |      __getitem__(self, i) -> lvar_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_lvar_t
 |      __init__(self, x) -> qvector_lvar_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_qvector_lvar_t(...)
 |      delete_qvector_lvar_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'lvar_t &'
 |  
 |  at = __getitem__(self, *args) -> 'lvar_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< lvar_t >::const_iterator'
 |      begin(self) -> lvar_t
 |      begin(self) -> lvar_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< lvar_t >::const_iterator'
 |      end(self) -> lvar_t
 |      end(self) -> lvar_t
 |  
 |  erase(self, *args) -> 'qvector< lvar_t >::iterator'
 |      erase(self, it) -> lvar_t
 |      erase(self, first, last) -> lvar_t
 |  
 |  extract(self, *args) -> 'lvar_t *'
 |      extract(self) -> lvar_t
 |  
 |  find(self, *args) -> 'qvector< lvar_t >::const_iterator'
 |      find(self, x) -> lvar_t
 |      find(self, x) -> lvar_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=lvar_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< lvar_t >::iterator'
 |      insert(self, it, x) -> lvar_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'lvar_t &'
 |      push_back(self, x)
 |      push_back(self) -> lvar_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function reg2mreg in module ida_hexrays:

reg2mreg(*args) -> 'mreg_t'
    reg2mreg(reg) -> mreg_t
    
    
    Map a processor register to a microregister.
    
    @param reg: processor register number (C++: int)
    @return: microregister register id or mr_none

Help on function remitem in module ida_hexrays:

remitem(*args) -> 'void'
    remitem(e)

Help on function remove_hexrays_callback in module ida_hexrays:

remove_hexrays_callback(callback)
    Deprecated. Please use Hexrays_Hooks instead

Help on function restore_user_cmts in module ida_hexrays:

restore_user_cmts(*args) -> 'user_cmts_t *'
    restore_user_cmts(func_ea) -> user_cmts_t
    
    
    Restore user defined comments from the database.
    
    @param func_ea: the entry address of the function (C++: ea_t)
    @return: collection of user defined comments. The returned object must
             be deleted by the caller using delete_user_cmts()

Help on function restore_user_defined_calls in module ida_hexrays:

restore_user_defined_calls(*args) -> 'bool'
    restore_user_defined_calls(udcalls, func_ea) -> bool
    
    
    Restore user defined function calls from the database.
    
    @param udcalls: ptr to output buffer (C++: udcall_map_t *)
    @param func_ea: entry address of the function (C++: ea_t)
    @return: success

Help on function restore_user_iflags in module ida_hexrays:

restore_user_iflags(*args) -> 'user_iflags_t *'
    restore_user_iflags(func_ea) -> user_iflags_t
    
    
    Restore user defined citem iflags from the database.
    
    @param func_ea: the entry address of the function (C++: ea_t)
    @return: collection of user defined iflags. The returned object must
             be deleted by the caller using delete_user_iflags()

Help on function restore_user_labels in module ida_hexrays:

restore_user_labels(*args) -> 'user_labels_t *'
    restore_user_labels(func_ea) -> user_labels_t
    
    
    Restore user defined labels from the database.
    
    @param func_ea: the entry address of the function (C++: ea_t)
    @return: collection of user defined labels. The returned object must
             be deleted by the caller using delete_user_labels()

Help on function restore_user_lvar_settings in module ida_hexrays:

restore_user_lvar_settings(*args) -> 'bool'
    restore_user_lvar_settings(lvinf, func_ea) -> bool
    
    
    Restore user defined local variable settings in the database.
    
    @param lvinf: ptr to output buffer (C++: lvar_uservec_t  *)
    @param func_ea: entry address of the function (C++: ea_t)
    @return: success

Help on function restore_user_numforms in module ida_hexrays:

restore_user_numforms(*args) -> 'user_numforms_t *'
    restore_user_numforms(func_ea) -> user_numforms_t
    
    
    Restore user defined number formats from the database.
    
    @param func_ea: the entry address of the function (C++: ea_t)
    @return: collection of user defined number formats. The returned
             object must be deleted by the caller using
             delete_user_numforms()

Help on function restore_user_unions in module ida_hexrays:

restore_user_unions(*args) -> 'user_unions_t *'
    restore_user_unions(func_ea) -> user_unions_t
    
    
    Restore user defined union field selections from the database.
    
    @param func_ea: the entry address of the function (C++: ea_t)
    @return: collection of union field selections The returned object must
             be deleted by the caller using delete_user_unions()

Help on class rlist_t in module ida_hexrays:

class rlist_t(bitset_t)
 |  Proxy of C++ rlist_t class.
 |  
 |  Method resolution order:
 |      rlist_t
 |      bitset_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rlist_t
 |      __init__(self, m) -> rlist_t
 |      __init__(self, reg, width) -> rlist_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_rlist_t(...)
 |      delete_rlist_t(self)
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from bitset_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __iter__(self)
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __len__ = count(self, *args) -> 'int'
 |      count(self) -> int
 |      count(self, bit) -> int
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  add(self, *args) -> 'bool'
 |      add(self, bit) -> bool
 |      add(self, bit, width) -> bool
 |      add(self, ml) -> bool
 |  
 |  back(self, *args) -> 'int'
 |      back(self) -> int
 |  
 |  begin(self, *args) -> 'bitset_t::iterator'
 |      begin(self) -> bitset_t::iterator
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  copy(self, *args) -> 'bitset_t &'
 |      copy(self, m) -> bitset_t
 |  
 |  count(self, *args) -> 'int'
 |      count(self) -> int
 |      count(self, bit) -> int
 |  
 |  cut_at(self, *args) -> 'bool'
 |      cut_at(self, maxbit) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'bitset_t::iterator'
 |      end(self) -> bitset_t::iterator
 |  
 |  fill_with_ones(self, *args) -> 'void'
 |      fill_with_ones(self, maxbit)
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, bit) -> bool
 |  
 |  has_all(self, *args) -> 'bool'
 |      has_all(self, bit, width) -> bool
 |  
 |  has_any(self, *args) -> 'bool'
 |      has_any(self, bit, width) -> bool
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, ml) -> bool
 |  
 |  inc(self, *args) -> 'void'
 |      inc(self, p, n=1)
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, ml) -> bool
 |  
 |  intersect(self, *args) -> 'bool'
 |      intersect(self, ml) -> bool
 |  
 |  is_subset_of(self, *args) -> 'bool'
 |      is_subset_of(self, ml) -> bool
 |  
 |  itat(self, *args) -> 'bitset_t::iterator'
 |      itat(self, n) -> bitset_t::iterator
 |  
 |  itv(self, *args) -> 'int'
 |      itv(self, it) -> int
 |  
 |  last(self, *args) -> 'int'
 |      last(self) -> int
 |  
 |  shift_down(self, *args) -> 'void'
 |      shift_down(self, shift)
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, bit) -> bool
 |      sub(self, bit, width) -> bool
 |      sub(self, ml) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from bitset_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from bitset_t:
 |  
 |  __hash__ = None

Help on function save_user_cmts in module ida_hexrays:

save_user_cmts(*args) -> 'void'
    save_user_cmts(func_ea, user_cmts)
    
    
    Save user defined comments into the database.
    
    @param func_ea: the entry address of the function (C++: ea_t)
    @param user_cmts: collection of user defined comments (C++: const
                      user_cmts_t *)

Help on function save_user_defined_calls in module ida_hexrays:

save_user_defined_calls(*args) -> 'void'
    save_user_defined_calls(func_ea, udcalls)
    
    
    Save user defined local function calls into the database.
    
    @param func_ea: entry address of the function (C++: ea_t)
    @param udcalls: user-specified info about user defined function calls
                    (C++: const udcall_map_t &)

Help on function save_user_iflags in module ida_hexrays:

save_user_iflags(*args) -> 'void'
    save_user_iflags(func_ea, iflags)
    
    
    Save user defined citem iflags into the database.
    
    @param func_ea: the entry address of the function (C++: ea_t)
    @param iflags: collection of user defined citem iflags (C++: const
                   user_iflags_t *)

Help on function save_user_labels in module ida_hexrays:

save_user_labels(*args) -> 'void'
    save_user_labels(func_ea, user_labels)
    
    
    Save user defined labels into the database.
    
    @param func_ea: the entry address of the function (C++: ea_t)
    @param user_labels: collection of user defined labels (C++: const
                        user_labels_t *)

Help on function save_user_lvar_settings in module ida_hexrays:

save_user_lvar_settings(*args) -> 'void'
    save_user_lvar_settings(func_ea, lvinf)
    
    
    Save user defined local variable settings into the database.
    
    @param func_ea: entry address of the function (C++: ea_t)
    @param lvinf: user-specified info about local variables (C++: const
                  lvar_uservec_t  &)

Help on function save_user_numforms in module ida_hexrays:

save_user_numforms(*args) -> 'void'
    save_user_numforms(func_ea, numforms)
    
    
    Save user defined number formats into the database.
    
    @param func_ea: the entry address of the function (C++: ea_t)
    @param numforms: collection of user defined comments (C++: const
                     user_numforms_t *)

Help on function save_user_unions in module ida_hexrays:

save_user_unions(*args) -> 'void'
    save_user_unions(func_ea, unions)
    
    
    Save user defined union field selections into the database.
    
    @param func_ea: the entry address of the function (C++: ea_t)
    @param unions: collection of union field selections (C++: const
                   user_unions_t *)

Help on class scif_t in module ida_hexrays:

class scif_t(vdloc_t)
 |  Proxy of C++ scif_t class.
 |  
 |  Method resolution order:
 |      scif_t
 |      vdloc_t
 |      ida_typeinf.argloc_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba, n, tif) -> scif_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_scif_t(...)
 |      delete_scif_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  mba
 |      scif_t_mba_get(self) -> mbl_array_t
 |  
 |  name
 |      scif_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      scif_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vdloc_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  _set_reg1(self, *args) -> 'void'
 |      _set_reg1(self, r1)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  is_aliasable(self, *args) -> 'bool'
 |      is_aliasable(self, mb, size) -> bool
 |  
 |  reg1(self, *args) -> 'int'
 |      reg1(self) -> int
 |  
 |  set_reg1(self, *args) -> 'void'
 |      set_reg1(self, r1)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from vdloc_t:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_typeinf.argloc_t:
 |  
 |  _consume_rrel(self, *args) -> 'bool'
 |      _consume_rrel(self, p) -> bool
 |  
 |  _consume_scattered(self, *args) -> 'bool'
 |      _consume_scattered(self, p) -> bool
 |  
 |  _set_badloc(self, *args) -> 'void'
 |      _set_badloc(self)
 |  
 |  _set_biggest(self, *args) -> 'void'
 |      _set_biggest(self, ct, data)
 |  
 |  _set_custom(self, *args) -> 'void'
 |      _set_custom(self, ct, pdata)
 |  
 |  _set_ea(self, *args) -> 'void'
 |      _set_ea(self, _ea)
 |  
 |  _set_reg2(self, *args) -> 'void'
 |      _set_reg2(self, _reg1, _reg2)
 |  
 |  _set_stkoff(self, *args) -> 'void'
 |      _set_stkoff(self, off)
 |  
 |  advance(self, *args) -> 'bool'
 |      advance(self, delta) -> bool
 |  
 |  atype(self, *args) -> 'argloc_type_t'
 |      atype(self) -> argloc_type_t
 |  
 |  calc_offset(self, *args) -> 'sval_t'
 |      calc_offset(self) -> sval_t
 |  
 |  consume_rrel(self, *args) -> 'void'
 |      consume_rrel(self, p)
 |  
 |  consume_scattered(self, *args) -> 'void'
 |      consume_scattered(self, p)
 |  
 |  get_biggest(self, *args) -> 'argloc_t::biggest_t'
 |      get_biggest(self) -> argloc_t::biggest_t
 |  
 |  get_custom(self, *args) -> 'void *'
 |      get_custom(self) -> void *
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self) -> ea_t
 |  
 |  get_reginfo(self, *args) -> 'uint32'
 |      get_reginfo(self) -> uint32
 |  
 |  get_rrel(self, *args) -> 'rrel_t const &'
 |      get_rrel(self) -> rrel_t
 |      get_rrel(self) -> rrel_t
 |  
 |  has_reg(self, *args) -> 'bool'
 |      has_reg(self) -> bool
 |  
 |  has_stkoff(self, *args) -> 'bool'
 |      has_stkoff(self) -> bool
 |  
 |  is_badloc(self, *args) -> 'bool'
 |      is_badloc(self) -> bool
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |  
 |  is_ea(self, *args) -> 'bool'
 |      is_ea(self) -> bool
 |  
 |  is_fragmented(self, *args) -> 'bool'
 |      is_fragmented(self) -> bool
 |  
 |  is_mixed_scattered(self, *args) -> 'bool'
 |      is_mixed_scattered(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |  
 |  is_rrel(self, *args) -> 'bool'
 |      is_rrel(self) -> bool
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |  
 |  justify_reg_high(self, *args) -> 'void'
 |      justify_reg_high(self, size, _slotsize)
 |  
 |  justify_stkoff_right(self, *args) -> 'void'
 |      justify_stkoff_right(self, size, _slotsize)
 |  
 |  reg2(self, *args) -> 'int'
 |      reg2(self) -> int
 |  
 |  regoff(self, *args) -> 'int'
 |      regoff(self) -> int
 |  
 |  scattered(self, *args) -> 'scattered_aloc_t const &'
 |      scattered(self) -> scattered_aloc_t
 |      scattered(self) -> scattered_aloc_t
 |  
 |  set_badloc(self, *args) -> 'void'
 |      set_badloc(self)
 |  
 |  set_ea(self, *args) -> 'void'
 |      set_ea(self, _ea)
 |  
 |  set_reg2(self, *args) -> 'void'
 |      set_reg2(self, _reg1, _reg2)
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, off)
 |  
 |  stkoff(self, *args) -> 'sval_t'
 |      stkoff(self) -> sval_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_typeinf.argloc_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class scif_visitor_t in module ida_hexrays:

class scif_visitor_t(builtins.object)
 |  Proxy of C++ scif_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> scif_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_scif_visitor_t(...)
 |      delete_scif_visitor_t(self)
 |  
 |  visit_scif_mop(self, *args) -> 'int'
 |      visit_scif_mop(self, r, off) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function select_udt_by_offset in module ida_hexrays:

select_udt_by_offset(*args) -> 'int'
    select_udt_by_offset(udts, ops, applicator) -> int
    
    
    Select UDT
    
    @param udts: list of UDT  tinfo_t  for the selection, if NULL or empty
                 then UDTs from the "Local types" will be used (C++: const
                 qvector <  tinfo_t  > *)
    @param ops: operands (C++: const  ui_stroff_ops_t  &)
    @param applicator (C++: ui_stroff_applicator_t  &)

Help on function send_database in module ida_hexrays:

send_database(*args) -> 'void'
    send_database(err, silent)
    
    
    Send the database to Hex-Rays. This function sends the current
    database to the Hex-Rays server. The database is sent in the
    compressed form over an encrypted (SSL) connection.
    
    @param err: failure description object. Empty  hexrays_failure_t
                object can be used if error information is not available.
                (C++: const  hexrays_failure_t  &)
    @param silent: if false, a dialog box will be displayed before sending
                   the database. (C++: bool)

Help on function set2jcnd in module ida_hexrays:

set2jcnd(*args) -> 'mcode_t'
    set2jcnd(code) -> mcode_t

Help on function set_type in module ida_hexrays:

set_type(*args) -> 'bool'
    set_type(id, tif, source, force=False) -> bool
    
    
    Set a global type.
    
    @param id: address or id of the object (C++: uval_t)
    @param tif: new type info (C++: const  tinfo_t  &)
    @param source: where the type comes from (C++: type_source_t)
    @param force: true means to set the type as is, false means to merge
                  the new type with the possibly existing old type info.
                  (C++: bool)
    @return: success

Help on class simple_graph_t in module ida_hexrays:

class simple_graph_t(builtins.object)
 |  Proxy of C++ simple_graph_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  colored_gdl_edges
 |      simple_graph_t_colored_gdl_edges_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  title
 |      simple_graph_t_title_get(self) -> qstring *

Help on class stkvar_ref_t in module ida_hexrays:

class stkvar_ref_t(builtins.object)
 |  Proxy of C++ stkvar_ref_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, m, o) -> stkvar_ref_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_stkvar_ref_t(...)
 |      delete_stkvar_ref_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, p_off=None) -> member_t *
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  mba
 |      stkvar_ref_t_mba_get(self) -> mbl_array_t
 |  
 |  off
 |      stkvar_ref_t_off_get(self) -> sval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function swap_mcode_relation in module ida_hexrays:

swap_mcode_relation(*args) -> 'mcode_t'
    swap_mcode_relation(code) -> mcode_t

Help on function swapped_relation in module ida_hexrays:

swapped_relation(*args) -> 'ctype_t'
    swapped_relation(op) -> ctype_t
    
    
    Swap a comparison operator. For example, cot_sge becomes cot_sle.
    
    
    @param op (C++: ctype_t)

Help on function term_hexrays_plugin in module ida_hexrays:

term_hexrays_plugin(*args) -> 'void'
    term_hexrays_plugin()
    
    
    Stop working with hex-rays decompiler.

Help on class treeloc_t in module ida_hexrays:

class treeloc_t(builtins.object)
 |  Proxy of C++ treeloc_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> treeloc_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_treeloc_t(...)
 |      delete_treeloc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      treeloc_t_ea_get(self) -> ea_t
 |  
 |  itp
 |      treeloc_t_itp_get(self) -> item_preciser_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class udc_filter_t in module ida_hexrays:

class udc_filter_t(microcode_filter_t)
 |  Proxy of C++ udc_filter_t class.
 |  
 |  Method resolution order:
 |      udc_filter_t
 |      microcode_filter_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udc_filter_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udc_filter_t(...)
 |      delete_udc_filter_t(self)
 |  
 |  apply(self, *args) -> 'merror_t'
 |      apply(self, cdg) -> merror_t
 |  
 |  init(self, *args) -> 'bool'
 |      init(self, decl) -> bool
 |  
 |  match(self, *args) -> 'bool'
 |      match(self, cdg) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from microcode_filter_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function udcall_map_begin in module ida_hexrays:

udcall_map_begin(*args) -> 'udcall_map_iterator_t'
    udcall_map_begin(map) -> udcall_map_iterator_t
    
    
    Get iterator pointing to the beginning of udcall_map_t.
    
    
    @param map (C++: const udcall_map_t *)

Help on function udcall_map_clear in module ida_hexrays:

udcall_map_clear(*args) -> 'void'
    udcall_map_clear(map)
    
    
    Clear udcall_map_t.
    
    
    @param map (C++: udcall_map_t *)

Help on function udcall_map_end in module ida_hexrays:

udcall_map_end(*args) -> 'udcall_map_iterator_t'
    udcall_map_end(map) -> udcall_map_iterator_t
    
    
    Get iterator pointing to the end of udcall_map_t.
    
    
    @param map (C++: const udcall_map_t *)

Help on function udcall_map_erase in module ida_hexrays:

udcall_map_erase(*args) -> 'void'
    udcall_map_erase(map, p)
    
    
    Erase current element from udcall_map_t.
    
    
    @param map (C++: udcall_map_t *)
    @param p (C++: udcall_map_iterator_t)

Help on function udcall_map_find in module ida_hexrays:

udcall_map_find(*args) -> 'udcall_map_iterator_t'
    udcall_map_find(map, key) -> udcall_map_iterator_t
    
    
    Find the specified key in udcall_map_t.
    
    
    @param map (C++: const udcall_map_t *)
    @param key (C++: const ea_t &)

Help on function udcall_map_first in module ida_hexrays:

udcall_map_first(*args) -> 'ea_t const &'
    udcall_map_first(p) -> ea_t const &
    
    
    Get reference to the current map key.
    
    
    @param p (C++: udcall_map_iterator_t)

Help on function udcall_map_free in module ida_hexrays:

udcall_map_free(*args) -> 'void'
    udcall_map_free(map)
    
    
    Delete udcall_map_t instance.
    
    
    @param map (C++: udcall_map_t *)

Help on function udcall_map_insert in module ida_hexrays:

udcall_map_insert(*args) -> 'udcall_map_iterator_t'
    udcall_map_insert(map, key, val) -> udcall_map_iterator_t
    
    
    Insert new (ea_t, 'udcall_t' ) pair into udcall_map_t.
    
    
    @param map (C++: udcall_map_t *)
    @param key (C++: const ea_t &)
    @param val (C++: const  udcall_t  &)

Help on class udcall_map_iterator_t in module ida_hexrays:

class udcall_map_iterator_t(builtins.object)
 |  Proxy of C++ udcall_map_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udcall_map_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udcall_map_iterator_t(...)
 |      delete_udcall_map_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      udcall_map_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function udcall_map_new in module ida_hexrays:

udcall_map_new(*args) -> 'udcall_map_t *'
    udcall_map_new() -> udcall_map_t *
    
    
    Create a new udcall_map_t instance.

Help on function udcall_map_next in module ida_hexrays:

udcall_map_next(*args) -> 'udcall_map_iterator_t'
    udcall_map_next(p) -> udcall_map_iterator_t
    
    
    Move to the next element.
    
    
    @param p (C++: udcall_map_iterator_t)

Help on function udcall_map_prev in module ida_hexrays:

udcall_map_prev(*args) -> 'udcall_map_iterator_t'
    udcall_map_prev(p) -> udcall_map_iterator_t
    
    
    Move to the previous element.
    
    
    @param p (C++: udcall_map_iterator_t)

Help on function udcall_map_second in module ida_hexrays:

udcall_map_second(*args) -> 'udcall_t &'
    udcall_map_second(p) -> udcall_t
    
    
    Get reference to the current map value.
    
    
    @param p (C++: udcall_map_iterator_t)

Help on function udcall_map_size in module ida_hexrays:

udcall_map_size(*args) -> 'size_t'
    udcall_map_size(map) -> size_t
    
    
    Get size of udcall_map_t.
    
    
    @param map (C++: udcall_map_t *)

Help on class udcall_t in module ida_hexrays:

class udcall_t(builtins.object)
 |  Proxy of C++ udcall_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udcall_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udcall_t(...)
 |      delete_udcall_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      udcall_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  tif
 |      udcall_t_tif_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class ui_stroff_applicator_t in module ida_hexrays:

class ui_stroff_applicator_t(builtins.object)
 |  Proxy of C++ ui_stroff_applicator_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_stroff_applicator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ui_stroff_applicator_t(...)
 |      delete_ui_stroff_applicator_t(self)
 |  
 |  apply(self, *args) -> 'bool'
 |      apply(self, opnum, path) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class ui_stroff_op_t in module ida_hexrays:

class ui_stroff_op_t(builtins.object)
 |  Proxy of C++ ui_stroff_op_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_stroff_op_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ui_stroff_op_t(...)
 |      delete_ui_stroff_op_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  offset
 |      ui_stroff_op_t_offset_get(self) -> uval_t
 |  
 |  text
 |      ui_stroff_op_t_text_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class ui_stroff_ops_t in module ida_hexrays:

class ui_stroff_ops_t(builtins.object)
 |  Proxy of C++ qvector< ui_stroff_op_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'ui_stroff_op_t const &'
 |      __getitem__(self, i) -> ui_stroff_op_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_stroff_ops_t
 |      __init__(self, x) -> ui_stroff_ops_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_ui_stroff_ops_t(...)
 |      delete_ui_stroff_ops_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'ui_stroff_op_t &'
 |  
 |  at = __getitem__(self, *args) -> 'ui_stroff_op_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< ui_stroff_op_t >::const_iterator'
 |      begin(self) -> ui_stroff_op_t
 |      begin(self) -> ui_stroff_op_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< ui_stroff_op_t >::const_iterator'
 |      end(self) -> ui_stroff_op_t
 |      end(self) -> ui_stroff_op_t
 |  
 |  erase(self, *args) -> 'qvector< ui_stroff_op_t >::iterator'
 |      erase(self, it) -> ui_stroff_op_t
 |      erase(self, first, last) -> ui_stroff_op_t
 |  
 |  extract(self, *args) -> 'ui_stroff_op_t *'
 |      extract(self) -> ui_stroff_op_t
 |  
 |  find(self, *args) -> 'qvector< ui_stroff_op_t >::const_iterator'
 |      find(self, x) -> ui_stroff_op_t
 |      find(self, x) -> ui_stroff_op_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=ui_stroff_op_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< ui_stroff_op_t >::iterator'
 |      insert(self, it, x) -> ui_stroff_op_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'ui_stroff_op_t &'
 |      push_back(self, x)
 |      push_back(self) -> ui_stroff_op_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_cmts_begin in module ida_hexrays:

user_cmts_begin(*args) -> 'user_cmts_iterator_t'
    user_cmts_begin(map) -> user_cmts_iterator_t
    
    
    Get iterator pointing to the beginning of user_cmts_t.
    
    
    @param map (C++: const user_cmts_t *)

Help on function user_cmts_clear in module ida_hexrays:

user_cmts_clear(*args) -> 'void'
    user_cmts_clear(map)
    
    
    Clear user_cmts_t.
    
    
    @param map (C++: user_cmts_t *)

Help on function user_cmts_end in module ida_hexrays:

user_cmts_end(*args) -> 'user_cmts_iterator_t'
    user_cmts_end(map) -> user_cmts_iterator_t
    
    
    Get iterator pointing to the end of user_cmts_t.
    
    
    @param map (C++: const user_cmts_t *)

Help on function user_cmts_erase in module ida_hexrays:

user_cmts_erase(*args) -> 'void'
    user_cmts_erase(map, p)
    
    
    Erase current element from user_cmts_t.
    
    
    @param map (C++: user_cmts_t *)
    @param p (C++: user_cmts_iterator_t)

Help on function user_cmts_find in module ida_hexrays:

user_cmts_find(*args) -> 'user_cmts_iterator_t'
    user_cmts_find(map, key) -> user_cmts_iterator_t
    
    
    Find the specified key in user_cmts_t.
    
    
    @param map (C++: const user_cmts_t *)
    @param key (C++: const  treeloc_t  &)

Help on function user_cmts_first in module ida_hexrays:

user_cmts_first(*args) -> 'treeloc_t const &'
    user_cmts_first(p) -> treeloc_t
    
    
    Get reference to the current map key.
    
    
    @param p (C++: user_cmts_iterator_t)

Help on function user_cmts_free in module ida_hexrays:

user_cmts_free(*args) -> 'void'
    user_cmts_free(map)
    
    
    Delete user_cmts_t instance.
    
    
    @param map (C++: user_cmts_t *)

Help on function user_cmts_insert in module ida_hexrays:

user_cmts_insert(*args) -> 'user_cmts_iterator_t'
    user_cmts_insert(map, key, val) -> user_cmts_iterator_t
    
    
    Insert new ( 'treeloc_t' , 'citem_cmt_t' ) pair into user_cmts_t.
    
    
    @param map (C++: user_cmts_t *)
    @param key (C++: const  treeloc_t  &)
    @param val (C++: const  citem_cmt_t  &)

Help on class user_cmts_iterator_t in module ida_hexrays:

class user_cmts_iterator_t(builtins.object)
 |  Proxy of C++ user_cmts_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_cmts_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_cmts_iterator_t(...)
 |      delete_user_cmts_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      user_cmts_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_cmts_new in module ida_hexrays:

user_cmts_new(*args) -> 'user_cmts_t *'
    user_cmts_new() -> user_cmts_t
    
    
    Create a new user_cmts_t instance.

Help on function user_cmts_next in module ida_hexrays:

user_cmts_next(*args) -> 'user_cmts_iterator_t'
    user_cmts_next(p) -> user_cmts_iterator_t
    
    
    Move to the next element.
    
    
    @param p (C++: user_cmts_iterator_t)

Help on function user_cmts_prev in module ida_hexrays:

user_cmts_prev(*args) -> 'user_cmts_iterator_t'
    user_cmts_prev(p) -> user_cmts_iterator_t
    
    
    Move to the previous element.
    
    
    @param p (C++: user_cmts_iterator_t)

Help on function user_cmts_second in module ida_hexrays:

user_cmts_second(*args) -> 'citem_cmt_t &'
    user_cmts_second(p) -> citem_cmt_t
    
    
    Get reference to the current map value.
    
    
    @param p (C++: user_cmts_iterator_t)

Help on function user_cmts_size in module ida_hexrays:

user_cmts_size(*args) -> 'size_t'
    user_cmts_size(map) -> size_t
    
    
    Get size of user_cmts_t.
    
    
    @param map (C++: user_cmts_t *)

Help on class user_cmts_t in module ida_hexrays:

class user_cmts_t(builtins.object)
 |  Proxy of C++ std::map< treeloc_t,citem_cmt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = user_cmts_begin(...)
 |      user_cmts_begin(map) -> user_cmts_iterator_t
 |  
 |  __clear = user_cmts_clear(...)
 |      user_cmts_clear(map)
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = user_cmts_end(...)
 |      user_cmts_end(map) -> user_cmts_iterator_t
 |  
 |  __erase = user_cmts_erase(...)
 |      user_cmts_erase(map, p)
 |  
 |  __find = user_cmts_find(...)
 |      user_cmts_find(map, key) -> user_cmts_iterator_t
 |  
 |  __first = user_cmts_first(...)
 |      user_cmts_first(p) -> treeloc_t
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_cmts_t
 |  
 |  __insert = user_cmts_insert(...)
 |      user_cmts_insert(map, key, val) -> user_cmts_iterator_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = user_cmts_next(...)
 |      user_cmts_next(p) -> user_cmts_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = user_cmts_second(...)
 |      user_cmts_second(p) -> citem_cmt_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = user_cmts_size(...)
 |      user_cmts_size(map) -> size_t
 |  
 |  __swig_destroy__ = delete_user_cmts_t(...)
 |      delete_user_cmts_t(self)
 |  
 |  at(self, *args) -> 'citem_cmt_t &'
 |      at(self, _Keyval) -> citem_cmt_t
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = <class 'ida_hexrays.treeloc_t'>
 |      Proxy of C++ treeloc_t class.
 |  
 |  valuetype = <class 'ida_hexrays.citem_cmt_t'>
 |      Proxy of C++ citem_cmt_t class.

Help on function user_iflags_begin in module ida_hexrays:

user_iflags_begin(*args) -> 'user_iflags_iterator_t'
    user_iflags_begin(map) -> user_iflags_iterator_t
    
    
    Get iterator pointing to the beginning of user_iflags_t.
    
    
    @param map (C++: const user_iflags_t *)

Help on function user_iflags_clear in module ida_hexrays:

user_iflags_clear(*args) -> 'void'
    user_iflags_clear(map)
    
    
    Clear user_iflags_t.
    
    
    @param map (C++: user_iflags_t *)

Help on function user_iflags_end in module ida_hexrays:

user_iflags_end(*args) -> 'user_iflags_iterator_t'
    user_iflags_end(map) -> user_iflags_iterator_t
    
    
    Get iterator pointing to the end of user_iflags_t.
    
    
    @param map (C++: const user_iflags_t *)

Help on function user_iflags_erase in module ida_hexrays:

user_iflags_erase(*args) -> 'void'
    user_iflags_erase(map, p)
    
    
    Erase current element from user_iflags_t.
    
    
    @param map (C++: user_iflags_t *)
    @param p (C++: user_iflags_iterator_t)

Help on function user_iflags_find in module ida_hexrays:

user_iflags_find(*args) -> 'user_iflags_iterator_t'
    user_iflags_find(map, key) -> user_iflags_iterator_t
    
    
    Find the specified key in user_iflags_t.
    
    
    @param map (C++: const user_iflags_t *)
    @param key (C++: const  citem_locator_t  &)

Help on function user_iflags_first in module ida_hexrays:

user_iflags_first(*args) -> 'citem_locator_t const &'
    user_iflags_first(p) -> citem_locator_t
    
    
    Get reference to the current map key.
    
    
    @param p (C++: user_iflags_iterator_t)

Help on function user_iflags_free in module ida_hexrays:

user_iflags_free(*args) -> 'void'
    user_iflags_free(map)
    
    
    Delete user_iflags_t instance.
    
    
    @param map (C++: user_iflags_t *)

Help on function user_iflags_insert in module ida_hexrays:

user_iflags_insert(*args) -> 'user_iflags_iterator_t'
    user_iflags_insert(map, key, val) -> user_iflags_iterator_t
    
    
    Insert new ( 'citem_locator_t' , int32) pair into user_iflags_t.
    
    
    @param map (C++: user_iflags_t *)
    @param key (C++: const  citem_locator_t  &)
    @param val (C++: const  int32  &)

Help on class user_iflags_iterator_t in module ida_hexrays:

class user_iflags_iterator_t(builtins.object)
 |  Proxy of C++ user_iflags_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_iflags_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_iflags_iterator_t(...)
 |      delete_user_iflags_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      user_iflags_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_iflags_new in module ida_hexrays:

user_iflags_new(*args) -> 'user_iflags_t *'
    user_iflags_new() -> user_iflags_t
    
    
    Create a new user_iflags_t instance.

Help on function user_iflags_next in module ida_hexrays:

user_iflags_next(*args) -> 'user_iflags_iterator_t'
    user_iflags_next(p) -> user_iflags_iterator_t
    
    
    Move to the next element.
    
    
    @param p (C++: user_iflags_iterator_t)

Help on function user_iflags_prev in module ida_hexrays:

user_iflags_prev(*args) -> 'user_iflags_iterator_t'
    user_iflags_prev(p) -> user_iflags_iterator_t
    
    
    Move to the previous element.
    
    
    @param p (C++: user_iflags_iterator_t)

Help on function user_iflags_second in module ida_hexrays:

user_iflags_second(*args) -> 'int32 const &'
    user_iflags_second(p) -> int32 const &
    
    
    Get reference to the current map value.
    
    
    @param p (C++: user_iflags_iterator_t)

Help on function user_iflags_size in module ida_hexrays:

user_iflags_size(*args) -> 'size_t'
    user_iflags_size(map) -> size_t
    
    
    Get size of user_iflags_t.
    
    
    @param map (C++: user_iflags_t *)

Help on class user_iflags_t in module ida_hexrays:

class user_iflags_t(builtins.object)
 |  Proxy of C++ std::map< citem_locator_t,int32 > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = user_iflags_begin(...)
 |      user_iflags_begin(map) -> user_iflags_iterator_t
 |  
 |  __clear = user_iflags_clear(...)
 |      user_iflags_clear(map)
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = user_iflags_end(...)
 |      user_iflags_end(map) -> user_iflags_iterator_t
 |  
 |  __erase = user_iflags_erase(...)
 |      user_iflags_erase(map, p)
 |  
 |  __find = user_iflags_find(...)
 |      user_iflags_find(map, key) -> user_iflags_iterator_t
 |  
 |  __first = user_iflags_first(...)
 |      user_iflags_first(p) -> citem_locator_t
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_iflags_t
 |  
 |  __insert = user_iflags_insert(...)
 |      user_iflags_insert(map, key, val) -> user_iflags_iterator_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = user_iflags_next(...)
 |      user_iflags_next(p) -> user_iflags_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = user_iflags_second(...)
 |      user_iflags_second(p) -> int32 const &
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = user_iflags_size(...)
 |      user_iflags_size(map) -> size_t
 |  
 |  __swig_destroy__ = delete_user_iflags_t(...)
 |      delete_user_iflags_t(self)
 |  
 |  at(self, *args) -> 'int &'
 |      at(self, _Keyval) -> int &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = <class 'ida_hexrays.citem_locator_t'>
 |      Proxy of C++ citem_locator_t class.
 |  
 |  valuetype = <class 'int'>
 |      int(x=0) -> integer
 |      int(x, base=10) -> integer
 |      
 |      Convert a number or string to an integer, or return 0 if no arguments
 |      are given.  If x is a number, return x.__int__().  For floating point
 |      numbers, this truncates towards zero.
 |      
 |      If x is not a number or if base is given, then x must be a string,
 |      bytes, or bytearray instance representing an integer literal in the
 |      given base.  The literal can be preceded by '+' or '-' and be surrounded
 |      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
 |      Base 0 means to interpret the base from the string as an integer literal.
 |      >>> int('0b100', base=0)
 |      4

Help on function user_labels_begin in module ida_hexrays:

user_labels_begin(*args) -> 'user_labels_iterator_t'
    user_labels_begin(map) -> user_labels_iterator_t
    
    
    Get iterator pointing to the beginning of user_labels_t.
    
    
    @param map (C++: const user_labels_t *)

Help on function user_labels_clear in module ida_hexrays:

user_labels_clear(*args) -> 'void'
    user_labels_clear(map)
    
    
    Clear user_labels_t.
    
    
    @param map (C++: user_labels_t *)

Help on function user_labels_end in module ida_hexrays:

user_labels_end(*args) -> 'user_labels_iterator_t'
    user_labels_end(map) -> user_labels_iterator_t
    
    
    Get iterator pointing to the end of user_labels_t.
    
    
    @param map (C++: const user_labels_t *)

Help on function user_labels_erase in module ida_hexrays:

user_labels_erase(*args) -> 'void'
    user_labels_erase(map, p)
    
    
    Erase current element from user_labels_t.
    
    
    @param map (C++: user_labels_t *)
    @param p (C++: user_labels_iterator_t)

Help on function user_labels_find in module ida_hexrays:

user_labels_find(*args) -> 'user_labels_iterator_t'
    user_labels_find(map, key) -> user_labels_iterator_t
    
    
    Find the specified key in user_labels_t.
    
    
    @param map (C++: const user_labels_t *)
    @param key (C++: const int &)

Help on function user_labels_first in module ida_hexrays:

user_labels_first(*args) -> 'int const &'
    user_labels_first(p) -> int const &
    
    
    Get reference to the current map key.
    
    
    @param p (C++: user_labels_iterator_t)

Help on function user_labels_free in module ida_hexrays:

user_labels_free(*args) -> 'void'
    user_labels_free(map)
    
    
    Delete user_labels_t instance.
    
    
    @param map (C++: user_labels_t *)

Help on function user_labels_insert in module ida_hexrays:

user_labels_insert(*args) -> 'user_labels_iterator_t'
    user_labels_insert(map, key, val) -> user_labels_iterator_t
    
    
    Insert new (int, qstring) pair into user_labels_t.
    
    
    @param map (C++: user_labels_t *)
    @param key (C++: const int &)
    @param val (C++: const  qstring  &)

Help on class user_labels_iterator_t in module ida_hexrays:

class user_labels_iterator_t(builtins.object)
 |  Proxy of C++ user_labels_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_labels_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_labels_iterator_t(...)
 |      delete_user_labels_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      user_labels_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_labels_new in module ida_hexrays:

user_labels_new(*args) -> 'user_labels_t *'
    user_labels_new() -> user_labels_t
    
    
    Create a new user_labels_t instance.

Help on function user_labels_next in module ida_hexrays:

user_labels_next(*args) -> 'user_labels_iterator_t'
    user_labels_next(p) -> user_labels_iterator_t
    
    
    Move to the next element.
    
    
    @param p (C++: user_labels_iterator_t)

Help on function user_labels_prev in module ida_hexrays:

user_labels_prev(*args) -> 'user_labels_iterator_t'
    user_labels_prev(p) -> user_labels_iterator_t
    
    
    Move to the previous element.
    
    
    @param p (C++: user_labels_iterator_t)

Help on function user_labels_second in module ida_hexrays:

user_labels_second(*args) -> 'qstring &'
    user_labels_second(p) -> qstring &
    
    
    Get reference to the current map value.
    
    
    @param p (C++: user_labels_iterator_t)

Help on function user_labels_size in module ida_hexrays:

user_labels_size(*args) -> 'size_t'
    user_labels_size(map) -> size_t
    
    
    Get size of user_labels_t.
    
    
    @param map (C++: user_labels_t *)

Help on class user_labels_t in module ida_hexrays:

class user_labels_t(builtins.object)
 |  Proxy of C++ std::map< int,qstring > class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_labels_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_labels_t(...)
 |      delete_user_labels_t(self)
 |  
 |  at(self, *args) -> '_qstring< char > &'
 |      at(self, _Keyval) -> _qstring< char > &
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class user_lvar_modifier_t in module ida_hexrays:

class user_lvar_modifier_t(builtins.object)
 |  Proxy of C++ user_lvar_modifier_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_lvar_modifier_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_lvar_modifier_t(...)
 |      delete_user_lvar_modifier_t(self)
 |  
 |  modify_lvars(self, *args) -> 'bool'
 |      modify_lvars(self, lvinf) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function user_numforms_begin in module ida_hexrays:

user_numforms_begin(*args) -> 'user_numforms_iterator_t'
    user_numforms_begin(map) -> user_numforms_iterator_t
    
    
    Get iterator pointing to the beginning of user_numforms_t.
    
    
    @param map (C++: const user_numforms_t *)

Help on function user_numforms_clear in module ida_hexrays:

user_numforms_clear(*args) -> 'void'
    user_numforms_clear(map)
    
    
    Clear user_numforms_t.
    
    
    @param map (C++: user_numforms_t *)

Help on function user_numforms_end in module ida_hexrays:

user_numforms_end(*args) -> 'user_numforms_iterator_t'
    user_numforms_end(map) -> user_numforms_iterator_t
    
    
    Get iterator pointing to the end of user_numforms_t.
    
    
    @param map (C++: const user_numforms_t *)

Help on function user_numforms_erase in module ida_hexrays:

user_numforms_erase(*args) -> 'void'
    user_numforms_erase(map, p)
    
    
    Erase current element from user_numforms_t.
    
    
    @param map (C++: user_numforms_t *)
    @param p (C++: user_numforms_iterator_t)

Help on function user_numforms_find in module ida_hexrays:

user_numforms_find(*args) -> 'user_numforms_iterator_t'
    user_numforms_find(map, key) -> user_numforms_iterator_t
    
    
    Find the specified key in user_numforms_t.
    
    
    @param map (C++: const user_numforms_t *)
    @param key (C++: const  operand_locator_t  &)

Help on function user_numforms_first in module ida_hexrays:

user_numforms_first(*args) -> 'operand_locator_t const &'
    user_numforms_first(p) -> operand_locator_t
    
    
    Get reference to the current map key.
    
    
    @param p (C++: user_numforms_iterator_t)

Help on function user_numforms_free in module ida_hexrays:

user_numforms_free(*args) -> 'void'
    user_numforms_free(map)
    
    
    Delete user_numforms_t instance.
    
    
    @param map (C++: user_numforms_t *)

Help on function user_numforms_insert in module ida_hexrays:

user_numforms_insert(*args) -> 'user_numforms_iterator_t'
    user_numforms_insert(map, key, val) -> user_numforms_iterator_t
    
    
    Insert new ( 'operand_locator_t' , 'number_format_t' ) pair into
    user_numforms_t.
    
    
    @param map (C++: user_numforms_t *)
    @param key (C++: const  operand_locator_t  &)
    @param val (C++: const  number_format_t  &)

Help on class user_numforms_iterator_t in module ida_hexrays:

class user_numforms_iterator_t(builtins.object)
 |  Proxy of C++ user_numforms_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_numforms_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_numforms_iterator_t(...)
 |      delete_user_numforms_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      user_numforms_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_numforms_new in module ida_hexrays:

user_numforms_new(*args) -> 'user_numforms_t *'
    user_numforms_new() -> user_numforms_t
    
    
    Create a new user_numforms_t instance.

Help on function user_numforms_next in module ida_hexrays:

user_numforms_next(*args) -> 'user_numforms_iterator_t'
    user_numforms_next(p) -> user_numforms_iterator_t
    
    
    Move to the next element.
    
    
    @param p (C++: user_numforms_iterator_t)

Help on function user_numforms_prev in module ida_hexrays:

user_numforms_prev(*args) -> 'user_numforms_iterator_t'
    user_numforms_prev(p) -> user_numforms_iterator_t
    
    
    Move to the previous element.
    
    
    @param p (C++: user_numforms_iterator_t)

Help on function user_numforms_second in module ida_hexrays:

user_numforms_second(*args) -> 'number_format_t &'
    user_numforms_second(p) -> number_format_t
    
    
    Get reference to the current map value.
    
    
    @param p (C++: user_numforms_iterator_t)

Help on function user_numforms_size in module ida_hexrays:

user_numforms_size(*args) -> 'size_t'
    user_numforms_size(map) -> size_t
    
    
    Get size of user_numforms_t.
    
    
    @param map (C++: user_numforms_t *)

Help on class user_numforms_t in module ida_hexrays:

class user_numforms_t(builtins.object)
 |  Proxy of C++ std::map< operand_locator_t,number_format_t > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = user_numforms_begin(...)
 |      user_numforms_begin(map) -> user_numforms_iterator_t
 |  
 |  __clear = user_numforms_clear(...)
 |      user_numforms_clear(map)
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = user_numforms_end(...)
 |      user_numforms_end(map) -> user_numforms_iterator_t
 |  
 |  __erase = user_numforms_erase(...)
 |      user_numforms_erase(map, p)
 |  
 |  __find = user_numforms_find(...)
 |      user_numforms_find(map, key) -> user_numforms_iterator_t
 |  
 |  __first = user_numforms_first(...)
 |      user_numforms_first(p) -> operand_locator_t
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_numforms_t
 |  
 |  __insert = user_numforms_insert(...)
 |      user_numforms_insert(map, key, val) -> user_numforms_iterator_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = user_numforms_next(...)
 |      user_numforms_next(p) -> user_numforms_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = user_numforms_second(...)
 |      user_numforms_second(p) -> number_format_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = user_numforms_size(...)
 |      user_numforms_size(map) -> size_t
 |  
 |  __swig_destroy__ = delete_user_numforms_t(...)
 |      delete_user_numforms_t(self)
 |  
 |  at(self, *args) -> 'number_format_t &'
 |      at(self, _Keyval) -> number_format_t
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = <class 'ida_hexrays.operand_locator_t'>
 |      Proxy of C++ operand_locator_t class.
 |  
 |  valuetype = <class 'ida_hexrays.number_format_t'>
 |      Proxy of C++ number_format_t class.

Help on function user_unions_begin in module ida_hexrays:

user_unions_begin(*args) -> 'user_unions_iterator_t'
    user_unions_begin(map) -> user_unions_iterator_t
    
    
    Get iterator pointing to the beginning of user_unions_t.
    
    
    @param map (C++: const user_unions_t *)

Help on function user_unions_clear in module ida_hexrays:

user_unions_clear(*args) -> 'void'
    user_unions_clear(map)
    
    
    Clear user_unions_t.
    
    
    @param map (C++: user_unions_t *)

Help on function user_unions_end in module ida_hexrays:

user_unions_end(*args) -> 'user_unions_iterator_t'
    user_unions_end(map) -> user_unions_iterator_t
    
    
    Get iterator pointing to the end of user_unions_t.
    
    
    @param map (C++: const user_unions_t *)

Help on function user_unions_erase in module ida_hexrays:

user_unions_erase(*args) -> 'void'
    user_unions_erase(map, p)
    
    
    Erase current element from user_unions_t.
    
    
    @param map (C++: user_unions_t *)
    @param p (C++: user_unions_iterator_t)

Help on function user_unions_find in module ida_hexrays:

user_unions_find(*args) -> 'user_unions_iterator_t'
    user_unions_find(map, key) -> user_unions_iterator_t
    
    
    Find the specified key in user_unions_t.
    
    
    @param map (C++: const user_unions_t *)
    @param key (C++: const ea_t &)

Help on function user_unions_first in module ida_hexrays:

user_unions_first(*args) -> 'ea_t const &'
    user_unions_first(p) -> ea_t const &
    
    
    Get reference to the current map key.
    
    
    @param p (C++: user_unions_iterator_t)

Help on function user_unions_free in module ida_hexrays:

user_unions_free(*args) -> 'void'
    user_unions_free(map)
    
    
    Delete user_unions_t instance.
    
    
    @param map (C++: user_unions_t *)

Help on function user_unions_insert in module ida_hexrays:

user_unions_insert(*args) -> 'user_unions_iterator_t'
    user_unions_insert(map, key, val) -> user_unions_iterator_t
    
    
    Insert new (ea_t, intvec_t) pair into user_unions_t.
    
    
    @param map (C++: user_unions_t *)
    @param key (C++: const ea_t &)
    @param val (C++: const  intvec_t  &)

Help on class user_unions_iterator_t in module ida_hexrays:

class user_unions_iterator_t(builtins.object)
 |  Proxy of C++ user_unions_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_unions_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_unions_iterator_t(...)
 |      delete_user_unions_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      user_unions_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_unions_new in module ida_hexrays:

user_unions_new(*args) -> 'user_unions_t *'
    user_unions_new() -> user_unions_t
    
    
    Create a new user_unions_t instance.

Help on function user_unions_next in module ida_hexrays:

user_unions_next(*args) -> 'user_unions_iterator_t'
    user_unions_next(p) -> user_unions_iterator_t
    
    
    Move to the next element.
    
    
    @param p (C++: user_unions_iterator_t)

Help on function user_unions_prev in module ida_hexrays:

user_unions_prev(*args) -> 'user_unions_iterator_t'
    user_unions_prev(p) -> user_unions_iterator_t
    
    
    Move to the previous element.
    
    
    @param p (C++: user_unions_iterator_t)

Help on function user_unions_second in module ida_hexrays:

user_unions_second(*args) -> 'intvec_t &'
    user_unions_second(p) -> intvec_t
    
    
    Get reference to the current map value.
    
    
    @param p (C++: user_unions_iterator_t)

Help on function user_unions_size in module ida_hexrays:

user_unions_size(*args) -> 'size_t'
    user_unions_size(map) -> size_t
    
    
    Get size of user_unions_t.
    
    
    @param map (C++: user_unions_t *)

Help on class user_unions_t in module ida_hexrays:

class user_unions_t(builtins.object)
 |  Proxy of C++ std::map< ea_t,intvec_t > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = user_unions_begin(...)
 |      user_unions_begin(map) -> user_unions_iterator_t
 |  
 |  __clear = user_unions_clear(...)
 |      user_unions_clear(map)
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = user_unions_end(...)
 |      user_unions_end(map) -> user_unions_iterator_t
 |  
 |  __erase = user_unions_erase(...)
 |      user_unions_erase(map, p)
 |  
 |  __find = user_unions_find(...)
 |      user_unions_find(map, key) -> user_unions_iterator_t
 |  
 |  __first = user_unions_first(...)
 |      user_unions_first(p) -> ea_t const &
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_unions_t
 |  
 |  __insert = user_unions_insert(...)
 |      user_unions_insert(map, key, val) -> user_unions_iterator_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = user_unions_next(...)
 |      user_unions_next(p) -> user_unions_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = user_unions_second(...)
 |      user_unions_second(p) -> intvec_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = user_unions_size(...)
 |      user_unions_size(map) -> size_t
 |  
 |  __swig_destroy__ = delete_user_unions_t(...)
 |      delete_user_unions_t(self)
 |  
 |  at(self, *args) -> 'qvector< int > &'
 |      at(self, _Keyval) -> intvec_t
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = (<class 'int'>,)
 |  
 |  valuetype = <class 'ida_pro.intvec_t'>
 |      Proxy of C++ qvector< int > class.

Help on class uval_ivl_ivlset_t in module ida_hexrays:

class uval_ivl_ivlset_t(builtins.object)
 |  Proxy of C++ ivlset_tpl< ivl_t,uval_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, v) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> uval_ivl_ivlset_t
 |      __init__(self, ivl) -> uval_ivl_ivlset_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, v) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_uval_ivl_ivlset_t(...)
 |      delete_uval_ivl_ivlset_t(self)
 |  
 |  all_values(self, *args) -> 'bool'
 |      all_values(self) -> bool
 |  
 |  begin(self, *args) -> 'ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator'↗
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator↗
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator'↗
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator↗
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  getivl(self, *args) -> 'ivl_t const &'
 |      getivl(self, idx) -> ivl_t
 |  
 |  lastivl(self, *args) -> 'ivl_t const &'
 |      lastivl(self) -> ivl_t
 |  
 |  nivls(self, *args) -> 'size_t'
 |      nivls(self) -> size_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  set_all_values(self, *args) -> 'void'
 |      set_all_values(self)
 |  
 |  single_value(self, *args) -> 'bool'
 |      single_value(self, v) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class uval_ivl_t in module ida_hexrays:

class uval_ivl_t(builtins.object)
 |  Proxy of C++ ivl_tpl< uval_t > class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _off, _size) -> uval_ivl_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_uval_ivl_t(...)
 |      delete_uval_ivl_t(self)
 |  
 |  end(self, *args) -> 'unsigned-ea-like-numeric-type'↗
 |      end(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  last(self, *args) -> 'unsigned-ea-like-numeric-type'↗
 |      last(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  valid(self, *args) -> 'bool'
 |      valid(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      uval_ivl_t_off_get(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  size
 |      uval_ivl_t_size_get(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  thisown
 |      The membership flag

Help on class valrng_t in module ida_hexrays:

class valrng_t(builtins.object)
 |  Proxy of C++ valrng_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, size_=MAX_VLR_SIZE) -> valrng_t
 |      __init__(self, r) -> valrng_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_valrng_t(...)
 |      delete_valrng_t(self)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  all_values(self, *args) -> 'bool'
 |      all_values(self) -> bool
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  cvt_to_cmp(self, *args) -> 'bool'
 |      cvt_to_cmp(self, strict) -> bool
 |  
 |  cvt_to_single_value(self, *args) -> 'bool'
 |      cvt_to_single_value(self) -> bool
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  get_size(self, *args) -> 'int'
 |      get_size(self) -> int
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, v) -> bool
 |  
 |  intersect_with(self, *args) -> 'bool'
 |      intersect_with(self, r) -> bool
 |  
 |  inverse(self, *args) -> 'void'
 |      inverse(self)
 |  
 |  is_unknown(self, *args) -> 'bool'
 |      is_unknown(self) -> bool
 |  
 |  max_svalue(self, *args) -> 'uvlr_t'
 |      max_svalue(self, size_) -> uvlr_t
 |      max_svalue(self) -> uvlr_t
 |  
 |  max_value(self, *args) -> 'uvlr_t'
 |      max_value(self, size_) -> uvlr_t
 |      max_value(self) -> uvlr_t
 |  
 |  min_svalue(self, *args) -> 'uvlr_t'
 |      min_svalue(self, size_) -> uvlr_t
 |      min_svalue(self) -> uvlr_t
 |  
 |  reduce_size(self, *args) -> 'bool'
 |      reduce_size(self, new_size) -> bool
 |  
 |  set_all(self, *args) -> 'void'
 |      set_all(self)
 |  
 |  set_cmp(self, *args) -> 'void'
 |      set_cmp(self, cmp, _value)
 |  
 |  set_eq(self, *args) -> 'void'
 |      set_eq(self, v)
 |  
 |  set_none(self, *args) -> 'void'
 |      set_none(self)
 |  
 |  set_unk(self, *args) -> 'void'
 |      set_unk(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  unite_with(self, *args) -> 'bool'
 |      unite_with(self, r) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class var_ref_t in module ida_hexrays:

class var_ref_t(builtins.object)
 |  Proxy of C++ var_ref_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> var_ref_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_var_ref_t(...)
 |      delete_var_ref_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  idx
 |      var_ref_t_idx_get(self) -> int
 |  
 |  mba
 |      var_ref_t_mba_get(self) -> mbl_array_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class vc_printer_t in module ida_hexrays:

class vc_printer_t(vd_printer_t)
 |  Proxy of C++ vc_printer_t class.
 |  
 |  Method resolution order:
 |      vc_printer_t
 |      vd_printer_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, f) -> vc_printer_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vc_printer_t(...)
 |      delete_vc_printer_t(self)
 |  
 |  oneliner(self, *args) -> 'bool'
 |      oneliner(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  func
 |      vc_printer_t_func_get(self) -> cfunc_t
 |  
 |  lastchar
 |      vc_printer_t_lastchar_get(self) -> char
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vd_printer_t:
 |  
 |  _print(self, *args) -> 'int'
 |      _print(self, indent, format) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vd_printer_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hdrlines
 |      vd_printer_t_hdrlines_get(self) -> int
 |  
 |  tmpbuf
 |      vd_printer_t_tmpbuf_get(self) -> qstring *

Help on class vd_failure_t in module ida_hexrays:

class vd_failure_t(builtins.object)
 |  Proxy of C++ vd_failure_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> vd_failure_t
 |      __init__(self, code, ea, buf=None) -> vd_failure_t
 |      __init__(self, code, ea, buf) -> vd_failure_t
 |      __init__(self, _hf) -> vd_failure_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vd_failure_t(...)
 |      delete_vd_failure_t(self)
 |  
 |  desc(self, *args) -> 'qstring'
 |      desc(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hf
 |      vd_failure_t_hf_get(self) -> hexrays_failure_t
 |  
 |  thisown
 |      The membership flag

Help on class vd_interr_t in module ida_hexrays:

class vd_interr_t(vd_failure_t)
 |  Proxy of C++ vd_interr_t class.
 |  
 |  Method resolution order:
 |      vd_interr_t
 |      vd_failure_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, ea, buf) -> vd_interr_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vd_interr_t(...)
 |      delete_vd_interr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vd_failure_t:
 |  
 |  desc(self, *args) -> 'qstring'
 |      desc(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vd_failure_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hf
 |      vd_failure_t_hf_get(self) -> hexrays_failure_t

Help on class vd_printer_t in module ida_hexrays:

class vd_printer_t(builtins.object)
 |  Proxy of C++ vd_printer_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> vd_printer_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vd_printer_t(...)
 |      delete_vd_printer_t(self)
 |  
 |  _print(self, *args) -> 'int'
 |      _print(self, indent, format) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hdrlines
 |      vd_printer_t_hdrlines_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  tmpbuf
 |      vd_printer_t_tmpbuf_get(self) -> qstring *

Help on class vdloc_t in module ida_hexrays:

class vdloc_t(ida_typeinf.argloc_t)
 |  Proxy of C++ vdloc_t class.
 |  
 |  Method resolution order:
 |      vdloc_t
 |      ida_typeinf.argloc_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> vdloc_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vdloc_t(...)
 |      delete_vdloc_t(self)
 |  
 |  _set_reg1(self, *args) -> 'void'
 |      _set_reg1(self, r1)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  is_aliasable(self, *args) -> 'bool'
 |      is_aliasable(self, mb, size) -> bool
 |  
 |  reg1(self, *args) -> 'int'
 |      reg1(self) -> int
 |  
 |  set_reg1(self, *args) -> 'void'
 |      set_reg1(self, r1)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_typeinf.argloc_t:
 |  
 |  _consume_rrel(self, *args) -> 'bool'
 |      _consume_rrel(self, p) -> bool
 |  
 |  _consume_scattered(self, *args) -> 'bool'
 |      _consume_scattered(self, p) -> bool
 |  
 |  _set_badloc(self, *args) -> 'void'
 |      _set_badloc(self)
 |  
 |  _set_biggest(self, *args) -> 'void'
 |      _set_biggest(self, ct, data)
 |  
 |  _set_custom(self, *args) -> 'void'
 |      _set_custom(self, ct, pdata)
 |  
 |  _set_ea(self, *args) -> 'void'
 |      _set_ea(self, _ea)
 |  
 |  _set_reg2(self, *args) -> 'void'
 |      _set_reg2(self, _reg1, _reg2)
 |  
 |  _set_stkoff(self, *args) -> 'void'
 |      _set_stkoff(self, off)
 |  
 |  advance(self, *args) -> 'bool'
 |      advance(self, delta) -> bool
 |  
 |  atype(self, *args) -> 'argloc_type_t'
 |      atype(self) -> argloc_type_t
 |  
 |  calc_offset(self, *args) -> 'sval_t'
 |      calc_offset(self) -> sval_t
 |  
 |  consume_rrel(self, *args) -> 'void'
 |      consume_rrel(self, p)
 |  
 |  consume_scattered(self, *args) -> 'void'
 |      consume_scattered(self, p)
 |  
 |  get_biggest(self, *args) -> 'argloc_t::biggest_t'
 |      get_biggest(self) -> argloc_t::biggest_t
 |  
 |  get_custom(self, *args) -> 'void *'
 |      get_custom(self) -> void *
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self) -> ea_t
 |  
 |  get_reginfo(self, *args) -> 'uint32'
 |      get_reginfo(self) -> uint32
 |  
 |  get_rrel(self, *args) -> 'rrel_t const &'
 |      get_rrel(self) -> rrel_t
 |      get_rrel(self) -> rrel_t
 |  
 |  has_reg(self, *args) -> 'bool'
 |      has_reg(self) -> bool
 |  
 |  has_stkoff(self, *args) -> 'bool'
 |      has_stkoff(self) -> bool
 |  
 |  is_badloc(self, *args) -> 'bool'
 |      is_badloc(self) -> bool
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |  
 |  is_ea(self, *args) -> 'bool'
 |      is_ea(self) -> bool
 |  
 |  is_fragmented(self, *args) -> 'bool'
 |      is_fragmented(self) -> bool
 |  
 |  is_mixed_scattered(self, *args) -> 'bool'
 |      is_mixed_scattered(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |  
 |  is_rrel(self, *args) -> 'bool'
 |      is_rrel(self) -> bool
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |  
 |  justify_reg_high(self, *args) -> 'void'
 |      justify_reg_high(self, size, _slotsize)
 |  
 |  justify_stkoff_right(self, *args) -> 'void'
 |      justify_stkoff_right(self, size, _slotsize)
 |  
 |  reg2(self, *args) -> 'int'
 |      reg2(self) -> int
 |  
 |  regoff(self, *args) -> 'int'
 |      regoff(self) -> int
 |  
 |  scattered(self, *args) -> 'scattered_aloc_t const &'
 |      scattered(self) -> scattered_aloc_t
 |      scattered(self) -> scattered_aloc_t
 |  
 |  set_badloc(self, *args) -> 'void'
 |      set_badloc(self)
 |  
 |  set_ea(self, *args) -> 'void'
 |      set_ea(self, _ea)
 |  
 |  set_reg2(self, *args) -> 'void'
 |      set_reg2(self, _reg1, _reg2)
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, off)
 |  
 |  stkoff(self, *args) -> 'sval_t'
 |      stkoff(self) -> sval_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_typeinf.argloc_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class vdui_t in module ida_hexrays:

class vdui_t(builtins.object)
 |  Proxy of C++ vdui_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vdui_t(...)
 |      delete_vdui_t(self)
 |  
 |  calc_cmt_type(self, *args) -> 'cmt_type_t'
 |      calc_cmt_type(self, lnnum, cmttype) -> cmt_type_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  collapse_item(self, *args) -> 'bool'
 |      collapse_item(self, hide) -> bool
 |  
 |  collapse_lvars(self, *args) -> 'bool'
 |      collapse_lvars(self, hide) -> bool
 |  
 |  ctree_to_disasm(self, *args) -> 'bool'
 |      ctree_to_disasm(self) -> bool
 |  
 |  del_orphan_cmts(self, *args) -> 'bool'
 |      del_orphan_cmts(self) -> bool
 |  
 |  edit_cmt(self, *args) -> 'bool'
 |      edit_cmt(self, loc) -> bool
 |  
 |  edit_func_cmt(self, *args) -> 'bool'
 |      edit_func_cmt(self) -> bool
 |  
 |  get_current_item(self, *args) -> 'bool'
 |      get_current_item(self, idv) -> bool
 |  
 |  get_current_label(self, *args) -> 'int'
 |      get_current_label(self) -> int
 |  
 |  get_number(self, *args) -> 'cnumber_t *'
 |      get_number(self) -> cnumber_t
 |  
 |  in_ctree(self, *args) -> 'bool'
 |      in_ctree(self) -> bool
 |  
 |  invert_bits(self, *args) -> 'bool'
 |      invert_bits(self) -> bool
 |  
 |  invert_sign(self, *args) -> 'bool'
 |      invert_sign(self) -> bool
 |  
 |  jump_enter(self, *args) -> 'bool'
 |      jump_enter(self, idv, omflags) -> bool
 |  
 |  locked(self, *args) -> 'bool'
 |      locked(self) -> bool
 |  
 |  map_lvar(self, *args) -> 'bool'
 |      map_lvar(self, frm, to) -> bool
 |  
 |  refresh_cpos(self, *args) -> 'bool'
 |      refresh_cpos(self, idv) -> bool
 |  
 |  refresh_ctext(self, *args) -> 'void'
 |      refresh_ctext(self, activate=True)
 |  
 |  refresh_view(self, *args) -> 'void'
 |      refresh_view(self, redo_mba)
 |  
 |  rename_global(self, *args) -> 'bool'
 |      rename_global(self, ea) -> bool
 |  
 |  rename_label(self, *args) -> 'bool'
 |      rename_label(self, label) -> bool
 |  
 |  rename_lvar(self, *args) -> 'bool'
 |      rename_lvar(self, v, name, is_user_name) -> bool
 |  
 |  rename_strmem(self, *args) -> 'bool'
 |      rename_strmem(self, sptr, mptr) -> bool
 |  
 |  set_global_type(self, *args) -> 'bool'
 |      set_global_type(self, ea) -> bool
 |  
 |  set_locked(self, *args) -> 'bool'
 |      set_locked(self, v) -> bool
 |  
 |  set_lvar_cmt(self, *args) -> 'bool'
 |      set_lvar_cmt(self, v, cmt) -> bool
 |  
 |  set_lvar_type(self, *args) -> 'bool'
 |      set_lvar_type(self, v, type) -> bool
 |  
 |  set_noptr_lvar(self, *args) -> 'bool'
 |      set_noptr_lvar(self, v) -> bool
 |  
 |  set_num_enum(self, *args) -> 'bool'
 |      set_num_enum(self) -> bool
 |  
 |  set_num_radix(self, *args) -> 'bool'
 |      set_num_radix(self, base) -> bool
 |  
 |  set_num_stroff(self, *args) -> 'bool'
 |      set_num_stroff(self) -> bool
 |  
 |  set_strmem_type(self, *args) -> 'bool'
 |      set_strmem_type(self, sptr, mptr) -> bool
 |  
 |  set_valid(self, *args) -> 'void'
 |      set_valid(self, v)
 |  
 |  set_visible(self, *args) -> 'void'
 |      set_visible(self, v)
 |  
 |  split_item(self, *args) -> 'bool'
 |      split_item(self, split) -> bool
 |  
 |  switch_to(self, *args) -> 'void'
 |      switch_to(self, f, activate)
 |  
 |  ui_edit_lvar_cmt(self, *args) -> 'bool'
 |      ui_edit_lvar_cmt(self, v) -> bool
 |  
 |  ui_map_lvar(self, *args) -> 'bool'
 |      ui_map_lvar(self, v) -> bool
 |  
 |  ui_rename_lvar(self, *args) -> 'bool'
 |      ui_rename_lvar(self, v) -> bool
 |  
 |  ui_set_call_type(self, *args) -> 'bool'
 |      ui_set_call_type(self, e) -> bool
 |  
 |  ui_set_lvar_type(self, *args) -> 'bool'
 |      ui_set_lvar_type(self, v) -> bool
 |  
 |  ui_unmap_lvar(self, *args) -> 'bool'
 |      ui_unmap_lvar(self, v) -> bool
 |  
 |  valid(self, *args) -> 'bool'
 |      valid(self) -> bool
 |  
 |  visible(self, *args) -> 'bool'
 |      visible(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cfunc
 |      vdui_t_cfunc_get(self) -> cfuncptr_t
 |  
 |  cpos
 |      vdui_t_cpos_get(self) -> ctext_position_t
 |  
 |  ct
 |      vdui_t_ct_get(self) -> TWidget *
 |  
 |  flags
 |      vdui_t_flags_get(self) -> int
 |  
 |  head
 |      vdui_t_head_get(self) -> ctree_item_t
 |  
 |  item
 |      vdui_t_item_get(self) -> ctree_item_t
 |  
 |  last_code
 |      vdui_t_last_code_get(self) -> merror_t
 |  
 |  mba
 |      vdui_t_mba_get(self) -> mbl_array_t
 |  
 |  tail
 |      vdui_t_tail_get(self) -> ctree_item_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  toplevel
 |      vdui_t_toplevel_get(self) -> TWidget *
 |  
 |  view_idx
 |      vdui_t_view_idx_get(self) -> int

Help on class vivl_t in module ida_hexrays:

class vivl_t(voff_t)
 |  Proxy of C++ vivl_t class.
 |  
 |  Method resolution order:
 |      vivl_t
 |      voff_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      __eq__(self, mop) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, _type=mop_z, _off=-1, _size=0) -> vivl_t
 |      __init__(self, ch) -> vivl_t
 |      __init__(self, op) -> vivl_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vivl_t(...)
 |      delete_vivl_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, voff2) -> bool
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  extend_to_cover(self, *args) -> 'bool'
 |      extend_to_cover(self, r) -> bool
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, r) -> bool
 |  
 |  intersect(self, *args) -> 'uval_t'
 |      intersect(self, r) -> uval_t
 |  
 |  overlap(self, *args) -> 'bool'
 |      overlap(self, r) -> bool
 |  
 |  set(self, *args) -> 'void'
 |      set(self, _type, _off, _size=0)
 |      set(self, voff, _size)
 |  
 |  set_reg(self, *args) -> 'void'
 |      set_reg(self, mreg, sz=0)
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, stkoff, sz=0)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  size
 |      vivl_t_size_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from voff_t:
 |  
 |  add(self, *args) -> 'voff_t'
 |      add(self, width) -> voff_t
 |  
 |  defined(self, *args) -> 'bool'
 |      defined(self) -> bool
 |  
 |  diff(self, *args) -> 'sval_t'
 |      diff(self, r) -> sval_t
 |  
 |  get_reg(self, *args) -> 'mreg_t'
 |      get_reg(self) -> mreg_t
 |  
 |  get_stkoff(self, *args) -> 'sval_t'
 |      get_stkoff(self) -> sval_t
 |  
 |  inc(self, *args) -> 'void'
 |      inc(self, delta)
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |  
 |  undef(self, *args) -> 'void'
 |      undef(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from voff_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      voff_t_off_get(self) -> sval_t
 |  
 |  type
 |      voff_t_type_get(self) -> mopt_t

Help on class voff_t in module ida_hexrays:

class voff_t(builtins.object)
 |  Proxy of C++ voff_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> voff_t
 |      __init__(self, _type, _off) -> voff_t
 |      __init__(self, op) -> voff_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_voff_t(...)
 |      delete_voff_t(self)
 |  
 |  add(self, *args) -> 'voff_t'
 |      add(self, width) -> voff_t
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  defined(self, *args) -> 'bool'
 |      defined(self) -> bool
 |  
 |  diff(self, *args) -> 'sval_t'
 |      diff(self, r) -> sval_t
 |  
 |  get_reg(self, *args) -> 'mreg_t'
 |      get_reg(self) -> mreg_t
 |  
 |  get_stkoff(self, *args) -> 'sval_t'
 |      get_stkoff(self) -> sval_t
 |  
 |  inc(self, *args) -> 'void'
 |      inc(self, delta)
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |  
 |  set(self, *args) -> 'void'
 |      set(self, _type, _off)
 |  
 |  set_reg(self, *args) -> 'void'
 |      set_reg(self, mreg)
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, stkoff)
 |  
 |  undef(self, *args) -> 'void'
 |      undef(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      voff_t_off_get(self) -> sval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      voff_t_type_get(self) -> mopt_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

=== ida_hexrays EPYDOC INJECTIONS ===
ida_hexrays.ACFL_BLKOPT
"""
perform interblock transformations
"""

ida_hexrays.ACFL_GLBDEL
"""
perform dead code eliminition
"""

ida_hexrays.ACFL_GLBPROP
"""
perform global propagation
"""

ida_hexrays.ACFL_GUESS
"""
may guess calling conventions
"""

ida_hexrays.ACFL_LOCOPT
"""
perform local propagation (requires ACFL_BLKOPT)
"""

ida_hexrays.ANCHOR_BLKCMT
"""
block comment (for ctree items)
"""

ida_hexrays.ANCHOR_CITEM
"""
c-tree item
"""

ida_hexrays.ANCHOR_ITP
"""
item type preciser
"""

ida_hexrays.ANCHOR_LVAR
"""
declaration of local variable
"""

ida_hexrays.CFL_FINAL
"""
call type is final, should not be changed
"""

ida_hexrays.CFL_HELPER
"""
created from a decompiler helper function
"""

ida_hexrays.CFS_BOUNDS
"""
'eamap' and 'boundaries' are ready
"""

ida_hexrays.CFS_LVARS_HIDDEN
"""
local variable definitions are collapsed
"""

ida_hexrays.CFS_TEXT
"""
'sv' is ready (and hdrlines)
"""

ida_hexrays.CHF_FAKE
"""
fake chain created by widen_chains()
"""

ida_hexrays.CHF_INITED
"""
is chain initialized? (valid only after lvar allocation)
"""

ida_hexrays.CHF_OVER
"""
overlapped chain
"""

ida_hexrays.CHF_PASSTHRU
"""
pass-thru chain, must use the input variable to the block
"""

ida_hexrays.CHF_REPLACED
"""
chain operands have been replaced?
"""

ida_hexrays.CHF_TERM
"""
terminating chain; the variable does not survive across the block
"""

ida_hexrays.CIT_COLLAPSED
"""
display element in collapsed form
"""

ida_hexrays.CPBLK_FAST
"""
do not update minbstkref and minbargref
"""

ida_hexrays.CPBLK_MINREF
"""
update minbstkref and minbargref
"""

ida_hexrays.CPBLK_OPTJMP
"""
if it becomes useless

del the jump insn at the end of the block
"""

ida_hexrays.CV_FAST
"""
do not maintain parent information
"""

ida_hexrays.CV_INSNS
"""
visit only statements, prune all expressions do not use before the
final ctree maturity because expressions may contain statements at
intermediate stages (see cot_insn). Otherwise you risk missing
statements embedded into expressions.
"""

ida_hexrays.CV_PARENTS
"""
maintain parent information
"""

ida_hexrays.CV_POST
"""
call the leave...() functions
"""

ida_hexrays.CV_PRUNE
"""
this bit is set by visit...() to prune the walk
"""

ida_hexrays.CV_RESTART
"""
restart enumeration at the top expr (apply_to_exprs)
"""

ida_hexrays.DECOMP_ALL_BLKS
"""
generate microcode for unreachable blocks
"""

ida_hexrays.DECOMP_NO_CACHE
"""
do not use decompilation cache
"""

ida_hexrays.DECOMP_NO_FRAME
"""
do not use function frame info (only snippet mode)
"""

ida_hexrays.DECOMP_NO_WAIT
"""
do not display waitbox
"""

ida_hexrays.DECOMP_WARNINGS
"""
display warnings in the output window
"""

ida_hexrays.EQ_CMPDEST
"""
compare instruction destinations
"""

ida_hexrays.EQ_IGNCODE
"""
ignore instruction opcodes
"""

ida_hexrays.EQ_IGNSIZE
"""
ignore operand sizes
"""

ida_hexrays.EQ_OPTINSN
"""
optimize mop_d operands
"""

ida_hexrays.EXFL_ALL
"""
all currently defined bits
"""

ida_hexrays.EXFL_ALONE
"""
standalone helper
"""

ida_hexrays.EXFL_CPADONE
"""
pointer arithmetic correction done
"""

ida_hexrays.EXFL_CSTR
"""
string literal
"""

ida_hexrays.EXFL_FPOP
"""
floating point operation
"""

ida_hexrays.EXFL_JUMPOUT
"""
jump out-of-function
"""

ida_hexrays.EXFL_LVALUE
"""
expression is lvalue even if it doesn't look like it
"""

ida_hexrays.EXFL_PARTIAL
"""
type of the expression is considered partial
"""

ida_hexrays.EXFL_UNDEF
"""
expression uses undefined value
"""

ida_hexrays.EXFL_VFTABLE
"""
is ptr to vftable (used for cot_memptr, cot_memref)
"""

ida_hexrays.FCI_DEAD
"""
some return registers were determined dead
"""

ida_hexrays.FCI_FINAL
"""
call type is final, should not be changed
"""

ida_hexrays.FCI_HASCALL
"""
A function is an synthetic helper combined from several instructions
and at least one of them was a call to a real functions
"""

ida_hexrays.FCI_HASFMT
"""
printf- or scanf-style format string

A variadic function with recognized
"""

ida_hexrays.FCI_NORET
"""
call does not return
"""

ida_hexrays.FCI_NOSIDE
"""
call does not have side effects
"""

ida_hexrays.FCI_PROP
"""
call has been propagated
"""

ida_hexrays.FCI_PURE
"""
pure function
"""

ida_hexrays.FCI_SPLOK
"""
spoiled/visible_memory lists have been optimized. for some functions
we can reduce them as soon as information about the arguments becomes
available. in order not to try optimize them again we use this bit.
"""

ida_hexrays.FD_BACKWARD
"""
search direction
"""

ida_hexrays.FD_DEF
"""
look for definition
"""

ida_hexrays.FD_DIRTY
"""
by function calls and indirect memory access

ignore possible implicit definitions
"""

ida_hexrays.FD_FORWARD
"""
search direction
"""

ida_hexrays.FD_USE
"""
look for use
"""

ida_hexrays.GCA_ALLOC
"""
enumerate only allocated chains
"""

ida_hexrays.GCA_EMPTY
"""
include empty chains
"""

ida_hexrays.GCA_NALLOC
"""
enumerate only non-allocated chains
"""

ida_hexrays.GCA_OFIRST
"""
consider only chains of the first block
"""

ida_hexrays.GCA_OLAST
"""
consider only chains of the last block
"""

ida_hexrays.GCA_SPEC
"""
include chains for special registers
"""

ida_hexrays.GCO_DEF
"""
is destination operand?
"""

ida_hexrays.GCO_REG
"""
is register? otherwise a stack variable
"""

ida_hexrays.GCO_STK
"""
a stack variable
"""

ida_hexrays.GCO_USE
"""
is source operand?
"""

ida_hexrays.GLN_ALL
"""
get both
"""

ida_hexrays.GLN_CURRENT
"""
get label of the current item
"""

ida_hexrays.GLN_GOTO_TARGET
"""
get goto target
"""

ida_hexrays.IPROP_ASSERT
"""
assertion: usually mov #val, op. assertions are used to help the
optimizer. assertions are ignored when generating ctree
"""

ida_hexrays.IPROP_CLNPOP
"""
(e.g. "pop ecx" is often used for that)

the purpose of the instruction is to clean stack
"""

ida_hexrays.IPROP_COMBINED
"""
insn has been modified because of a partial reference
"""

ida_hexrays.IPROP_DONT_COMB
"""
may not combine this instruction with others
"""

ida_hexrays.IPROP_DONT_PROP
"""
may not propagate
"""

ida_hexrays.IPROP_EXTSTX
"""
this is m_ext propagated into m_stx
"""

ida_hexrays.IPROP_FARCALL
"""
call of a far function using push cs/call sequence
"""

ida_hexrays.IPROP_FPINSN
"""
floating point insn
"""

ida_hexrays.IPROP_IGNLOWSRC
"""
low part of the instruction source operand has been created
artificially (this bit is used only for 'and x, 80...')
"""

ida_hexrays.IPROP_INV_JX
"""
inverted conditional jump
"""

ida_hexrays.IPROP_MBARRIER
"""
(instructions accessing memory may not be reordered past it)

this instruction acts as a memory barrier
"""

ida_hexrays.IPROP_MULTI_MOV
"""
(example: STM on ARM may transfer multiple registers)

the minsn was generated as part of insn that moves multiple
registersbits that can be set by plugins:
"""

ida_hexrays.IPROP_OPTIONAL
"""
optional instruction
"""

ida_hexrays.IPROP_PERSIST
"""
persistent insn; they are not destroyed
"""

ida_hexrays.IPROP_SPLIT
"""
the instruction has been split:
"""

ida_hexrays.IPROP_SPLIT1
"""
into 1 byte
"""

ida_hexrays.IPROP_SPLIT2
"""
into 2 bytes
"""

ida_hexrays.IPROP_SPLIT4
"""
into 4 bytes
"""

ida_hexrays.IPROP_SPLIT8
"""
into 8 bytes
"""

ida_hexrays.IPROP_TAILCALL
"""
tail call
"""

ida_hexrays.IPROP_WAS_NORET
"""
was noret icall
"""

ida_hexrays.IPROP_WILDMATCH
"""
match multiple insns
"""

ida_hexrays.LOCOPT_ALL
"""
is not set, only dirty blocks will be optimized

redo optimization for all blocks. if this bit
"""

ida_hexrays.LOCOPT_REFINE
"""
refine return type, ok to fail
"""

ida_hexrays.LOCOPT_REFINE2
"""
refine return type, try harder
"""

ida_hexrays.LVINF_FORCE
"""
force allocation of a new variable. forces the decompiler to create a
new variable at ll.defea
"""

ida_hexrays.LVINF_KEEP
"""
preserve saved user settings regardless of vars for example, if a var
loses all its user-defined attributes or even gets destroyed, keep its
'lvar_saved_info_t' . this is used for ephemeral variables that get
destroyed by macro recognition.
"""

ida_hexrays.LVINF_NOMAP
"""
forbid automatic mapping of the variable
"""

ida_hexrays.LVINF_NOPTR
"""
variable type should not be a pointer
"""

ida_hexrays.MBA_ASRPROP
"""
assertion have been propagated
"""

ida_hexrays.MBA_ASRTOK
"""
assertions have been generated
"""

ida_hexrays.MBA_CALLS
"""
callinfo has been built
"""

ida_hexrays.MBA_CHVARS
"""
can verify chain varnums
"""

ida_hexrays.MBA_CMBBLK
"""
request to combine blocks
"""

ida_hexrays.MBA_CMNSTK
"""
stkvars+stkargs should be considered as one area
"""

ida_hexrays.MBA_COLGDL
"""
display graph after each reduction
"""

ida_hexrays.MBA_DELPAIRS
"""
pairs have been deleted once
"""

ida_hexrays.MBA_GLBOPT
"""
microcode has been optimized globally
"""

ida_hexrays.MBA_INSGDL
"""
display instruction in graphs
"""

ida_hexrays.MBA_LOADED
"""
loaded gdl, no instructions (debugging)
"""

ida_hexrays.MBA_LVARS0
"""
lvar pre-allocation has been performed
"""

ida_hexrays.MBA_LVARS1
"""
lvar real allocation has been performed
"""

ida_hexrays.MBA_NICE
"""
apply transformations to c code
"""

ida_hexrays.MBA_NOFUNC
"""
function is not present, addresses might be wrong
"""

ida_hexrays.MBA_NUMADDR
"""
display definition addresses for numbers
"""

ida_hexrays.MBA_PASSREGS
"""
has 'mcallinfo_t::pass_regs'
"""

ida_hexrays.MBA_PATTERN
"""
microcode pattern, callinfo is present
"""

ida_hexrays.MBA_PRCDEFS
"""
use precise defeas for chain-allocated lvars
"""

ida_hexrays.MBA_PREOPT
"""
preoptimization stage complete
"""

ida_hexrays.MBA_REFINE
"""
may refine return value size
"""

ida_hexrays.MBA_RETFP
"""
function returns floating point value
"""

ida_hexrays.MBA_RETREF
"""
return type has been refined
"""

ida_hexrays.MBA_SAVRST
"""
save-restore analysis has been performed
"""

ida_hexrays.MBA_SHORT
"""
use short display
"""

ida_hexrays.MBA_SPLINFO
"""
(final_type ? idb_spoiled : spoiled_regs) is valid
"""

ida_hexrays.MBA_THUNK
"""
thunk function
"""

ida_hexrays.MBA_VALNUM
"""
display value numbers
"""

ida_hexrays.MBA_WINGR32
"""
use wingraph32
"""

ida_hexrays.MBL_BACKPROP
"""
performed backprop_cc
"""

ida_hexrays.MBL_CALL
"""
call information has been built
"""

ida_hexrays.MBL_COMB
"""
needs "combine" pass
"""

ida_hexrays.MBL_DEAD
"""
needs "eliminate deads" pass
"""

ida_hexrays.MBL_DMT64
"""
needs "demote 64bits"
"""

ida_hexrays.MBL_DSLOT
"""
block for delay slot
"""

ida_hexrays.MBL_FAKE
"""
fake block (after a tail call)
"""

ida_hexrays.MBL_GOTO
"""
this block is a goto target
"""

ida_hexrays.MBL_INCONST
"""
inconsistent lists: we are building them
"""

ida_hexrays.MBL_LIST
"""
use/def lists are ready (not dirty)
"""

ida_hexrays.MBL_NONFAKE
"""
regular block
"""

ida_hexrays.MBL_NORET
"""
dead end block: doesn't return execution control
"""

ida_hexrays.MBL_PRIV
"""
the specified are accepted (used in patterns)

private block - no instructions except
"""

ida_hexrays.MBL_PROP
"""
needs 'propagation' pass
"""

ida_hexrays.MBL_PUSH
"""
needs "convert push/pop instructions"
"""

ida_hexrays.MBL_TCAL
"""
aritifical call block for tail calls
"""

ida_hexrays.MBL_VALRANGES
"""
should optimize using value ranges
"""

ida_hexrays.MLI_CLR_FLAGS
"""
clear LVINF_... bits
"""

ida_hexrays.MLI_CMT
"""
apply lvar comment
"""

ida_hexrays.MLI_NAME
"""
apply lvar name
"""

ida_hexrays.MLI_SET_FLAGS
"""
set LVINF_... bits
"""

ida_hexrays.MLI_TYPE
"""
apply lvar type
"""

ida_hexrays.NALT_VD
"""
this index is not used by ida
"""

ida_hexrays.NF_BINVDONE
"""
temporary internal bit: inverting bits is done
"""

ida_hexrays.NF_BITNOT
"""
The user asked to invert bits of the constant.
"""

ida_hexrays.NF_FIXED
"""
number format has been defined by the user
"""

ida_hexrays.NF_NEGATE
"""
The user asked to negate the constant.
"""

ida_hexrays.NF_NEGDONE
"""
temporary internal bit: negation has been performed
"""

ida_hexrays.NF_STROFF
"""
internal bit: used as stroff, valid iff 'is_stroff()'
"""

ida_hexrays.OPROP_CCFLAGS
"""
condition codes register value
"""

ida_hexrays.OPROP_FLOAT
"""
possibly floating value
"""

ida_hexrays.OPROP_IMPDONE
"""
imported operand (a pointer) has been dereferenced
"""

ida_hexrays.OPROP_UDEFVAL
"""
uses undefined value
"""

ida_hexrays.OPROP_UDT
"""
a struct or union
"""

ida_hexrays.OPTI_ADDREXPRS
"""
optimize all address expressions (&x+N; &x-&y)
"""

ida_hexrays.OPTI_COMBINSNS
"""
may combine insns (only for optimize_insn)
"""

ida_hexrays.OPTI_MINSTKREF
"""
may update minstkref
"""

ida_hexrays.OPTI_NO_LDXOPT
"""
do not optimize low/high(ldx)
"""

ida_hexrays.SHINS_LDXEA
"""
display address of ldx expressions (not used)
"""

ida_hexrays.SHINS_NUMADDR
"""
display definition addresses for numbers
"""

ida_hexrays.SHINS_SHORT
"""
do not display use-def chains and other attrs
"""

ida_hexrays.SHINS_VALNUM
"""
display value numbers
"""

ida_hexrays.ULV_PRECISE_DEFEA
"""
Use precise defea's for lvar locations.
"""

ida_hexrays.VDRUN_APPEND
"""
Create a new file or append to existing file.
"""

ida_hexrays.VDRUN_CMDLINE
"""
Called from ida's command line.
"""

ida_hexrays.VDRUN_LUMINA
"""
Use lumina server.
"""

ida_hexrays.VDRUN_MAYSTOP
"""
The user can cancel decompilation.
"""

ida_hexrays.VDRUN_NEWFILE
"""
Create a new file or overwrite existing file.
"""

ida_hexrays.VDRUN_ONLYNEW
"""
Fail if output file already exists.
"""

ida_hexrays.VDRUN_SENDIDB
"""
Send problematic databases to hex-rays.com.
"""

ida_hexrays.VDRUN_SILENT
"""
Silent decompilation.
"""

ida_hexrays.VDRUN_STATS
"""
Print statistics into vd_stats.txt.
"""

ida_hexrays.VDUI_LOCKED
"""
is locked?
"""

ida_hexrays.VDUI_VALID
"""
is valid?
"""

ida_hexrays.VDUI_VISIBLE
"""
is visible?
"""

ida_hexrays.VR_AT_END
"""
get value ranges after the instruction or at the block end, just after
the last instruction (if M is NULL)
"""

ida_hexrays.VR_AT_START
"""
at the block start (if M is NULL)

get value ranges before the instruction or
"""

ida_hexrays.VR_EXACT
"""
valrng size will be >= vivl.size

find exact match. if not set, the returned
"""
=== ida_hexrays EPYDOC INJECTIONS END ===
Help on function __make_idainfo_accessors in module ida_ida:

__make_idainfo_accessors(attr, getter_name=None, setter_name=None)

Help on function __make_idainfo_bound in module ida_ida:

__make_idainfo_bound(func, attr)
    #<pycode(py_ida)>

Help on function __make_idainfo_getter in module ida_ida:

__make_idainfo_getter(name)

Help on function calc_default_idaplace_flags in module ida_ida:

calc_default_idaplace_flags(*args) -> 'int'
    calc_default_idaplace_flags() -> int
    
    
    Get default disassembly line options.

Help on class compiler_info_t in module ida_ida:

class compiler_info_t(builtins.object)
 |  Proxy of C++ compiler_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> compiler_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_compiler_info_t(...)
 |      delete_compiler_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cm
 |      compiler_info_t_cm_get(self) -> cm_t
 |  
 |  defalign
 |      compiler_info_t_defalign_get(self) -> uchar
 |  
 |  id
 |      compiler_info_t_id_get(self) -> comp_t
 |  
 |  size_b
 |      compiler_info_t_size_b_get(self) -> uchar
 |  
 |  size_e
 |      compiler_info_t_size_e_get(self) -> uchar
 |  
 |  size_i
 |      compiler_info_t_size_i_get(self) -> uchar
 |  
 |  size_l
 |      compiler_info_t_size_l_get(self) -> uchar
 |  
 |  size_ldbl
 |      compiler_info_t_size_ldbl_get(self) -> uchar
 |  
 |  size_ll
 |      compiler_info_t_size_ll_get(self) -> uchar
 |  
 |  size_s
 |      compiler_info_t_size_s_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag

Help on class idainfo in module ida_ida:

class idainfo(builtins.object)
 |  Proxy of C++ idainfo class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  big_arg_align = __func(self, *args)
 |  
 |  gen_lzero = __func(self, *args)
 |  
 |  gen_null = __func(self, *args)
 |  
 |  gen_tryblks = __func(self, *args)
 |  
 |  get_abiname(self, *args) -> 'qstring'
 |      get_abiname(self) -> qstring
 |  
 |  get_demname_form = __func(self, *args)
 |  
 |  get_maxEA(self, *args) -> 'ea_t'
 |      get_maxEA(self) -> ea_t
 |  
 |  get_minEA(self, *args) -> 'ea_t'
 |      get_minEA(self) -> ea_t
 |  
 |  get_pack_mode = __func(self, *args)
 |  
 |  get_procName(self, *args) -> 'qstring'
 |      get_procName(self) -> qstring
 |  
 |  is_32bit = __func(self, *args)
 |  
 |  is_64bit = __func(self, *args)
 |  
 |  is_auto_enabled = __func(self, *args)
 |  
 |  is_be = __func(self, *args)
 |  
 |  is_dll = __func(self, *args)
 |  
 |  is_flat_off32 = __func(self, *args)
 |  
 |  is_graph_view = __func(self, *args)
 |  
 |  is_hard_float = __func(self, *args)
 |  
 |  is_kernel_mode = __func(self, *args)
 |  
 |  is_mem_aligned4 = __func(self, *args)
 |  
 |  is_snapshot = __func(self, *args)
 |  
 |  is_wide_high_byte_first = __func(self, *args)
 |  
 |  like_binary = __func(self, *args)
 |  
 |  line_pref_with_seg = __func(self, *args)
 |  
 |  loading_idc = __func(self, *args)
 |  
 |  map_stkargs = __func(self, *args)
 |  
 |  pack_stkargs = __func(self, *args)
 |  
 |  readonly_idb = __func(self, *args)
 |  
 |  set_64bit = __func(self, *args)
 |  
 |  set_auto_enabled = __func(self, *args)
 |  
 |  set_be = __func(self, *args)
 |  
 |  set_gen_lzero = __func(self, *args)
 |  
 |  set_gen_null = __func(self, *args)
 |  
 |  set_gen_tryblks = __func(self, *args)
 |  
 |  set_graph_view = __func(self, *args)
 |  
 |  set_line_pref_with_seg = __func(self, *args)
 |  
 |  set_maxEA(self, *args) -> 'void'
 |      set_maxEA(self, ea)
 |  
 |  set_minEA(self, *args) -> 'void'
 |      set_minEA(self, ea)
 |  
 |  set_pack_mode = __func(self, *args)
 |  
 |  set_show_auto = __func(self, *args)
 |  
 |  set_show_line_pref = __func(self, *args)
 |  
 |  set_show_void = __func(self, *args)
 |  
 |  set_wide_high_byte_first = __func(self, *args)
 |  
 |  show_auto = __func(self, *args)
 |  
 |  show_line_pref = __func(self, *args)
 |  
 |  show_void = __func(self, *args)
 |  
 |  stack_ldbl = __func(self, *args)
 |  
 |  stack_varargs = __func(self, *args)
 |  
 |  use_allasm = __func(self, *args)
 |  
 |  use_gcc_layout = __func(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  abibits
 |      idainfo_abibits_get(self) -> uint32
 |  
 |  abiname
 |      get_abiname(self) -> qstring
 |  
 |  af
 |      idainfo_af_get(self) -> uint32
 |  
 |  af2
 |      idainfo_af2_get(self) -> uint32
 |  
 |  appcall_options
 |      idainfo_appcall_options_get(self) -> uint32
 |  
 |  apptype
 |      idainfo_apptype_get(self) -> ushort
 |  
 |  asmtype
 |      idainfo_asmtype_get(self) -> uchar
 |  
 |  baseaddr
 |      idainfo_baseaddr_get(self) -> uval_t
 |  
 |  bin_prefix_size
 |      idainfo_bin_prefix_size_get(self) -> short
 |  
 |  cc
 |      idainfo_cc_get(self) -> compiler_info_t
 |  
 |  comment
 |      idainfo_comment_get(self) -> uchar
 |  
 |  database_change_count
 |      idainfo_database_change_count_get(self) -> uint32
 |  
 |  datatypes
 |      idainfo_datatypes_get(self) -> uval_t
 |  
 |  demnames
 |      idainfo_demnames_get(self) -> uchar
 |  
 |  filetype
 |      idainfo_filetype_get(self) -> ushort
 |  
 |  highoff
 |      idainfo_highoff_get(self) -> ea_t
 |  
 |  indent
 |      idainfo_indent_get(self) -> uchar
 |  
 |  lenxref
 |      idainfo_lenxref_get(self) -> ushort
 |  
 |  lflags
 |      idainfo_lflags_get(self) -> uint32
 |  
 |  listnames
 |      idainfo_listnames_get(self) -> uchar
 |  
 |  long_demnames
 |      idainfo_long_demnames_get(self) -> uint32
 |  
 |  lowoff
 |      idainfo_lowoff_get(self) -> ea_t
 |  
 |  main
 |      idainfo_main_get(self) -> ea_t
 |  
 |  margin
 |      idainfo_margin_get(self) -> ushort
 |  
 |  maxEA
 |      get_maxEA(self) -> ea_t
 |  
 |  max_autoname_len
 |      idainfo_max_autoname_len_get(self) -> ushort
 |  
 |  max_ea
 |      idainfo_max_ea_get(self) -> ea_t
 |  
 |  maxref
 |      idainfo_maxref_get(self) -> uval_t
 |  
 |  minEA
 |      get_minEA(self) -> ea_t
 |  
 |  min_ea
 |      idainfo_min_ea_get(self) -> ea_t
 |  
 |  nametype
 |      idainfo_nametype_get(self) -> char
 |  
 |  omax_ea
 |      idainfo_omax_ea_get(self) -> ea_t
 |  
 |  omin_ea
 |      idainfo_omin_ea_get(self) -> ea_t
 |  
 |  ostype
 |      idainfo_ostype_get(self) -> ushort
 |  
 |  outflags
 |      idainfo_outflags_get(self) -> uint32
 |  
 |  procName
 |      get_procName(self) -> qstring
 |  
 |  procname
 |      idainfo_procname_get(self) -> char [16]
 |  
 |  refcmtnum
 |      idainfo_refcmtnum_get(self) -> uchar
 |  
 |  s_cmtflg
 |      idainfo_s_cmtflg_get(self) -> uchar
 |  
 |  s_genflags
 |      idainfo_s_genflags_get(self) -> ushort
 |  
 |  s_limiter
 |      idainfo_s_limiter_get(self) -> uchar
 |  
 |  s_prefflag
 |      idainfo_s_prefflag_get(self) -> uchar
 |  
 |  s_xrefflag
 |      idainfo_s_xrefflag_get(self) -> uchar
 |  
 |  short_demnames
 |      idainfo_short_demnames_get(self) -> uint32
 |  
 |  specsegs
 |      idainfo_specsegs_get(self) -> uchar
 |  
 |  start_cs
 |      idainfo_start_cs_get(self) -> sel_t
 |  
 |  start_ea
 |      idainfo_start_ea_get(self) -> ea_t
 |  
 |  start_ip
 |      idainfo_start_ip_get(self) -> ea_t
 |  
 |  start_sp
 |      idainfo_start_sp_get(self) -> ea_t
 |  
 |  start_ss
 |      idainfo_start_ss_get(self) -> sel_t
 |  
 |  strlit_break
 |      idainfo_strlit_break_get(self) -> uchar
 |  
 |  strlit_flags
 |      idainfo_strlit_flags_get(self) -> uchar
 |  
 |  strlit_pref
 |      idainfo_strlit_pref_get(self) -> char [16]
 |  
 |  strlit_sernum
 |      idainfo_strlit_sernum_get(self) -> uval_t
 |  
 |  strlit_zeroes
 |      idainfo_strlit_zeroes_get(self) -> char
 |  
 |  strtype
 |      idainfo_strtype_get(self) -> int32
 |  
 |  tag
 |      idainfo_tag_get(self) -> char [3]
 |  
 |  thisown
 |      The membership flag
 |  
 |  type_xrefnum
 |      idainfo_type_xrefnum_get(self) -> uchar
 |  
 |  version
 |      idainfo_version_get(self) -> ushort
 |  
 |  xrefnum
 |      idainfo_xrefnum_get(self) -> uchar

Help on function inf_big_arg_align in module ida_ida:

inf_big_arg_align(*args) -> 'bool'
    inf_big_arg_align() -> bool

Help on function inf_gen_lzero in module ida_ida:

inf_gen_lzero(*args) -> 'bool'
    inf_gen_lzero() -> bool

Help on function inf_gen_null in module ida_ida:

inf_gen_null(*args) -> 'bool'
    inf_gen_null() -> bool

Help on function inf_gen_tryblks in module ida_ida:

inf_gen_tryblks(*args) -> 'bool'
    inf_gen_tryblks() -> bool

Help on function inf_get_demname_form in module ida_ida:

inf_get_demname_form(*args) -> 'uchar'
    inf_get_demname_form() -> uchar
    
    
    Get 'DEMNAM_MASK' bits of #demnames.

Help on function inf_get_pack_mode in module ida_ida:

inf_get_pack_mode(*args) -> 'int'
    inf_get_pack_mode() -> int

Help on function inf_is_32bit in module ida_ida:

inf_is_32bit(*args) -> 'bool'
    inf_is_32bit() -> bool

Help on function inf_is_64bit in module ida_ida:

inf_is_64bit(*args) -> 'bool'
    inf_is_64bit() -> bool

Help on function inf_is_auto_enabled in module ida_ida:

inf_is_auto_enabled(*args) -> 'bool'
    inf_is_auto_enabled() -> bool

Help on function inf_is_be in module ida_ida:

inf_is_be(*args) -> 'bool'
    inf_is_be() -> bool

Help on function inf_is_dll in module ida_ida:

inf_is_dll(*args) -> 'bool'
    inf_is_dll() -> bool

Help on function inf_is_flat_off32 in module ida_ida:

inf_is_flat_off32(*args) -> 'bool'
    inf_is_flat_off32() -> bool

Help on function inf_is_graph_view in module ida_ida:

inf_is_graph_view(*args) -> 'bool'
    inf_is_graph_view() -> bool

Help on function inf_is_hard_float in module ida_ida:

inf_is_hard_float(*args) -> 'bool'
    inf_is_hard_float() -> bool

Help on function inf_is_kernel_mode in module ida_ida:

inf_is_kernel_mode(*args) -> 'bool'
    inf_is_kernel_mode() -> bool

Help on function inf_is_mem_aligned4 in module ida_ida:

inf_is_mem_aligned4(*args) -> 'bool'
    inf_is_mem_aligned4() -> bool

Help on function inf_is_snapshot in module ida_ida:

inf_is_snapshot(*args) -> 'bool'
    inf_is_snapshot() -> bool

Help on function inf_is_wide_high_byte_first in module ida_ida:

inf_is_wide_high_byte_first(*args) -> 'bool'
    inf_is_wide_high_byte_first() -> bool

Help on function inf_like_binary in module ida_ida:

inf_like_binary(*args) -> 'bool'
    inf_like_binary() -> bool

Help on function inf_line_pref_with_seg in module ida_ida:

inf_line_pref_with_seg(*args) -> 'bool'
    inf_line_pref_with_seg() -> bool

Help on function inf_loading_idc in module ida_ida:

inf_loading_idc(*args) -> 'bool'
    inf_loading_idc() -> bool

Help on function inf_map_stkargs in module ida_ida:

inf_map_stkargs(*args) -> 'bool'
    inf_map_stkargs() -> bool

Help on function inf_pack_stkargs in module ida_ida:

inf_pack_stkargs(*args) -> 'bool'
    inf_pack_stkargs() -> bool

Help on function inf_readonly_idb in module ida_ida:

inf_readonly_idb(*args) -> 'bool'
    inf_readonly_idb() -> bool

Help on function inf_set_64bit in module ida_ida:

inf_set_64bit(*args) -> 'bool'
    inf_set_64bit(_v=True) -> bool

Help on function inf_set_auto_enabled in module ida_ida:

inf_set_auto_enabled(*args) -> 'bool'
    inf_set_auto_enabled(_v=True) -> bool

Help on function inf_set_be in module ida_ida:

inf_set_be(*args) -> 'bool'
    inf_set_be(_v=True) -> bool

Help on function inf_set_gen_lzero in module ida_ida:

inf_set_gen_lzero(*args) -> 'bool'
    inf_set_gen_lzero(_v=True) -> bool

Help on function inf_set_gen_null in module ida_ida:

inf_set_gen_null(*args) -> 'bool'
    inf_set_gen_null(_v=True) -> bool

Help on function inf_set_gen_tryblks in module ida_ida:

inf_set_gen_tryblks(*args) -> 'bool'
    inf_set_gen_tryblks(_v=True) -> bool

Help on function inf_set_graph_view in module ida_ida:

inf_set_graph_view(*args) -> 'bool'
    inf_set_graph_view(_v=True) -> bool

Help on function inf_set_line_pref_with_seg in module ida_ida:

inf_set_line_pref_with_seg(*args) -> 'bool'
    inf_set_line_pref_with_seg(_v=True) -> bool

Help on function inf_set_pack_mode in module ida_ida:

inf_set_pack_mode(*args) -> 'int'
    inf_set_pack_mode(pack_mode) -> int

Help on function inf_set_show_auto in module ida_ida:

inf_set_show_auto(*args) -> 'bool'
    inf_set_show_auto(_v=True) -> bool

Help on function inf_set_show_line_pref in module ida_ida:

inf_set_show_line_pref(*args) -> 'bool'
    inf_set_show_line_pref(_v=True) -> bool

Help on function inf_set_show_void in module ida_ida:

inf_set_show_void(*args) -> 'bool'
    inf_set_show_void(_v=True) -> bool

Help on function <lambda> in module ida_ida:

<lambda> lambda *args

Help on function inf_set_wide_high_byte_first in module ida_ida:

inf_set_wide_high_byte_first(*args) -> 'bool'
    inf_set_wide_high_byte_first(_v=True) -> bool

Help on function inf_show_auto in module ida_ida:

inf_show_auto(*args) -> 'bool'
    inf_show_auto() -> bool

Help on function inf_show_line_pref in module ida_ida:

inf_show_line_pref(*args) -> 'bool'
    inf_show_line_pref() -> bool

Help on function inf_show_void in module ida_ida:

inf_show_void(*args) -> 'bool'
    inf_show_void() -> bool

Help on function inf_stack_ldbl in module ida_ida:

inf_stack_ldbl(*args) -> 'bool'
    inf_stack_ldbl() -> bool

Help on function inf_stack_varargs in module ida_ida:

inf_stack_varargs(*args) -> 'bool'
    inf_stack_varargs() -> bool

Help on function inf_use_allasm in module ida_ida:

inf_use_allasm(*args) -> 'bool'
    inf_use_allasm() -> bool

Help on function inf_use_gcc_layout in module ida_ida:

inf_use_gcc_layout(*args) -> 'bool'
    inf_use_gcc_layout() -> bool

Help on function inf_abi_set_by_user in module ida_ida:

inf_abi_set_by_user(*args) -> 'bool'
    inf_abi_set_by_user() -> bool

Help on function inf_allow_non_matched_ops in module ida_ida:

inf_allow_non_matched_ops(*args) -> 'bool'
    inf_allow_non_matched_ops() -> bool

Help on function inf_allow_sigmulti in module ida_ida:

inf_allow_sigmulti(*args) -> 'bool'
    inf_allow_sigmulti() -> bool

Help on function inf_append_sigcmt in module ida_ida:

inf_append_sigcmt(*args) -> 'bool'
    inf_append_sigcmt() -> bool

Help on function inf_check_manual_ops in module ida_ida:

inf_check_manual_ops(*args) -> 'bool'
    inf_check_manual_ops() -> bool

Help on function inf_check_unicode_strlits in module ida_ida:

inf_check_unicode_strlits(*args) -> 'bool'
    inf_check_unicode_strlits() -> bool

Help on function inf_coagulate_code in module ida_ida:

inf_coagulate_code(*args) -> 'bool'
    inf_coagulate_code() -> bool

Help on function inf_coagulate_data in module ida_ida:

inf_coagulate_data(*args) -> 'bool'
    inf_coagulate_data() -> bool

Help on function inf_compress_idb in module ida_ida:

inf_compress_idb(*args) -> 'bool'
    inf_compress_idb() -> bool

Help on function inf_create_all_xrefs in module ida_ida:

inf_create_all_xrefs(*args) -> 'bool'
    inf_create_all_xrefs() -> bool

Help on function inf_create_func_from_call in module ida_ida:

inf_create_func_from_call(*args) -> 'bool'
    inf_create_func_from_call() -> bool

Help on function inf_create_func_from_ptr in module ida_ida:

inf_create_func_from_ptr(*args) -> 'bool'
    inf_create_func_from_ptr() -> bool

Help on function inf_create_func_tails in module ida_ida:

inf_create_func_tails(*args) -> 'bool'
    inf_create_func_tails() -> bool

Help on function inf_create_jump_tables in module ida_ida:

inf_create_jump_tables(*args) -> 'bool'
    inf_create_jump_tables() -> bool

Help on function inf_create_off_on_dref in module ida_ida:

inf_create_off_on_dref(*args) -> 'bool'
    inf_create_off_on_dref() -> bool

Help on function inf_create_off_using_fixup in module ida_ida:

inf_create_off_using_fixup(*args) -> 'bool'
    inf_create_off_using_fixup() -> bool

Help on function inf_create_strlit_on_xref in module ida_ida:

inf_create_strlit_on_xref(*args) -> 'bool'
    inf_create_strlit_on_xref() -> bool

Help on function inf_data_offset in module ida_ida:

inf_data_offset(*args) -> 'bool'
    inf_data_offset() -> bool

Help on function inf_dbg_no_store_path in module ida_ida:

inf_dbg_no_store_path(*args) -> 'bool'
    inf_dbg_no_store_path() -> bool

Help on function inf_decode_fpp in module ida_ida:

inf_decode_fpp(*args) -> 'bool'
    inf_decode_fpp() -> bool

Help on function inf_del_no_xref_insns in module ida_ida:

inf_del_no_xref_insns(*args) -> 'bool'
    inf_del_no_xref_insns() -> bool

Help on function inf_final_pass in module ida_ida:

inf_final_pass(*args) -> 'bool'
    inf_final_pass() -> bool

Help on function inf_full_sp_ana in module ida_ida:

inf_full_sp_ana(*args) -> 'bool'
    inf_full_sp_ana() -> bool

Help on function inf_gen_assume in module ida_ida:

inf_gen_assume(*args) -> 'bool'
    inf_gen_assume() -> bool

Help on function inf_gen_org in module ida_ida:

inf_gen_org(*args) -> 'bool'
    inf_gen_org() -> bool

Help on function inf_get_abibits in module ida_ida:

inf_get_abibits(*args) -> 'uint32'
    inf_get_abibits() -> uint32

Help on function inf_get_af in module ida_ida:

inf_get_af(*args) -> 'uint32'
    inf_get_af() -> uint32

Help on function inf_get_af2 in module ida_ida:

inf_get_af2(*args) -> 'uint32'
    inf_get_af2() -> uint32

Help on function inf_get_af2_low in module ida_ida:

inf_get_af2_low(*args) -> 'ushort'
    inf_get_af2_low() -> ushort
    
    
    Get/set low 16bit half of inf.af2.

Help on function inf_get_af_high in module ida_ida:

inf_get_af_high(*args) -> 'ushort'
    inf_get_af_high() -> ushort

Help on function inf_get_af_low in module ida_ida:

inf_get_af_low(*args) -> 'ushort'
    inf_get_af_low() -> ushort
    
    
    Get/set low/high 16bit halves of inf.af.

Help on function inf_get_appcall_options in module ida_ida:

inf_get_appcall_options(*args) -> 'uint32'
    inf_get_appcall_options() -> uint32

Help on function inf_get_apptype in module ida_ida:

inf_get_apptype(*args) -> 'ushort'
    inf_get_apptype() -> ushort

Help on function inf_get_asmtype in module ida_ida:

inf_get_asmtype(*args) -> 'uchar'
    inf_get_asmtype() -> uchar

Help on function inf_get_baseaddr in module ida_ida:

inf_get_baseaddr(*args) -> 'uval_t'
    inf_get_baseaddr() -> uval_t

Help on function inf_get_bin_prefix_size in module ida_ida:

inf_get_bin_prefix_size(*args) -> 'short'
    inf_get_bin_prefix_size() -> short

Help on function inf_get_cc in module ida_ida:

inf_get_cc(*args) -> 'bool'
    inf_get_cc(out) -> bool

Help on function inf_get_cc_cm in module ida_ida:

inf_get_cc_cm(*args) -> 'cm_t'
    inf_get_cc_cm() -> cm_t

Help on function inf_get_cc_defalign in module ida_ida:

inf_get_cc_defalign(*args) -> 'uchar'
    inf_get_cc_defalign() -> uchar

Help on function inf_get_cc_id in module ida_ida:

inf_get_cc_id(*args) -> 'comp_t'
    inf_get_cc_id() -> comp_t

Help on function inf_get_cc_size_b in module ida_ida:

inf_get_cc_size_b(*args) -> 'uchar'
    inf_get_cc_size_b() -> uchar

Help on function inf_get_cc_size_e in module ida_ida:

inf_get_cc_size_e(*args) -> 'uchar'
    inf_get_cc_size_e() -> uchar

Help on function inf_get_cc_size_i in module ida_ida:

inf_get_cc_size_i(*args) -> 'uchar'
    inf_get_cc_size_i() -> uchar

Help on function inf_get_cc_size_l in module ida_ida:

inf_get_cc_size_l(*args) -> 'uchar'
    inf_get_cc_size_l() -> uchar

Help on function inf_get_cc_size_ldbl in module ida_ida:

inf_get_cc_size_ldbl(*args) -> 'uchar'
    inf_get_cc_size_ldbl() -> uchar

Help on function inf_get_cc_size_ll in module ida_ida:

inf_get_cc_size_ll(*args) -> 'uchar'
    inf_get_cc_size_ll() -> uchar

Help on function inf_get_cc_size_s in module ida_ida:

inf_get_cc_size_s(*args) -> 'uchar'
    inf_get_cc_size_s() -> uchar

Help on function inf_get_cmtflg in module ida_ida:

inf_get_cmtflg(*args) -> 'uchar'
    inf_get_cmtflg() -> uchar

Help on function inf_get_comment in module ida_ida:

inf_get_comment(*args) -> 'uchar'
    inf_get_comment() -> uchar

Help on function inf_get_database_change_count in module ida_ida:

inf_get_database_change_count(*args) -> 'uint32'
    inf_get_database_change_count() -> uint32

Help on function inf_get_datatypes in module ida_ida:

inf_get_datatypes(*args) -> 'uval_t'
    inf_get_datatypes() -> uval_t

Help on function inf_get_demnames in module ida_ida:

inf_get_demnames(*args) -> 'uchar'
    inf_get_demnames() -> uchar

Help on function inf_get_filetype in module ida_ida:

inf_get_filetype(*args) -> 'filetype_t'
    inf_get_filetype() -> filetype_t

Help on function inf_get_genflags in module ida_ida:

inf_get_genflags(*args) -> 'ushort'
    inf_get_genflags() -> ushort

Help on function inf_get_highoff in module ida_ida:

inf_get_highoff(*args) -> 'ea_t'
    inf_get_highoff() -> ea_t

Help on function inf_get_indent in module ida_ida:

inf_get_indent(*args) -> 'uchar'
    inf_get_indent() -> uchar

Help on function inf_get_lenxref in module ida_ida:

inf_get_lenxref(*args) -> 'ushort'
    inf_get_lenxref() -> ushort

Help on function inf_get_lflags in module ida_ida:

inf_get_lflags(*args) -> 'uint32'
    inf_get_lflags() -> uint32

Help on function inf_get_limiter in module ida_ida:

inf_get_limiter(*args) -> 'uchar'
    inf_get_limiter() -> uchar

Help on function inf_get_listnames in module ida_ida:

inf_get_listnames(*args) -> 'uchar'
    inf_get_listnames() -> uchar

Help on function inf_get_long_demnames in module ida_ida:

inf_get_long_demnames(*args) -> 'uint32'
    inf_get_long_demnames() -> uint32

Help on function inf_get_lowoff in module ida_ida:

inf_get_lowoff(*args) -> 'ea_t'
    inf_get_lowoff() -> ea_t

Help on function inf_get_main in module ida_ida:

inf_get_main(*args) -> 'ea_t'
    inf_get_main() -> ea_t

Help on function inf_get_margin in module ida_ida:

inf_get_margin(*args) -> 'ushort'
    inf_get_margin() -> ushort

Help on function inf_get_max_autoname_len in module ida_ida:

inf_get_max_autoname_len(*args) -> 'ushort'
    inf_get_max_autoname_len() -> ushort

Help on function inf_get_max_ea in module ida_ida:

inf_get_max_ea(*args) -> 'ea_t'
    inf_get_max_ea() -> ea_t

Help on function inf_get_maxref in module ida_ida:

inf_get_maxref(*args) -> 'uval_t'
    inf_get_maxref() -> uval_t

Help on function inf_get_min_ea in module ida_ida:

inf_get_min_ea(*args) -> 'ea_t'
    inf_get_min_ea() -> ea_t

Help on function inf_get_nametype in module ida_ida:

inf_get_nametype(*args) -> 'char'
    inf_get_nametype() -> char

Help on function inf_get_netdelta in module ida_ida:

inf_get_netdelta(*args) -> 'sval_t'
    inf_get_netdelta() -> sval_t

Help on function inf_get_omax_ea in module ida_ida:

inf_get_omax_ea(*args) -> 'ea_t'
    inf_get_omax_ea() -> ea_t

Help on function inf_get_omin_ea in module ida_ida:

inf_get_omin_ea(*args) -> 'ea_t'
    inf_get_omin_ea() -> ea_t

Help on function inf_get_ostype in module ida_ida:

inf_get_ostype(*args) -> 'ushort'
    inf_get_ostype() -> ushort

Help on function inf_get_outflags in module ida_ida:

inf_get_outflags(*args) -> 'uint32'
    inf_get_outflags() -> uint32

Help on function inf_get_prefflag in module ida_ida:

inf_get_prefflag(*args) -> 'uchar'
    inf_get_prefflag() -> uchar

Help on function inf_get_privrange in module ida_ida:

inf_get_privrange(*args) -> 'range_t'
    inf_get_privrange(out) -> bool
    inf_get_privrange() -> range_t

Help on function inf_get_privrange_end_ea in module ida_ida:

inf_get_privrange_end_ea(*args) -> 'ea_t'
    inf_get_privrange_end_ea() -> ea_t

Help on function inf_get_privrange_start_ea in module ida_ida:

inf_get_privrange_start_ea(*args) -> 'ea_t'
    inf_get_privrange_start_ea() -> ea_t

Help on function inf_get_procname in module ida_ida:

inf_get_procname(*args) -> 'size_t'
    inf_get_procname() -> str

Help on function inf_get_refcmtnum in module ida_ida:

inf_get_refcmtnum(*args) -> 'uchar'
    inf_get_refcmtnum() -> uchar

Help on function inf_get_short_demnames in module ida_ida:

inf_get_short_demnames(*args) -> 'uint32'
    inf_get_short_demnames() -> uint32

Help on function inf_get_specsegs in module ida_ida:

inf_get_specsegs(*args) -> 'uchar'
    inf_get_specsegs() -> uchar

Help on function inf_get_start_cs in module ida_ida:

inf_get_start_cs(*args) -> 'sel_t'
    inf_get_start_cs() -> sel_t

Help on function inf_get_start_ea in module ida_ida:

inf_get_start_ea(*args) -> 'ea_t'
    inf_get_start_ea() -> ea_t

Help on function inf_get_start_ip in module ida_ida:

inf_get_start_ip(*args) -> 'ea_t'
    inf_get_start_ip() -> ea_t

Help on function inf_get_start_sp in module ida_ida:

inf_get_start_sp(*args) -> 'ea_t'
    inf_get_start_sp() -> ea_t

Help on function inf_get_start_ss in module ida_ida:

inf_get_start_ss(*args) -> 'sel_t'
    inf_get_start_ss() -> sel_t

Help on function inf_get_strlit_break in module ida_ida:

inf_get_strlit_break(*args) -> 'uchar'
    inf_get_strlit_break() -> uchar

Help on function inf_get_strlit_flags in module ida_ida:

inf_get_strlit_flags(*args) -> 'uchar'
    inf_get_strlit_flags() -> uchar

Help on function inf_get_strlit_pref in module ida_ida:

inf_get_strlit_pref(*args) -> 'size_t'
    inf_get_strlit_pref() -> str

Help on function inf_get_strlit_sernum in module ida_ida:

inf_get_strlit_sernum(*args) -> 'uval_t'
    inf_get_strlit_sernum() -> uval_t

Help on function inf_get_strlit_zeroes in module ida_ida:

inf_get_strlit_zeroes(*args) -> 'char'
    inf_get_strlit_zeroes() -> char

Help on function inf_get_strtype in module ida_ida:

inf_get_strtype(*args) -> 'int32'
    inf_get_strtype() -> int32

Help on function inf_get_type_xrefnum in module ida_ida:

inf_get_type_xrefnum(*args) -> 'uchar'
    inf_get_type_xrefnum() -> uchar

Help on function inf_get_version in module ida_ida:

inf_get_version(*args) -> 'ushort'
    inf_get_version() -> ushort

Help on function inf_get_xrefflag in module ida_ida:

inf_get_xrefflag(*args) -> 'uchar'
    inf_get_xrefflag() -> uchar

Help on function inf_get_xrefnum in module ida_ida:

inf_get_xrefnum(*args) -> 'uchar'
    inf_get_xrefnum() -> uchar

Help on function inf_guess_func_type in module ida_ida:

inf_guess_func_type(*args) -> 'bool'
    inf_guess_func_type() -> bool

Help on function inf_handle_eh in module ida_ida:

inf_handle_eh(*args) -> 'bool'
    inf_handle_eh() -> bool

Help on function inf_handle_rtti in module ida_ida:

inf_handle_rtti(*args) -> 'bool'
    inf_handle_rtti() -> bool

Help on function inf_hide_comments in module ida_ida:

inf_hide_comments(*args) -> 'bool'
    inf_hide_comments() -> bool

Help on function inf_hide_libfuncs in module ida_ida:

inf_hide_libfuncs(*args) -> 'bool'
    inf_hide_libfuncs() -> bool

Help on function inf_huge_arg_align in module ida_ida:

inf_huge_arg_align(*args) -> 'bool'
    inf_huge_arg_align() -> bool

Help on function inf_inc_database_change_count in module ida_ida:

inf_inc_database_change_count(*args) -> 'void'
    inf_inc_database_change_count(cnt=1)

Help on function inf_is_limiter_empty in module ida_ida:

inf_is_limiter_empty(*args) -> 'bool'
    inf_is_limiter_empty() -> bool

Help on function inf_is_limiter_thick in module ida_ida:

inf_is_limiter_thick(*args) -> 'bool'
    inf_is_limiter_thick() -> bool

Help on function inf_is_limiter_thin in module ida_ida:

inf_is_limiter_thin(*args) -> 'bool'
    inf_is_limiter_thin() -> bool

Help on function inf_macros_enabled in module ida_ida:

inf_macros_enabled(*args) -> 'bool'
    inf_macros_enabled() -> bool

Help on function inf_mark_code in module ida_ida:

inf_mark_code(*args) -> 'bool'
    inf_mark_code() -> bool

Help on function inf_no_store_user_info in module ida_ida:

inf_no_store_user_info(*args) -> 'bool'
    inf_no_store_user_info() -> bool

Help on function inf_noflow_to_data in module ida_ida:

inf_noflow_to_data(*args) -> 'bool'
    inf_noflow_to_data() -> bool

Help on function inf_noret_ana in module ida_ida:

inf_noret_ana(*args) -> 'bool'
    inf_noret_ana() -> bool

Help on function inf_op_offset in module ida_ida:

inf_op_offset(*args) -> 'bool'
    inf_op_offset() -> bool

Help on function inf_pack_idb in module ida_ida:

inf_pack_idb(*args) -> 'bool'
    inf_pack_idb() -> bool

Help on function inf_postinc_strlit_sernum in module ida_ida:

inf_postinc_strlit_sernum(*args) -> 'uval_t'
    inf_postinc_strlit_sernum(cnt=1) -> uval_t

Help on function inf_prefix_show_funcoff in module ida_ida:

inf_prefix_show_funcoff(*args) -> 'bool'
    inf_prefix_show_funcoff() -> bool

Help on function inf_prefix_show_segaddr in module ida_ida:

inf_prefix_show_segaddr(*args) -> 'bool'
    inf_prefix_show_segaddr() -> bool

Help on function inf_prefix_show_stack in module ida_ida:

inf_prefix_show_stack(*args) -> 'bool'
    inf_prefix_show_stack() -> bool

Help on function inf_prefix_truncate_opcode_bytes in module ida_ida:

inf_prefix_truncate_opcode_bytes(*args) -> 'bool'
    inf_prefix_truncate_opcode_bytes() -> bool

Help on function inf_propagate_regargs in module ida_ida:

inf_propagate_regargs(*args) -> 'bool'
    inf_propagate_regargs() -> bool

Help on function inf_propagate_stkargs in module ida_ida:

inf_propagate_stkargs(*args) -> 'bool'
    inf_propagate_stkargs() -> bool

Help on function inf_rename_jumpfunc in module ida_ida:

inf_rename_jumpfunc(*args) -> 'bool'
    inf_rename_jumpfunc() -> bool

Help on function inf_rename_nullsub in module ida_ida:

inf_rename_nullsub(*args) -> 'bool'
    inf_rename_nullsub() -> bool

Help on function inf_set_32bit in module ida_ida:

inf_set_32bit(*args) -> 'bool'
    inf_set_32bit(_v=True) -> bool

Help on function inf_set_abi_set_by_user in module ida_ida:

inf_set_abi_set_by_user(*args) -> 'bool'
    inf_set_abi_set_by_user(_v=True) -> bool

Help on function inf_set_abibits in module ida_ida:

inf_set_abibits(*args) -> 'bool'
    inf_set_abibits(_v) -> bool

Help on function inf_set_af in module ida_ida:

inf_set_af(*args) -> 'bool'
    inf_set_af(_v) -> bool

Help on function inf_set_af2 in module ida_ida:

inf_set_af2(*args) -> 'bool'
    inf_set_af2(_v) -> bool

Help on function inf_set_af2_low in module ida_ida:

inf_set_af2_low(*args) -> 'void'
    inf_set_af2_low(saf)

Help on function inf_set_af_high in module ida_ida:

inf_set_af_high(*args) -> 'void'
    inf_set_af_high(saf2)

Help on function inf_set_af_low in module ida_ida:

inf_set_af_low(*args) -> 'void'
    inf_set_af_low(saf)

Help on function inf_set_allow_non_matched_ops in module ida_ida:

inf_set_allow_non_matched_ops(*args) -> 'bool'
    inf_set_allow_non_matched_ops(_v=True) -> bool

Help on function inf_set_allow_sigmulti in module ida_ida:

inf_set_allow_sigmulti(*args) -> 'bool'
    inf_set_allow_sigmulti(_v=True) -> bool

Help on function inf_set_appcall_options in module ida_ida:

inf_set_appcall_options(*args) -> 'bool'
    inf_set_appcall_options(_v) -> bool

Help on function inf_set_append_sigcmt in module ida_ida:

inf_set_append_sigcmt(*args) -> 'bool'
    inf_set_append_sigcmt(_v=True) -> bool

Help on function inf_set_apptype in module ida_ida:

inf_set_apptype(*args) -> 'bool'
    inf_set_apptype(_v) -> bool

Help on function inf_set_asmtype in module ida_ida:

inf_set_asmtype(*args) -> 'bool'
    inf_set_asmtype(_v) -> bool

Help on function inf_set_baseaddr in module ida_ida:

inf_set_baseaddr(*args) -> 'bool'
    inf_set_baseaddr(_v) -> bool

Help on function inf_set_big_arg_align in module ida_ida:

inf_set_big_arg_align(*args) -> 'bool'
    inf_set_big_arg_align(_v=True) -> bool

Help on function inf_set_bin_prefix_size in module ida_ida:

inf_set_bin_prefix_size(*args) -> 'bool'
    inf_set_bin_prefix_size(_v) -> bool

Help on function inf_set_cc in module ida_ida:

inf_set_cc(*args) -> 'bool'
    inf_set_cc(_v) -> bool

Help on function inf_set_cc_cm in module ida_ida:

inf_set_cc_cm(*args) -> 'bool'
    inf_set_cc_cm(_v) -> bool

Help on function inf_set_cc_defalign in module ida_ida:

inf_set_cc_defalign(*args) -> 'bool'
    inf_set_cc_defalign(_v) -> bool

Help on function inf_set_cc_id in module ida_ida:

inf_set_cc_id(*args) -> 'bool'
    inf_set_cc_id(_v) -> bool

Help on function inf_set_cc_size_b in module ida_ida:

inf_set_cc_size_b(*args) -> 'bool'
    inf_set_cc_size_b(_v) -> bool

Help on function inf_set_cc_size_e in module ida_ida:

inf_set_cc_size_e(*args) -> 'bool'
    inf_set_cc_size_e(_v) -> bool

Help on function inf_set_cc_size_i in module ida_ida:

inf_set_cc_size_i(*args) -> 'bool'
    inf_set_cc_size_i(_v) -> bool

Help on function inf_set_cc_size_l in module ida_ida:

inf_set_cc_size_l(*args) -> 'bool'
    inf_set_cc_size_l(_v) -> bool

Help on function inf_set_cc_size_ldbl in module ida_ida:

inf_set_cc_size_ldbl(*args) -> 'bool'
    inf_set_cc_size_ldbl(_v) -> bool

Help on function inf_set_cc_size_ll in module ida_ida:

inf_set_cc_size_ll(*args) -> 'bool'
    inf_set_cc_size_ll(_v) -> bool

Help on function inf_set_cc_size_s in module ida_ida:

inf_set_cc_size_s(*args) -> 'bool'
    inf_set_cc_size_s(_v) -> bool

Help on function inf_set_check_manual_ops in module ida_ida:

inf_set_check_manual_ops(*args) -> 'bool'
    inf_set_check_manual_ops(_v=True) -> bool

Help on function inf_set_check_unicode_strlits in module ida_ida:

inf_set_check_unicode_strlits(*args) -> 'bool'
    inf_set_check_unicode_strlits(_v=True) -> bool

Help on function inf_set_cmtflg in module ida_ida:

inf_set_cmtflg(*args) -> 'bool'
    inf_set_cmtflg(_v) -> bool

Help on function inf_set_coagulate_code in module ida_ida:

inf_set_coagulate_code(*args) -> 'bool'
    inf_set_coagulate_code(_v=True) -> bool

Help on function inf_set_coagulate_data in module ida_ida:

inf_set_coagulate_data(*args) -> 'bool'
    inf_set_coagulate_data(_v=True) -> bool

Help on function inf_set_comment in module ida_ida:

inf_set_comment(*args) -> 'bool'
    inf_set_comment(_v) -> bool

Help on function inf_set_compress_idb in module ida_ida:

inf_set_compress_idb(*args) -> 'bool'
    inf_set_compress_idb(_v=True) -> bool

Help on function inf_set_create_all_xrefs in module ida_ida:

inf_set_create_all_xrefs(*args) -> 'bool'
    inf_set_create_all_xrefs(_v=True) -> bool

Help on function inf_set_create_func_from_call in module ida_ida:

inf_set_create_func_from_call(*args) -> 'bool'
    inf_set_create_func_from_call(_v=True) -> bool

Help on function inf_set_create_func_from_ptr in module ida_ida:

inf_set_create_func_from_ptr(*args) -> 'bool'
    inf_set_create_func_from_ptr(_v=True) -> bool

Help on function inf_set_create_func_tails in module ida_ida:

inf_set_create_func_tails(*args) -> 'bool'
    inf_set_create_func_tails(_v=True) -> bool

Help on function inf_set_create_jump_tables in module ida_ida:

inf_set_create_jump_tables(*args) -> 'bool'
    inf_set_create_jump_tables(_v=True) -> bool

Help on function inf_set_create_off_on_dref in module ida_ida:

inf_set_create_off_on_dref(*args) -> 'bool'
    inf_set_create_off_on_dref(_v=True) -> bool

Help on function inf_set_create_off_using_fixup in module ida_ida:

inf_set_create_off_using_fixup(*args) -> 'bool'
    inf_set_create_off_using_fixup(_v=True) -> bool

Help on function inf_set_create_strlit_on_xref in module ida_ida:

inf_set_create_strlit_on_xref(*args) -> 'bool'
    inf_set_create_strlit_on_xref(_v=True) -> bool

Help on function inf_set_data_offset in module ida_ida:

inf_set_data_offset(*args) -> 'bool'
    inf_set_data_offset(_v=True) -> bool

Help on function inf_set_database_change_count in module ida_ida:

inf_set_database_change_count(*args) -> 'bool'
    inf_set_database_change_count(_v) -> bool

Help on function inf_set_datatypes in module ida_ida:

inf_set_datatypes(*args) -> 'bool'
    inf_set_datatypes(_v) -> bool

Help on function inf_set_dbg_no_store_path in module ida_ida:

inf_set_dbg_no_store_path(*args) -> 'bool'
    inf_set_dbg_no_store_path(_v=True) -> bool

Help on function inf_set_decode_fpp in module ida_ida:

inf_set_decode_fpp(*args) -> 'bool'
    inf_set_decode_fpp(_v=True) -> bool

Help on function inf_set_del_no_xref_insns in module ida_ida:

inf_set_del_no_xref_insns(*args) -> 'bool'
    inf_set_del_no_xref_insns(_v=True) -> bool

Help on function inf_set_demnames in module ida_ida:

inf_set_demnames(*args) -> 'bool'
    inf_set_demnames(_v) -> bool

Help on function inf_set_dll in module ida_ida:

inf_set_dll(*args) -> 'bool'
    inf_set_dll(_v=True) -> bool

Help on function inf_set_filetype in module ida_ida:

inf_set_filetype(*args) -> 'bool'
    inf_set_filetype(_v) -> bool

Help on function inf_set_final_pass in module ida_ida:

inf_set_final_pass(*args) -> 'bool'
    inf_set_final_pass(_v=True) -> bool

Help on function inf_set_flat_off32 in module ida_ida:

inf_set_flat_off32(*args) -> 'bool'
    inf_set_flat_off32(_v=True) -> bool

Help on function inf_set_full_sp_ana in module ida_ida:

inf_set_full_sp_ana(*args) -> 'bool'
    inf_set_full_sp_ana(_v=True) -> bool

Help on function inf_set_gen_assume in module ida_ida:

inf_set_gen_assume(*args) -> 'bool'
    inf_set_gen_assume(_v=True) -> bool

Help on function inf_set_gen_org in module ida_ida:

inf_set_gen_org(*args) -> 'bool'
    inf_set_gen_org(_v=True) -> bool

Help on function inf_set_genflags in module ida_ida:

inf_set_genflags(*args) -> 'bool'
    inf_set_genflags(_v) -> bool

Help on function inf_set_guess_func_type in module ida_ida:

inf_set_guess_func_type(*args) -> 'bool'
    inf_set_guess_func_type(_v=True) -> bool

Help on function inf_set_handle_eh in module ida_ida:

inf_set_handle_eh(*args) -> 'bool'
    inf_set_handle_eh(_v=True) -> bool

Help on function inf_set_handle_rtti in module ida_ida:

inf_set_handle_rtti(*args) -> 'bool'
    inf_set_handle_rtti(_v=True) -> bool

Help on function inf_set_hard_float in module ida_ida:

inf_set_hard_float(*args) -> 'bool'
    inf_set_hard_float(_v=True) -> bool

Help on function inf_set_hide_comments in module ida_ida:

inf_set_hide_comments(*args) -> 'bool'
    inf_set_hide_comments(_v=True) -> bool

Help on function inf_set_hide_libfuncs in module ida_ida:

inf_set_hide_libfuncs(*args) -> 'bool'
    inf_set_hide_libfuncs(_v=True) -> bool

Help on function inf_set_highoff in module ida_ida:

inf_set_highoff(*args) -> 'bool'
    inf_set_highoff(_v) -> bool

Help on function inf_set_huge_arg_align in module ida_ida:

inf_set_huge_arg_align(*args) -> 'bool'
    inf_set_huge_arg_align(_v=True) -> bool

Help on function inf_set_indent in module ida_ida:

inf_set_indent(*args) -> 'bool'
    inf_set_indent(_v) -> bool

Help on function inf_set_kernel_mode in module ida_ida:

inf_set_kernel_mode(*args) -> 'bool'
    inf_set_kernel_mode(_v=True) -> bool

Help on function inf_set_lenxref in module ida_ida:

inf_set_lenxref(*args) -> 'bool'
    inf_set_lenxref(_v) -> bool

Help on function inf_set_lflags in module ida_ida:

inf_set_lflags(*args) -> 'bool'
    inf_set_lflags(_v) -> bool

Help on function inf_set_limiter in module ida_ida:

inf_set_limiter(*args) -> 'bool'
    inf_set_limiter(_v) -> bool

Help on function inf_set_limiter_empty in module ida_ida:

inf_set_limiter_empty(*args) -> 'bool'
    inf_set_limiter_empty(_v=True) -> bool

Help on function inf_set_limiter_thick in module ida_ida:

inf_set_limiter_thick(*args) -> 'bool'
    inf_set_limiter_thick(_v=True) -> bool

Help on function inf_set_limiter_thin in module ida_ida:

inf_set_limiter_thin(*args) -> 'bool'
    inf_set_limiter_thin(_v=True) -> bool

Help on function inf_set_listnames in module ida_ida:

inf_set_listnames(*args) -> 'bool'
    inf_set_listnames(_v) -> bool

Help on function inf_set_loading_idc in module ida_ida:

inf_set_loading_idc(*args) -> 'bool'
    inf_set_loading_idc(_v=True) -> bool

Help on function inf_set_long_demnames in module ida_ida:

inf_set_long_demnames(*args) -> 'bool'
    inf_set_long_demnames(_v) -> bool

Help on function inf_set_lowoff in module ida_ida:

inf_set_lowoff(*args) -> 'bool'
    inf_set_lowoff(_v) -> bool

Help on function inf_set_macros_enabled in module ida_ida:

inf_set_macros_enabled(*args) -> 'bool'
    inf_set_macros_enabled(_v=True) -> bool

Help on function inf_set_main in module ida_ida:

inf_set_main(*args) -> 'bool'
    inf_set_main(_v) -> bool

Help on function inf_set_map_stkargs in module ida_ida:

inf_set_map_stkargs(*args) -> 'bool'
    inf_set_map_stkargs(_v=True) -> bool

Help on function inf_set_margin in module ida_ida:

inf_set_margin(*args) -> 'bool'
    inf_set_margin(_v) -> bool

Help on function inf_set_mark_code in module ida_ida:

inf_set_mark_code(*args) -> 'bool'
    inf_set_mark_code(_v=True) -> bool

Help on function inf_set_max_autoname_len in module ida_ida:

inf_set_max_autoname_len(*args) -> 'bool'
    inf_set_max_autoname_len(_v) -> bool

Help on function inf_set_max_ea in module ida_ida:

inf_set_max_ea(*args) -> 'bool'
    inf_set_max_ea(_v) -> bool

Help on function inf_set_maxref in module ida_ida:

inf_set_maxref(*args) -> 'bool'
    inf_set_maxref(_v) -> bool

Help on function inf_set_mem_aligned4 in module ida_ida:

inf_set_mem_aligned4(*args) -> 'bool'
    inf_set_mem_aligned4(_v=True) -> bool

Help on function inf_set_min_ea in module ida_ida:

inf_set_min_ea(*args) -> 'bool'
    inf_set_min_ea(_v) -> bool

Help on function inf_set_nametype in module ida_ida:

inf_set_nametype(*args) -> 'bool'
    inf_set_nametype(_v) -> bool

Help on function inf_set_netdelta in module ida_ida:

inf_set_netdelta(*args) -> 'bool'
    inf_set_netdelta(_v) -> bool

Help on function inf_set_no_store_user_info in module ida_ida:

inf_set_no_store_user_info(*args) -> 'bool'
    inf_set_no_store_user_info(_v=True) -> bool

Help on function inf_set_noflow_to_data in module ida_ida:

inf_set_noflow_to_data(*args) -> 'bool'
    inf_set_noflow_to_data(_v=True) -> bool

Help on function inf_set_noret_ana in module ida_ida:

inf_set_noret_ana(*args) -> 'bool'
    inf_set_noret_ana(_v=True) -> bool

Help on function inf_set_omax_ea in module ida_ida:

inf_set_omax_ea(*args) -> 'bool'
    inf_set_omax_ea(_v) -> bool

Help on function inf_set_omin_ea in module ida_ida:

inf_set_omin_ea(*args) -> 'bool'
    inf_set_omin_ea(_v) -> bool

Help on function inf_set_op_offset in module ida_ida:

inf_set_op_offset(*args) -> 'bool'
    inf_set_op_offset(_v=True) -> bool

Help on function inf_set_ostype in module ida_ida:

inf_set_ostype(*args) -> 'bool'
    inf_set_ostype(_v) -> bool

Help on function inf_set_outflags in module ida_ida:

inf_set_outflags(*args) -> 'bool'
    inf_set_outflags(_v) -> bool

Help on function inf_set_pack_idb in module ida_ida:

inf_set_pack_idb(*args) -> 'bool'
    inf_set_pack_idb(_v=True) -> bool

Help on function inf_set_pack_stkargs in module ida_ida:

inf_set_pack_stkargs(*args) -> 'bool'
    inf_set_pack_stkargs(_v=True) -> bool

Help on function inf_set_prefflag in module ida_ida:

inf_set_prefflag(*args) -> 'bool'
    inf_set_prefflag(_v) -> bool

Help on function inf_set_prefix_show_funcoff in module ida_ida:

inf_set_prefix_show_funcoff(*args) -> 'bool'
    inf_set_prefix_show_funcoff(_v=True) -> bool

Help on function inf_set_prefix_show_segaddr in module ida_ida:

inf_set_prefix_show_segaddr(*args) -> 'bool'
    inf_set_prefix_show_segaddr(_v=True) -> bool

Help on function inf_set_prefix_show_stack in module ida_ida:

inf_set_prefix_show_stack(*args) -> 'bool'
    inf_set_prefix_show_stack(_v=True) -> bool

Help on function inf_set_prefix_truncate_opcode_bytes in module ida_ida:

inf_set_prefix_truncate_opcode_bytes(*args) -> 'bool'
    inf_set_prefix_truncate_opcode_bytes(_v=True) -> bool

Help on function inf_set_privrange in module ida_ida:

inf_set_privrange(*args) -> 'bool'
    inf_set_privrange(_v) -> bool

Help on function inf_set_privrange_end_ea in module ida_ida:

inf_set_privrange_end_ea(*args) -> 'bool'
    inf_set_privrange_end_ea(_v) -> bool

Help on function inf_set_privrange_start_ea in module ida_ida:

inf_set_privrange_start_ea(*args) -> 'bool'
    inf_set_privrange_start_ea(_v) -> bool

Help on function inf_set_procname in module ida_ida:

inf_set_procname(*args) -> 'bool'
    inf_set_procname(_v, len=size_t(-1)) -> bool

Help on function inf_set_propagate_regargs in module ida_ida:

inf_set_propagate_regargs(*args) -> 'bool'
    inf_set_propagate_regargs(_v=True) -> bool

Help on function inf_set_propagate_stkargs in module ida_ida:

inf_set_propagate_stkargs(*args) -> 'bool'
    inf_set_propagate_stkargs(_v=True) -> bool

Help on function inf_set_readonly_idb in module ida_ida:

inf_set_readonly_idb(*args) -> 'bool'
    inf_set_readonly_idb(_v=True) -> bool

Help on function inf_set_refcmtnum in module ida_ida:

inf_set_refcmtnum(*args) -> 'bool'
    inf_set_refcmtnum(_v) -> bool

Help on function inf_set_rename_jumpfunc in module ida_ida:

inf_set_rename_jumpfunc(*args) -> 'bool'
    inf_set_rename_jumpfunc(_v=True) -> bool

Help on function inf_set_rename_nullsub in module ida_ida:

inf_set_rename_nullsub(*args) -> 'bool'
    inf_set_rename_nullsub(_v=True) -> bool

Help on function inf_set_short_demnames in module ida_ida:

inf_set_short_demnames(*args) -> 'bool'
    inf_set_short_demnames(_v) -> bool

Help on function inf_set_should_create_stkvars in module ida_ida:

inf_set_should_create_stkvars(*args) -> 'bool'
    inf_set_should_create_stkvars(_v=True) -> bool

Help on function inf_set_should_trace_sp in module ida_ida:

inf_set_should_trace_sp(*args) -> 'bool'
    inf_set_should_trace_sp(_v=True) -> bool

Help on function inf_set_show_all_comments in module ida_ida:

inf_set_show_all_comments(*args) -> 'bool'
    inf_set_show_all_comments(_v=True) -> bool

Help on function inf_set_show_hidden_funcs in module ida_ida:

inf_set_show_hidden_funcs(*args) -> 'bool'
    inf_set_show_hidden_funcs(_v=True) -> bool

Help on function inf_set_show_hidden_insns in module ida_ida:

inf_set_show_hidden_insns(*args) -> 'bool'
    inf_set_show_hidden_insns(_v=True) -> bool

Help on function inf_set_show_hidden_segms in module ida_ida:

inf_set_show_hidden_segms(*args) -> 'bool'
    inf_set_show_hidden_segms(_v=True) -> bool

Help on function inf_set_show_repeatables in module ida_ida:

inf_set_show_repeatables(*args) -> 'bool'
    inf_set_show_repeatables(_v=True) -> bool

Help on function inf_set_show_src_linnum in module ida_ida:

inf_set_show_src_linnum(*args) -> 'bool'
    inf_set_show_src_linnum(_v=True) -> bool

Help on function inf_set_show_xref_fncoff in module ida_ida:

inf_set_show_xref_fncoff(*args) -> 'bool'
    inf_set_show_xref_fncoff(_v=True) -> bool

Help on function inf_set_show_xref_seg in module ida_ida:

inf_set_show_xref_seg(*args) -> 'bool'
    inf_set_show_xref_seg(_v=True) -> bool

Help on function inf_set_show_xref_tmarks in module ida_ida:

inf_set_show_xref_tmarks(*args) -> 'bool'
    inf_set_show_xref_tmarks(_v=True) -> bool

Help on function inf_set_show_xref_val in module ida_ida:

inf_set_show_xref_val(*args) -> 'bool'
    inf_set_show_xref_val(_v=True) -> bool

Help on function inf_set_snapshot in module ida_ida:

inf_set_snapshot(*args) -> 'bool'
    inf_set_snapshot(_v=True) -> bool

Help on function inf_set_specsegs in module ida_ida:

inf_set_specsegs(*args) -> 'bool'
    inf_set_specsegs(_v) -> bool

Help on function inf_set_stack_ldbl in module ida_ida:

inf_set_stack_ldbl(*args) -> 'bool'
    inf_set_stack_ldbl(_v=True) -> bool

Help on function inf_set_stack_varargs in module ida_ida:

inf_set_stack_varargs(*args) -> 'bool'
    inf_set_stack_varargs(_v=True) -> bool

Help on function inf_set_start_cs in module ida_ida:

inf_set_start_cs(*args) -> 'bool'
    inf_set_start_cs(_v) -> bool

Help on function inf_set_start_ea in module ida_ida:

inf_set_start_ea(*args) -> 'bool'
    inf_set_start_ea(_v) -> bool

Help on function inf_set_start_ip in module ida_ida:

inf_set_start_ip(*args) -> 'bool'
    inf_set_start_ip(_v) -> bool

Help on function inf_set_start_sp in module ida_ida:

inf_set_start_sp(*args) -> 'bool'
    inf_set_start_sp(_v) -> bool

Help on function inf_set_start_ss in module ida_ida:

inf_set_start_ss(*args) -> 'bool'
    inf_set_start_ss(_v) -> bool

Help on function inf_set_strlit_autocmt in module ida_ida:

inf_set_strlit_autocmt(*args) -> 'bool'
    inf_set_strlit_autocmt(_v=True) -> bool

Help on function inf_set_strlit_break in module ida_ida:

inf_set_strlit_break(*args) -> 'bool'
    inf_set_strlit_break(_v) -> bool

Help on function inf_set_strlit_flags in module ida_ida:

inf_set_strlit_flags(*args) -> 'bool'
    inf_set_strlit_flags(_v) -> bool

Help on function inf_set_strlit_name_bit in module ida_ida:

inf_set_strlit_name_bit(*args) -> 'bool'
    inf_set_strlit_name_bit(_v=True) -> bool

Help on function inf_set_strlit_names in module ida_ida:

inf_set_strlit_names(*args) -> 'bool'
    inf_set_strlit_names(_v=True) -> bool

Help on function inf_set_strlit_pref in module ida_ida:

inf_set_strlit_pref(*args) -> 'bool'
    inf_set_strlit_pref(_v, len=size_t(-1)) -> bool

Help on function inf_set_strlit_savecase in module ida_ida:

inf_set_strlit_savecase(*args) -> 'bool'
    inf_set_strlit_savecase(_v=True) -> bool

Help on function inf_set_strlit_serial_names in module ida_ida:

inf_set_strlit_serial_names(*args) -> 'bool'
    inf_set_strlit_serial_names(_v=True) -> bool

Help on function inf_set_strlit_sernum in module ida_ida:

inf_set_strlit_sernum(*args) -> 'bool'
    inf_set_strlit_sernum(_v) -> bool

Help on function inf_set_strlit_zeroes in module ida_ida:

inf_set_strlit_zeroes(*args) -> 'bool'
    inf_set_strlit_zeroes(_v) -> bool

Help on function inf_set_strtype in module ida_ida:

inf_set_strtype(*args) -> 'bool'
    inf_set_strtype(_v) -> bool

Help on function inf_set_test_mode in module ida_ida:

inf_set_test_mode(*args) -> 'bool'
    inf_set_test_mode(_v=True) -> bool

Help on function inf_set_trace_flow in module ida_ida:

inf_set_trace_flow(*args) -> 'bool'
    inf_set_trace_flow(_v=True) -> bool

Help on function inf_set_truncate_on_del in module ida_ida:

inf_set_truncate_on_del(*args) -> 'bool'
    inf_set_truncate_on_del(_v=True) -> bool

Help on function inf_set_type_xrefnum in module ida_ida:

inf_set_type_xrefnum(*args) -> 'bool'
    inf_set_type_xrefnum(_v) -> bool

Help on function inf_set_unicode_strlits in module ida_ida:

inf_set_unicode_strlits(*args) -> 'bool'
    inf_set_unicode_strlits(_v=True) -> bool

Help on function inf_set_use_allasm in module ida_ida:

inf_set_use_allasm(*args) -> 'bool'
    inf_set_use_allasm(_v=True) -> bool

Help on function inf_set_use_flirt in module ida_ida:

inf_set_use_flirt(*args) -> 'bool'
    inf_set_use_flirt(_v=True) -> bool

Help on function inf_set_use_gcc_layout in module ida_ida:

inf_set_use_gcc_layout(*args) -> 'bool'
    inf_set_use_gcc_layout(_v=True) -> bool

Help on function inf_set_version in module ida_ida:

inf_set_version(*args) -> 'bool'
    inf_set_version(_v) -> bool

Help on function inf_set_xrefflag in module ida_ida:

inf_set_xrefflag(*args) -> 'bool'
    inf_set_xrefflag(_v) -> bool

Help on function inf_set_xrefnum in module ida_ida:

inf_set_xrefnum(*args) -> 'bool'
    inf_set_xrefnum(_v) -> bool

Help on function inf_should_create_stkvars in module ida_ida:

inf_should_create_stkvars(*args) -> 'bool'
    inf_should_create_stkvars() -> bool

Help on function inf_should_trace_sp in module ida_ida:

inf_should_trace_sp(*args) -> 'bool'
    inf_should_trace_sp() -> bool

Help on function inf_show_all_comments in module ida_ida:

inf_show_all_comments(*args) -> 'bool'
    inf_show_all_comments() -> bool

Help on function inf_show_hidden_funcs in module ida_ida:

inf_show_hidden_funcs(*args) -> 'bool'
    inf_show_hidden_funcs() -> bool

Help on function inf_show_hidden_insns in module ida_ida:

inf_show_hidden_insns(*args) -> 'bool'
    inf_show_hidden_insns() -> bool

Help on function inf_show_hidden_segms in module ida_ida:

inf_show_hidden_segms(*args) -> 'bool'
    inf_show_hidden_segms() -> bool

Help on function inf_show_repeatables in module ida_ida:

inf_show_repeatables(*args) -> 'bool'
    inf_show_repeatables() -> bool

Help on function inf_show_src_linnum in module ida_ida:

inf_show_src_linnum(*args) -> 'bool'
    inf_show_src_linnum() -> bool

Help on function inf_show_xref_fncoff in module ida_ida:

inf_show_xref_fncoff(*args) -> 'bool'
    inf_show_xref_fncoff() -> bool

Help on function inf_show_xref_seg in module ida_ida:

inf_show_xref_seg(*args) -> 'bool'
    inf_show_xref_seg() -> bool

Help on function inf_show_xref_tmarks in module ida_ida:

inf_show_xref_tmarks(*args) -> 'bool'
    inf_show_xref_tmarks() -> bool

Help on function inf_show_xref_val in module ida_ida:

inf_show_xref_val(*args) -> 'bool'
    inf_show_xref_val() -> bool

Help on function inf_strlit_autocmt in module ida_ida:

inf_strlit_autocmt(*args) -> 'bool'
    inf_strlit_autocmt() -> bool

Help on function inf_strlit_name_bit in module ida_ida:

inf_strlit_name_bit(*args) -> 'bool'
    inf_strlit_name_bit() -> bool

Help on function inf_strlit_names in module ida_ida:

inf_strlit_names(*args) -> 'bool'
    inf_strlit_names() -> bool

Help on function inf_strlit_savecase in module ida_ida:

inf_strlit_savecase(*args) -> 'bool'
    inf_strlit_savecase() -> bool

Help on function inf_strlit_serial_names in module ida_ida:

inf_strlit_serial_names(*args) -> 'bool'
    inf_strlit_serial_names() -> bool

Help on function inf_test_mode in module ida_ida:

inf_test_mode(*args) -> 'bool'
    inf_test_mode() -> bool

Help on function inf_trace_flow in module ida_ida:

inf_trace_flow(*args) -> 'bool'
    inf_trace_flow() -> bool

Help on function inf_truncate_on_del in module ida_ida:

inf_truncate_on_del(*args) -> 'bool'
    inf_truncate_on_del() -> bool

Help on function inf_unicode_strlits in module ida_ida:

inf_unicode_strlits(*args) -> 'bool'
    inf_unicode_strlits() -> bool

Help on function inf_use_flirt in module ida_ida:

inf_use_flirt(*args) -> 'bool'
    inf_use_flirt() -> bool

Help on function is_filetype_like_binary in module ida_ida:

is_filetype_like_binary(*args) -> 'bool'
    is_filetype_like_binary(ft) -> bool
    
    
    Is unstructured input file?
    
    
    @param ft (C++: filetype_t)

Help on function <lambda> in module ida_ida:

<lambda> lambda *args

Help on function to_ea in module ida_ida:

to_ea(*args) -> 'ea_t'
    to_ea(reg_cs, reg_ip) -> ea_t
    
    
    Convert (sel,off) value to a linear address.
    
    
    @param reg_cs (C++: sel_t)
    @param reg_ip (C++: uval_t)

=== ida_ida EPYDOC INJECTIONS ===
ida_ida.ABI_8ALIGN4
"""
4 byte alignment for 8byte scalars (__int64/double) inside structures?
"""

ida_ida.ABI_BIGARG_ALIGN
"""
(e.g. __int64 argument should be 8byte aligned on some 32bit
platforms)

use natural type alignment for argument if the alignment exceeds
native word size
"""

ida_ida.ABI_GCC_LAYOUT
"""
use gcc layout for udts (used for mingw)
"""

ida_ida.ABI_HARD_FLOAT
"""
use the floating-point register set
"""

ida_ida.ABI_HUGEARG_ALIGN
"""
use natural type alignment for an argument even if its alignment
exceeds double native word size (the default is to use double word
max). e.g. if this bit is set, __int128 has 16-byte alignment
"""

ida_ida.ABI_MAP_STKARGS
"""
register arguments are mapped to stack area (and consume stack slots)
"""

ida_ida.ABI_PACK_STKARGS
"""
do not align stack arguments to stack slots
"""

ida_ida.ABI_SET_BY_USER
"""
compiler/abi were set by user flag and require SETCOMP_BY_USER flag to
be changed
"""

ida_ida.ABI_STACK_LDBL
"""
long double arguments are passed on stack
"""

ida_ida.ABI_STACK_VARARGS
"""
varargs are always passed on stack (even when there are free
registers)
"""

ida_ida.AF2_DOEH
"""
Handle EH information.
"""

ida_ida.AF2_DORTTI
"""
Handle RTTI information.
"""

ida_ida.AF2_MACRO
"""
Try to combine several instructions into a macro instruction
"""

ida_ida.AF_ANORET
"""
Perform 'no-return' analysis.
"""

ida_ida.AF_CHKUNI
"""
Check for unicode strings.
"""

ida_ida.AF_CODE
"""
Trace execution flow.
"""

ida_ida.AF_DATOFF
"""
Automatically convert data to offsets.
"""

ida_ida.AF_DOCODE
"""
Coagulate code segs at the final pass.
"""

ida_ida.AF_DODATA
"""
Coagulate data segs at the final pass.
"""

ida_ida.AF_DREFOFF
"""
Create offset if data xref to seg32 exists.
"""

ida_ida.AF_FINAL
"""
Final pass of analysis.
"""

ida_ida.AF_FIXUP
"""
Create offsets and segments using fixup info.
"""

ida_ida.AF_FLIRT
"""
Use flirt signatures.
"""

ida_ida.AF_FTAIL
"""
Create function tails.
"""

ida_ida.AF_HFLIRT
"""
Automatically hide library functions.
"""

ida_ida.AF_IMMOFF
"""
Convert 32bit instruction operand to offset.
"""

ida_ida.AF_JFUNC
"""
Rename jump functions as j_...
"""

ida_ida.AF_JUMPTBL
"""
Locate and create jump tables.
"""

ida_ida.AF_LVAR
"""
Create stack variables.
"""

ida_ida.AF_MARKCODE
"""
Mark typical code sequences as code.
"""

ida_ida.AF_MEMFUNC
"""
Try to guess member function types.
"""

ida_ida.AF_NULLSUB
"""
Rename empty functions as nullsub_...
"""

ida_ida.AF_PROC
"""
Create functions if call is present.
"""

ida_ida.AF_PROCPTR
"""
Create function if data xref data->code32 exists.
"""

ida_ida.AF_PURDAT
"""
Control flow to data segment is ignored.
"""

ida_ida.AF_REGARG
"""
Propagate register argument information.
"""

ida_ida.AF_SIGCMT
"""
Append a signature name comment for recognized anonymous library
functions.
"""

ida_ida.AF_SIGMLT
"""
Allow recognition of several copies of the same function.
"""

ida_ida.AF_STKARG
"""
Propagate stack argument information.
"""

ida_ida.AF_STRLIT
"""
Create string literal if data xref exists.
"""

ida_ida.AF_TRACE
"""
Trace stack pointer.
"""

ida_ida.AF_TRFUNC
"""
Truncate functions upon code deletion.
"""

ida_ida.AF_UNK
"""
Delete instructions with no xrefs.
"""

ida_ida.AF_USED
"""
Analyze and create all xrefs.
"""

ida_ida.AF_VERSP
"""
Perform full SP-analysis. (\\ph{verify_sp})
"""

ida_ida.DEMNAM_CMNT
"""
display demangled names as comments
"""

ida_ida.DEMNAM_FIRST
"""
override type info
"""

ida_ida.DEMNAM_GCC3
"""
assume gcc3 names (valid for gnu compiler)
"""

ida_ida.DEMNAM_MASK
"""
mask for name form
"""

ida_ida.DEMNAM_NAME
"""
display demangled names as regular names
"""

ida_ida.DEMNAM_NONE
"""
don't display demangled names
"""

ida_ida.IDAINFO_TAG_SIZE
"""
The database parameters. This structure is kept in the ida database.
It contains the essential parameters for the current program
"""

ida_ida.IDB_COMPRESSED
"""
compress & pack database components
"""

ida_ida.IDB_PACKED
"""
pack database components into .idb
"""

ida_ida.IDB_UNPACKED
"""
leave database components unpacked
"""

ida_ida.INFFL_ALLASM
"""
the target assembler

may use constructs not supported by
"""

ida_ida.INFFL_AUTO
"""
Autoanalysis is enabled?
"""

ida_ida.INFFL_CHKOPS
"""
check manual operands? (unused)
"""

ida_ida.INFFL_GRAPH_VIEW
"""
currently using graph options (\\dto{graph})
"""

ida_ida.INFFL_LOADIDC
"""
loading an idc file that contains database info
"""

ida_ida.INFFL_NMOPS
"""
allow non-matched operands? (unused)
"""

ida_ida.INFFL_NOUSER
"""
do not store user info in the database
"""

ida_ida.INFFL_READONLY
"""
(internal) temporary interdiction to modify the database
"""

ida_ida.LFLG_64BIT
"""
64-bit program?
"""

ida_ida.LFLG_COMPRESS
"""
compress the database?
"""

ida_ida.LFLG_DBG_NOPATH
"""
do not store input full path in debugger process options
"""

ida_ida.LFLG_FLAT_OFF32
"""
treat 'REF_OFF32' as 32-bit offset for 16bit segments (otherwise try
SEG16:OFF16)
"""

ida_ida.LFLG_IS_DLL
"""
Is dynamic library?
"""

ida_ida.LFLG_KERNMODE
"""
is kernel mode binary?
"""

ida_ida.LFLG_MSF
"""
Byte order: is MSB first?
"""

ida_ida.LFLG_PACK
"""
pack the database?
"""

ida_ida.LFLG_PC_FLAT
"""
32-bit program?
"""

ida_ida.LFLG_PC_FPP
"""
decode floating point processor instructions?
"""

ida_ida.LFLG_SNAPSHOT
"""
memory snapshot was taken?
"""

ida_ida.LFLG_WIDE_HBF
"""
(wide bytes: \\ph{dnbits} > 8)

Bit order of wide bytes: high byte first?
"""

ida_ida.LMT_EMPTY
"""
empty lines at the end of basic blocks
"""

ida_ida.LMT_THICK
"""
thick borders
"""

ida_ida.LMT_THIN
"""
thin borders
"""

ida_ida.LN_AUTO
"""
include autogenerated names
"""

ida_ida.LN_NORMAL
"""
include normal names
"""

ida_ida.LN_PUBLIC
"""
include public names
"""

ida_ida.LN_WEAK
"""
include weak names
"""

ida_ida.OFLG_GEN_ASSUME
"""
Generate 'assume' directives?
"""

ida_ida.OFLG_GEN_NULL
"""
Generate empty lines?
"""

ida_ida.OFLG_GEN_ORG
"""
Generate 'org' directives?
"""

ida_ida.OFLG_GEN_TRYBLKS
"""
Generate try/catch directives?
"""

ida_ida.OFLG_LZERO
"""
generate leading zeroes in numbers
"""

ida_ida.OFLG_PREF_SEG
"""
line prefixes with segment name?
"""

ida_ida.OFLG_SHOW_AUTO
"""
Display autoanalysis indicator?
"""

ida_ida.OFLG_SHOW_PREF
"""
Show line prefixes?
"""

ida_ida.OFLG_SHOW_VOID
"""
Display void marks?
"""

ida_ida.PREF_FNCOFF
"""
show function offsets?
"""

ida_ida.PREF_PFXTRUNC
"""
truncate instruction bytes if they would need more than 1 line
"""

ida_ida.PREF_SEGADR
"""
show segment addresses?
"""

ida_ida.PREF_STACK
"""
show stack pointer?
"""

ida_ida.SCF_ALLCMT
"""
comment all lines?
"""

ida_ida.SCF_LINNUM
"""
show source line numbers
"""

ida_ida.SCF_NOCMT
"""
no comments at all
"""

ida_ida.SCF_RPTCMT
"""
show repeatable comments?
"""

ida_ida.SCF_SHHID_FUNC
"""
show hidden functions
"""

ida_ida.SCF_SHHID_ITEM
"""
show hidden instructions
"""

ida_ida.SCF_SHHID_SEGM
"""
show hidden segments
"""

ida_ida.SCF_TESTMODE
"""
testida.idc is running
"""

ida_ida.STRF_AUTO
"""
names have 'autogenerated' bit?
"""

ida_ida.STRF_COMMENT
"""
generate auto comment for string references?
"""

ida_ida.STRF_GEN
"""
generate names?
"""

ida_ida.STRF_SAVECASE
"""
preserve case of strings for identifiers
"""

ida_ida.STRF_SERIAL
"""
generate serial names?
"""

ida_ida.STRF_UNICODE
"""
unicode strings are present?
"""

ida_ida.SW_SEGXRF
"""
show segments in xrefs?
"""

ida_ida.SW_XRFFNC
"""
show function offsets?
"""

ida_ida.SW_XRFMRK
"""
show xref type marks?
"""

ida_ida.SW_XRFVAL
"""
show xref values? (otherwise-"...")
"""

ida_ida.UA_MAXOP
"""
max number of operands allowed for an instruction
"""
=== ida_ida EPYDOC INJECTIONS END ===
Help on class CustomIDAMemo in module ida_kernwin:

class CustomIDAMemo(View_Hooks)
 |  Proxy of C++ View_Hooks class.
 |  
 |  Method resolution order:
 |      CustomIDAMemo
 |      View_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  __init__(self)
 |      __init__(self, _flags=0) -> View_Hooks
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |      view_activated(self, view)
 |  
 |  view_click(self, view, ve)
 |      view_click(self, view, event)
 |  
 |  view_close(self, view, *args)
 |      view_close(self, view)
 |  
 |  view_curpos(self, view, *args)
 |      view_curpos(self, view)
 |  
 |  view_dblclick(self, view, ve)
 |      view_dblclick(self, view, event)
 |  
 |  view_deactivated(self, view)
 |      view_deactivated(self, view)
 |  
 |  view_keydown(self, view, key, state)
 |      view_keydown(self, view, key, state)
 |  
 |  view_loc_changed(self, view, now, was)
 |      view_loc_changed(self, view, now, was)
 |  
 |  view_mouse_moved(self, view, ve)
 |      view_mouse_moved(self, view, event)
 |  
 |  view_mouse_over(self, view, ve)
 |      view_mouse_over(self, view, event)
 |  
 |  view_switched(self, view, rt)
 |      view_switched(self, view, rt)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_View_Hooks(...)
 |      delete_View_Hooks(self)
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args) -> 'void'
 |      view_created(self, view)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on __IDAPython_Completion_Util in module ida_idaapi object:

class __IDAPython_Completion_Util(builtins.object)
 |  Internal utility class for auto-completion support
 |  
 |  Methods defined here:
 |  
 |  __call__(self, line, x)
 |      Call self as a function.
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  debug(self, *args)
 |  
 |  dir_namespace(self, m, prefix)
 |  
 |  get_candidates(self, qname, line, match_syntax_char)
 |  
 |  maybe_extend_syntactically(self, ns, name, line, syntax_char)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  QNAME_PAT = re.compile('([a-zA-Z_]([a-zA-Z0-9_\\.]*)?)')

Help on function IDAPython_ExecScript in module ida_idaapi:

IDAPython_ExecScript(script, g, print_error=True)
    Run the specified script.
    It also addresses http://code.google.com/p/idapython/issues/detail?id=42
    
    This function is used by the low-level plugin code.

Help on function IDAPython_ExecSystem in module ida_idaapi:

IDAPython_ExecSystem(cmd)
    Executes a command with popen().

Help on function IDAPython_FormatExc in module ida_idaapi:

IDAPython_FormatExc(etype, value=None, tb=None, limit=None)
    This function is used to format an exception given the
    values returned by a PyErr_Fetch()

Help on function IDAPython_LoadProcMod in module ida_idaapi:

IDAPython_LoadProcMod(script, g, print_error=True)
    Load processor module.

Help on function IDAPython_UnLoadProcMod in module ida_idaapi:

IDAPython_UnLoadProcMod(script, g, print_error=True)
    Unload processor module.

Help on class IDAPython_displayhook in module ida_idaapi:

class IDAPython_displayhook(builtins.object)
 |  # ------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  _print_hex(self, x)
 |  
 |  displayhook(self, item)
 |  
 |  format_item(self, num_printer, storage, item)
 |  
 |  format_seq(self, num_printer, storage, item, opn, cls)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class PyIdc_cvt_int64__ in module ida_idaapi:

class PyIdc_cvt_int64__(pyidc_cvt_helper__)
 |  Helper class for explicitly representing VT_INT64 values
 |  
 |  Method resolution order:
 |      PyIdc_cvt_int64__
 |      pyidc_cvt_helper__
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  _PyIdc_cvt_int64____op = __op(self, op_n, other, rev=False)
 |  
 |  __add__(self, other)
 |  
 |  __div__(self, other)
 |  
 |  __init__(self, v)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __mul__(self, other)
 |  
 |  __radd__(self, other)
 |  
 |  __rdiv__(self, other)
 |  
 |  __rmul__(self, other)
 |  
 |  __rsub__(self, other)
 |  
 |  __sub__(self, other)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  _PyIdc_cvt_int64____op_table = {0: <function PyIdc_cvt_int64__.<lambda...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from pyidc_cvt_helper__:
 |  
 |  _pyidc_cvt_helper____get_value = __get_value(self)
 |  
 |  _pyidc_cvt_helper____set_value = __set_value(self, v)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pyidc_cvt_helper__:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  value

Help on class PyIdc_cvt_refclass__ in module ida_idaapi:

class PyIdc_cvt_refclass__(pyidc_cvt_helper__)
 |  Helper class for representing references to immutable objects
 |  
 |  Method resolution order:
 |      PyIdc_cvt_refclass__
 |      pyidc_cvt_helper__
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, v)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  cstr(self)
 |      Returns the string as a C string (up to the zero termination)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from pyidc_cvt_helper__:
 |  
 |  _pyidc_cvt_helper____get_value = __get_value(self)
 |  
 |  _pyidc_cvt_helper____set_value = __set_value(self, v)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pyidc_cvt_helper__:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  value

Help on __BC695 in module ida_idaapi object:

class __BC695(builtins.object)
 |  # ----------------------------------- helpers for bw-compat w/ 6.95 API
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  dummy(self, *args)
 |  
 |  false_p(self, *args)
 |  
 |  identity(self, arg)
 |  
 |  replace_fun(self, new)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on IDAPython_displayhook in module ida_idaapi object:

class IDAPython_displayhook(builtins.object)
 |  # ------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  _print_hex(self, x)
 |  
 |  displayhook(self, item)
 |  
 |  format_item(self, num_printer, storage, item)
 |  
 |  format_seq(self, num_printer, storage, item, opn, cls)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class __BC695 in module ida_idaapi:

class __BC695(builtins.object)
 |  # ----------------------------------- helpers for bw-compat w/ 6.95 API
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  dummy(self, *args)
 |  
 |  false_p(self, *args)
 |  
 |  identity(self, arg)
 |  
 |  replace_fun(self, new)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class __IDAPython_Completion_Util in module ida_idaapi:

class __IDAPython_Completion_Util(builtins.object)
 |  Internal utility class for auto-completion support
 |  
 |  Methods defined here:
 |  
 |  __call__(self, line, x)
 |      Call self as a function.
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  debug(self, *args)
 |  
 |  dir_namespace(self, m, prefix)
 |  
 |  get_candidates(self, qname, line, match_syntax_char)
 |  
 |  maybe_extend_syntactically(self, ns, name, line, syntax_char)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  QNAME_PAT = re.compile('([a-zA-Z_]([a-zA-Z0-9_\\.]*)?)')

Help on function __install_excepthook in module ida_idaapi:

__install_excepthook()
    # Since version 5.5, PyQt5 doesn't simply print the PyQt exceptions by default
    # anymore: https://github.com/baoboa/pyqt5/commit/1e1d8a3ba677ef3e47b916b8a5b9c281d0f8e4b5#diff-848704a82f6a6e3a13112145ce32ac69L63
    # The default behavior now is that qFatal() is called, causing the application
    # to abort().
    # We do not want that to happen in IDA, and simply having a sys.excepthook
    # that is different from sys.__excepthook__ is enough for PyQt5 to return
    # to the previous behavior

Help on function _bounded_getitem_iterator in module ida_idaapi:

_bounded_getitem_iterator(self)
    Helper function, to be set as __iter__ method for qvector-, or array-based classes.

Help on function _listify_types in module ida_idaapi:

_listify_types(*classes)

Help on function _qvector_back in module ida_idaapi:

_qvector_back(self)
    # -----------------------------------------------------------------------

Help on function _qvector_front in module ida_idaapi:

_qvector_front(self)
    # -----------------------------------------------------------------------

Help on function _replace_module_function in module ida_idaapi:

_replace_module_function(replacement)

Help on function _utf8_native in module ida_idaapi:

_utf8_native(utf8)

Help on function as_UTF16 in module ida_idaapi:

as_UTF16(s)
    Convenience function to convert a string into appropriate unicode format

Help on function as_cstr in module ida_idaapi:

as_cstr(val)
    Returns a C str from the passed value. The passed value can be of type refclass (returned by a call to buffer() or byref())
    It scans for the first   and returns the string value up to that point.

Help on function as_int32 in module ida_idaapi:

as_int32(v)
    Returns a number as a signed int32 number

Help on function as_signed in module ida_idaapi:

as_signed(v, nbits=32)
    Returns a number as signed. The number of bits are specified by the user.
    The MSB holds the sign.

Help on function as_uint32 in module ida_idaapi:

as_uint32(v)
    Returns a number as an unsigned int32 number

Help on function copy_bits in module ida_idaapi:

copy_bits(v, s, e=-1)
    Copy bits from a value
    @param v: the value
    @param s: starting bit (0-based)
    @param e: ending bit

Help on function disable_script_timeout in module ida_idaapi:

disable_script_timeout(*args) -> 'void'
    disable_script_timeout()
    
    
    Disables the script timeout and hides the script wait box.
    Calling L{set_script_timeout} will not have any effects until the script is compiled and executed again
    
    @return: None

Help on function enable_extlang_python in module ida_idaapi:

enable_extlang_python(*args) -> 'void'
    enable_extlang_python(enable)
    
    
    Enables or disables Python extlang.
    When enabled, all expressions will be evaluated by Python.
    @param enable: Set to True to enable, False otherwise

Help on function enable_python_cli in module ida_idaapi:

enable_python_cli(*args) -> 'void'
    enable_python_cli(enable)

Help on function format_basestring in module ida_idaapi:

format_basestring(*args) -> 'PyObject *'
    format_basestring(_in) -> PyObject *

Help on function get_inf_structure in module ida_idaapi:

get_inf_structure(*args) -> 'idainfo *'
    get_inf_structure() -> idainfo
    
    
    Returns the global variable 'inf' (an instance of idainfo structure, see ida.hpp)

Help on class loader_input_t in module ida_idaapi:

class loader_input_t(builtins.object)
 |  Proxy of C++ loader_input_t class.
 |  
 |  
 |  A helper class to work with linput_t related functions.
 |  This class is also used by file loaders scripts.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, pycapsule=None) -> loader_input_t
 |      
 |      
 |      Closes the file
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_loader_input_t(...)
 |      delete_loader_input_t(self)
 |  
 |  close(self, *args) -> 'void'
 |      close(self)
 |  
 |  file2base(self, *args) -> 'int'
 |      file2base(self, pos, ea1, ea2, patchable) -> int
 |      
 |      
 |      Load portion of file into the database
 |      This function will include (ea1..ea2) into the addressing space of the
 |      program (make it enabled)
 |      @param li: pointer ot input source
 |      @param pos: position in the file
 |      @param (ea1..ea2): range of destination linear addresses
 |      @param patchable: should the kernel remember correspondance of
 |                        file offsets to linear addresses.
 |      @return: 1-ok,0-read error, a warning is displayed
 |  
 |  filename(self, *args) -> 'PyObject *'
 |      filename(self) -> PyObject *
 |  
 |  get_byte(self, *args) -> 'PyObject *'
 |      get_byte(self) -> PyObject *
 |      
 |      
 |      Reads a single byte from the file. Returns None if EOF or the read byte
 |  
 |  get_linput(self, *args) -> 'linput_t *'
 |      get_linput(self) -> linput_t *
 |  
 |  gets(self, *args) -> 'PyObject *'
 |      gets(self, len) -> PyObject *
 |      
 |      
 |      Reads a line from the input file. Returns the read line or None
 |  
 |  getz(self, *args) -> 'PyObject *'
 |      getz(self, sz, fpos=-1) -> PyObject *
 |      
 |      
 |      Returns a zero terminated string at the given position
 |      @param sz: maximum size of the string
 |      @param fpos: if != -1 then seek will be performed before reading
 |      @return: The string or None on failure.
 |  
 |  open(self, *args) -> 'bool'
 |      open(self, filename, remote=False) -> bool
 |      
 |      
 |      Opens a file (or a remote file)
 |      @return: Boolean
 |  
 |  open_memory(self, *args) -> 'bool'
 |      open_memory(self, start, size=0) -> bool
 |      
 |      
 |      Create a linput for process memory (By internally calling idaapi.create_memory_linput())
 |      This linput will use dbg->read_memory() to read data
 |      @param start: starting address of the input
 |      @param size: size of the memory range to represent as linput
 |                  if unknown, may be passed as 0
 |  
 |  opened(self, *args) -> 'bool'
 |      opened(self) -> bool
 |      
 |      
 |      Checks if the file is opened or not
 |  
 |  read(self, *args) -> 'PyObject *'
 |      read(self, size) -> PyObject *
 |      
 |      
 |      Reads from the file. Returns the buffer or None
 |  
 |  readbytes(self, *args) -> 'PyObject *'
 |      readbytes(self, size, big_endian) -> PyObject *
 |      
 |      
 |      Similar to read() but it respect the endianness
 |  
 |  seek(self, *args) -> 'int64'
 |      seek(self, pos, whence=SEEK_SET) -> int64
 |      
 |      
 |      Set input source position
 |      @return: the new position (not 0 as fseek!)
 |  
 |  set_linput(self, *args) -> 'void'
 |      set_linput(self, linput)
 |      
 |      
 |      Links the current loader_input_t instance to a linput_t instance
 |  
 |  size(self, *args) -> 'int64'
 |      size(self) -> int64
 |  
 |  tell(self, *args) -> 'int64'
 |      tell(self) -> int64
 |      
 |      
 |      Returns the current position
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  from_capsule(*args) -> 'loader_input_t *'
 |      from_capsule(pycapsule) -> loader_input_t
 |  
 |  from_fp(*args) -> 'loader_input_t *'
 |      from_fp(fp) -> loader_input_t
 |      
 |      
 |      A static method to construct an instance from a FILE*
 |  
 |  from_linput(*args) -> 'loader_input_t *'
 |      from_linput(linput) -> loader_input_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __idc_cvt_id__
 |      loader_input_t___idc_cvt_id___get(self) -> int
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function loader_input_t_from_capsule in module ida_idaapi:

loader_input_t_from_capsule(*args) -> 'loader_input_t *'
    loader_input_t_from_capsule(pycapsule) -> loader_input_t

Help on function loader_input_t_from_fp in module ida_idaapi:

loader_input_t_from_fp(*args) -> 'loader_input_t *'
    loader_input_t_from_fp(fp) -> loader_input_t

Help on function loader_input_t_from_linput in module ida_idaapi:

loader_input_t_from_linput(*args) -> 'loader_input_t *'
    loader_input_t_from_linput(linput) -> loader_input_t

Help on function notify_when in module ida_idaapi:

notify_when(when, callback)
    Register a callback that will be called when an event happens.
    @param when: one of NW_XXXX constants
    @param callback: This callback prototype varies depending on the 'when' parameter:
                     The general callback format:
                         def notify_when_callback(nw_code)
                     In the case of NW_OPENIDB:
                         def notify_when_callback(nw_code, is_old_database)
    @return: Boolean

Help on class object_t in module ida_idaapi:

class object_t(builtins.object)
 |  Helper class used to initialize empty objects
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, idx)
 |      Allow access to object attributes by index (like dictionaries)
 |  
 |  __init__(self, **kwds)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function parse_command_line3 in module ida_idaapi:

parse_command_line3(*args) -> 'PyObject *'
    parse_command_line3(cmdline) -> PyObject *

Help on class plugin_t in module ida_idaapi:

class plugin_t(pyidc_opaque_object_t)
 |  Base class for all scripted plugins.
 |  
 |  Method resolution order:
 |      plugin_t
 |      pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Data descriptors inherited from pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on class py_clinked_object_t in module ida_idaapi:

class py_clinked_object_t(pyidc_opaque_object_t)
 |  This is a utility and base class for C linked objects
 |  
 |  Method resolution order:
 |      py_clinked_object_t
 |      pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __del__(self)
 |      Delete the link upon object destruction (only if not static)
 |  
 |  __init__(self, lnk=None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  _create_clink(self)
 |      Overwrite me.
 |      Creates a new clink
 |      @return: PyCapsule representing the C link
 |  
 |  _del_clink(self, lnk)
 |      Overwrite me.
 |      This method deletes the link
 |  
 |  _free(self)
 |      Explicitly delete the link (only if not static)
 |  
 |  _get_clink_ptr(self)
 |      Overwrite me.
 |      Returns the C link pointer as a 64bit number
 |  
 |  assign(self, other)
 |      Overwrite me.
 |      This method allows you to assign an instance contents to anothers
 |      @return: Boolean
 |  
 |  copy(self)
 |      Returns a new copy of this class
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  clink
 |  
 |  clink_ptr
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on function pycim_get_widget in module ida_idaapi:

pycim_get_widget(*args) -> 'TWidget *'
    pycim_get_widget(_self) -> TWidget *

Help on function pycim_view_close in module ida_idaapi:

pycim_view_close(*args) -> 'void'
    pycim_view_close(_self)

Help on function pygc_create_groups in module ida_idaapi:

pygc_create_groups(*args) -> 'PyObject *'
    pygc_create_groups(_self, groups_infos) -> PyObject *

Help on function pygc_delete_groups in module ida_idaapi:

pygc_delete_groups(*args) -> 'PyObject *'
    pygc_delete_groups(_self, groups, new_current) -> PyObject *

Help on function pygc_refresh in module ida_idaapi:

pygc_refresh(*args) -> 'void'
    pygc_refresh(_self)

Help on function pygc_set_groups_visibility in module ida_idaapi:

pygc_set_groups_visibility(*args) -> 'PyObject *'
    pygc_set_groups_visibility(_self, groups, expand, new_current) -> PyObject *

Help on class pyidc_cvt_helper__ in module ida_idaapi:

class pyidc_cvt_helper__(builtins.object)
 |  This is a special helper object that helps detect which kind
 |  of object is this python object wrapping and how to convert it
 |  back and from IDC.
 |  This object is characterized by its special attribute and its value
 |  
 |  Methods defined here:
 |  
 |  __init__(self, cvt_id, value)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  _pyidc_cvt_helper____get_value = __get_value(self)
 |  
 |  _pyidc_cvt_helper____set_value = __set_value(self, v)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  value

Help on class pyidc_opaque_object_t in module ida_idaapi:

class pyidc_opaque_object_t(builtins.object)
 |  This is the base class for all Python<->IDC opaque objects
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __idc_cvt_id__ = 2

Help on function replfun in module ida_idaapi:

replfun(func)

Help on function require in module ida_idaapi:

require(modulename, package=None)
    Load, or reload a module.
    
    When under heavy development, a user's tool might consist of multiple
    modules. If those are imported using the standard 'import' mechanism,
    there is no guarantee that the Python implementation will re-read
    and re-evaluate the module's Python code. In fact, it usually doesn't.
    What should be done instead is 'reload()'-ing that module.
    
    This is a simple helper function that will do just that: In case the
    module doesn't exist, it 'import's it, and if it does exist,
    'reload()'s it.
    
    The importing module (i.e., the module calling require()) will have
    the loaded module bound to its globals(), under the name 'modulename'.
    (If require() is called from the command line, the importing module
    will be '__main__'.)
    
    For more information, see: <http://www.hexblog.com/?p=749>.

Help on function set_script_timeout in module ida_idaapi:

set_script_timeout(*args) -> 'int'
    set_script_timeout(timeout) -> int
    
    
    Changes the script timeout value. The script wait box dialog will be hidden and shown again when the timeout elapses.
    See also L{disable_script_timeout}.
    
    @param timeout: This value is in seconds.
                    If this value is set to zero then the script will never timeout.
    @return: Returns the old timeout value

Help on function struct_unpack in module ida_idaapi:

struct_unpack(buffer, signed=False, offs=0)
    Unpack a buffer given its length and offset using struct.unpack_from().
    This function will know how to unpack the given buffer by using the lookup table '__struct_unpack_table'
    If the buffer is of unknown length then None is returned. Otherwise the unpacked value is returned.

Help on function get_mark_comment in module ida_idc:

get_mark_comment(*args) -> 'PyObject *'
    get_mark_comment(slot) -> PyObject *

Help on function get_marked_pos in module ida_idc:

get_marked_pos(*args) -> 'ea_t'
    get_marked_pos(slot) -> ea_t

Help on function mark_position in module ida_idc:

mark_position(*args) -> 'void'
    mark_position(ea, lnnum, x, y, slot, comment)

Help on Appcall__ in module ida_idd object:

class Appcall__(builtins.object)
 |  # -----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  _Appcall____get_consts = __get_consts(self)
 |  
 |  __getattr__(self, name_or_ea)
 |      Allows you to call functions as if they were member functions (by returning a callable object)
 |  
 |  __getitem__(self, idx)
 |      Use self[func_name] syntax if the function name contains invalid characters for an attribute name
 |      See __getattr___
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  UTF16(s)
 |  
 |  _Appcall____name_or_ea = __name_or_ea(name_or_ea)
 |      Function that accepts a name or an ea and checks if the address is enabled.
 |      If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
 |      @return:
 |          - Returns the resolved EA or
 |          - Raises an exception if the address is not enabled
 |  
 |  _Appcall____typedecl_or_tinfo = __typedecl_or_tinfo(typedecl_or_tinfo, flags=None)
 |      Function that accepts a tinfo_t object or type declaration as a string
 |      If a type declaration is passed then ida_typeinf.parse_decl() is applied to prepare tinfo_t object
 |      @return:
 |          - Returns the tinfo_t object
 |          - Raises an exception if the declaration cannot be parsed
 |  
 |  array(type_name)
 |      Defines an array type. Later you need to pack() / unpack()
 |  
 |  buffer(str=None, size=0, fill='\x00')
 |      Creates a string buffer. The returned value (r) will be a byref object.
 |      Use r.value to get the contents and r.size to get the buffer's size
 |  
 |  byref(val)
 |      Method to create references to immutable objects
 |      Currently we support references to int/strings
 |      Objects need not be passed by reference (this will be done automatically)
 |  
 |  cleanup_appcall(tid=0)
 |      Equivalent to IDC's CleanupAppcall()
 |  
 |  cstr(val)
 |  
 |  get_appcall_options()
 |      Return the global Appcall options
 |  
 |  int64(v)
 |      Whenever a 64bit number is needed use this method to construct an object
 |  
 |  obj(**kwds)
 |      Returns an empty object or objects with attributes as passed via its keywords arguments
 |  
 |  proto(name_or_ea, proto_or_tinfo, flags=None)
 |      Allows you to instantiate an appcall (callable object) with the desired prototype
 |      @param name_or_ea: The name of the function (will be resolved with LocByName())
 |      @param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
 |      @return:
 |          - On failure it raises an exception if the prototype could not be parsed
 |            or the address is not resolvable
 |          - Returns a callbable Appcall instance with the given prototypes and flags
 |  
 |  set_appcall_options(opt)
 |      Method to change the Appcall options globally (not per Appcall)
 |  
 |  typedobj(typedecl_or_tinfo, ea=None)
 |      Returns an appcall object for a type (can be given as tinfo_t object or
 |      as a string declaration)
 |      One can then use retrieve() member method
 |      @param ea: Optional parameter that later can be used to retrieve the type
 |      @return: Appcall object or raises ValueError exception
 |  
 |  unicode = UTF16(s)
 |  
 |  valueof(name, default=0)
 |      Returns the numeric value of a given name string.
 |      If the name could not be resolved then the default value will be returned
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  Consts
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  APPCALL_DEBEV = 2
 |  
 |  APPCALL_MANUAL = 1
 |  
 |  APPCALL_TIMEOUT = 4
 |  
 |  __name__ = 'Appcall__'

Help on class Appcall__ in module ida_idd:

class Appcall__(builtins.object)
 |  # -----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  _Appcall____get_consts = __get_consts(self)
 |  
 |  __getattr__(self, name_or_ea)
 |      Allows you to call functions as if they were member functions (by returning a callable object)
 |  
 |  __getitem__(self, idx)
 |      Use self[func_name] syntax if the function name contains invalid characters for an attribute name
 |      See __getattr___
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  UTF16(s)
 |  
 |  _Appcall____name_or_ea = __name_or_ea(name_or_ea)
 |      Function that accepts a name or an ea and checks if the address is enabled.
 |      If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
 |      @return:
 |          - Returns the resolved EA or
 |          - Raises an exception if the address is not enabled
 |  
 |  _Appcall____typedecl_or_tinfo = __typedecl_or_tinfo(typedecl_or_tinfo, flags=None)
 |      Function that accepts a tinfo_t object or type declaration as a string
 |      If a type declaration is passed then ida_typeinf.parse_decl() is applied to prepare tinfo_t object
 |      @return:
 |          - Returns the tinfo_t object
 |          - Raises an exception if the declaration cannot be parsed
 |  
 |  array(type_name)
 |      Defines an array type. Later you need to pack() / unpack()
 |  
 |  buffer(str=None, size=0, fill='\x00')
 |      Creates a string buffer. The returned value (r) will be a byref object.
 |      Use r.value to get the contents and r.size to get the buffer's size
 |  
 |  byref(val)
 |      Method to create references to immutable objects
 |      Currently we support references to int/strings
 |      Objects need not be passed by reference (this will be done automatically)
 |  
 |  cleanup_appcall(tid=0)
 |      Equivalent to IDC's CleanupAppcall()
 |  
 |  cstr(val)
 |  
 |  get_appcall_options()
 |      Return the global Appcall options
 |  
 |  int64(v)
 |      Whenever a 64bit number is needed use this method to construct an object
 |  
 |  obj(**kwds)
 |      Returns an empty object or objects with attributes as passed via its keywords arguments
 |  
 |  proto(name_or_ea, proto_or_tinfo, flags=None)
 |      Allows you to instantiate an appcall (callable object) with the desired prototype
 |      @param name_or_ea: The name of the function (will be resolved with LocByName())
 |      @param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
 |      @return:
 |          - On failure it raises an exception if the prototype could not be parsed
 |            or the address is not resolvable
 |          - Returns a callbable Appcall instance with the given prototypes and flags
 |  
 |  set_appcall_options(opt)
 |      Method to change the Appcall options globally (not per Appcall)
 |  
 |  typedobj(typedecl_or_tinfo, ea=None)
 |      Returns an appcall object for a type (can be given as tinfo_t object or
 |      as a string declaration)
 |      One can then use retrieve() member method
 |      @param ea: Optional parameter that later can be used to retrieve the type
 |      @return: Appcall object or raises ValueError exception
 |  
 |  unicode = UTF16(s)
 |  
 |  valueof(name, default=0)
 |      Returns the numeric value of a given name string.
 |      If the name could not be resolved then the default value will be returned
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  Consts
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  APPCALL_DEBEV = 2
 |  
 |  APPCALL_MANUAL = 1
 |  
 |  APPCALL_TIMEOUT = 4
 |  
 |  __name__ = 'Appcall__'

Help on class Appcall_array__ in module ida_idd:

class Appcall_array__(builtins.object)
 |  This class is used with Appcall.array() method
 |  
 |  Methods defined here:
 |  
 |  __init__(self, tp)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  pack(self, L)
 |      Packs a list or tuple into a byref buffer
 |  
 |  try_to_convert_to_list(self, obj)
 |      Is this object a list? We check for the existance of attribute zero and attribute self.size-1
 |  
 |  unpack(self, buf, as_list=True)
 |      Unpacks an array back into a list or an object
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class Appcall_callable__ in module ida_idd:

class Appcall_callable__(builtins.object)
 |  Helper class to issue appcalls using a natural syntax:
 |    appcall.FunctionNameInTheDatabase(arguments, ....)
 |  or
 |    appcall["Function@8"](arguments, ...)
 |  or
 |    f8 = appcall["Function@8"]
 |    f8(arg1, arg2, ...)
 |  or
 |    o = appcall.obj()
 |    i = byref(5)
 |    appcall.funcname(arg1, i, "hello", o)
 |  
 |  Methods defined here:
 |  
 |  _Appcall_callable____get_ea = __get_ea(self)
 |  
 |  _Appcall_callable____get_fields = __get_fields(self)
 |  
 |  _Appcall_callable____get_options = __get_options(self)
 |  
 |  _Appcall_callable____get_size = __get_size(self)
 |  
 |  _Appcall_callable____get_tif = __get_tif(self)
 |  
 |  _Appcall_callable____get_timeout = __get_timeout(self)
 |  
 |  _Appcall_callable____get_type = __get_type(self)
 |  
 |  _Appcall_callable____set_ea = __set_ea(self, val)
 |  
 |  _Appcall_callable____set_options = __set_options(self, v)
 |  
 |  _Appcall_callable____set_timeout = __set_timeout(self, v)
 |  
 |  __call__(self, *args)
 |      Make object callable. We redirect execution to idaapi.appcall()
 |  
 |  __init__(self, ea, tinfo_or_typestr=None, fields=None)
 |      Initializes an appcall with a given function ea
 |  
 |  retrieve(self, src=None, flags=0)
 |      Unpacks a typed object from the database if an ea is given or from a string if a string was passed
 |      @param src: the address of the object or a string
 |      @return: Returns a tuple of boolean and object or error number (Bool, Error | Object).
 |  
 |  store(self, obj, dest_ea=None, base_ea=0, flags=0)
 |      Packs an object into a given ea if provided or into a string if no address was passed.
 |      @param obj: The object to pack
 |      @param dest_ea: If packing to idb this will be the store location
 |      @param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers
 |      
 |      @return:
 |          - If packing to a string then a Tuple(Boolean, packed_string or error code)
 |          - If packing to the database then a return code is returned (0 is success)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |  
 |  fields
 |  
 |  options
 |  
 |  size
 |  
 |  tif
 |  
 |  timeout
 |  
 |  type

Help on class Appcall_consts__ in module ida_idd:

class Appcall_consts__(builtins.object)
 |  Helper class used by Appcall.Consts attribute
 |  It is used to retrieve constants via attribute access
 |  
 |  Methods defined here:
 |  
 |  __getattr__(self, attr)
 |  
 |  __init__(self, default=None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function appcall in module ida_idd:

appcall(*args) -> 'PyObject *'
    appcall(func_ea, tid, _type_or_none, _fields, arg_list) -> PyObject *

Help on class bptaddr_t in module ida_idd:

class bptaddr_t(builtins.object)
 |  Proxy of C++ bptaddr_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bptaddr_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bptaddr_t(...)
 |      delete_bptaddr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hea
 |      bptaddr_t_hea_get(self) -> ea_t
 |  
 |  kea
 |      bptaddr_t_kea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag

Help on class call_stack_info_t in module ida_idd:

class call_stack_info_t(builtins.object)
 |  Proxy of C++ call_stack_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> call_stack_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_call_stack_info_t(...)
 |      delete_call_stack_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  callea
 |      call_stack_info_t_callea_get(self) -> ea_t
 |  
 |  fp
 |      call_stack_info_t_fp_get(self) -> ea_t
 |  
 |  funcea
 |      call_stack_info_t_funcea_get(self) -> ea_t
 |  
 |  funcok
 |      call_stack_info_t_funcok_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class call_stack_t in module ida_idd:

class call_stack_t(builtins.object)
 |  Proxy of C++ qvector< call_stack_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'call_stack_info_t const &'
 |      __getitem__(self, i) -> call_stack_info_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> call_stack_t
 |      __init__(self, x) -> call_stack_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_call_stack_t(...)
 |      delete_call_stack_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'call_stack_info_t const &'
 |      at(self, _idx) -> call_stack_info_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< call_stack_info_t >::const_iterator'
 |      begin(self) -> call_stack_info_t
 |      begin(self) -> call_stack_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< call_stack_info_t >::const_iterator'
 |      end(self) -> call_stack_info_t
 |      end(self) -> call_stack_info_t
 |  
 |  erase(self, *args) -> 'qvector< call_stack_info_t >::iterator'
 |      erase(self, it) -> call_stack_info_t
 |      erase(self, first, last) -> call_stack_info_t
 |  
 |  extract(self, *args) -> 'call_stack_info_t *'
 |      extract(self) -> call_stack_info_t
 |  
 |  find(self, *args) -> 'qvector< call_stack_info_t >::const_iterator'
 |      find(self, x) -> call_stack_info_t
 |      find(self, x) -> call_stack_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=call_stack_info_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< call_stack_info_t >::iterator'
 |      insert(self, it, x) -> call_stack_info_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'call_stack_info_t &'
 |      push_back(self, x)
 |      push_back(self) -> call_stack_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function can_exc_continue in module ida_idd:

can_exc_continue(*args) -> 'bool'
    can_exc_continue(ev) -> bool

Help on function cleanup_appcall in module ida_idd:

cleanup_appcall(*args) -> 'error_t'
    cleanup_appcall(tid) -> error_t
    
    
    Cleanup after manual appcall.
    
    @param tid: thread to use.  NO_THREAD  means to use the current thread
                The application state is restored as it was before calling
                the last appcall(). Nested appcalls are supported. (C++:
                thid_t)
    @return: eOk  if successful, otherwise an error code

Help on function dbg_appcall in module ida_idd:

dbg_appcall(*args) -> 'error_t'
    dbg_appcall(retval, func_ea, tid, ptif, argv, argnum) -> error_t
    
    
    Call a function from the debugged application.
    
    @param retval (C++: idc_value_t  *)
    @param func_ea: address to call (C++: ea_t)
    @param tid: thread to use.  NO_THREAD  means to use the current thread
                (C++: thid_t)
    @param ptif: pointer to type of the function to call (C++: const
                 tinfo_t  *)
    @param argv: array of arguments (C++: idc_value_t  *)
    @param argnum: number of actual arguments (C++: size_t)
    @return: eOk  if successful, otherwise an error code

Help on built-in function dbg_can_query in module _ida_dbg:

dbg_can_query(...)
    dbg_can_query() -> bool

Help on function dbg_get_memory_info in module ida_idd:

dbg_get_memory_info(*args) -> 'PyObject *'
    dbg_get_memory_info() -> PyObject *
    
    
    This function returns the memory configuration of a debugged process.
    @return:
        None if no debugger is active
        tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm)

Help on function dbg_get_name in module ida_idd:

dbg_get_name(*args) -> 'PyObject *'
    dbg_get_name() -> PyObject *
    
    
    This function returns the current debugger's name.
    @return: Debugger name or None if no debugger is active

Help on function dbg_get_registers in module ida_idd:

dbg_get_registers(*args) -> 'PyObject *'
    dbg_get_registers() -> PyObject *
    
    
    This function returns the register definition from the currently loaded debugger.
    Basically, it returns an array of structure similar to to idd.hpp / register_info_t
    @return:
        None if no debugger is loaded
        tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
        The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)

Help on function dbg_get_thread_sreg_base in module ida_idd:

dbg_get_thread_sreg_base(*args) -> 'PyObject *'
    dbg_get_thread_sreg_base(tid, sreg_value) -> PyObject *
    
    
    Returns the segment register base value
    @param tid: thread id
    @param sreg_value: segment register (selector) value
    @return:
        - The base as an 'ea'
        - Or None on failure

Help on function dbg_read_memory in module ida_idd:

dbg_read_memory(*args) -> 'PyObject *'
    dbg_read_memory(ea, sz) -> PyObject *
    
    
    Reads from the debugee's memory at the specified ea
    @return:
        - The read buffer (as a string)
        - Or None on failure

Help on function dbg_write_memory in module ida_idd:

dbg_write_memory(*args) -> 'PyObject *'
    dbg_write_memory(ea, buf) -> PyObject *
    
    
    Writes a buffer to the debugee's memory
    @return: Boolean

Help on class debapp_attrs_t in module ida_idd:

class debapp_attrs_t(builtins.object)
 |  Proxy of C++ debapp_attrs_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> debapp_attrs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_debapp_attrs_t(...)
 |      delete_debapp_attrs_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  addrsize
 |      debapp_attrs_t_addrsize_get(self) -> int
 |  
 |  cbsize
 |      debapp_attrs_t_cbsize_get(self) -> int32
 |  
 |  is_be
 |      debapp_attrs_t_is_be_get(self) -> int
 |  
 |  platform
 |      debapp_attrs_t_platform_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on class debug_event_t in module ida_idd:

class debug_event_t(builtins.object)
 |  Proxy of C++ debug_event_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> debug_event_t
 |      __init__(self, r) -> debug_event_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_debug_event_t(...)
 |      delete_debug_event_t(self)
 |  
 |  bpt(self, *args) -> 'bptaddr_t const &'
 |      bpt(self) -> bptaddr_t
 |      bpt(self) -> bptaddr_t
 |  
 |  bpt_ea(self, *args) -> 'ea_t'
 |      bpt_ea(self) -> ea_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  clear_all(self, *args) -> 'void'
 |      clear_all(self)
 |  
 |  copy(self, *args) -> 'debug_event_t &'
 |      copy(self, r) -> debug_event_t
 |  
 |  eid(self, *args) -> 'event_id_t'
 |      eid(self) -> event_id_t
 |  
 |  exc(self, *args) -> 'excinfo_t const &'
 |      exc(self) -> excinfo_t
 |      exc(self) -> excinfo_t
 |  
 |  exit_code(self, *args) -> 'int const &'
 |      exit_code(self) -> int const &
 |  
 |  info(self, *args) -> 'qstring const &'
 |      info(self) -> qstring
 |      info(self) -> qstring const &
 |  
 |  modinfo(self, *args) -> 'modinfo_t const &'
 |      modinfo(self) -> modinfo_t
 |      modinfo(self) -> modinfo_t
 |  
 |  set_bpt(self, *args) -> 'bptaddr_t &'
 |      set_bpt(self) -> bptaddr_t
 |  
 |  set_eid(self, *args) -> 'void'
 |      set_eid(self, id)
 |  
 |  set_exception(self, *args) -> 'excinfo_t &'
 |      set_exception(self) -> excinfo_t
 |  
 |  set_exit_code(self, *args) -> 'void'
 |      set_exit_code(self, id, code)
 |  
 |  set_info(self, *args) -> 'qstring &'
 |      set_info(self, id) -> qstring &
 |  
 |  set_modinfo(self, *args) -> 'modinfo_t &'
 |      set_modinfo(self, id) -> modinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      debug_event_t_ea_get(self) -> ea_t
 |  
 |  handled
 |      debug_event_t_handled_get(self) -> bool
 |  
 |  pid
 |      debug_event_t_pid_get(self) -> pid_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      debug_event_t_tid_get(self) -> thid_t

Help on class exception_info_t in module ida_idd:

class exception_info_t(builtins.object)
 |  Proxy of C++ exception_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> exception_info_t
 |      __init__(self, _code, _flags, _name, _desc) -> exception_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_exception_info_t(...)
 |      delete_exception_info_t(self)
 |  
 |  break_on(self, *args) -> 'bool'
 |      break_on(self) -> bool
 |  
 |  handle(self, *args) -> 'bool'
 |      handle(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  code
 |      exception_info_t_code_get(self) -> uint
 |  
 |  desc
 |      exception_info_t_desc_get(self) -> qstring *
 |  
 |  flags
 |      exception_info_t_flags_get(self) -> uint32
 |  
 |  name
 |      exception_info_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on class excinfo_t in module ida_idd:

class excinfo_t(builtins.object)
 |  Proxy of C++ excinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> excinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_excinfo_t(...)
 |      delete_excinfo_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  can_cont
 |      excinfo_t_can_cont_get(self) -> bool
 |  
 |  code
 |      excinfo_t_code_get(self) -> uint32
 |  
 |  ea
 |      excinfo_t_ea_get(self) -> ea_t
 |  
 |  info
 |      excinfo_t_info_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on class excvec_t in module ida_idd:

class excvec_t(builtins.object)
 |  Proxy of C++ qvector< exception_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'exception_info_t const &'
 |      __getitem__(self, i) -> exception_info_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> excvec_t
 |      __init__(self, x) -> excvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_excvec_t(...)
 |      delete_excvec_t(self)
 |  
 |  at(self, *args) -> 'exception_info_t const &'
 |      at(self, _idx) -> exception_info_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< exception_info_t >::const_iterator'
 |      begin(self) -> exception_info_t
 |      begin(self) -> exception_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< exception_info_t >::const_iterator'
 |      end(self) -> exception_info_t
 |      end(self) -> exception_info_t
 |  
 |  erase(self, *args) -> 'qvector< exception_info_t >::iterator'
 |      erase(self, it) -> exception_info_t
 |      erase(self, first, last) -> exception_info_t
 |  
 |  extract(self, *args) -> 'exception_info_t *'
 |      extract(self) -> exception_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=exception_info_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< exception_info_t >::iterator'
 |      insert(self, it, x) -> exception_info_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'exception_info_t &'
 |      push_back(self, x)
 |      push_back(self) -> exception_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function get_event_bpt_hea in module ida_idd:

get_event_bpt_hea(*args) -> 'ea_t'
    get_event_bpt_hea(ev) -> ea_t

Help on function get_event_exc_code in module ida_idd:

get_event_exc_code(*args) -> 'uint'
    get_event_exc_code(ev) -> uint

Help on function get_event_exc_ea in module ida_idd:

get_event_exc_ea(*args) -> 'ea_t'
    get_event_exc_ea(ev) -> ea_t

Help on function get_event_exc_info in module ida_idd:

get_event_exc_info(*args) -> 'size_t'
    get_event_exc_info(ev) -> str

Help on function get_event_info in module ida_idd:

get_event_info(*args) -> 'size_t'
    get_event_info(ev) -> str

Help on function get_event_module_base in module ida_idd:

get_event_module_base(*args) -> 'ea_t'
    get_event_module_base(ev) -> ea_t

Help on function get_event_module_name in module ida_idd:

get_event_module_name(*args) -> 'size_t'
    get_event_module_name(ev) -> str

Help on function get_event_module_size in module ida_idd:

get_event_module_size(*args) -> 'asize_t'
    get_event_module_size(ev) -> asize_t

Help on class meminfo_vec_t in module ida_idd:

class meminfo_vec_t(builtins.object)
 |  Proxy of C++ qvector< memory_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'memory_info_t const &'
 |      __getitem__(self, i) -> memory_info_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> meminfo_vec_t
 |      __init__(self, x) -> meminfo_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_meminfo_vec_t(...)
 |      delete_meminfo_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'memory_info_t const &'
 |      at(self, _idx) -> memory_info_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< memory_info_t >::const_iterator'
 |      begin(self) -> memory_info_t
 |      begin(self) -> memory_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< memory_info_t >::const_iterator'
 |      end(self) -> memory_info_t
 |      end(self) -> memory_info_t
 |  
 |  erase(self, *args) -> 'qvector< memory_info_t >::iterator'
 |      erase(self, it) -> memory_info_t
 |      erase(self, first, last) -> memory_info_t
 |  
 |  extract(self, *args) -> 'memory_info_t *'
 |      extract(self) -> memory_info_t
 |  
 |  find(self, *args) -> 'qvector< memory_info_t >::const_iterator'
 |      find(self, x) -> memory_info_t
 |      find(self, x) -> memory_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=memory_info_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< memory_info_t >::iterator'
 |      insert(self, it, x) -> memory_info_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'memory_info_t &'
 |      push_back(self, x)
 |      push_back(self) -> memory_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class memory_info_t in module ida_idd:

class memory_info_t(ida_range.range_t)
 |  Proxy of C++ memory_info_t class.
 |  
 |  Method resolution order:
 |      memory_info_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> memory_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_memory_info_t(...)
 |      delete_memory_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bitness
 |      memory_info_t_bitness_get(self) -> uchar
 |  
 |  name
 |      memory_info_t_name_get(self) -> qstring *
 |  
 |  perm
 |      memory_info_t_perm_get(self) -> uchar
 |  
 |  sbase
 |      memory_info_t_sbase_get(self) -> ea_t
 |  
 |  sclass
 |      memory_info_t_sclass_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      contains(self, r) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t

Help on class modinfo_t in module ida_idd:

class modinfo_t(builtins.object)
 |  Proxy of C++ modinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> modinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_modinfo_t(...)
 |      delete_modinfo_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  base
 |      modinfo_t_base_get(self) -> ea_t
 |  
 |  name
 |      modinfo_t_name_get(self) -> qstring *
 |  
 |  rebase_to
 |      modinfo_t_rebase_to_get(self) -> ea_t
 |  
 |  size
 |      modinfo_t_size_get(self) -> asize_t
 |  
 |  thisown
 |      The membership flag

Help on class process_info_t in module ida_idd:

class process_info_t(builtins.object)
 |  Proxy of C++ process_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> process_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_process_info_t(...)
 |      delete_process_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      process_info_t_name_get(self) -> qstring *
 |  
 |  pid
 |      process_info_t_pid_get(self) -> pid_t
 |  
 |  thisown
 |      The membership flag

Help on class procinfo_vec_t in module ida_idd:

class procinfo_vec_t(builtins.object)
 |  Proxy of C++ qvector< process_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'process_info_t const &'
 |      __getitem__(self, i) -> process_info_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> procinfo_vec_t
 |      __init__(self, x) -> procinfo_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_procinfo_vec_t(...)
 |      delete_procinfo_vec_t(self)
 |  
 |  at(self, *args) -> 'process_info_t const &'
 |      at(self, _idx) -> process_info_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< process_info_t >::const_iterator'
 |      begin(self) -> process_info_t
 |      begin(self) -> process_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< process_info_t >::const_iterator'
 |      end(self) -> process_info_t
 |      end(self) -> process_info_t
 |  
 |  erase(self, *args) -> 'qvector< process_info_t >::iterator'
 |      erase(self, it) -> process_info_t
 |      erase(self, first, last) -> process_info_t
 |  
 |  extract(self, *args) -> 'process_info_t *'
 |      extract(self) -> process_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=process_info_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< process_info_t >::iterator'
 |      insert(self, it, x) -> process_info_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'process_info_t &'
 |      push_back(self, x)
 |      push_back(self) -> process_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class register_info_t in module ida_idd:

class register_info_t(builtins.object)
 |  Proxy of C++ register_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> register_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_register_info_t(...)
 |      delete_register_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bit_strings
 |      register_info_t_bit_strings_get(self) -> char const *const *
 |  
 |  default_bit_strings_mask
 |      register_info_t_default_bit_strings_mask_get(self) -> uval_t
 |  
 |  dtype
 |      register_info_t_dtype_get(self) -> op_dtype_t
 |  
 |  flags
 |      register_info_t_flags_get(self) -> uint32
 |  
 |  name
 |      register_info_t_name_get(self) -> char const *
 |  
 |  register_class
 |      register_info_t_register_class_get(self) -> register_class_t
 |  
 |  thisown
 |      The membership flag

Help on class regval_t in module ida_idd:

class regval_t(builtins.object)
 |  Proxy of C++ regval_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regval_t
 |      __init__(self, r) -> regval_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_regval_t(...)
 |      delete_regval_t(self)
 |  
 |  bytes(self, *args) -> 'bytevec_t const &'
 |      bytes(self) -> bytevec_t
 |      bytes(self) -> bytevec_t const &
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  get_data(self, *args) -> 'void const *'
 |      get_data(self)
 |      get_data(self) -> void const *
 |  
 |  get_data_size(self, *args) -> 'size_t'
 |      get_data_size(self) -> size_t
 |  
 |  set_bytes(self, *args) -> 'bytevec_t &'
 |      set_bytes(self, data, size)
 |      set_bytes(self, v)
 |      set_bytes(self) -> bytevec_t &
 |  
 |  set_float(self, *args) -> 'void'
 |      set_float(self, x)
 |  
 |  set_int(self, *args) -> 'void'
 |      set_int(self, x)
 |  
 |  set_unavailable(self, *args) -> 'void'
 |      set_unavailable(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fval
 |      regval_t_fval_get(self) -> uint16 [6]
 |  
 |  ival
 |      regval_t_ival_get(self) -> uint64
 |  
 |  rvtype
 |      regval_t_rvtype_get(self) -> int32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class scattered_segm_t in module ida_idd:

class scattered_segm_t(ida_range.range_t)
 |  Proxy of C++ scattered_segm_t class.
 |  
 |  Method resolution order:
 |      scattered_segm_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> scattered_segm_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_scattered_segm_t(...)
 |      delete_scattered_segm_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  name
 |      scattered_segm_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      contains(self, r) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on function set_debug_event_code in module ida_idd:

set_debug_event_code(*args) -> 'void'
    set_debug_event_code(ev, id)

Help on class thread_name_t in module ida_idd:

class thread_name_t(builtins.object)
 |  Proxy of C++ thread_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> thread_name_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_thread_name_t(...)
 |      delete_thread_name_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      thread_name_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      thread_name_t_tid_get(self) -> thid_t

=== ida_idd EPYDOC INJECTIONS ===
ida_idd.EXC_BREAK
"""
break on the exception
"""

ida_idd.EXC_HANDLE
"""
should be handled by the debugger?
"""

ida_idd.EXC_MSG
"""
instead of a warning, log the exception to the output window
"""

ida_idd.EXC_SILENT
"""
do not warn or log to the output window
"""

ida_idd.IDD_INTERFACE_VERSION
"""
The IDD interface version number.
"""

ida_idd.NO_PROCESS
"""
No process.
"""

ida_idd.NO_THREAD
"""
No thread. in 'PROCESS_STARTED' this value can be used to specify that
the main thread has not been created. It will be initialized later by
a 'THREAD_STARTED' event.
"""

ida_idd.REGISTER_ADDRESS
"""
may contain an address
"""

ida_idd.REGISTER_CS
"""
code segment
"""

ida_idd.REGISTER_CUSTFMT
"""
register should be displayed using a custom data format. the format
name is in bit_strings[0] the corresponding 'regval_t' will use
'bytevec_t'
"""

ida_idd.REGISTER_FP
"""
frame pointer
"""

ida_idd.REGISTER_IP
"""
instruction pointer
"""

ida_idd.REGISTER_NOLF
"""
allowing the next register to be displayed to its right (on the same
line)

displays this register without returning to the next line
"""

ida_idd.REGISTER_READONLY
"""
the user can't modify the current value of this register
"""

ida_idd.REGISTER_SP
"""
stack pointer
"""

ida_idd.REGISTER_SS
"""
stack segment
"""

ida_idd.RVT_FLOAT
"""
floating point
"""

ida_idd.RVT_INT
"""
integer
"""

ida_idd.RVT_UNAVAILABLE
"""
other values mean custom data type

unavailable
"""
=== ida_idd EPYDOC INJECTIONS END ===
Help on function AssembleLine in module ida_idp:

AssembleLine(*args) -> 'PyObject *'
    AssembleLine(ea, cs, ip, use32, nonnul_line) -> PyObject *
    
    
    Assemble an instruction to a string (display a warning if an error is found)
    
    @param ea: linear address of instruction
    @param cs:  cs of instruction
    @param ip:  ip of instruction
    @param use32: is 32bit segment
    @param line: line to assemble
    @return:
        - None on failure
        - or a string containing the assembled instruction

Help on class IDB_Hooks in module ida_idp:

class IDB_Hooks(builtins.object)
 |  Proxy of C++ IDB_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> IDB_Hooks
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_IDB_Hooks(...)
 |      delete_IDB_Hooks(self)
 |  
 |  allsegs_moved(self, *args) -> 'void'
 |      allsegs_moved(self, info)
 |  
 |  auto_empty(self, *args) -> 'void'
 |      auto_empty(self)
 |  
 |  auto_empty_finally(self, *args) -> 'void'
 |      auto_empty_finally(self)
 |  
 |  bookmark_changed(self, *args) -> 'void'
 |      bookmark_changed(self, index, pos, desc)
 |  
 |  byte_patched(self, *args) -> 'void'
 |      byte_patched(self, ea, old_value)
 |  
 |  callee_addr_changed(self, *args) -> 'void'
 |      callee_addr_changed(self, ea, callee)
 |  
 |  changing_cmt(self, *args) -> 'void'
 |      changing_cmt(self, ea, repeatable_cmt, newcmt)
 |  
 |  changing_enum_bf(self, *args) -> 'void'
 |      changing_enum_bf(self, id, new_bf)
 |  
 |  changing_enum_cmt(self, *args) -> 'void'
 |      changing_enum_cmt(self, id, repeatable, newcmt)
 |  
 |  changing_op_ti(self, *args) -> 'void'
 |      changing_op_ti(self, ea, n, new_type, new_fnames)
 |  
 |  changing_op_type(self, *args) -> 'void'
 |      changing_op_type(self, ea, n, opinfo)
 |  
 |  changing_range_cmt(self, *args) -> 'void'
 |      changing_range_cmt(self, kind, a, cmt, repeatable)
 |  
 |  changing_segm_class(self, *args) -> 'void'
 |      changing_segm_class(self, s)
 |  
 |  changing_segm_end(self, *args) -> 'void'
 |      changing_segm_end(self, s, new_end, segmod_flags)
 |  
 |  changing_segm_name(self, *args) -> 'void'
 |      changing_segm_name(self, s, oldname)
 |  
 |  changing_segm_start(self, *args) -> 'void'
 |      changing_segm_start(self, s, new_start, segmod_flags)
 |  
 |  changing_struc_align(self, *args) -> 'void'
 |      changing_struc_align(self, sptr)
 |  
 |  changing_struc_cmt(self, *args) -> 'void'
 |      changing_struc_cmt(self, struc_id, repeatable, newcmt)
 |  
 |  changing_struc_member(self, *args) -> 'void'
 |      changing_struc_member(self, sptr, mptr, flag, ti, nbytes)
 |  
 |  changing_ti(self, *args) -> 'void'
 |      changing_ti(self, ea, new_type, new_fnames)
 |  
 |  closebase(self, *args) -> 'void'
 |      closebase(self)
 |  
 |  cmt_changed(self, *args) -> 'void'
 |      cmt_changed(self, ea, repeatable_cmt)
 |  
 |  compiler_changed(self, *args) -> 'void'
 |      compiler_changed(self)
 |  
 |  deleting_enum(self, *args) -> 'void'
 |      deleting_enum(self, id)
 |  
 |  deleting_enum_member(self, *args) -> 'void'
 |      deleting_enum_member(self, id, cid)
 |  
 |  deleting_func(self, *args) -> 'void'
 |      deleting_func(self, pfn)
 |  
 |  deleting_func_tail(self, *args) -> 'void'
 |      deleting_func_tail(self, pfn, tail)
 |  
 |  deleting_segm(self, *args) -> 'void'
 |      deleting_segm(self, start_ea)
 |  
 |  deleting_struc(self, *args) -> 'void'
 |      deleting_struc(self, sptr)
 |  
 |  deleting_struc_member(self, *args) -> 'void'
 |      deleting_struc_member(self, sptr, mptr)
 |  
 |  deleting_tryblks(self, *args) -> 'void'
 |      deleting_tryblks(self, range)
 |  
 |  destroyed_items(self, *args) -> 'void'
 |      destroyed_items(self, ea1, ea2, will_disable_range)
 |  
 |  determined_main(self, *args) -> 'void'
 |      determined_main(self, main)
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  enum_bf_changed(self, *args) -> 'void'
 |      enum_bf_changed(self, id)
 |  
 |  enum_cmt_changed(self, *args) -> 'void'
 |      enum_cmt_changed(self, id, repeatable)
 |  
 |  enum_created(self, *args) -> 'void'
 |      enum_created(self, id)
 |  
 |  enum_deleted(self, *args) -> 'void'
 |      enum_deleted(self, id)
 |  
 |  enum_member_created(self, *args) -> 'void'
 |      enum_member_created(self, id, cid)
 |  
 |  enum_member_deleted(self, *args) -> 'void'
 |      enum_member_deleted(self, id, cid)
 |  
 |  enum_renamed(self, *args) -> 'void'
 |      enum_renamed(self, id)
 |  
 |  expanding_struc(self, *args) -> 'void'
 |      expanding_struc(self, sptr, offset, delta)
 |  
 |  extlang_changed(self, *args) -> 'void'
 |      extlang_changed(self, kind, el, idx)
 |  
 |  extra_cmt_changed(self, *args) -> 'void'
 |      extra_cmt_changed(self, ea, line_idx, cmt)
 |  
 |  flow_chart_created(self, *args) -> 'void'
 |      flow_chart_created(self, fc)
 |  
 |  frame_deleted(self, *args) -> 'void'
 |      frame_deleted(self, pfn)
 |  
 |  func_added(self, *args) -> 'void'
 |      func_added(self, pfn)
 |  
 |  func_noret_changed(self, *args) -> 'void'
 |      func_noret_changed(self, pfn)
 |  
 |  func_tail_appended(self, *args) -> 'void'
 |      func_tail_appended(self, pfn, tail)
 |  
 |  func_tail_deleted(self, *args) -> 'void'
 |      func_tail_deleted(self, pfn, tail_ea)
 |  
 |  func_updated(self, *args) -> 'void'
 |      func_updated(self, pfn)
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  idasgn_loaded(self, *args) -> 'void'
 |      idasgn_loaded(self, short_sig_name)
 |  
 |  item_color_changed(self, *args) -> 'void'
 |      item_color_changed(self, ea, color)
 |  
 |  kernel_config_loaded(self, *args) -> 'void'
 |      kernel_config_loaded(self)
 |  
 |  loader_finished(self, *args) -> 'void'
 |      loader_finished(self, li, neflags, filetypename)
 |  
 |  local_types_changed(self, *args) -> 'void'
 |      local_types_changed(self)
 |  
 |  make_code(self, *args) -> 'void'
 |      make_code(self, insn)
 |  
 |  make_data(self, *args) -> 'void'
 |      make_data(self, ea, flags, tid, len)
 |  
 |  op_ti_changed(self, *args) -> 'void'
 |      op_ti_changed(self, ea, n, type, fnames)
 |  
 |  op_type_changed(self, *args) -> 'void'
 |      op_type_changed(self, ea, n)
 |  
 |  range_cmt_changed(self, *args) -> 'void'
 |      range_cmt_changed(self, kind, a, cmt, repeatable)
 |  
 |  renamed(self, *args) -> 'void'
 |      renamed(self, ea, new_name, local_name)
 |  
 |  renaming_enum(self, *args) -> 'void'
 |      renaming_enum(self, id, is_enum, newname)
 |  
 |  renaming_struc(self, *args) -> 'void'
 |      renaming_struc(self, id, oldname, newname)
 |  
 |  renaming_struc_member(self, *args) -> 'void'
 |      renaming_struc_member(self, sptr, mptr, newname)
 |  
 |  savebase(self, *args) -> 'void'
 |      savebase(self)
 |  
 |  segm_added(self, *args) -> 'void'
 |      segm_added(self, s)
 |  
 |  segm_attrs_updated(self, *args) -> 'void'
 |      segm_attrs_updated(self, s)
 |  
 |  segm_class_changed(self, *args) -> 'void'
 |      segm_class_changed(self, s, sclass)
 |  
 |  segm_deleted(self, *args) -> 'void'
 |      segm_deleted(self, start_ea, end_ea)
 |  
 |  segm_end_changed(self, *args) -> 'void'
 |      segm_end_changed(self, s, oldend)
 |  
 |  segm_moved(self, *args) -> 'void'
 |      segm_moved(self, _from, to, size, changed_netmap)
 |  
 |  segm_name_changed(self, *args) -> 'void'
 |      segm_name_changed(self, s, name)
 |  
 |  segm_start_changed(self, *args) -> 'void'
 |      segm_start_changed(self, s, oldstart)
 |  
 |  set_func_end(self, *args) -> 'void'
 |      set_func_end(self, pfn, new_end)
 |  
 |  set_func_start(self, *args) -> 'void'
 |      set_func_start(self, pfn, new_start)
 |  
 |  sgr_changed(self, *args) -> 'void'
 |      sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag)
 |  
 |  sgr_deleted(self, *args) -> 'void'
 |      sgr_deleted(self, start_ea, end_ea, regnum)
 |  
 |  stkpnts_changed(self, *args) -> 'void'
 |      stkpnts_changed(self, pfn)
 |  
 |  struc_align_changed(self, *args) -> 'void'
 |      struc_align_changed(self, sptr)
 |  
 |  struc_cmt_changed(self, *args) -> 'void'
 |      struc_cmt_changed(self, struc_id, repeatable_cmt)
 |  
 |  struc_created(self, *args) -> 'void'
 |      struc_created(self, struc_id)
 |  
 |  struc_deleted(self, *args) -> 'void'
 |      struc_deleted(self, struc_id)
 |  
 |  struc_expanded(self, *args) -> 'void'
 |      struc_expanded(self, sptr)
 |  
 |  struc_member_changed(self, *args) -> 'void'
 |      struc_member_changed(self, sptr, mptr)
 |  
 |  struc_member_created(self, *args) -> 'void'
 |      struc_member_created(self, sptr, mptr)
 |  
 |  struc_member_deleted(self, *args) -> 'void'
 |      struc_member_deleted(self, sptr, member_id, offset)
 |  
 |  struc_member_renamed(self, *args) -> 'void'
 |      struc_member_renamed(self, sptr, mptr)
 |  
 |  struc_renamed(self, *args) -> 'void'
 |      struc_renamed(self, sptr)
 |  
 |  tail_owner_changed(self, *args) -> 'void'
 |      tail_owner_changed(self, tail, owner_func, old_owner)
 |  
 |  thunk_func_created(self, *args) -> 'void'
 |      thunk_func_created(self, pfn)
 |  
 |  ti_changed(self, *args) -> 'void'
 |      ti_changed(self, ea, type, fnames)
 |  
 |  tryblks_updated(self, *args) -> 'void'
 |      tryblks_updated(self, tbv)
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  updating_tryblks(self, *args) -> 'void'
 |      updating_tryblks(self, tbv)
 |  
 |  upgraded(self, *args) -> 'void'
 |      upgraded(self, _from)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class IDP_Hooks in module ida_idp:

class IDP_Hooks(builtins.object)
 |  Proxy of C++ IDP_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> IDP_Hooks
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_IDP_Hooks(...)
 |      delete_IDP_Hooks(self)
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  ev_add_cref(self, *args) -> 'int'
 |      ev_add_cref(self, _from, to, type) -> int
 |  
 |  ev_add_dref(self, *args) -> 'int'
 |      ev_add_dref(self, _from, to, type) -> int
 |  
 |  ev_adjust_argloc(self, *args) -> 'int'
 |      ev_adjust_argloc(self, argloc, optional_type, size) -> int
 |  
 |  ev_adjust_libfunc_ea(self, *args) -> 'int'
 |      ev_adjust_libfunc_ea(self, sig, libfun, ea) -> int
 |  
 |  ev_adjust_refinfo(self, *args) -> 'int'
 |      ev_adjust_refinfo(self, ri, ea, n, fd) -> int
 |  
 |  ev_ana_insn(self, *args) -> 'bool'
 |      ev_ana_insn(self, out) -> bool
 |      
 |      
 |      Analyzes and decodes an instruction at insn.ea
 |         - insn.itype must be set >= idaapi.CUSTOM_CMD_ITYPE
 |         - insn.size must be set to the instruction length
 |      
 |      @return: Boolean
 |          - False if the instruction is not recognized
 |          - True if the instruction was decoded. 'insn' should be filled in that case.
 |  
 |  ev_analyze_prolog(self, *args) -> 'int'
 |      ev_analyze_prolog(self, ea) -> int
 |  
 |  ev_arg_addrs_ready(self, *args) -> 'int'
 |      ev_arg_addrs_ready(self, caller, n, tif, addrs) -> int
 |  
 |  ev_assemble(self, *args) -> 'PyObject *'
 |      ev_assemble(self, ea, cs, ip, use32, line) -> PyObject *
 |      
 |      
 |      Assembles an instruction
 |      
 |      @param ea: linear address of instruction
 |      @param cs: cs of instruction
 |      @param ip: ip of instruction
 |      @param use32: is 32bit segment?
 |      @param line: line to assemble
 |      
 |      @return: - None to let the underlying processor module assemble the line
 |               - or a string containing the assembled buffer
 |  
 |  ev_auto_queue_empty(self, *args) -> 'void'
 |      ev_auto_queue_empty(self, type)
 |  
 |  ev_calc_arglocs(self, *args) -> 'int'
 |      ev_calc_arglocs(self, fti) -> int
 |  
 |  ev_calc_cdecl_purged_bytes(self, *args) -> 'int'
 |      ev_calc_cdecl_purged_bytes(self, ea) -> int
 |  
 |  ev_calc_next_eas(self, *args) -> 'int'
 |      ev_calc_next_eas(self, res, insn, over) -> int
 |  
 |  ev_calc_purged_bytes(self, *args) -> 'int'
 |      ev_calc_purged_bytes(self, p_purged_bytes, fti) -> int
 |  
 |  ev_calc_retloc(self, *args) -> 'int'
 |      ev_calc_retloc(self, retloc, rettype, cc) -> int
 |  
 |  ev_calc_spdelta(self, *args) -> 'int'
 |      ev_calc_spdelta(self, spdelta, insn) -> int
 |  
 |  ev_calc_step_over(self, *args) -> 'int'
 |      ev_calc_step_over(self, target, ip) -> int
 |  
 |  ev_calc_switch_cases(self, *args) -> 'int'
 |      ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -> int
 |  
 |  ev_calc_varglocs(self, *args) -> 'int'
 |      ev_calc_varglocs(self, ftd, aux_regs, aux_stkargs, nfixed) -> int
 |  
 |  ev_calcrel(self, *args) -> 'int'
 |      ev_calcrel(self) -> int
 |  
 |  ev_can_have_type(self, *args) -> 'int'
 |      ev_can_have_type(self, op) -> int
 |  
 |  ev_clean_tbit(self, *args) -> 'int'
 |      ev_clean_tbit(self, ea, getreg, regvalues) -> int
 |  
 |  ev_cmp_operands(self, *args) -> 'int'
 |      ev_cmp_operands(self, op1, op2) -> int
 |  
 |  ev_coagulate(self, *args) -> 'int'
 |      ev_coagulate(self, start_ea) -> int
 |  
 |  ev_coagulate_dref(self, *args) -> 'int'
 |      ev_coagulate_dref(self, _from, to, may_define, code_ea) -> int
 |  
 |  ev_create_flat_group(self, *args) -> 'int'
 |      ev_create_flat_group(self, image_base, bitness, dataseg_sel) -> int
 |  
 |  ev_create_func_frame(self, *args) -> 'int'
 |      ev_create_func_frame(self, pfn) -> int
 |  
 |  ev_create_switch_xrefs(self, *args) -> 'int'
 |      ev_create_switch_xrefs(self, jumpea, si) -> int
 |  
 |  ev_creating_segm(self, *args) -> 'int'
 |      ev_creating_segm(self, seg) -> int
 |  
 |  ev_decorate_name(self, *args) -> 'PyObject *'
 |      ev_decorate_name(self, name, mangle, cc, optional_type) -> PyObject *
 |  
 |  ev_del_cref(self, *args) -> 'int'
 |      ev_del_cref(self, _from, to, expand) -> int
 |  
 |  ev_del_dref(self, *args) -> 'int'
 |      ev_del_dref(self, _from, to) -> int
 |  
 |  ev_delay_slot_insn(self, *args) -> 'PyObject *'
 |      ev_delay_slot_insn(self, ea, bexec, fexec) -> PyObject *
 |  
 |  ev_demangle_name(self, *args) -> 'PyObject *'
 |      ev_demangle_name(self, name, disable_mask, demreq) -> PyObject *
 |  
 |  ev_emu_insn(self, *args) -> 'bool'
 |      ev_emu_insn(self, insn) -> bool
 |      
 |      
 |      Emulate instruction, create cross-references, plan to analyze
 |      subsequent instructions, modify flags etc. Upon entrance to this function
 |      all information about the instruction is in 'insn' structure.
 |      
 |      @return: Boolean (whether this instruction has been emulated or not)
 |  
 |  ev_endbinary(self, *args) -> 'int'
 |      ev_endbinary(self, ok) -> int
 |  
 |  ev_ending_undo(self, *args) -> 'int'
 |      ev_ending_undo(self, action_name, is_undo) -> int
 |  
 |  ev_equal_reglocs(self, *args) -> 'int'
 |      ev_equal_reglocs(self, a1, a2) -> int
 |  
 |  ev_extract_address(self, *args) -> 'int'
 |      ev_extract_address(self, out_ea, screen_ea, string, position) -> int
 |  
 |  ev_find_op_value(self, *args) -> 'PyObject *'
 |      ev_find_op_value(self, pinsn, opn) -> PyObject *
 |  
 |  ev_find_reg_value(self, *args) -> 'PyObject *'
 |      ev_find_reg_value(self, pinsn, reg) -> PyObject *
 |  
 |  ev_func_bounds(self, *args) -> 'void'
 |      ev_func_bounds(self, possible_return_code, pfn, max_func_end_ea)
 |  
 |  ev_gen_asm_or_lst(self, *args) -> 'void'
 |      ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline)
 |  
 |  ev_gen_map_file(self, *args) -> 'int'
 |      ev_gen_map_file(self, nlines, fp) -> int
 |  
 |  ev_gen_regvar_def(self, *args) -> 'int'
 |      ev_gen_regvar_def(self, outctx, v) -> int
 |  
 |  ev_gen_src_file_lnnum(self, *args) -> 'int'
 |      ev_gen_src_file_lnnum(self, outctx, file, lnnum) -> int
 |  
 |  ev_gen_stkvar_def(self, *args) -> 'int'
 |      ev_gen_stkvar_def(self, outctx, mptr, v) -> int
 |  
 |  ev_get_abi_info(self, *args) -> 'int'
 |      ev_get_abi_info(self, abi_names, abi_opts, comp) -> int
 |  
 |  ev_get_autocmt(self, *args) -> 'PyObject *'
 |      ev_get_autocmt(self, insn) -> PyObject *
 |  
 |  ev_get_bg_color(self, *args) -> 'int'
 |      ev_get_bg_color(self, ea) -> int or None
 |  
 |  ev_get_cc_regs(self, *args) -> 'int'
 |      ev_get_cc_regs(self, regs, cc) -> int
 |  
 |  ev_get_code16_mode(self, *args) -> 'int'
 |      ev_get_code16_mode(self, ea) -> int
 |  
 |  ev_get_dbr_opnum(self, *args) -> 'int'
 |      ev_get_dbr_opnum(self, opnum, insn) -> int
 |  
 |  ev_get_default_enum_size(self, *args) -> 'int'
 |      ev_get_default_enum_size(self, cm) -> int
 |  
 |  ev_get_frame_retsize(self, *args) -> 'int'
 |      ev_get_frame_retsize(self, frsize, pfn) -> int
 |  
 |  ev_get_macro_insn_head(self, *args) -> 'int'
 |      ev_get_macro_insn_head(self, head, ip) -> int
 |  
 |  ev_get_operand_string(self, *args) -> 'PyObject *'
 |      ev_get_operand_string(self, insn, opnum) -> PyObject *
 |  
 |  ev_get_reg_info(self, *args) -> 'int'
 |      ev_get_reg_info(self, main_regname, bitrange, regname) -> int
 |  
 |  ev_get_reg_name(self, *args) -> 'PyObject *'
 |      ev_get_reg_name(self, reg, width, reghi) -> PyObject *
 |  
 |  ev_get_simd_types(self, *args) -> 'int'
 |      ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -> int
 |  
 |  ev_get_stkarg_offset(self, *args) -> 'int'
 |      ev_get_stkarg_offset(self) -> int
 |  
 |  ev_get_stkvar_scale_factor(self, *args) -> 'int'
 |      ev_get_stkvar_scale_factor(self) -> int
 |  
 |  ev_getreg(self, *args) -> 'int'
 |      ev_getreg(self, regval, regnum) -> int
 |  
 |  ev_init(self, *args) -> 'int'
 |      ev_init(self, idp_modname) -> int
 |  
 |  ev_insn_reads_tbit(self, *args) -> 'int'
 |      ev_insn_reads_tbit(self, insn, getreg, regvalues) -> int
 |  
 |  ev_is_align_insn(self, *args) -> 'int'
 |      ev_is_align_insn(self, ea) -> int
 |  
 |  ev_is_alloca_probe(self, *args) -> 'int'
 |      ev_is_alloca_probe(self, ea) -> int
 |  
 |  ev_is_basic_block_end(self, *args) -> 'int'
 |      ev_is_basic_block_end(self, insn, call_insn_stops_block) -> int
 |  
 |  ev_is_call_insn(self, *args) -> 'int'
 |      ev_is_call_insn(self, insn) -> int
 |      
 |      
 |      Is the instruction a "call"?
 |      
 |      @param insn: instruction
 |      @return: 0-unknown, 1-yes, -1-no
 |  
 |  ev_is_cond_insn(self, *args) -> 'int'
 |      ev_is_cond_insn(self, insn) -> int
 |  
 |  ev_is_far_jump(self, *args) -> 'int'
 |      ev_is_far_jump(self, icode) -> int
 |  
 |  ev_is_indirect_jump(self, *args) -> 'int'
 |      ev_is_indirect_jump(self, insn) -> int
 |  
 |  ev_is_insn_table_jump(self, *args) -> 'int'
 |      ev_is_insn_table_jump(self, insn) -> int
 |  
 |  ev_is_jump_func(self, *args) -> 'int'
 |      ev_is_jump_func(self, pfn, jump_target, func_pointer) -> int
 |  
 |  ev_is_ret_insn(self, *args) -> 'int'
 |      ev_is_ret_insn(self, insn, strict) -> int
 |      
 |      
 |      Is the instruction a "return"?
 |      
 |      @param insn: instruction
 |      @param strict: - True: report only ret instructions
 |                       False: include instructions like "leave" which begins the function epilog
 |      @return: 0-unknown, 1-yes, -1-no
 |  
 |  ev_is_sane_insn(self, *args) -> 'int'
 |      ev_is_sane_insn(self, insn, no_crefs) -> int
 |      
 |      
 |      is the instruction sane for the current file type?
 |      @param insn: the instruction
 |      @param no_crefs:
 |            - 1: the instruction has no code refs to it.
 |                 ida just tries to convert unexplored bytes
 |                 to an instruction (but there is no other
 |                 reason to convert them into an instruction)
 |            - 0: the instruction is created because
 |                 of some coderef, user request or another
 |                 weighty reason.
 |      @return: >=0-ok, <0-no, the instruction isn't likely to appear in the program
 |  
 |  ev_is_sp_based(self, *args) -> 'int'
 |      ev_is_sp_based(self, mode, insn, op) -> int
 |  
 |  ev_is_switch(self, *args) -> 'int'
 |      ev_is_switch(self, si, insn) -> int
 |  
 |  ev_last_cb_before_loader(self, *args) -> 'int'
 |      ev_last_cb_before_loader(self) -> int
 |  
 |  ev_loader(self, *args) -> 'int'
 |      ev_loader(self) -> int
 |  
 |  ev_lower_func_type(self, *args) -> 'int'
 |      ev_lower_func_type(self, argnums, fti) -> int
 |  
 |  ev_max_ptr_size(self, *args) -> 'int'
 |      ev_max_ptr_size(self) -> int
 |  
 |  ev_may_be_func(self, *args) -> 'int'
 |      ev_may_be_func(self, insn, state) -> int
 |      
 |      
 |      Can a function start here?
 |      @param insn: the instruction
 |      @param state: autoanalysis phase
 |            0: creating functions
 |            1: creating chunks
 |      
 |      @return: integer (probability 0..100)
 |  
 |  ev_may_show_sreg(self, *args) -> 'int'
 |      ev_may_show_sreg(self, current_ea) -> int
 |  
 |  ev_moving_segm(self, *args) -> 'int'
 |      ev_moving_segm(self, seg, to, flags) -> int
 |  
 |  ev_newasm(self, *args) -> 'int'
 |      ev_newasm(self, asmnum) -> int
 |  
 |  ev_newbinary(self, *args) -> 'int'
 |      ev_newbinary(self, filename, fileoff, basepara, binoff, nbytes) -> int
 |  
 |  ev_newfile(self, *args) -> 'int'
 |      ev_newfile(self, fname) -> int
 |  
 |  ev_newprc(self, *args) -> 'int'
 |      ev_newprc(self, pnum, keep_cfg) -> int
 |  
 |  ev_next_exec_insn(self, *args) -> 'int'
 |      ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -> int
 |  
 |  ev_oldfile(self, *args) -> 'int'
 |      ev_oldfile(self, fname) -> int
 |  
 |  ev_out_assumes(self, *args) -> 'int'
 |      ev_out_assumes(self, outctx) -> int
 |  
 |  ev_out_data(self, *args) -> 'int'
 |      ev_out_data(self, outctx, analyze_only) -> int
 |  
 |  ev_out_footer(self, *args) -> 'void'
 |      ev_out_footer(self, outctx)
 |  
 |  ev_out_header(self, *args) -> 'void'
 |      ev_out_header(self, outctx)
 |  
 |  ev_out_insn(self, *args) -> 'bool'
 |      ev_out_insn(self, outctx) -> bool
 |      
 |      
 |      Outputs the instruction defined in 'ctx.insn'
 |      
 |      @return: Boolean (whether this instruction can be outputted or not)
 |  
 |  ev_out_label(self, *args) -> 'int'
 |      ev_out_label(self, outctx, colored_name) -> int
 |  
 |  ev_out_mnem(self, *args) -> 'int'
 |      ev_out_mnem(self, outctx) -> int
 |  
 |  ev_out_operand(self, *args) -> 'bool'
 |      ev_out_operand(self, outctx, op) -> bool
 |      
 |      
 |      Notification to generate operand text.
 |      If False was returned, then the standard operand output function will be called.
 |      
 |      this notification may use out_...() functions to form the operand text
 |      
 |      @return: Boolean (whether the operand has been outputted or not)
 |  
 |  ev_out_segend(self, *args) -> 'int'
 |      ev_out_segend(self, outctx, seg) -> int
 |  
 |  ev_out_segstart(self, *args) -> 'int'
 |      ev_out_segstart(self, outctx, seg) -> int
 |  
 |  ev_out_special_item(self, *args) -> 'int'
 |      ev_out_special_item(self, outctx, segtype) -> int
 |  
 |  ev_realcvt(self, *args) -> 'int'
 |      ev_realcvt(self, m, e, swt) -> int
 |  
 |  ev_rename(self, *args) -> 'int'
 |      ev_rename(self, ea, new_name) -> int
 |      
 |      
 |      The kernel is going to rename a byte.
 |      
 |      @param ea: Address
 |      @param new_name: The new name
 |      
 |      @return:
 |          - If returns value <0, then the kernel should
 |            not rename it. See also the 'renamed' event
 |  
 |  ev_replaying_undo(self, *args) -> 'int'
 |      ev_replaying_undo(self, action_name, vec, is_undo) -> int
 |  
 |  ev_set_code16_mode(self, *args) -> 'int'
 |      ev_set_code16_mode(self, ea, code16) -> int
 |  
 |  ev_set_idp_options(self, *args) -> 'int'
 |      ev_set_idp_options(self, keyword, value_type, value, errbuf, idb_loaded) -> int
 |  
 |  ev_set_proc_options(self, *args) -> 'int'
 |      ev_set_proc_options(self, options, confidence) -> int
 |  
 |  ev_setup_til(self, *args) -> 'void'
 |      ev_setup_til(self)
 |  
 |  ev_shadow_args_size(self, *args) -> 'int'
 |      ev_shadow_args_size(self, shadow_args_size, pfn) -> int
 |  
 |  ev_str2reg(self, *args) -> 'int'
 |      ev_str2reg(self, regname) -> int
 |  
 |  ev_term(self, *args) -> 'int'
 |      ev_term(self) -> int
 |  
 |  ev_treat_hindering_item(self, *args) -> 'int'
 |      ev_treat_hindering_item(self, hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> int
 |  
 |  ev_undefine(self, *args) -> 'int'
 |      ev_undefine(self, ea) -> int
 |      
 |      
 |      An item in the database (insn or data) is being deleted
 |      @param ea: Address
 |      @return:
 |          - 1 - do not delete srranges at the item end
 |          - 0 - srranges can be deleted
 |  
 |  ev_use_arg_types(self, *args) -> 'int'
 |      ev_use_arg_types(self, ea, fti, rargs) -> int
 |  
 |  ev_use_regarg_type(self, *args) -> 'PyObject *'
 |      ev_use_regarg_type(self, ea, rargs) -> PyObject *
 |  
 |  ev_use_stkarg_type(self, *args) -> 'int'
 |      ev_use_stkarg_type(self, ea, arg) -> int
 |  
 |  ev_validate_flirt_func(self, *args) -> 'int'
 |      ev_validate_flirt_func(self, start_ea, funcname) -> int
 |  
 |  ev_verify_noreturn(self, *args) -> 'int'
 |      ev_verify_noreturn(self, pfn) -> int
 |  
 |  ev_verify_sp(self, *args) -> 'int'
 |      ev_verify_sp(self, pfn) -> int
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |      
 |      
 |      Creates an IDP hook
 |      
 |      @return: Boolean true on success
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |      
 |      
 |      Removes the IDP hook
 |      @return: Boolean true on success
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class __ph in module ida_idp:

class __ph(builtins.object)
 |  # ----------------------------------------------------------------------
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cnbits
 |  
 |  dnbits
 |  
 |  flag
 |  
 |  icode_return
 |  
 |  id
 |  
 |  instruc
 |  
 |  instruc_end
 |  
 |  instruc_start
 |  
 |  reg_code_sreg
 |  
 |  reg_data_sreg
 |  
 |  reg_first_sreg
 |  
 |  reg_last_sreg
 |  
 |  regnames
 |  
 |  segreg_size
 |  
 |  tbyte_size
 |  
 |  version

Help on class _notify_when_dispatcher_t in module ida_idp:

class _notify_when_dispatcher_t(builtins.object)
 |  Methods defined here:
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  _find(self, fun)
 |  
 |  dispatch(self, slot, *args)
 |  
 |  notify_when(self, when, fun)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  _IDB_Hooks = <class 'ida_idp._notify_when_dispatcher_t._IDB_Hooks'>
 |      Proxy of C++ IDB_Hooks class.
 |  
 |  _IDP_Hooks = <class 'ida_idp._notify_when_dispatcher_t._IDP_Hooks'>
 |      Proxy of C++ IDP_Hooks class.
 |  
 |  _callback_t = <class 'ida_idp._notify_when_dispatcher_t._callback_t'>

Help on class _processor_t_Trampoline_IDB_Hooks in module ida_idp:

class _processor_t_Trampoline_IDB_Hooks(IDB_Hooks)
 |  Proxy of C++ IDB_Hooks class.
 |  
 |  Method resolution order:
 |      _processor_t_Trampoline_IDB_Hooks
 |      IDB_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, proc)
 |      __init__(self, _flags=0) -> IDB_Hooks
 |  
 |  _processor_t_Trampoline_IDB_Hooks__dummy = __dummy(self, *args)
 |  
 |  _processor_t_Trampoline_IDB_Hooks__make_parent_caller = __make_parent_caller(self, key)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from IDB_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_IDB_Hooks(...)
 |      delete_IDB_Hooks(self)
 |  
 |  allsegs_moved(self, *args) -> 'void'
 |      allsegs_moved(self, info)
 |  
 |  auto_empty(self, *args) -> 'void'
 |      auto_empty(self)
 |  
 |  auto_empty_finally(self, *args) -> 'void'
 |      auto_empty_finally(self)
 |  
 |  bookmark_changed(self, *args) -> 'void'
 |      bookmark_changed(self, index, pos, desc)
 |  
 |  byte_patched(self, *args) -> 'void'
 |      byte_patched(self, ea, old_value)
 |  
 |  callee_addr_changed(self, *args) -> 'void'
 |      callee_addr_changed(self, ea, callee)
 |  
 |  changing_cmt(self, *args) -> 'void'
 |      changing_cmt(self, ea, repeatable_cmt, newcmt)
 |  
 |  changing_enum_bf(self, *args) -> 'void'
 |      changing_enum_bf(self, id, new_bf)
 |  
 |  changing_enum_cmt(self, *args) -> 'void'
 |      changing_enum_cmt(self, id, repeatable, newcmt)
 |  
 |  changing_op_ti(self, *args) -> 'void'
 |      changing_op_ti(self, ea, n, new_type, new_fnames)
 |  
 |  changing_op_type(self, *args) -> 'void'
 |      changing_op_type(self, ea, n, opinfo)
 |  
 |  changing_range_cmt(self, *args) -> 'void'
 |      changing_range_cmt(self, kind, a, cmt, repeatable)
 |  
 |  changing_segm_class(self, *args) -> 'void'
 |      changing_segm_class(self, s)
 |  
 |  changing_segm_end(self, *args) -> 'void'
 |      changing_segm_end(self, s, new_end, segmod_flags)
 |  
 |  changing_segm_name(self, *args) -> 'void'
 |      changing_segm_name(self, s, oldname)
 |  
 |  changing_segm_start(self, *args) -> 'void'
 |      changing_segm_start(self, s, new_start, segmod_flags)
 |  
 |  changing_struc_align(self, *args) -> 'void'
 |      changing_struc_align(self, sptr)
 |  
 |  changing_struc_cmt(self, *args) -> 'void'
 |      changing_struc_cmt(self, struc_id, repeatable, newcmt)
 |  
 |  changing_struc_member(self, *args) -> 'void'
 |      changing_struc_member(self, sptr, mptr, flag, ti, nbytes)
 |  
 |  changing_ti(self, *args) -> 'void'
 |      changing_ti(self, ea, new_type, new_fnames)
 |  
 |  closebase(self, *args) -> 'void'
 |      closebase(self)
 |  
 |  cmt_changed(self, *args) -> 'void'
 |      cmt_changed(self, ea, repeatable_cmt)
 |  
 |  compiler_changed(self, *args) -> 'void'
 |      compiler_changed(self)
 |  
 |  deleting_enum(self, *args) -> 'void'
 |      deleting_enum(self, id)
 |  
 |  deleting_enum_member(self, *args) -> 'void'
 |      deleting_enum_member(self, id, cid)
 |  
 |  deleting_func(self, *args) -> 'void'
 |      deleting_func(self, pfn)
 |  
 |  deleting_func_tail(self, *args) -> 'void'
 |      deleting_func_tail(self, pfn, tail)
 |  
 |  deleting_segm(self, *args) -> 'void'
 |      deleting_segm(self, start_ea)
 |  
 |  deleting_struc(self, *args) -> 'void'
 |      deleting_struc(self, sptr)
 |  
 |  deleting_struc_member(self, *args) -> 'void'
 |      deleting_struc_member(self, sptr, mptr)
 |  
 |  deleting_tryblks(self, *args) -> 'void'
 |      deleting_tryblks(self, range)
 |  
 |  destroyed_items(self, *args) -> 'void'
 |      destroyed_items(self, ea1, ea2, will_disable_range)
 |  
 |  determined_main(self, *args) -> 'void'
 |      determined_main(self, main)
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  enum_bf_changed(self, *args) -> 'void'
 |      enum_bf_changed(self, id)
 |  
 |  enum_cmt_changed(self, *args) -> 'void'
 |      enum_cmt_changed(self, id, repeatable)
 |  
 |  enum_created(self, *args) -> 'void'
 |      enum_created(self, id)
 |  
 |  enum_deleted(self, *args) -> 'void'
 |      enum_deleted(self, id)
 |  
 |  enum_member_created(self, *args) -> 'void'
 |      enum_member_created(self, id, cid)
 |  
 |  enum_member_deleted(self, *args) -> 'void'
 |      enum_member_deleted(self, id, cid)
 |  
 |  enum_renamed(self, *args) -> 'void'
 |      enum_renamed(self, id)
 |  
 |  expanding_struc(self, *args) -> 'void'
 |      expanding_struc(self, sptr, offset, delta)
 |  
 |  extlang_changed(self, *args) -> 'void'
 |      extlang_changed(self, kind, el, idx)
 |  
 |  extra_cmt_changed(self, *args) -> 'void'
 |      extra_cmt_changed(self, ea, line_idx, cmt)
 |  
 |  flow_chart_created(self, *args) -> 'void'
 |      flow_chart_created(self, fc)
 |  
 |  frame_deleted(self, *args) -> 'void'
 |      frame_deleted(self, pfn)
 |  
 |  func_added(self, *args) -> 'void'
 |      func_added(self, pfn)
 |  
 |  func_noret_changed(self, *args) -> 'void'
 |      func_noret_changed(self, pfn)
 |  
 |  func_tail_appended(self, *args) -> 'void'
 |      func_tail_appended(self, pfn, tail)
 |  
 |  func_tail_deleted(self, *args) -> 'void'
 |      func_tail_deleted(self, pfn, tail_ea)
 |  
 |  func_updated(self, *args) -> 'void'
 |      func_updated(self, pfn)
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  idasgn_loaded(self, *args) -> 'void'
 |      idasgn_loaded(self, short_sig_name)
 |  
 |  item_color_changed(self, *args) -> 'void'
 |      item_color_changed(self, ea, color)
 |  
 |  kernel_config_loaded(self, *args) -> 'void'
 |      kernel_config_loaded(self)
 |  
 |  loader_finished(self, *args) -> 'void'
 |      loader_finished(self, li, neflags, filetypename)
 |  
 |  local_types_changed(self, *args) -> 'void'
 |      local_types_changed(self)
 |  
 |  make_code(self, *args) -> 'void'
 |      make_code(self, insn)
 |  
 |  make_data(self, *args) -> 'void'
 |      make_data(self, ea, flags, tid, len)
 |  
 |  op_ti_changed(self, *args) -> 'void'
 |      op_ti_changed(self, ea, n, type, fnames)
 |  
 |  op_type_changed(self, *args) -> 'void'
 |      op_type_changed(self, ea, n)
 |  
 |  range_cmt_changed(self, *args) -> 'void'
 |      range_cmt_changed(self, kind, a, cmt, repeatable)
 |  
 |  renamed(self, *args) -> 'void'
 |      renamed(self, ea, new_name, local_name)
 |  
 |  renaming_enum(self, *args) -> 'void'
 |      renaming_enum(self, id, is_enum, newname)
 |  
 |  renaming_struc(self, *args) -> 'void'
 |      renaming_struc(self, id, oldname, newname)
 |  
 |  renaming_struc_member(self, *args) -> 'void'
 |      renaming_struc_member(self, sptr, mptr, newname)
 |  
 |  savebase(self, *args) -> 'void'
 |      savebase(self)
 |  
 |  segm_added(self, *args) -> 'void'
 |      segm_added(self, s)
 |  
 |  segm_attrs_updated(self, *args) -> 'void'
 |      segm_attrs_updated(self, s)
 |  
 |  segm_class_changed(self, *args) -> 'void'
 |      segm_class_changed(self, s, sclass)
 |  
 |  segm_deleted(self, *args) -> 'void'
 |      segm_deleted(self, start_ea, end_ea)
 |  
 |  segm_end_changed(self, *args) -> 'void'
 |      segm_end_changed(self, s, oldend)
 |  
 |  segm_moved(self, *args) -> 'void'
 |      segm_moved(self, _from, to, size, changed_netmap)
 |  
 |  segm_name_changed(self, *args) -> 'void'
 |      segm_name_changed(self, s, name)
 |  
 |  segm_start_changed(self, *args) -> 'void'
 |      segm_start_changed(self, s, oldstart)
 |  
 |  set_func_end(self, *args) -> 'void'
 |      set_func_end(self, pfn, new_end)
 |  
 |  set_func_start(self, *args) -> 'void'
 |      set_func_start(self, pfn, new_start)
 |  
 |  sgr_changed(self, *args) -> 'void'
 |      sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag)
 |  
 |  sgr_deleted(self, *args) -> 'void'
 |      sgr_deleted(self, start_ea, end_ea, regnum)
 |  
 |  stkpnts_changed(self, *args) -> 'void'
 |      stkpnts_changed(self, pfn)
 |  
 |  struc_align_changed(self, *args) -> 'void'
 |      struc_align_changed(self, sptr)
 |  
 |  struc_cmt_changed(self, *args) -> 'void'
 |      struc_cmt_changed(self, struc_id, repeatable_cmt)
 |  
 |  struc_created(self, *args) -> 'void'
 |      struc_created(self, struc_id)
 |  
 |  struc_deleted(self, *args) -> 'void'
 |      struc_deleted(self, struc_id)
 |  
 |  struc_expanded(self, *args) -> 'void'
 |      struc_expanded(self, sptr)
 |  
 |  struc_member_changed(self, *args) -> 'void'
 |      struc_member_changed(self, sptr, mptr)
 |  
 |  struc_member_created(self, *args) -> 'void'
 |      struc_member_created(self, sptr, mptr)
 |  
 |  struc_member_deleted(self, *args) -> 'void'
 |      struc_member_deleted(self, sptr, member_id, offset)
 |  
 |  struc_member_renamed(self, *args) -> 'void'
 |      struc_member_renamed(self, sptr, mptr)
 |  
 |  struc_renamed(self, *args) -> 'void'
 |      struc_renamed(self, sptr)
 |  
 |  tail_owner_changed(self, *args) -> 'void'
 |      tail_owner_changed(self, tail, owner_func, old_owner)
 |  
 |  thunk_func_created(self, *args) -> 'void'
 |      thunk_func_created(self, pfn)
 |  
 |  ti_changed(self, *args) -> 'void'
 |      ti_changed(self, ea, type, fnames)
 |  
 |  tryblks_updated(self, *args) -> 'void'
 |      tryblks_updated(self, tbv)
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  updating_tryblks(self, *args) -> 'void'
 |      updating_tryblks(self, tbv)
 |  
 |  upgraded(self, *args) -> 'void'
 |      upgraded(self, _from)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from IDB_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class asm_t in module ida_idp:

class asm_t(builtins.object)
 |  Proxy of C++ asm_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> asm_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_asm_t(...)
 |      delete_asm_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a_align
 |      asm_t_a_align_get(self) -> char const *
 |  
 |  a_ascii
 |      asm_t_a_ascii_get(self) -> char const *
 |  
 |  a_band
 |      asm_t_a_band_get(self) -> char const *
 |  
 |  a_bnot
 |      asm_t_a_bnot_get(self) -> char const *
 |  
 |  a_bor
 |      asm_t_a_bor_get(self) -> char const *
 |  
 |  a_bss
 |      asm_t_a_bss_get(self) -> char const *
 |  
 |  a_byte
 |      asm_t_a_byte_get(self) -> char const *
 |  
 |  a_comdef
 |      asm_t_a_comdef_get(self) -> char const *
 |  
 |  a_curip
 |      asm_t_a_curip_get(self) -> char const *
 |  
 |  a_double
 |      asm_t_a_double_get(self) -> char const *
 |  
 |  a_dups
 |      asm_t_a_dups_get(self) -> char const *
 |  
 |  a_dword
 |      asm_t_a_dword_get(self) -> char const *
 |  
 |  a_equ
 |      asm_t_a_equ_get(self) -> char const *
 |  
 |  a_extrn
 |      asm_t_a_extrn_get(self) -> char const *
 |  
 |  a_float
 |      asm_t_a_float_get(self) -> char const *
 |  
 |  a_include_fmt
 |      asm_t_a_include_fmt_get(self) -> char const *
 |  
 |  a_mod
 |      asm_t_a_mod_get(self) -> char const *
 |  
 |  a_oword
 |      asm_t_a_oword_get(self) -> char const *
 |  
 |  a_packreal
 |      asm_t_a_packreal_get(self) -> char const *
 |  
 |  a_public
 |      asm_t_a_public_get(self) -> char const *
 |  
 |  a_qword
 |      asm_t_a_qword_get(self) -> char const *
 |  
 |  a_rva
 |      asm_t_a_rva_get(self) -> char const *
 |  
 |  a_seg
 |      asm_t_a_seg_get(self) -> char const *
 |  
 |  a_shl
 |      asm_t_a_shl_get(self) -> char const *
 |  
 |  a_shr
 |      asm_t_a_shr_get(self) -> char const *
 |  
 |  a_sizeof_fmt
 |      asm_t_a_sizeof_fmt_get(self) -> char const *
 |  
 |  a_tbyte
 |      asm_t_a_tbyte_get(self) -> char const *
 |  
 |  a_vstruc_fmt
 |      asm_t_a_vstruc_fmt_get(self) -> char const *
 |  
 |  a_weak
 |      asm_t_a_weak_get(self) -> char const *
 |  
 |  a_word
 |      asm_t_a_word_get(self) -> char const *
 |  
 |  a_xor
 |      asm_t_a_xor_get(self) -> char const *
 |  
 |  a_yword
 |      asm_t_a_yword_get(self) -> char const *
 |  
 |  accsep
 |      asm_t_accsep_get(self) -> char
 |  
 |  ascsep
 |      asm_t_ascsep_get(self) -> char
 |  
 |  cmnt
 |      asm_t_cmnt_get(self) -> char const *
 |  
 |  cmnt2
 |      asm_t_cmnt2_get(self) -> char const *
 |  
 |  end
 |      asm_t_end_get(self) -> char const *
 |  
 |  esccodes
 |      asm_t_esccodes_get(self) -> char const *
 |  
 |  flag
 |      asm_t_flag_get(self) -> uint32
 |  
 |  flag2
 |      asm_t_flag2_get(self) -> uint32
 |  
 |  header
 |      asm_t_header_get(self) -> char const *const *
 |  
 |  help
 |      asm_t_help_get(self) -> help_t
 |  
 |  high16
 |      asm_t_high16_get(self) -> char const *
 |  
 |  high8
 |      asm_t_high8_get(self) -> char const *
 |  
 |  lbrace
 |      asm_t_lbrace_get(self) -> char
 |  
 |  low16
 |      asm_t_low16_get(self) -> char const *
 |  
 |  low8
 |      asm_t_low8_get(self) -> char const *
 |  
 |  name
 |      asm_t_name_get(self) -> char const *
 |  
 |  origin
 |      asm_t_origin_get(self) -> char const *
 |  
 |  rbrace
 |      asm_t_rbrace_get(self) -> char
 |  
 |  thisown
 |      The membership flag
 |  
 |  uflag
 |      asm_t_uflag_get(self) -> uint16

Help on function assemble in module ida_idp:

assemble(*args) -> 'bool'
    assemble(ea, cs, ip, use32, line) -> bool
    
    
    Assemble an instruction into the database (display a warning if an error is found)
    @param ea: linear address of instruction
    @param cs: cs of instruction
    @param ip: ip of instruction
    @param use32: is 32bit segment?
    @param line: line to assemble
    
    @return: Boolean. True on success.

Help on function cfg_get_cc_header_path in module ida_idp:

cfg_get_cc_header_path(*args) -> 'char const *'
    cfg_get_cc_header_path(compid) -> char const *

Help on function cfg_get_cc_parm in module ida_idp:

cfg_get_cc_parm(*args) -> 'char const *'
    cfg_get_cc_parm(compid, name) -> char const *

Help on function cfg_get_cc_predefined_macros in module ida_idp:

cfg_get_cc_predefined_macros(*args) -> 'char const *'
    cfg_get_cc_predefined_macros(compid) -> char const *

Help on function delay_slot_insn in module ida_idp:

delay_slot_insn(*args) -> 'bool'
    delay_slot_insn(ea, bexec, fexec) -> bool
    
    
    Helper function to get the delay slot instruction.
    
    
    @param ea (C++: ea_t *)
    @param bexec (C++: bool *)
    @param fexec (C++: bool *)

Help on function gen_idb_event in module ida_idp:

gen_idb_event(*args) -> 'void'
    gen_idb_event(code)
    
    
    the kernel will use this function to generate idb_events
    
    
    @param code (C++: idb_event::event_code_t)

Help on function get_idb_notifier_addr in module ida_idp:

get_idb_notifier_addr(*args) -> 'PyObject *'
    get_idb_notifier_addr(arg1) -> PyObject *

Help on function get_idb_notifier_ud_addr in module ida_idp:

get_idb_notifier_ud_addr(*args) -> 'PyObject *'
    get_idb_notifier_ud_addr(hooks) -> PyObject *

Help on function get_idp_name in module ida_idp:

get_idp_name(*args) -> 'size_t'
    get_idp_name() -> str
    
    
    Get name of the current processor module. The name is derived from the
    file name. For example, for IBM PC the module is named "pc.w32"
    (windows version), then the module name is "PC" (uppercase). If no
    processor module is loaded, this function will return NULL

Help on function get_idp_notifier_addr in module ida_idp:

get_idp_notifier_addr(*args) -> 'PyObject *'
    get_idp_notifier_addr(arg1) -> PyObject *

Help on function get_idp_notifier_ud_addr in module ida_idp:

get_idp_notifier_ud_addr(*args) -> 'PyObject *'
    get_idp_notifier_ud_addr(hooks) -> PyObject *

Help on function get_reg_info in module ida_idp:

get_reg_info(*args) -> 'char const *'
    get_reg_info(regname, bitrange) -> char const *
    
    
    Get register information - useful for registers like al, ah, dil, etc.
    
    @param regname (C++: const char *)
    @param bitrange (C++: bitrange_t  *)
    @return: NULL no such register

Help on function get_reg_name in module ida_idp:

get_reg_name(*args) -> 'qstring *'
    get_reg_name(reg, width, reghi=-1) -> str
    
    
    Get text representation of a register. For most processors this
    function will just return \ph{reg_names}[reg]. If the processor module
    has implemented processor_t::get_reg_name, it will be used instead
    
    @param reg: internal register number as defined in the processor
                module (C++: int)
    @param width: register width in bytes (C++: size_t)
    @param reghi: if specified, then this function will return the
                  register pair (C++: int)
    @return: length of register name in bytes or -1 if failure

Help on function has_cf_chg in module ida_idp:

has_cf_chg(*args) -> 'bool'
    has_cf_chg(feature, opnum) -> bool
    
    
    Does an instruction with the specified feature modify the i-th
    operand?
    
    
    @param feature (C++: uint32)
    @param opnum (C++: uint)

Help on function has_cf_use in module ida_idp:

has_cf_use(*args) -> 'bool'
    has_cf_use(feature, opnum) -> bool
    
    
    Does an instruction with the specified feature use a value of the i-th
    operand?
    
    
    @param feature (C++: uint32)
    @param opnum (C++: uint)

Help on function has_insn_feature in module ida_idp:

has_insn_feature(*args) -> 'bool'
    has_insn_feature(icode, bit) -> bool
    
    
    Does the specified instruction have the specified feature?
    
    
    @param icode (C++: int)
    @param bit (C++: uint32)

Help on function is_align_insn in module ida_idp:

is_align_insn(*args) -> 'int'
    is_align_insn(ea) -> int
    
    
    If the instruction at 'ea' looks like an alignment instruction, return
    its length in bytes. Otherwise return 0.
    
    @param ea (C++: ea_t)

Help on function is_basic_block_end in module ida_idp:

is_basic_block_end(*args) -> 'bool'
    is_basic_block_end(insn, call_insn_stops_block) -> bool
    
    
    Is the instruction the end of a basic block?
    
    
    @param insn (C++: const  insn_t  &)
    @param call_insn_stops_block (C++: bool)

Help on function is_call_insn in module ida_idp:

is_call_insn(*args) -> 'bool'
    is_call_insn(insn) -> bool
    
    
    Is the instruction a "call"?
    
    
    @param insn (C++: const  insn_t  &)

Help on function is_indirect_jump_insn in module ida_idp:

is_indirect_jump_insn(*args) -> 'bool'
    is_indirect_jump_insn(insn) -> bool
    
    
    Is the instruction an indirect jump?
    
    
    @param insn (C++: const  insn_t  &)

Help on function is_ret_insn in module ida_idp:

is_ret_insn(*args) -> 'bool'
    is_ret_insn(insn, strict=True) -> bool
    
    
    Is the instruction a "return"?
    
    
    @param insn (C++: const  insn_t  &)
    @param strict (C++: bool)

Help on function parse_reg_name in module ida_idp:

parse_reg_name(*args) -> 'bool'
    parse_reg_name(ri, regname) -> bool
    
    
    Get register info by name.
    
    @param ri: result (C++: reg_info_t  *)
    @param regname: name of register (C++: const char *)
    @return: success

Help on __ph in module ida_idp object:

class __ph(builtins.object)
 |  # ----------------------------------------------------------------------
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cnbits
 |  
 |  dnbits
 |  
 |  flag
 |  
 |  icode_return
 |  
 |  id
 |  
 |  instruc
 |  
 |  instruc_end
 |  
 |  instruc_start
 |  
 |  reg_code_sreg
 |  
 |  reg_data_sreg
 |  
 |  reg_first_sreg
 |  
 |  reg_last_sreg
 |  
 |  regnames
 |  
 |  segreg_size
 |  
 |  tbyte_size
 |  
 |  version

Help on function ph_calcrel in module ida_idp:

ph_calcrel(*args) -> 'bytevec_t *'
    ph_calcrel(ea)

Help on function ph_find_op_value in module ida_idp:

ph_find_op_value(*args) -> 'unsigned-ea-like-numeric-type *'↗
    ph_find_op_value(insn, op) -> ssize_t

Help on function ph_find_reg_value in module ida_idp:

ph_find_reg_value(*args) -> 'unsigned-ea-like-numeric-type *'↗
    ph_find_reg_value(insn, reg) -> ssize_t

Help on function ph_get_cnbits in module ida_idp:

ph_get_cnbits(*args) -> 'size_t'
    ph_get_cnbits() -> size_t
    
    
    Returns the 'ph.cnbits'

Help on function ph_get_dnbits in module ida_idp:

ph_get_dnbits(*args) -> 'size_t'
    ph_get_dnbits() -> size_t
    
    
    Returns the 'ph.dnbits'

Help on function ph_get_flag in module ida_idp:

ph_get_flag(*args) -> 'size_t'
    ph_get_flag() -> size_t
    
    
    Returns the 'ph.flag'

Help on function ph_get_icode_return in module ida_idp:

ph_get_icode_return(*args) -> 'size_t'
    ph_get_icode_return() -> size_t
    
    
    Returns the 'ph.icode_return'

Help on function ph_get_id in module ida_idp:

ph_get_id(*args) -> 'size_t'
    ph_get_id() -> size_t
    
    
    Returns the 'ph.id' field

Help on function ph_get_instruc in module ida_idp:

ph_get_instruc(*args) -> 'PyObject *'
    ph_get_instruc() -> PyObject *
    
    
    Returns a list of tuples (instruction_name, instruction_feature) containing the
    instructions list as defined in he processor module

Help on function ph_get_instruc_end in module ida_idp:

ph_get_instruc_end(*args) -> 'size_t'
    ph_get_instruc_end() -> size_t
    
    
    Returns the 'ph.instruc_end'

Help on function ph_get_instruc_start in module ida_idp:

ph_get_instruc_start(*args) -> 'size_t'
    ph_get_instruc_start() -> size_t
    
    
    Returns the 'ph.instruc_start'

Help on function ph_get_operand_info in module ida_idp:

ph_get_operand_info(*args) -> 'PyObject *'
    ph_get_operand_info(ea, n) -> PyObject *
    
    
    Returns the operand information given an ea and operand number.
    
    @param ea: address
    @param n: operand number
    
    @return: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).
             Please refer to idd_opinfo_t structure in the SDK.

Help on function ph_get_reg_code_sreg in module ida_idp:

ph_get_reg_code_sreg(*args) -> 'size_t'
    ph_get_reg_code_sreg() -> size_t
    
    
    Returns the 'ph.reg_code_sreg'

Help on function ph_get_reg_data_sreg in module ida_idp:

ph_get_reg_data_sreg(*args) -> 'size_t'
    ph_get_reg_data_sreg() -> size_t
    
    
    Returns the 'ph.reg_data_sreg'

Help on function ph_get_reg_first_sreg in module ida_idp:

ph_get_reg_first_sreg(*args) -> 'size_t'
    ph_get_reg_first_sreg() -> size_t
    
    
    Returns the 'ph.reg_first_sreg'

Help on function ph_get_reg_last_sreg in module ida_idp:

ph_get_reg_last_sreg(*args) -> 'size_t'
    ph_get_reg_last_sreg() -> size_t
    
    
    Returns the 'ph.reg_last_sreg'

Help on function ph_get_regnames in module ida_idp:

ph_get_regnames(*args) -> 'PyObject *'
    ph_get_regnames() -> PyObject *
    
    
    Returns the list of register names as defined in the processor module

Help on function ph_get_segreg_size in module ida_idp:

ph_get_segreg_size(*args) -> 'size_t'
    ph_get_segreg_size() -> size_t
    
    
    Returns the 'ph.segreg_size'

Help on function ph_get_tbyte_size in module ida_idp:

ph_get_tbyte_size(*args) -> 'size_t'
    ph_get_tbyte_size() -> size_t
    
    
    Returns the 'ph.tbyte_size' field as defined in he processor module

Help on function ph_get_version in module ida_idp:

ph_get_version(*args) -> 'size_t'
    ph_get_version() -> size_t
    
    
    Returns the 'ph.version'

Help on class processor_t in module ida_idp:

class processor_t(IDP_Hooks)
 |  Proxy of C++ IDP_Hooks class.
 |  
 |  Method resolution order:
 |      processor_t
 |      IDP_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |      __init__(self, _flags=0) -> IDP_Hooks
 |  
 |  _get_idb_notifier_addr(self)
 |  
 |  _get_idb_notifier_ud_addr(self)
 |  
 |  _get_idp_notifier_addr(self)
 |  
 |  _get_idp_notifier_ud_addr(self)
 |  
 |  _get_notify(self, what, unimp_val=0, imp_forced_val=None, add_prefix=True, mandatory_impl=None)
 |      This helper is used to implement backward-compatibility
 |      of pre IDA 7.3 processor_t interfaces.
 |  
 |  _make_forced_value_wrapper(self, val, meth=None)
 |  
 |  _make_int_returning_wrapper(self, meth, intval=0)
 |  
 |  auto_empty(self, *args)
 |  
 |  auto_empty_finally(self, *args)
 |  
 |  closebase(self, *args)
 |  
 |  compiler_changed(self, *args)
 |  
 |  deleting_func(self, pfn)
 |  
 |  determined_main(self, *args)
 |  
 |  ev_ana_insn(self, *args)
 |      ev_ana_insn(self, out) -> bool
 |      
 |      
 |      Analyzes and decodes an instruction at insn.ea
 |         - insn.itype must be set >= idaapi.CUSTOM_CMD_ITYPE
 |         - insn.size must be set to the instruction length
 |      
 |      @return: Boolean
 |          - False if the instruction is not recognized
 |          - True if the instruction was decoded. 'insn' should be filled in that case.
 |  
 |  ev_assemble(self, *args)
 |      ev_assemble(self, ea, cs, ip, use32, line) -> PyObject *
 |      
 |      
 |      Assembles an instruction
 |      
 |      @param ea: linear address of instruction
 |      @param cs: cs of instruction
 |      @param ip: ip of instruction
 |      @param use32: is 32bit segment?
 |      @param line: line to assemble
 |      
 |      @return: - None to let the underlying processor module assemble the line
 |               - or a string containing the assembled buffer
 |  
 |  ev_auto_queue_empty(self, *args)
 |      ev_auto_queue_empty(self, type)
 |  
 |  ev_calc_step_over(self, target, ip)
 |      ev_calc_step_over(self, target, ip) -> int
 |  
 |  ev_can_have_type(self, *args)
 |      ev_can_have_type(self, op) -> int
 |  
 |  ev_cmp_operands(self, *args)
 |      ev_cmp_operands(self, op1, op2) -> int
 |  
 |  ev_coagulate(self, *args)
 |      ev_coagulate(self, start_ea) -> int
 |  
 |  ev_coagulate_dref(self, from_ea, to_ea, may_define, _code_ea)
 |      ev_coagulate_dref(self, _from, to, may_define, code_ea) -> int
 |  
 |  ev_create_func_frame(self, pfn)
 |      ev_create_func_frame(self, pfn) -> int
 |  
 |  ev_create_switch_xrefs(self, *args)
 |      ev_create_switch_xrefs(self, jumpea, si) -> int
 |  
 |  ev_creating_segm(self, s)
 |      ev_creating_segm(self, seg) -> int
 |  
 |  ev_emu_insn(self, *args)
 |      ev_emu_insn(self, insn) -> bool
 |      
 |      
 |      Emulate instruction, create cross-references, plan to analyze
 |      subsequent instructions, modify flags etc. Upon entrance to this function
 |      all information about the instruction is in 'insn' structure.
 |      
 |      @return: Boolean (whether this instruction has been emulated or not)
 |  
 |  ev_endbinary(self, *args)
 |      ev_endbinary(self, ok) -> int
 |  
 |  ev_func_bounds(self, _possible_return_code, pfn, max_func_end_ea)
 |      ev_func_bounds(self, possible_return_code, pfn, max_func_end_ea)
 |  
 |  ev_gen_map_file(self, nlines, fp)
 |      ev_gen_map_file(self, nlines, fp) -> int
 |  
 |  ev_gen_regvar_def(self, ctx, v)
 |      ev_gen_regvar_def(self, outctx, v) -> int
 |  
 |  ev_gen_src_file_lnnum(self, *args)
 |      ev_gen_src_file_lnnum(self, outctx, file, lnnum) -> int
 |  
 |  ev_get_autocmt(self, *args)
 |      ev_get_autocmt(self, insn) -> PyObject *
 |  
 |  ev_get_frame_retsize(self, frsize, pfn)
 |      ev_get_frame_retsize(self, frsize, pfn) -> int
 |  
 |  ev_get_operand_string(self, buf, insn, opnum)
 |      ev_get_operand_string(self, insn, opnum) -> PyObject *
 |  
 |  ev_is_align_insn(self, *args)
 |      ev_is_align_insn(self, ea) -> int
 |  
 |  ev_is_alloca_probe(self, *args)
 |      ev_is_alloca_probe(self, ea) -> int
 |  
 |  ev_is_basic_block_end(self, *args)
 |      ev_is_basic_block_end(self, insn, call_insn_stops_block) -> int
 |  
 |  ev_is_call_insn(self, *args)
 |      ev_is_call_insn(self, insn) -> int
 |      
 |      
 |      Is the instruction a "call"?
 |      
 |      @param insn: instruction
 |      @return: 0-unknown, 1-yes, -1-no
 |  
 |  ev_is_far_jump(self, *args)
 |      ev_is_far_jump(self, icode) -> int
 |  
 |  ev_is_indirect_jump(self, *args)
 |      ev_is_indirect_jump(self, insn) -> int
 |  
 |  ev_is_insn_table_jump(self, *args)
 |      ev_is_insn_table_jump(self, insn) -> int
 |  
 |  ev_is_ret_insn(self, *args)
 |      ev_is_ret_insn(self, insn, strict) -> int
 |      
 |      
 |      Is the instruction a "return"?
 |      
 |      @param insn: instruction
 |      @param strict: - True: report only ret instructions
 |                       False: include instructions like "leave" which begins the function epilog
 |      @return: 0-unknown, 1-yes, -1-no
 |  
 |  ev_is_sane_insn(self, *args)
 |      ev_is_sane_insn(self, insn, no_crefs) -> int
 |      
 |      
 |      is the instruction sane for the current file type?
 |      @param insn: the instruction
 |      @param no_crefs:
 |            - 1: the instruction has no code refs to it.
 |                 ida just tries to convert unexplored bytes
 |                 to an instruction (but there is no other
 |                 reason to convert them into an instruction)
 |            - 0: the instruction is created because
 |                 of some coderef, user request or another
 |                 weighty reason.
 |      @return: >=0-ok, <0-no, the instruction isn't likely to appear in the program
 |  
 |  ev_is_sp_based(self, mode, insn, op)
 |      ev_is_sp_based(self, mode, insn, op) -> int
 |  
 |  ev_is_switch(self, *args)
 |      ev_is_switch(self, si, insn) -> int
 |  
 |  ev_may_be_func(self, *args)
 |      ev_may_be_func(self, insn, state) -> int
 |      
 |      
 |      Can a function start here?
 |      @param insn: the instruction
 |      @param state: autoanalysis phase
 |            0: creating functions
 |            1: creating chunks
 |      
 |      @return: integer (probability 0..100)
 |  
 |  ev_may_show_sreg(self, *args)
 |      ev_may_show_sreg(self, current_ea) -> int
 |  
 |  ev_moving_segm(self, s, to_ea, flags)
 |      ev_moving_segm(self, seg, to, flags) -> int
 |  
 |  ev_newbinary(self, *args)
 |      ev_newbinary(self, filename, fileoff, basepara, binoff, nbytes) -> int
 |  
 |  ev_newfile(self, *args)
 |      ev_newfile(self, fname) -> int
 |  
 |  ev_newprc(self, *args)
 |      ev_newprc(self, pnum, keep_cfg) -> int
 |  
 |  ev_oldfile(self, *args)
 |      ev_oldfile(self, fname) -> int
 |  
 |  ev_out_assumes(self, *args)
 |      ev_out_assumes(self, outctx) -> int
 |  
 |  ev_out_data(self, *args)
 |      ev_out_data(self, outctx, analyze_only) -> int
 |  
 |  ev_out_footer(self, *args)
 |      ev_out_footer(self, outctx)
 |  
 |  ev_out_header(self, *args)
 |      ev_out_header(self, outctx)
 |  
 |  ev_out_insn(self, *args)
 |      ev_out_insn(self, outctx) -> bool
 |      
 |      
 |      Outputs the instruction defined in 'ctx.insn'
 |      
 |      @return: Boolean (whether this instruction can be outputted or not)
 |  
 |  ev_out_label(self, *args)
 |      ev_out_label(self, outctx, colored_name) -> int
 |  
 |  ev_out_mnem(self, *args)
 |      ev_out_mnem(self, outctx) -> int
 |  
 |  ev_out_operand(self, *args)
 |      ev_out_operand(self, outctx, op) -> bool
 |      
 |      
 |      Notification to generate operand text.
 |      If False was returned, then the standard operand output function will be called.
 |      
 |      this notification may use out_...() functions to form the operand text
 |      
 |      @return: Boolean (whether the operand has been outputted or not)
 |  
 |  ev_out_segend(self, ctx, s)
 |      ev_out_segend(self, outctx, seg) -> int
 |  
 |  ev_out_segstart(self, ctx, s)
 |      ev_out_segstart(self, outctx, seg) -> int
 |  
 |  ev_out_special_item(self, *args)
 |      ev_out_special_item(self, outctx, segtype) -> int
 |  
 |  ev_rename(self, *args)
 |      ev_rename(self, ea, new_name) -> int
 |      
 |      
 |      The kernel is going to rename a byte.
 |      
 |      @param ea: Address
 |      @param new_name: The new name
 |      
 |      @return:
 |          - If returns value <0, then the kernel should
 |            not rename it. See also the 'renamed' event
 |  
 |  ev_set_idp_options(self, keyword, value_type, value)
 |      ev_set_idp_options(self, keyword, value_type, value, errbuf, idb_loaded) -> int
 |  
 |  ev_set_proc_options(self, *args)
 |      ev_set_proc_options(self, options, confidence) -> int
 |  
 |  ev_str2reg(self, *args)
 |      ev_str2reg(self, regname) -> int
 |  
 |  ev_treat_hindering_item(self, *args)
 |      ev_treat_hindering_item(self, hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> int
 |  
 |  ev_undefine(self, *args)
 |      ev_undefine(self, ea) -> int
 |      
 |      
 |      An item in the database (insn or data) is being deleted
 |      @param ea: Address
 |      @return:
 |          - 1 - do not delete srranges at the item end
 |          - 0 - srranges can be deleted
 |  
 |  ev_validate_flirt_func(self, *args)
 |      ev_validate_flirt_func(self, start_ea, funcname) -> int
 |  
 |  ev_verify_noreturn(self, pfn)
 |      ev_verify_noreturn(self, pfn) -> int
 |  
 |  ev_verify_sp(self, pfn)
 |      ev_verify_sp(self, pfn) -> int
 |  
 |  func_added(self, pfn)
 |  
 |  get_auxpref(self, insn)
 |      This function returns insn.auxpref value
 |  
 |  get_idpdesc(self)
 |      This function must be present and should return the list of
 |      short processor names similar to the one in ph.psnames.
 |      This method can be overridden to return to the kernel a different IDP description.
 |  
 |  get_uFlag(self)
 |      Use this utility function to retrieve the 'uFlag' global variable
 |  
 |  idasgn_loaded(self, *args)
 |  
 |  kernel_config_loaded(self, *args)
 |  
 |  make_code(self, *args)
 |  
 |  make_data(self, *args)
 |  
 |  renamed(self, *args)
 |  
 |  savebase(self, *args)
 |  
 |  segm_moved(self, from_ea, to_ea, size, changed_netmap)
 |  
 |  set_func_end(self, *args)
 |  
 |  set_func_start(self, *args)
 |  
 |  sgr_changed(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __idc_cvt_id__ = 2
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from IDP_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_IDP_Hooks(...)
 |      delete_IDP_Hooks(self)
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  ev_add_cref(self, *args) -> 'int'
 |      ev_add_cref(self, _from, to, type) -> int
 |  
 |  ev_add_dref(self, *args) -> 'int'
 |      ev_add_dref(self, _from, to, type) -> int
 |  
 |  ev_adjust_argloc(self, *args) -> 'int'
 |      ev_adjust_argloc(self, argloc, optional_type, size) -> int
 |  
 |  ev_adjust_libfunc_ea(self, *args) -> 'int'
 |      ev_adjust_libfunc_ea(self, sig, libfun, ea) -> int
 |  
 |  ev_adjust_refinfo(self, *args) -> 'int'
 |      ev_adjust_refinfo(self, ri, ea, n, fd) -> int
 |  
 |  ev_analyze_prolog(self, *args) -> 'int'
 |      ev_analyze_prolog(self, ea) -> int
 |  
 |  ev_arg_addrs_ready(self, *args) -> 'int'
 |      ev_arg_addrs_ready(self, caller, n, tif, addrs) -> int
 |  
 |  ev_calc_arglocs(self, *args) -> 'int'
 |      ev_calc_arglocs(self, fti) -> int
 |  
 |  ev_calc_cdecl_purged_bytes(self, *args) -> 'int'
 |      ev_calc_cdecl_purged_bytes(self, ea) -> int
 |  
 |  ev_calc_next_eas(self, *args) -> 'int'
 |      ev_calc_next_eas(self, res, insn, over) -> int
 |  
 |  ev_calc_purged_bytes(self, *args) -> 'int'
 |      ev_calc_purged_bytes(self, p_purged_bytes, fti) -> int
 |  
 |  ev_calc_retloc(self, *args) -> 'int'
 |      ev_calc_retloc(self, retloc, rettype, cc) -> int
 |  
 |  ev_calc_spdelta(self, *args) -> 'int'
 |      ev_calc_spdelta(self, spdelta, insn) -> int
 |  
 |  ev_calc_switch_cases(self, *args) -> 'int'
 |      ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -> int
 |  
 |  ev_calc_varglocs(self, *args) -> 'int'
 |      ev_calc_varglocs(self, ftd, aux_regs, aux_stkargs, nfixed) -> int
 |  
 |  ev_calcrel(self, *args) -> 'int'
 |      ev_calcrel(self) -> int
 |  
 |  ev_clean_tbit(self, *args) -> 'int'
 |      ev_clean_tbit(self, ea, getreg, regvalues) -> int
 |  
 |  ev_create_flat_group(self, *args) -> 'int'
 |      ev_create_flat_group(self, image_base, bitness, dataseg_sel) -> int
 |  
 |  ev_decorate_name(self, *args) -> 'PyObject *'
 |      ev_decorate_name(self, name, mangle, cc, optional_type) -> PyObject *
 |  
 |  ev_del_cref(self, *args) -> 'int'
 |      ev_del_cref(self, _from, to, expand) -> int
 |  
 |  ev_del_dref(self, *args) -> 'int'
 |      ev_del_dref(self, _from, to) -> int
 |  
 |  ev_delay_slot_insn(self, *args) -> 'PyObject *'
 |      ev_delay_slot_insn(self, ea, bexec, fexec) -> PyObject *
 |  
 |  ev_demangle_name(self, *args) -> 'PyObject *'
 |      ev_demangle_name(self, name, disable_mask, demreq) -> PyObject *
 |  
 |  ev_ending_undo(self, *args) -> 'int'
 |      ev_ending_undo(self, action_name, is_undo) -> int
 |  
 |  ev_equal_reglocs(self, *args) -> 'int'
 |      ev_equal_reglocs(self, a1, a2) -> int
 |  
 |  ev_extract_address(self, *args) -> 'int'
 |      ev_extract_address(self, out_ea, screen_ea, string, position) -> int
 |  
 |  ev_find_op_value(self, *args) -> 'PyObject *'
 |      ev_find_op_value(self, pinsn, opn) -> PyObject *
 |  
 |  ev_find_reg_value(self, *args) -> 'PyObject *'
 |      ev_find_reg_value(self, pinsn, reg) -> PyObject *
 |  
 |  ev_gen_asm_or_lst(self, *args) -> 'void'
 |      ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline)
 |  
 |  ev_gen_stkvar_def(self, *args) -> 'int'
 |      ev_gen_stkvar_def(self, outctx, mptr, v) -> int
 |  
 |  ev_get_abi_info(self, *args) -> 'int'
 |      ev_get_abi_info(self, abi_names, abi_opts, comp) -> int
 |  
 |  ev_get_bg_color(self, *args) -> 'int'
 |      ev_get_bg_color(self, ea) -> int or None
 |  
 |  ev_get_cc_regs(self, *args) -> 'int'
 |      ev_get_cc_regs(self, regs, cc) -> int
 |  
 |  ev_get_code16_mode(self, *args) -> 'int'
 |      ev_get_code16_mode(self, ea) -> int
 |  
 |  ev_get_dbr_opnum(self, *args) -> 'int'
 |      ev_get_dbr_opnum(self, opnum, insn) -> int
 |  
 |  ev_get_default_enum_size(self, *args) -> 'int'
 |      ev_get_default_enum_size(self, cm) -> int
 |  
 |  ev_get_macro_insn_head(self, *args) -> 'int'
 |      ev_get_macro_insn_head(self, head, ip) -> int
 |  
 |  ev_get_reg_info(self, *args) -> 'int'
 |      ev_get_reg_info(self, main_regname, bitrange, regname) -> int
 |  
 |  ev_get_reg_name(self, *args) -> 'PyObject *'
 |      ev_get_reg_name(self, reg, width, reghi) -> PyObject *
 |  
 |  ev_get_simd_types(self, *args) -> 'int'
 |      ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -> int
 |  
 |  ev_get_stkarg_offset(self, *args) -> 'int'
 |      ev_get_stkarg_offset(self) -> int
 |  
 |  ev_get_stkvar_scale_factor(self, *args) -> 'int'
 |      ev_get_stkvar_scale_factor(self) -> int
 |  
 |  ev_getreg(self, *args) -> 'int'
 |      ev_getreg(self, regval, regnum) -> int
 |  
 |  ev_init(self, *args) -> 'int'
 |      ev_init(self, idp_modname) -> int
 |  
 |  ev_insn_reads_tbit(self, *args) -> 'int'
 |      ev_insn_reads_tbit(self, insn, getreg, regvalues) -> int
 |  
 |  ev_is_cond_insn(self, *args) -> 'int'
 |      ev_is_cond_insn(self, insn) -> int
 |  
 |  ev_is_jump_func(self, *args) -> 'int'
 |      ev_is_jump_func(self, pfn, jump_target, func_pointer) -> int
 |  
 |  ev_last_cb_before_loader(self, *args) -> 'int'
 |      ev_last_cb_before_loader(self) -> int
 |  
 |  ev_loader(self, *args) -> 'int'
 |      ev_loader(self) -> int
 |  
 |  ev_lower_func_type(self, *args) -> 'int'
 |      ev_lower_func_type(self, argnums, fti) -> int
 |  
 |  ev_max_ptr_size(self, *args) -> 'int'
 |      ev_max_ptr_size(self) -> int
 |  
 |  ev_newasm(self, *args) -> 'int'
 |      ev_newasm(self, asmnum) -> int
 |  
 |  ev_next_exec_insn(self, *args) -> 'int'
 |      ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -> int
 |  
 |  ev_realcvt(self, *args) -> 'int'
 |      ev_realcvt(self, m, e, swt) -> int
 |  
 |  ev_replaying_undo(self, *args) -> 'int'
 |      ev_replaying_undo(self, action_name, vec, is_undo) -> int
 |  
 |  ev_set_code16_mode(self, *args) -> 'int'
 |      ev_set_code16_mode(self, ea, code16) -> int
 |  
 |  ev_setup_til(self, *args) -> 'void'
 |      ev_setup_til(self)
 |  
 |  ev_shadow_args_size(self, *args) -> 'int'
 |      ev_shadow_args_size(self, shadow_args_size, pfn) -> int
 |  
 |  ev_term(self, *args) -> 'int'
 |      ev_term(self) -> int
 |  
 |  ev_use_arg_types(self, *args) -> 'int'
 |      ev_use_arg_types(self, ea, fti, rargs) -> int
 |  
 |  ev_use_regarg_type(self, *args) -> 'PyObject *'
 |      ev_use_regarg_type(self, ea, rargs) -> PyObject *
 |  
 |  ev_use_stkarg_type(self, *args) -> 'int'
 |      ev_use_stkarg_type(self, ea, arg) -> int
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |      
 |      
 |      Creates an IDP hook
 |      
 |      @return: Boolean true on success
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |      
 |      
 |      Removes the IDP hook
 |      @return: Boolean true on success
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from IDP_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class reg_info_t in module ida_idp:

class reg_info_t(builtins.object)
 |  Proxy of C++ reg_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reg_info_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_reg_info_t(...)
 |      delete_reg_info_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  reg
 |      reg_info_t_reg_get(self) -> int
 |  
 |  size
 |      reg_info_t_size_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function set_processor_type in module ida_idp:

set_processor_type(*args) -> 'bool'
    set_processor_type(procname, level) -> bool
    
    
    Set target processor type. Once a processor module is loaded, it
    cannot be replaced until we close the idb.
    
    @param procname: name of processor type (one of names present in
                     \ph{psnames}) (C++: const char *)
    @param level: SETPROC_ (C++: setproc_level_t)
    @return: success

Help on function set_target_assembler in module ida_idp:

set_target_assembler(*args) -> 'bool'
    set_target_assembler(asmnum) -> bool
    
    
    Set target assembler.
    
    @param asmnum: number of assembler in the current processor module
                   (C++: int)
    @return: success

Help on function sizeof_ldbl in module ida_idp:

sizeof_ldbl(*args) -> 'size_t'
    sizeof_ldbl() -> size_t
    
    
    Get size of long double.

Help on function str2reg in module ida_idp:

str2reg(*args) -> 'int'
    str2reg(p) -> int
    
    
    Get any reg number (-1 on error)
    
    
    @param p (C++: const char *)

=== ida_idp EPYDOC INJECTIONS ===
ida_idp.AS2_BRACE
"""
Use braces for all expressions.
"""

ida_idp.AS2_BYTE1CHAR
"""
Meaningful only for wide byte processors.

One symbol per processor byte
"""

ida_idp.AS2_COLONSUF
"""
addresses may have ":xx" suffix this suffix must be ignored when
extracting the address under the cursor
"""

ida_idp.AS2_IDEALDSCR
"""
Description of struc/union is in the 'reverse' form (keyword before
name) the same as in borland tasm ideal
"""

ida_idp.AS2_STRINV
"""
(For processors with bytes bigger than 8 bits)

Invert meaning of \\inf{wide_high_byte_first} for text strings
"""

ida_idp.AS2_TERSESTR
"""
NAME<fld,fld,...> is supported.

'terse' structure initialization form
"""

ida_idp.AS2_YWORD
"""
a_yword field is present and valid
"""

ida_idp.ASB_BINF0
"""
010101b
"""

ida_idp.ASB_BINF1
"""
^B010101
"""

ida_idp.ASB_BINF2
"""
%010101
"""

ida_idp.ASB_BINF3
"""
0b1010101
"""

ida_idp.ASB_BINF4
"""
b'1010101
"""

ida_idp.ASB_BINF5
"""
b'1010101'
"""

ida_idp.ASD_DECF0
"""
34
"""

ida_idp.ASD_DECF1
"""
#34
"""

ida_idp.ASD_DECF3
"""
.34
"""

ida_idp.ASH_HEXF0
"""
34h
"""

ida_idp.ASH_HEXF1
"""
h'34
"""

ida_idp.ASH_HEXF2
"""
34
"""

ida_idp.ASH_HEXF3
"""
0x34
"""

ida_idp.ASH_HEXF4
"""
$34
"""

ida_idp.ASH_HEXF5
"""
<^R > (radix)
"""

ida_idp.ASO_OCTF0
"""
123o
"""

ida_idp.ASO_OCTF1
"""
0123
"""

ida_idp.ASO_OCTF2
"""
123
"""

ida_idp.ASO_OCTF3
"""
@123
"""

ida_idp.ASO_OCTF4
"""
o'123
"""

ida_idp.ASO_OCTF5
"""
123q
"""

ida_idp.ASO_OCTF6
"""
~123
"""

ida_idp.ASO_OCTF7
"""
q'123
"""

ida_idp.AS_1TEXT
"""
1 text per line, no bytes
"""

ida_idp.AS_2CHRE
"""
double char constants are: "xy
"""

ida_idp.AS_ALIGN2
"""
(.align 5 means to align at 32byte boundary)

.align directive expects an exponent rather than a power of 2
"""

ida_idp.AS_ASCIIC
"""
(\\n,\\x01 and similar)

ascii directive accepts C-like escape sequences
"""

ida_idp.AS_ASCIIZ
"""
ascii directive inserts implicit zero byte at the end
"""

ida_idp.AS_BINFM
"""
mask - binary number format
"""

ida_idp.AS_COLON
"""
create colons after data names ?
"""

ida_idp.AS_DECFM
"""
mask - decimal number format
"""

ida_idp.AS_HEXFM
"""
mask - hex number format
"""

ida_idp.AS_LALIGN
"""
Labels at "align" keyword are supported.
"""

ida_idp.AS_N2CHR
"""
can't have 2 byte char consts
"""

ida_idp.AS_NCHRE
"""
char constants are: 'x
"""

ida_idp.AS_NCMAS
"""
no commas in ascii directives
"""

ida_idp.AS_NHIAS
"""
no characters with high bit
"""

ida_idp.AS_NOCODECLN
"""
don't create colons after code names
"""

ida_idp.AS_NOSPACE
"""
No spaces in expressions.
"""

ida_idp.AS_NOXRF
"""
Disable xrefs during the output file generation.
"""

ida_idp.AS_OCTFM
"""
mask - octal number format
"""

ida_idp.AS_OFFST
"""
offsets are 'offset xxx' ?
"""

ida_idp.AS_ONEDUP
"""
One array definition per line.
"""

ida_idp.AS_RELSUP
"""
Checkarg: 'and','or','xor' operations with addresses are possible.
"""

ida_idp.AS_UDATA
"""
can use '?' in data directives
"""

ida_idp.AS_UNEQU
"""
replace undefined data items with EQU (for ANTA's A80)
"""

ida_idp.AS_XTRNTYPE
"""
Assembler understands type of extern symbols as ":type" suffix.
"""

ida_idp.CF_CALL
"""
CALL instruction (should make a procedure here)
"""

ida_idp.CF_CHG1
"""
The instruction modifies the first operand.
"""

ida_idp.CF_CHG2
"""
The instruction modifies the second operand.
"""

ida_idp.CF_CHG3
"""
The instruction modifies the third operand.
"""

ida_idp.CF_CHG4
"""
The instruction modifies 4 operand.
"""

ida_idp.CF_CHG5
"""
The instruction modifies 5 operand.
"""

ida_idp.CF_CHG6
"""
The instruction modifies 6 operand.
"""

ida_idp.CF_HLL
"""
language function.

Instruction may be present in a high level
"""

ida_idp.CF_JUMP
"""
jump or call (thus needs additional analysis)

The instruction passes execution using indirect
"""

ida_idp.CF_SHFT
"""
Bit-shift instruction (shl,shr...)
"""

ida_idp.CF_STOP
"""
next instruction

Instruction doesn't pass execution to the
"""

ida_idp.CF_USE1
"""
The instruction uses value of the first operand.
"""

ida_idp.CF_USE2
"""
The instruction uses value of the second operand.
"""

ida_idp.CF_USE3
"""
The instruction uses value of the third operand.
"""

ida_idp.CF_USE4
"""
The instruction uses value of the 4 operand.
"""

ida_idp.CF_USE5
"""
The instruction uses value of the 5 operand.
"""

ida_idp.CF_USE6
"""
The instruction uses value of the 6 operand.
"""

ida_idp.CUSTOM_INSN_ITYPE
"""
Custom instruction codes defined by processor extension plugins must
be greater than or equal to this
"""

ida_idp.IDP_INTERFACE_VERSION
"""
The interface version number.see also 'IDA_SDK_VERSION' from 'pro.h'
"""

ida_idp.OP_FP_BASED
"""
operand is FP based
"""

ida_idp.OP_SP_ADD
"""
operand value is added to the pointer
"""

ida_idp.OP_SP_BASED
"""
operand is SP based
"""

ida_idp.OP_SP_SUB
"""
operand value is subtracted from the pointer
"""

ida_idp.PLFM_386
"""
Intel 80x86.
"""

ida_idp.PLFM_6502
"""
6502
"""

ida_idp.PLFM_65C816
"""
65802/65816
"""

ida_idp.PLFM_6800
"""
Motorola 68xx.
"""

ida_idp.PLFM_68K
"""
Motorola 680x0.
"""

ida_idp.PLFM_80196
"""
Intel 80196.
"""

ida_idp.PLFM_8051
"""
8051
"""

ida_idp.PLFM_AD2106X
"""
Analog Devices ADSP 2106X.
"""

ida_idp.PLFM_AD218X
"""
Analog Devices ADSP 218X.
"""

ida_idp.PLFM_ALPHA
"""
DEC Alpha.
"""

ida_idp.PLFM_ARC
"""
Argonaut RISC Core.
"""

ida_idp.PLFM_ARM
"""
Advanced RISC Machines.
"""

ida_idp.PLFM_AVR
"""
Atmel 8-bit RISC processor(s)
"""

ida_idp.PLFM_C166
"""
Siemens C166 family.
"""

ida_idp.PLFM_C39
"""
Rockwell C39.
"""

ida_idp.PLFM_CR16
"""
NSC CR16.
"""

ida_idp.PLFM_DALVIK
"""
Android Dalvik Virtual Machine.
"""

ida_idp.PLFM_DSP56K
"""
Motorola DSP5600x.
"""

ida_idp.PLFM_DSP96K
"""
Motorola DSP96000.
"""

ida_idp.PLFM_EBC
"""
EFI Bytecode.
"""

ida_idp.PLFM_F2MC
"""
Fujistu F2MC-16.
"""

ida_idp.PLFM_FR
"""
Fujitsu FR Family.
"""

ida_idp.PLFM_H8
"""
Hitachi H8/300, H8/2000.
"""

ida_idp.PLFM_H8500
"""
Hitachi H8/500.
"""

ida_idp.PLFM_HPPA
"""
Hewlett-Packard PA-RISC.
"""

ida_idp.PLFM_I860
"""
Intel 860.
"""

ida_idp.PLFM_I960
"""
Intel 960.
"""

ida_idp.PLFM_IA64
"""
Intel Itanium IA64.
"""

ida_idp.PLFM_JAVA
"""
Java.
"""

ida_idp.PLFM_KR1878
"""
Angstrem KR1878.
"""

ida_idp.PLFM_M16C
"""
Renesas M16C.
"""

ida_idp.PLFM_M32R
"""
Mitsubishi 32bit RISC.
"""

ida_idp.PLFM_M740
"""
Mitsubishi 8bit.
"""

ida_idp.PLFM_M7700
"""
Mitsubishi 16bit.
"""

ida_idp.PLFM_M7900
"""
Mitsubishi 7900.
"""

ida_idp.PLFM_MC6812
"""
Motorola 68HC12.
"""

ida_idp.PLFM_MC6816
"""
Motorola 68HC16.
"""

ida_idp.PLFM_MIPS
"""
MIPS.
"""

ida_idp.PLFM_MN102L00
"""
Panasonic MN10200.
"""

ida_idp.PLFM_MSP430
"""
Texas Instruments MSP430.
"""

ida_idp.PLFM_NEC_78K0
"""
NEC 78K0.
"""

ida_idp.PLFM_NEC_78K0S
"""
NEC 78K0S.
"""

ida_idp.PLFM_NEC_V850X
"""
NEC V850 and V850ES/E1/E2.
"""

ida_idp.PLFM_NET
"""
Microsoft Visual Studio.Net.
"""

ida_idp.PLFM_OAKDSP
"""
Atmel OAK DSP.
"""

ida_idp.PLFM_PDP
"""
PDP11.
"""

ida_idp.PLFM_PIC
"""
Microchip's PIC.
"""

ida_idp.PLFM_PIC16
"""
Microchip's 16-bit PIC.
"""

ida_idp.PLFM_PPC
"""
PowerPC.
"""

ida_idp.PLFM_S390
"""
IBM's S390.
"""

ida_idp.PLFM_SCR_ADPT
"""
Processor module adapter for processor modules written in scripting
languages.
"""

ida_idp.PLFM_SH
"""
Renesas (formerly Hitachi) SuperH.
"""

ida_idp.PLFM_SPARC
"""
SPARC.
"""

ida_idp.PLFM_SPC700
"""
Sony SPC700.
"""

ida_idp.PLFM_SPU
"""
Cell Broadband Engine Synergistic Processor Unit.
"""

ida_idp.PLFM_ST20
"""
SGS-Thomson ST20.
"""

ida_idp.PLFM_ST7
"""
SGS-Thomson ST7.
"""

ida_idp.PLFM_ST9
"""
ST9+.
"""

ida_idp.PLFM_TLCS900
"""
Toshiba TLCS-900.
"""

ida_idp.PLFM_TMS
"""
Texas Instruments TMS320C5x.
"""

ida_idp.PLFM_TMS320C1X
"""
Texas Instruments TMS320C1x.
"""

ida_idp.PLFM_TMS320C28
"""
Texas Instruments TMS320C28x.
"""

ida_idp.PLFM_TMS320C3
"""
Texas Instruments TMS320C3.
"""

ida_idp.PLFM_TMS320C54
"""
Texas Instruments TMS320C54xx.
"""

ida_idp.PLFM_TMS320C55
"""
Texas Instruments TMS320C55xx.
"""

ida_idp.PLFM_TMSC6
"""
Texas Instruments TMS320C6x.
"""

ida_idp.PLFM_TRICORE
"""
Tasking Tricore.
"""

ida_idp.PLFM_TRIMEDIA
"""
Trimedia.
"""

ida_idp.PLFM_UNSP
"""
SunPlus unSP.
"""

ida_idp.PLFM_Z8
"""
Z8.
"""

ida_idp.PLFM_Z80
"""
8085, Z80
"""

ida_idp.PRN_BIN
"""
binary
"""

ida_idp.PRN_DEC
"""
decimal
"""

ida_idp.PRN_HEX
"""
hex
"""

ida_idp.PRN_OCT
"""
octal
"""

ida_idp.PR_ADJSEGS
"""
IDA may adjust segments' starting/ending addresses.
"""

ida_idp.PR_ALIGN
"""
All data items should be aligned properly.
"""

ida_idp.PR_ALIGN_INSN
"""
allow ida to create alignment instructions arbitrarily. Since these
instructions might lead to other wrong instructions and spoil the
listing, IDA does not create them by default anymore
"""

ida_idp.PR_ASSEMBLE
"""
Module has a built-in assembler and will react to ev_assemble.
"""

ida_idp.PR_BINMEM
"""
the processor module provides correct segmentation for binary files
(i.e. it creates additional segments) The kernel will not ask the user
to specify the RAM/ROM sizes
"""

ida_idp.PR_CHK_XREF
"""
don't allow near xrefs between segments with different bases
"""

ida_idp.PR_CNDINSNS
"""
has conditional instructions
"""

ida_idp.PR_DEFNUM
"""
mask - default number representation
"""

ida_idp.PR_DEFSEG32
"""
segments are 32-bit by default
"""

ida_idp.PR_DEFSEG64
"""
segments are 64-bit by default
"""

ida_idp.PR_DELAYED
"""
has delayed jumps and calls if this flag is set,
\\ph{is_basic_block_end}, \\ph{has_delay_slot} should be implemented
"""

ida_idp.PR_NOCHANGE
"""
(display only)

The user can't change segments and code/data attributes
"""

ida_idp.PR_NO_SEGMOVE
"""
(i.e. the user can't move segments)

the processor module doesn't support 'move_segm()'
"""

ida_idp.PR_PURGING
"""
there are calling conventions which may purge bytes from the stack
"""

ida_idp.PR_RNAMESOK
"""
allow user register names for location names
"""

ida_idp.PR_SCALE_STKVARS
"""
use \\ph{get_stkvar_scale} callback
"""

ida_idp.PR_SEGS
"""
has segment registers?
"""

ida_idp.PR_SEGTRANS
"""
the processor module supports the segment translation feature (meaning
it calculates the code addresses using the 'map_code_ea()' function)
"""

ida_idp.PR_SGROTHER
"""
the segment registers don't contain the segment selectors.
"""

ida_idp.PR_STACK_UP
"""
the stack grows up
"""

ida_idp.PR_TYPEINFO
"""
ALL OF THEM SHOULD BE IMPLEMENTED!

the processor module supports type information callbacks
"""

ida_idp.PR_USE32
"""
supports 32-bit addressing?
"""

ida_idp.PR_USE64
"""
supports 64-bit addressing?
"""

ida_idp.PR_USE_ARG_TYPES
"""
use \\ph{use_arg_types} callback
"""

ida_idp.PR_USE_TBYTE
"""
 'BTMT_SPECFLT' means _TBYTE type
"""

ida_idp.PR_WORD_INS
"""
instruction codes are grouped 2bytes in binary line prefix
"""

ida_idp.REG_SPOIL
"""
processor_t::use_regarg_type uses this bit in the return value to
indicate that the register value has been spoiled
"""
=== ida_idp EPYDOC INJECTIONS END ===
Help on class Choose in module ida_kernwin:

class Choose(builtins.object)
 |  Chooser wrapper class.
 |  
 |  Some constants are defined in this class.
 |  Please refer to kernwin.hpp for more information.
 |  
 |  Methods defined here:
 |  
 |  Activate(self)
 |      Activates a visible chooser
 |  
 |  AddCommand(self, caption, flags=4, menu_index=-1, icon=-1, emb=None, shortcut=None)
 |  
 |  Close(self)
 |      Closes the chooser
 |  
 |  Embedded(self, create_chobj=False)
 |      Creates an embedded chooser (as opposed to Show())
 |      @return: Returns 0 on success or NO_ATTR
 |  
 |  GetEmbSelection(self)
 |      Deprecated. For embedded choosers, the selection is
 |      available through 'Form.EmbeddedChooserControl.selection'
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  OnPopup(self, widget, popup_handle)
 |  
 |  Refresh(self)
 |      Causes the refresh callback to trigger
 |  
 |  Show(self, modal=False)
 |      Activates or creates a chooser window
 |      @param modal: Display as modal dialog
 |      @return: For all choosers it will return NO_ATTR if some mandatory
 |               attribute is missing. The mandatory attributes are: flags,
 |               title, cols, OnGetSize(), OnGetLine();
 |               For modal choosers it will return the selected item index (0-based),
 |               or NO_SELECTION if no selection,
 |               or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
 |               For non-modal choosers it will return 0
 |               or ALREADY_EXISTS if the chooser was already open and is active now;
 |  
 |  __init__(self, title, cols, flags=0, popup_names=None, icon=-1, x1=-1, y1=-1, x2=-1, y2=-1, deflt=None, embedded=False, width=None, height=None, forbidden_cb=0)
 |      Constructs a chooser window.
 |      @param title: The chooser title
 |      @param cols: a list of colums; each list item is a list of two items
 |          example: [ ["Address", 10 | Choose.CHCOL_HEX],
 |                     ["Name",    30 | Choose.CHCOL_PLAIN] ]
 |      @param flags: One of CH_XXXX constants
 |      @param deflt: The index of the default item (0-based) for single
 |          selection choosers or the list of indexes for multi selection
 |          chooser
 |      @param popup_names: List of new captions to replace this list
 |          ["Insert", "Delete", "Edit", "Refresh"]
 |      @param icon: Icon index (the icon should exist in ida resources or
 |          an index to a custom loaded icon)
 |      @param x1, y1, x2, y2: The default location (for txt-version)
 |      @param embedded: Create as embedded chooser
 |      @param width: Embedded chooser width
 |      @param height: Embedded chooser height
 |      @param forbidden_cb: Explicitly forbidden callbacks
 |  
 |  adjust_last_item(self, n)
 |      Helper for OnDeleteLine() and OnRefresh() callbacks.
 |      They can be finished by the following line:
 |      return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
 |      @param: line number of the remaining select item
 |      @return: list of selected lines numbers (one element or empty)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  ALL_CHANGED = 1
 |  
 |  ALREADY_EXISTS = -3
 |  
 |  CHCOL_DEC = 196608
 |  
 |  CHCOL_EA = 262144
 |  
 |  CHCOL_FNAME = 327680
 |  
 |  CHCOL_FORMAT = 458752
 |  
 |  CHCOL_HEX = 131072
 |  
 |  CHCOL_PATH = 65536
 |  
 |  CHCOL_PLAIN = 0
 |  
 |  CHOOSE_HAVE_DEL = 16
 |  
 |  CHOOSE_HAVE_EDIT = 32
 |  
 |  CHOOSE_HAVE_ENTER = 64
 |  
 |  CHOOSE_HAVE_GETATTR = 4
 |  
 |  CHOOSE_HAVE_GETICON = 2
 |  
 |  CHOOSE_HAVE_INIT = 1
 |  
 |  CHOOSE_HAVE_INS = 8
 |  
 |  CHOOSE_HAVE_ONCLOSE = 512
 |  
 |  CHOOSE_HAVE_REFRESH = 128
 |  
 |  CHOOSE_HAVE_SELECT = 256
 |  
 |  CH_ATTRS = 32
 |  
 |  CH_BUILTIN_MASK = 33030144
 |  
 |  CH_BUILTIN_SHIFT = 19
 |  
 |  CH_CAN_DEL = 512
 |  
 |  CH_CAN_EDIT = 1024
 |  
 |  CH_CAN_INS = 256
 |  
 |  CH_CAN_REFRESH = 2048
 |  
 |  CH_FORCE_DEFAULT = 128
 |  
 |  CH_MODAL = 1
 |  
 |  CH_MULTI = 4
 |  
 |  CH_NOBTNS = 16
 |  
 |  CH_NOIDB = 64
 |  
 |  CH_NO_STATUS_BAR = 65536
 |  
 |  CH_QFLT = 4096
 |  
 |  CH_QFTYP_DEFAULT = 0
 |  
 |  CH_QFTYP_FUZZY = 32768
 |  
 |  CH_QFTYP_MASK = 57344
 |  
 |  CH_QFTYP_NORMAL = 8192
 |  
 |  CH_QFTYP_REGEX = 24576
 |  
 |  CH_QFTYP_SHIFT = 13
 |  
 |  CH_QFTYP_WHOLE_WORDS = 16384
 |  
 |  CH_RESTORE = 131072
 |  
 |  EMPTY_CHOOSER = -2
 |  
 |  NOTHING_CHANGED = 0
 |  
 |  NO_ATTR = -4
 |  
 |  NO_SELECTION = -1
 |  
 |  SELECTION_CHANGED = 2
 |  
 |  UI_Hooks_Trampoline = <class 'ida_kernwin.Choose.UI_Hooks_Trampoline'>
 |      Proxy of C++ UI_Hooks class.

Help on class CustomIDAMemo in module ida_kernwin:

class CustomIDAMemo(View_Hooks)
 |  Proxy of C++ View_Hooks class.
 |  
 |  Method resolution order:
 |      CustomIDAMemo
 |      View_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  __init__(self)
 |      __init__(self, _flags=0) -> View_Hooks
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |      view_activated(self, view)
 |  
 |  view_click(self, view, ve)
 |      view_click(self, view, event)
 |  
 |  view_close(self, view, *args)
 |      view_close(self, view)
 |  
 |  view_curpos(self, view, *args)
 |      view_curpos(self, view)
 |  
 |  view_dblclick(self, view, ve)
 |      view_dblclick(self, view, event)
 |  
 |  view_deactivated(self, view)
 |      view_deactivated(self, view)
 |  
 |  view_keydown(self, view, key, state)
 |      view_keydown(self, view, key, state)
 |  
 |  view_loc_changed(self, view, now, was)
 |      view_loc_changed(self, view, now, was)
 |  
 |  view_mouse_moved(self, view, ve)
 |      view_mouse_moved(self, view, event)
 |  
 |  view_mouse_over(self, view, ve)
 |      view_mouse_over(self, view, event)
 |  
 |  view_switched(self, view, rt)
 |      view_switched(self, view, rt)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_View_Hooks(...)
 |      delete_View_Hooks(self)
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args) -> 'void'
 |      view_created(self, view)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class Form in module ida_kernwin:

class Form(builtins.object)
 |  # -----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  Add(self, name, ctrl, mkattr=True)
 |      Low level function. Prefer AddControls() to this function.
 |      This function adds one control to the form.
 |      
 |      @param name: Control name
 |      @param ctrl: Control object
 |      @param mkattr: Create control name / control object as a form attribute
 |  
 |  AddControls(self, controls, mkattr=True)
 |      Adds controls from a dictionary.
 |      The dictionary key is the control name and the value is a Form.Control object
 |      @param controls: The control dictionary
 |  
 |  Close(self, close_normally)
 |      Close the form
 |      @param close_normally:
 |                 1: form is closed normally as if the user pressed Enter
 |                 0: form is closed abnormally as if the user pressed Esc
 |      @return: None
 |  
 |  Compile(self)
 |      Compiles a form and returns the form object (self) and the argument list.
 |      The form object will contain object names corresponding to the form elements
 |      
 |      @return: It will raise an exception on failure. Otherwise the return value is ignored
 |  
 |  CompileEx(self, form)
 |      Low level function.
 |      Compiles (parses the form syntax and adds the control) the form string and
 |      returns the argument list to be passed the argument list to ask_form().
 |      
 |      The form controls are wrapped inside curly braces: {ControlName}.
 |      
 |      A special operator can be used to return the index of a given control by its name: {id:ControlName}.
 |      This is useful when you use the STARTITEM form keyword to set the initially focused control.
 |      (note that, technically, the index is not the same as the ID; that's because STARTITEM
 |      uses raw, 0-based indexes rather than control IDs to determine the focused widget.)
 |      
 |      @param form: Compiles the form and returns the arguments needed to be passed to ask_form()
 |  
 |  Compiled(self)
 |      Checks if the form has already been compiled
 |      
 |      @return: Boolean
 |  
 |  EnableField(self, ctrl, enable)
 |      Enable or disable an input field
 |      @return: False - no such control
 |  
 |  Execute(self)
 |      Displays a modal dialog containing the compiled form.
 |      @return: 1 - ok ; 0 - cancel
 |  
 |  FindControlById(self, id)
 |      Finds a control instance given its id
 |  
 |  Free(self)
 |      Frees all resources associated with a compiled form.
 |      Make sure you call this function when you finish using the form.
 |  
 |  GetControlValue(self, ctrl)
 |      Returns the control's value depending on its type
 |      @param ctrl: Form control instance
 |      @return:
 |          - color button, radio controls: integer
 |          - file/dir input, string input and string label: string
 |          - embedded chooser control (0-based indices of selected items): integer list
 |          - for multilinetext control: textctrl_info_t
 |          - dropdown list controls: string (when editable) or index (when readonly)
 |          - None: on failure
 |  
 |  GetFocusedField(self)
 |      Get currently focused input field.
 |      @return: None if no field is selected otherwise the control ID
 |  
 |  MoveField(self, ctrl, x, y, w, h)
 |      Move/resize an input field
 |      
 |      @return: False - no such fiel
 |  
 |  Open(self)
 |      Opens a widget containing the compiled form.
 |  
 |  RefreshField(self, ctrl)
 |      Refresh a field
 |      @return: False - no such control
 |  
 |  SetControlValue(self, ctrl, value)
 |      Set the control's value depending on its type
 |      @param ctrl: Form control instance
 |      @param value:
 |          - embedded chooser: a 0-base indices list to select embedded chooser items
 |          - multilinetext: a textctrl_info_t
 |          - dropdown list: an integer designating the selection index if readonly
 |                           a string designating the edit control value if not readonly
 |      @return: Boolean true on success
 |  
 |  SetFocusedField(self, ctrl)
 |      Set currently focused input field
 |      @return: False - no such control
 |  
 |  ShowField(self, ctrl, show)
 |      Show or hide an input field
 |      @return: False - no such control
 |  
 |  _AddGroup(self, Group, mkattr=True)
 |      Internal function.
 |      This function expands the group item names and creates individual group item controls
 |      
 |      @param Group: The group class (checkbox or radio group class)
 |  
 |  _ChkCompiled(self)
 |  
 |  __getitem__(self, name)
 |      Returns a control object by name
 |  
 |  __init__(self, form, controls)
 |      Contruct a Form class.
 |      This class wraps around ask_form() or open_form() and provides an easier / alternative syntax for describing forms.
 |      The form control names are wrapped inside the opening and closing curly braces and the control themselves are
 |      defined and instantiated via various form controls (subclasses of Form).
 |      
 |      @param form: The form string
 |      @param controls: A dictionary containing the control name as a _key_ and control object as _value_
 |  
 |  _reset(self)
 |      Resets the Form class state variables
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  ControlToFieldTypeIdAndSize(ctrl)
 |      Converts a control object to a tuple containing the field id
 |      and the associated buffer size
 |  
 |  _ParseFormTitle(form)
 |      Parses the form's title from the form text
 |  
 |  create_string_buffer(value, size=None)
 |  
 |  fieldtype_to_ctype(tp, i64=False)
 |      Factory method returning a ctype class corresponding to the field type string
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  ButtonInput = <class 'ida_kernwin.Form.ButtonInput'>
 |      Button control.
 |      A handler along with a 'code' (numeric value) can be associated with the button.
 |      This way one handler can handle many buttons based on the button code (or in other terms id or tag)
 |  
 |  ChkGroupControl = <class 'ida_kernwin.Form.ChkGroupControl'>
 |      Checkbox group control class.
 |      It holds a set of checkbox controls
 |  
 |  ChkGroupItemControl = <class 'ida_kernwin.Form.ChkGroupItemControl'>
 |      Checkbox group item control
 |  
 |  ColorInput = <class 'ida_kernwin.Form.ColorInput'>
 |      Color button input control
 |  
 |  Control = <class 'ida_kernwin.Form.Control'>
 |  
 |  
 |  DirInput = <class 'ida_kernwin.Form.DirInput'>
 |      Directory browsing control
 |  
 |  DropdownListControl = <class 'ida_kernwin.Form.DropdownListControl'>
 |      Dropdown control
 |      This control allows manipulating a dropdown control
 |  
 |  EmbeddedChooserControl = <class 'ida_kernwin.Form.EmbeddedChooserContr...
 |      Embedded chooser control.
 |      This control links to a Chooser2 control created with the 'embedded=True'
 |  
 |  FT_ADDR = '$'
 |  
 |  FT_ASCII = 'A'
 |  
 |  FT_BIN = 'Y'
 |  
 |  FT_BUTTON = 'B'
 |  
 |  FT_CHAR = 'H'
 |  
 |  FT_CHKGRP = 'C'
 |  
 |  FT_CHKGRP2 = 'c'
 |  
 |  FT_COLOR = 'K'
 |  
 |  FT_DEC = 'D'
 |  
 |  FT_DIR = 'F'
 |  
 |  FT_DROPDOWN_LIST = 'b'
 |  
 |  FT_ECHOOSER = 'E'
 |  
 |  FT_FILE = 'f'
 |  
 |  FT_FORMCHG = '%/'
 |  
 |  FT_HEX = 'N'
 |  
 |  FT_HTML_LABEL = 'h'
 |  
 |  FT_IDENT = 'I'
 |  
 |  FT_INT64 = 'l'
 |  
 |  FT_MULTI_LINE_TEXT = 't'
 |  
 |  FT_OCT = 'O'
 |  
 |  FT_RADGRP = 'R'
 |  
 |  FT_RADGRP2 = 'r'
 |  
 |  FT_RAWHEX = 'M'
 |  
 |  FT_SEG = 'S'
 |  
 |  FT_SHEX = 'n'
 |  
 |  FT_TYPE = 'T'
 |  
 |  FT_UINT64 = 'L'
 |  
 |  FileInput = <class 'ida_kernwin.Form.FileInput'>
 |      File Open/Save input control
 |  
 |  FormChangeCb = <class 'ida_kernwin.Form.FormChangeCb'>
 |      Form change handler.
 |      This can be thought of like a dialog procedure.
 |      Everytime a form action occurs, this handler will be called along with the control id.
 |      The programmer can then call various form actions accordingly:
 |        - EnableField
 |        - ShowField
 |        - MoveField
 |        - GetFieldValue
 |        - etc...
 |      
 |      Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)
 |  
 |  GroupControl = <class 'ida_kernwin.Form.GroupControl'>
 |      Base class for group controls
 |  
 |  GroupItemControl = <class 'ida_kernwin.Form.GroupItemControl'>
 |      Base class for group control items
 |  
 |  InputControl = <class 'ida_kernwin.Form.InputControl'>
 |      Generic form input control.
 |      It could be numeric control, string control, directory/file browsing, etc...
 |  
 |  LabelControl = <class 'ida_kernwin.Form.LabelControl'>
 |      Base class for static label control
 |  
 |  MultiLineTextControl = <class 'ida_kernwin.Form.MultiLineTextControl'>
 |      Multi line text control.
 |      This class inherits from textctrl_info_t. Thus the attributes are also inherited
 |      This control allows manipulating a multilinetext control
 |  
 |  NumericArgument = <class 'ida_kernwin.Form.NumericArgument'>
 |      Argument representing various integer arguments (ushort, uint32, uint64, etc...)
 |      @param tp: One of Form.FT_XXX
 |  
 |  NumericInput = <class 'ida_kernwin.Form.NumericInput'>
 |      A composite class serving as a base numeric input control class
 |  
 |  NumericLabel = <class 'ida_kernwin.Form.NumericLabel'>
 |      Numeric label control
 |  
 |  RadGroupControl = <class 'ida_kernwin.Form.RadGroupControl'>
 |      Radiobox group control class.
 |      It holds a set of radiobox controls
 |  
 |  RadGroupItemControl = <class 'ida_kernwin.Form.RadGroupItemControl'>
 |      Radiobox group item control
 |  
 |  StringArgument = <class 'ida_kernwin.Form.StringArgument'>
 |      Argument representing a character buffer
 |  
 |  StringInput = <class 'ida_kernwin.Form.StringInput'>
 |      Base string input control class.
 |      This class also constructs a StringArgument
 |  
 |  StringLabel = <class 'ida_kernwin.Form.StringLabel'>
 |      String label control
 |  
 |  _FT_USHORT = '_US'

Help on class IDAViewWrapper in module ida_kernwin:

class IDAViewWrapper(CustomIDAMemo)
 |  Deprecated. Use View_Hooks instead.
 |  
 |  Because the lifecycle of an IDAView is not trivial to track (e.g., a user
 |  might close, then re-open the same disassembly view), this wrapper doesn't
 |  bring anything superior to the View_Hooks: quite the contrary, as the
 |  latter is much more generic (and better maps IDA's internal model.)
 |  
 |  Method resolution order:
 |      IDAViewWrapper
 |      CustomIDAMemo
 |      View_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  Bind(self)
 |  
 |  Unbind(self)
 |  
 |  __init__(self, title)
 |      __init__(self, _flags=0) -> View_Hooks
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from CustomIDAMemo:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |      view_activated(self, view)
 |  
 |  view_click(self, view, ve)
 |      view_click(self, view, event)
 |  
 |  view_close(self, view, *args)
 |      view_close(self, view)
 |  
 |  view_curpos(self, view, *args)
 |      view_curpos(self, view)
 |  
 |  view_dblclick(self, view, ve)
 |      view_dblclick(self, view, event)
 |  
 |  view_deactivated(self, view)
 |      view_deactivated(self, view)
 |  
 |  view_keydown(self, view, key, state)
 |      view_keydown(self, view, key, state)
 |  
 |  view_loc_changed(self, view, now, was)
 |      view_loc_changed(self, view, now, was)
 |  
 |  view_mouse_moved(self, view, ve)
 |      view_mouse_moved(self, view, event)
 |  
 |  view_mouse_over(self, view, ve)
 |      view_mouse_over(self, view, event)
 |  
 |  view_switched(self, view, rt)
 |      view_switched(self, view, rt)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from CustomIDAMemo:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_View_Hooks(...)
 |      delete_View_Hooks(self)
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args) -> 'void'
 |      view_created(self, view)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class PluginForm in module ida_kernwin:

class PluginForm(builtins.object)
 |  PluginForm class.
 |  
 |  This form can be used to host additional controls. Please check the PyQt example.
 |  
 |  Methods defined here:
 |  
 |  Close(self, options)
 |      Closes the form.
 |      
 |      @param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)
 |      
 |      @return: None
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  OnClose(self, form)
 |      Called when the plugin form is closed
 |      
 |      @return: None
 |  
 |  OnCreate(self, form)
 |      This event is called when the plugin form is created.
 |      The programmer should populate the form when this event is triggered.
 |      
 |      @return: None
 |  
 |  Show(self, caption, options=0)
 |      Creates the form if not was not created or brings to front if it was already created
 |      
 |      @param caption: The form caption
 |      @param options: One of PluginForm.WOPN_ constants
 |  
 |  __init__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  FormToPyQtWidget = TWidgetToPyQtWidget(tw, ctx=<module '__main__' (built-in)>)
 |      Convert a TWidget* to a QWidget to be used by PyQt
 |      
 |      @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
 |  
 |  FormToPySideWidget = TWidgetToPySideWidget(tw, ctx=<module '__main__' (built-in)>)
 |      Use this method to convert a TWidget* to a QWidget to be used by PySide
 |      
 |      @param ctx: Context. Reference to a module that already imported QtWidgets module
 |  
 |  QtWidgetToTWidget(w, ctx=<module '__main__' (built-in)>)
 |      Convert a QWidget to a TWidget* to be used by IDA
 |      
 |      @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
 |  
 |  TWidgetToPyQtWidget(tw, ctx=<module '__main__' (built-in)>)
 |      Convert a TWidget* to a QWidget to be used by PyQt
 |      
 |      @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
 |  
 |  TWidgetToPySideWidget(tw, ctx=<module '__main__' (built-in)>)
 |      Use this method to convert a TWidget* to a QWidget to be used by PySide
 |      
 |      @param ctx: Context. Reference to a module that already imported QtWidgets module
 |  
 |  _ensure_widget_deps(ctx)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  VALID_CAPSULE_NAME = b'$valid$'
 |  
 |  WCLS_CLOSE_LATER = 8
 |  
 |  WCLS_DONT_SAVE_SIZE = 4
 |  
 |  WCLS_NO_CONTEXT = 2
 |  
 |  WCLS_SAVE = 1
 |  
 |  WOPN_CENTERED = 32
 |  
 |  WOPN_CREATE_ONLY = {}
 |  
 |  WOPN_DP_BEFORE = 2097152
 |  
 |  WOPN_DP_BOTTOM = 524288
 |  
 |  WOPN_DP_FLOATING = 8388608
 |  
 |  WOPN_DP_INSIDE = 1048576
 |  
 |  WOPN_DP_INSIDE_BEFORE = 3145728
 |  
 |  WOPN_DP_LEFT = 65536
 |  
 |  WOPN_DP_RIGHT = 262144
 |  
 |  WOPN_DP_TAB = 4194304
 |  
 |  WOPN_DP_TAB_BEFORE = 6291456
 |  
 |  WOPN_DP_TOP = 131072
 |  
 |  WOPN_MDI = 1
 |  
 |  WOPN_MENU = 16
 |  
 |  WOPN_ONTOP = 8
 |  
 |  WOPN_PERSIST = 64
 |  
 |  WOPN_RESTORE = 4
 |  
 |  WOPN_TAB = 2

Help on function TWidget__from_ptrval__ in module ida_kernwin:

TWidget__from_ptrval__(*args) -> 'TWidget *'
    TWidget__from_ptrval__(ptrval) -> TWidget *

Help on class UI_Hooks in module ida_kernwin:

class UI_Hooks(builtins.object)
 |  Proxy of C++ UI_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> UI_Hooks
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_UI_Hooks(...)
 |      delete_UI_Hooks(self)
 |  
 |  create_desktop_widget(self, *args) -> 'PyObject *'
 |      create_desktop_widget(self, title, cfg) -> PyObject *
 |  
 |  current_widget_changed(self, *args) -> 'void'
 |      current_widget_changed(self, widget, prev_widget)
 |  
 |  database_inited(self, *args) -> 'void'
 |      database_inited(self, is_new_database, idc_script)
 |  
 |  debugger_menu_change(self, *args) -> 'void'
 |      debugger_menu_change(self, enable)
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  finish_populating_widget_popup(self, *args) -> 'void'
 |      finish_populating_widget_popup(self, widget, popup_handle, ctx=None)
 |      
 |      
 |      The UI is about to be done populating the TWidget's popup menu.
 |      Now is a good time to call idaapi.attach_action_to_popup()
 |      
 |      @param widget: The widget
 |      @param popup: The popup menu.
 |      @return: Ignored
 |  
 |  get_chooser_item_attrs(self, *args) -> 'void'
 |      get_chooser_item_attrs(self, chooser, n, attrs)
 |  
 |  get_custom_viewer_hint(self, *args) -> 'PyObject *'
 |      get_custom_viewer_hint(self, viewer, place) -> PyObject *
 |  
 |  get_ea_hint(self, *args) -> 'PyObject *'
 |      get_ea_hint(self, ea) -> PyObject *
 |      
 |      
 |      The UI wants to display a simple hint for an address in the navigation band
 |      
 |      @param ea: The address
 |      @return: String with the hint or None
 |  
 |  get_item_hint(self, *args) -> 'PyObject *'
 |      get_item_hint(self, ea, max_lines) -> PyObject *
 |  
 |  get_widget_config(self, *args) -> 'PyObject *'
 |      get_widget_config(self, widget, cfg) -> PyObject *
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |      
 |      
 |      Creates an UI hook
 |      
 |      @return: Boolean true on success
 |  
 |  idcstart(self, *args) -> 'void'
 |      idcstart(self)
 |  
 |  idcstop(self, *args) -> 'void'
 |      idcstop(self)
 |  
 |  plugin_loaded(self, *args) -> 'void'
 |      plugin_loaded(self, plugin_info)
 |  
 |  plugin_unloading(self, *args) -> 'void'
 |      plugin_unloading(self, plugin_info)
 |  
 |  populating_widget_popup(self, *args) -> 'void'
 |      populating_widget_popup(self, widget, popup_handle, ctx=None)
 |      
 |      
 |      The UI is populating the TWidget's popup menu.
 |      Now is a good time to call idaapi.attach_action_to_popup()
 |      
 |      @param widget: The widget
 |      @param popup: The popup menu.
 |      @return: Ignored
 |  
 |  postprocess_action(self, *args) -> 'void'
 |      postprocess_action(self)
 |      
 |      
 |      An ida ui action has been handled
 |      
 |      @return: Ignored
 |  
 |  preprocess_action(self, *args) -> 'void'
 |      preprocess_action(self, name)
 |      
 |      
 |      IDA ui is about to handle a user action
 |      
 |      @param name: ui action name
 |                   (these names can be looked up in ida[tg]ui.cfg)
 |      @return: 0-ok, nonzero - a plugin has handled the action
 |  
 |  range(self, *args) -> 'void'
 |      range(self)
 |  
 |  ready_to_run(self, *args) -> 'void'
 |      ready_to_run(self)
 |  
 |  resume(self, *args) -> 'void'
 |      resume(self)
 |  
 |  saved(self, *args) -> 'void'
 |      saved(self)
 |      
 |      
 |      The kernel has saved the database.
 |      
 |      @return: Ignored
 |  
 |  saving(self, *args) -> 'void'
 |      saving(self)
 |      
 |      
 |      The kernel is saving the database.
 |      
 |      @return: Ignored
 |  
 |  screen_ea_changed(self, *args) -> 'void'
 |      screen_ea_changed(self, ea, prev_ea)
 |  
 |  set_widget_config(self, *args) -> 'void'
 |      set_widget_config(self, widget, cfg)
 |  
 |  suspend(self, *args) -> 'void'
 |      suspend(self)
 |  
 |  term(self, *args) -> 'void'
 |      term(self)
 |      
 |      
 |      IDA is terminated and the database is already closed.
 |      The UI may close its windows in this callback.
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |      
 |      
 |      Removes the UI hook
 |      @return: Boolean true on success
 |  
 |  updated_actions(self, *args) -> 'void'
 |      updated_actions(self)
 |      
 |      
 |      The UI is done updating actions.
 |      
 |      @return: Ignored
 |  
 |  updating_actions(self, *args) -> 'void'
 |      updating_actions(self, ctx)
 |      
 |      
 |      The UI is about to batch-update some actions.
 |      
 |      @param ctx: The action_update_ctx_t instance
 |      @return: Ignored
 |  
 |  widget_closing(self, *args) -> 'void'
 |      widget_closing(self, widget)
 |  
 |  widget_invisible(self, *args) -> 'void'
 |      widget_invisible(self, widget)
 |  
 |  widget_visible(self, *args) -> 'void'
 |      widget_visible(self, widget)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class View_Hooks in module ida_kernwin:

class View_Hooks(builtins.object)
 |  Proxy of C++ View_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> View_Hooks
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_View_Hooks(...)
 |      delete_View_Hooks(self)
 |  
 |  dump_state(self, *args) -> 'qstring'
 |      dump_state(self) -> qstring
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  view_activated(self, *args) -> 'void'
 |      view_activated(self, view)
 |  
 |  view_click(self, *args) -> 'void'
 |      view_click(self, view, event)
 |  
 |  view_close(self, *args) -> 'void'
 |      view_close(self, view)
 |  
 |  view_created(self, *args) -> 'void'
 |      view_created(self, view)
 |  
 |  view_curpos(self, *args) -> 'void'
 |      view_curpos(self, view)
 |  
 |  view_dblclick(self, *args) -> 'void'
 |      view_dblclick(self, view, event)
 |  
 |  view_deactivated(self, *args) -> 'void'
 |      view_deactivated(self, view)
 |  
 |  view_keydown(self, *args) -> 'void'
 |      view_keydown(self, view, key, state)
 |  
 |  view_loc_changed(self, *args) -> 'void'
 |      view_loc_changed(self, view, now, was)
 |  
 |  view_mouse_moved(self, *args) -> 'void'
 |      view_mouse_moved(self, view, event)
 |  
 |  view_mouse_over(self, *args) -> 'void'
 |      view_mouse_over(self, view, event)
 |  
 |  view_switched(self, *args) -> 'void'
 |      view_switched(self, view, rt)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class __qtimer_t in module ida_kernwin:

class __qtimer_t(builtins.object)
 |  Proxy of C++ __qtimer_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qtimer_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete___qtimer_t(...)
 |      delete___qtimer_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function _ask_addr in module ida_kernwin:

_ask_addr(*args) -> 'ea_t *'
    _ask_addr(addr, format) -> bool

Help on function _ask_long in module ida_kernwin:

_ask_long(*args) -> 'sval_t *'
    _ask_long(value, format) -> bool

Help on function _ask_seg in module ida_kernwin:

_ask_seg(*args) -> 'sel_t *'
    _ask_seg(sel, format) -> bool

Help on function _call_ask_form in module ida_kernwin:

_call_ask_form(*args)

Help on function _call_open_form in module ida_kernwin:

_call_open_form(*args)

Help on class action_ctx_base_t in module ida_kernwin:

class action_ctx_base_t(builtins.object)
 |  Proxy of C++ action_ctx_base_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> action_ctx_base_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_action_ctx_base_t(...)
 |      delete_action_ctx_base_t(self)
 |  
 |  _get_form(self, *args) -> 'TWidget *'
 |      _get_form(self) -> TWidget *
 |  
 |  _get_form_title(self, *args) -> 'qstring'
 |      _get_form_title(self) -> qstring
 |  
 |  _get_form_type(self, *args) -> 'twidget_type_t'
 |      _get_form_type(self) -> twidget_type_t
 |  
 |  has_flag(self, *args) -> 'bool'
 |      has_flag(self, flag) -> bool
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  action
 |      action_ctx_base_t_action_get(self) -> char const *
 |  
 |  chooser_selection
 |      action_ctx_base_t_chooser_selection_get(self) -> sizevec_t *
 |  
 |  cur_ea
 |      action_ctx_base_t_cur_ea_get(self) -> ea_t
 |  
 |  cur_enum
 |      action_ctx_base_t_cur_enum_get(self) -> enum_t
 |  
 |  cur_extracted_ea
 |      action_ctx_base_t_cur_value_get(self) -> uval_t
 |  
 |  cur_fchunk
 |      action_ctx_base_t_cur_fchunk_get(self) -> func_t *
 |  
 |  cur_flags
 |      action_ctx_base_t_cur_flags_get(self) -> uint32
 |  
 |  cur_func
 |      action_ctx_base_t_cur_func_get(self) -> func_t *
 |  
 |  cur_seg
 |      action_ctx_base_t_cur_seg_get(self) -> segment_t *
 |  
 |  cur_strmem
 |      action_ctx_base_t_cur_strmem_get(self) -> member_t *
 |  
 |  cur_struc
 |      action_ctx_base_t_cur_struc_get(self) -> struc_t *
 |  
 |  cur_value
 |      action_ctx_base_t_cur_value_get(self) -> uval_t
 |  
 |  focus
 |      action_ctx_base_t_focus_get(self) -> TWidget *
 |  
 |  form
 |      _get_form(self) -> TWidget *
 |  
 |  form_title
 |      _get_form_title(self) -> qstring
 |  
 |  form_type
 |      _get_form_type(self) -> twidget_type_t
 |  
 |  graph_selection
 |      action_ctx_base_t_graph_selection_get(self) -> screen_graph_selection_t *
 |  
 |  regname
 |      action_ctx_base_t_regname_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  widget
 |      action_ctx_base_t_widget_get(self) -> TWidget *
 |  
 |  widget_title
 |      action_ctx_base_t_widget_title_get(self) -> qstring *
 |  
 |  widget_type
 |      action_ctx_base_t_widget_type_get(self) -> twidget_type_t

Help on class action_desc_t in module ida_kernwin:

class action_desc_t(builtins.object)
 |  Proxy of C++ action_desc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, name, label, handler, shortcut=None, tooltip=None, icon=-1, flags=0) -> action_desc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_action_desc_t(...)
 |      delete_action_desc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      action_desc_t_cb_get(self) -> int
 |  
 |  flags
 |      action_desc_t_flags_get(self) -> int
 |  
 |  icon
 |      action_desc_t_icon_get(self) -> int
 |  
 |  label
 |      action_desc_t_label_get(self) -> char const *
 |  
 |  name
 |      action_desc_t_name_get(self) -> char const *
 |  
 |  owner
 |      action_desc_t_owner_get(self) -> plugin_t const *
 |  
 |  shortcut
 |      action_desc_t_shortcut_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  tooltip
 |      action_desc_t_tooltip_get(self) -> char const *

Help on class action_handler_t in module ida_kernwin:

class action_handler_t(builtins.object)
 |  # ----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  activate(self, ctx)
 |  
 |  update(self, ctx)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function activate_widget in module ida_kernwin:

activate_widget(*args) -> 'void'
    activate_widget(widget, take_focus)
    
    
    Activate widget (only gui version) ( 'ui_activate_widget' ).
    
    @param widget: existing widget to display (C++: TWidget *)
    @param take_focus: give focus to given widget (C++: bool)

Help on function add_hotkey in module ida_kernwin:

add_hotkey(*args) -> 'PyObject *'
    add_hotkey(hotkey, pyfunc) -> PyObject *
    
    
    Associates a function call with a hotkey.
    Callable pyfunc will be called each time the hotkey is pressed
    
    @param hotkey: The hotkey
    @param pyfunc: Callable
    
    @return: Context object on success or None on failure.

Help on function add_idc_hotkey in module ida_kernwin:

add_idc_hotkey(*args) -> 'int'
    add_idc_hotkey(hotkey, idcfunc) -> int
    
    
    Add hotkey for IDC function ( 'ui_add_idckey' ).
    
    @param hotkey: hotkey name (C++: const char *)
    @param idcfunc: IDC function name (C++: const char *)
    @return: IDC hotkey error codes

Help on function add_spaces in module ida_kernwin:

add_spaces(*args) -> 'PyObject *'
    add_spaces(s, len) -> PyObject *
    
    
    Add space characters to the colored string so that its length will be
    at least 'len' characters. Don't trim the string if it is longer than
    'len'.
    
    @param len: the desired length of the string (C++: ssize_t)
    @return: pointer to the end of input string

Help on function addon_count in module ida_kernwin:

addon_count(*args) -> 'int'
    addon_count() -> int
    
    
    Get number of installed addons.

Help on class addon_info_t in module ida_kernwin:

class addon_info_t(builtins.object)
 |  Proxy of C++ addon_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> addon_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_addon_info_t(...)
 |      delete_addon_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      addon_info_t_cb_get(self) -> size_t
 |  
 |  custom_data
 |      addon_info_t_custom_data_get(self) -> void const *
 |  
 |  custom_size
 |      addon_info_t_custom_size_get(self) -> size_t
 |  
 |  freeform
 |      addon_info_t_freeform_get(self) -> char const *
 |  
 |  id
 |      addon_info_t_id_get(self) -> char const *
 |  
 |  name
 |      addon_info_t_name_get(self) -> char const *
 |  
 |  producer
 |      addon_info_t_producer_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  url
 |      addon_info_t_url_get(self) -> char const *
 |  
 |  version
 |      addon_info_t_version_get(self) -> char const *

Help on function analyzer_options in module ida_kernwin:

analyzer_options(*args) -> 'void'
    analyzer_options()
    
    
    Allow the user to set analyzer options. (show a dialog box) (
    'ui_analyzer_options' )

Help on function ask_addr in module ida_kernwin:

ask_addr(defval, format)
    # ----------------------------------------------------------------------

Help on function ask_buttons in module ida_kernwin:

ask_buttons(*args) -> 'int'
    ask_buttons(Yes, No, Cancel, deflt, format) -> int
    
    
    Display a dialog box and get choice from maximum three possibilities (
    'ui_ask_buttons' ).for all buttons:use "" or NULL to take the default
    name for the button.use 'format' to hide the cancel button
    
    @param Yes: text for the first button (C++: const char *)
    @param No: text for the second button (C++: const char *)
    @param Cancel: text for the third button (C++: const char *)
    @param deflt: default choice: one of  Button IDs (C++: int)
    @param format: printf-style format string for question. It may have
                   some prefixes, see below. (C++: const char *)
    @return: one of  Button IDs  specifying the selected button (Esc key
             returns Cancel/3rd button value)

Help on function ask_file in module ida_kernwin:

ask_file(*args) -> 'char *'
    ask_file(for_saving, defval, format) -> char *

Help on function ask_for_feedback in module ida_kernwin:

ask_for_feedback(*args) -> 'void'
    ask_for_feedback(format)
    
    
    Show a message box asking to send the input file tosupport@hex-
    rays.com.
    
    @param format: the reason why the input file is bad (C++: const char
                   *)

Help on function ask_ident in module ida_kernwin:

ask_ident(defval, format)
    # ----------------------------------------------------------------------

Help on function ask_long in module ida_kernwin:

ask_long(defval, format)
    # ----------------------------------------------------------------------

Help on function ask_seg in module ida_kernwin:

ask_seg(defval, format)
    # ----------------------------------------------------------------------

Help on function ask_str in module ida_kernwin:

ask_str(*args) -> 'PyObject *'
    ask_str(defval, hist, prompt) -> PyObject *
    
    
    Asks for a long text
    
    @param hist:   history id
    @param defval: The default value
    @param prompt: The prompt value
    @return: None or the entered string

Help on function ask_text in module ida_kernwin:

ask_text(*args) -> 'PyObject *'
    ask_text(max_size, defval, prompt) -> PyObject *
    
    
    Asks for a long text
    
    @param max_size: Maximum text length, 0 for unlimited
    @param defval: The default value
    @param prompt: The prompt value
    @return: None or the entered string

Help on function ask_yn in module ida_kernwin:

ask_yn(*args) -> 'int'
    ask_yn(deflt, format) -> int
    
    
    Display a dialog box and get choice from "Yes", "No", "Cancel".
    
    @param deflt: default choice: one of  Button IDs (C++: int)
    @param format: The question in printf() style format (C++: const char
                   *)
    @return: the selected button (one of  Button IDs ). Esc key returns
             ASKBTN_CANCEL .

Help on function attach_action_to_menu in module ida_kernwin:

attach_action_to_menu(*args) -> 'bool'
    attach_action_to_menu(menupath, name, flags) -> bool
    
    
    Attach a previously-registered action to the menu (
    'ui_attach_action_to_menu' ).You should not change top level menu, or
    the Edit,Plugins submenus If you want to modify the debugger menu, do
    it at the ui_debugger_menu_change event (ida might destroy your menu
    item if you do it elsewhere).
    
    @param menupath: path to the menu item after or before which the
                     insertion will take place.      Example:
                     Debug/StartProcess   Whitespace, punctuation are
                     ignored.   It is allowed to specify only the prefix
                     of the menu item.   Comparison is case insensitive.
                     menupath may start with the following prefixes:   [S]
                     - modify the main menu of the structure window   [E]
                     - modify the main menu of the enum window (C++: const
                     char *)
    @param name: the action name (C++: const char *)
    @param flags: a combination of  Set menu flags , to determine menu
                  item position (C++: int)
    @return: success

Help on function attach_action_to_popup in module ida_kernwin:

attach_action_to_popup(*args) -> 'bool'
    attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0) -> bool
    
    
    Insert a previously-registered action into the widget's popup menu (
    'ui_attach_action_to_popup' ). This function has two "modes": 'single-
    shot', and 'permanent'.
    
    @param widget: target widget (C++: TWidget *)
    @param popup_handle: target popup menu   if non-NULL, the action is
                         added to this popup menu invocation (i.e.,
                         'single-shot')   if NULL, the action is added to
                         a list of actions that should always be present
                         in context menus for this widget (i.e.,
                         'permanent'.) (C++: TPopupMenu *)
    @param name: action name (C++: const char *)
    @param popuppath: can be NULL (C++: const char *)
    @param flags: a combination of SETMENU_ flags (see  Set menu flags )
                  (C++: int)
    @return: success

Help on function attach_action_to_toolbar in module ida_kernwin:

attach_action_to_toolbar(*args) -> 'bool'
    attach_action_to_toolbar(toolbar_name, name) -> bool
    
    
    Attach an action to an existing toolbar (
    'ui_attach_action_to_toolbar' ).
    
    @param toolbar_name: the name of the toolbar (C++: const char *)
    @param name: the action name (C++: const char *)
    @return: success

Help on function attach_dynamic_action_to_popup in module ida_kernwin:

attach_dynamic_action_to_popup(*args) -> 'bool'
    attach_dynamic_action_to_popup(widget, popup_handle, desc, popuppath=None, flags=0) -> bool
    
    
    Create & insert an action into the widget's popup menu (
    'ui_attach_dynamic_action_to_popup' ). 'action_desc_t::handler' for
    'desc' must be instantiated using 'new', as it will be 'delete'd when
    the action is unregistered.
    
    @param widget: target widget (C++: TWidget *)
    @param popup_handle: target popup (C++: TPopupMenu *)
    @param desc: created with  DYNACTION_DESC_LITERAL (C++: const
                 action_desc_t  &)
    @param popuppath: can be NULL (C++: const char *)
    @param flags: a combination of SETMENU_ constants (see  Set menu flags
                  ) (C++: int)
    @return: success

Help on function banner in module ida_kernwin:

banner(*args) -> 'bool'
    banner(wait) -> bool
    
    
    Show a banner dialog box ( 'ui_banner' ).
    
    @param wait: time to wait before closing (C++: int)

Help on function beep in module ida_kernwin:

beep(*args) -> 'void'
    beep(beep_type=beep_default)
    
    
    Issue a beeping sound ( 'ui_beep' ).
    
    @param beep_type: beep_t (C++: beep_t)

Help on function call_nav_colorizer in module ida_kernwin:

call_nav_colorizer(*args) -> 'uint32'
    call_nav_colorizer(dict, ea, nbytes) -> uint32
    
    
    To be used with the IDA-provided colorizer, that is
    returned as result of the first call to set_nav_colorizer().

Help on function cancel_exec_request in module ida_kernwin:

cancel_exec_request(*args) -> 'bool'
    cancel_exec_request(req_id) -> bool
    
    
    Try to cancel an asynchronous exec request ( 'ui_cancel_exec_request'
    ).
    
    @param req_id: request id (C++: int)

Help on function choose_activate in module ida_kernwin:

choose_activate(*args) -> 'void'
    choose_activate(_self)

Help on function choose_choose in module ida_kernwin:

choose_choose(*args) -> 'PyObject *'
    choose_choose(_self) -> PyObject *

Help on function choose_close in module ida_kernwin:

choose_close(*args) -> 'void'
    choose_close(_self)

Help on function choose_create_embedded_chobj in module ida_kernwin:

choose_create_embedded_chobj(*args) -> 'PyObject *'
    choose_create_embedded_chobj(_self) -> PyObject *

Help on function choose_entry in module ida_kernwin:

choose_entry(*args) -> 'ea_t'
    choose_entry(title) -> ea_t
    
    
    Choose an entry point ( 'ui_choose' , 'chtype_entry' ).
    
    @param title: chooser title (C++: const char *)
    @return: ea of selected entry point,  BADADDR  if none selected

Help on function choose_enum in module ida_kernwin:

choose_enum(*args) -> 'enum_t'
    choose_enum(title, default_id) -> enum_t
    
    
    Choose an enum ( 'ui_choose' , 'chtype_enum' ).
    
    @param title: chooser title (C++: const char *)
    @param default_id: id of enum to select by default (C++: enum_t)
    @return: enum id of selected enum,  BADNODE  if none selected

Help on function choose_enum_by_value in module ida_kernwin:

choose_enum_by_value(*args) -> 'uchar *'
    choose_enum_by_value(title, default_id, value, nbytes) -> enum_t
    
    
    Choose an enum, restricted by value & size ( 'ui_choose' ,
    'chtype_enum_by_value_and_size' ). If the given value cannot be found
    initially, this function will ask if the user would like to import a
    standard enum.
    
    @param title: chooser title (C++: const char *)
    @param default_id: id of enum to select by default (C++: enum_t)
    @param value: value to search for (C++: uval_t)
    @param nbytes: size of value (C++: int)
    @return: enum id of selected (or imported) enum,  BADNODE  if none was
             found

Help on function choose_find in module ida_kernwin:

choose_find(*args) -> 'PyObject *'
    choose_find(title) -> PyObject *

Help on function choose_func in module ida_kernwin:

choose_func(*args) -> 'func_t *'
    choose_func(title, default_ea) -> func_t *
    
    
    Choose a function ( 'ui_choose' , 'chtype_func' ).
    
    @param title: chooser title (C++: const char *)
    @param default_ea: ea of function to select by default (C++: ea_t)
    @return: pointer to function that was selected, NULL if none selected

Help on function choose_get_widget in module ida_kernwin:

choose_get_widget(*args) -> 'TWidget *'
    choose_get_widget(_self) -> TWidget *

Help on function choose_idasgn in module ida_kernwin:

choose_idasgn(*args) -> 'PyObject *'
    choose_idasgn() -> PyObject *
    
    
    Opens the signature chooser
    
    @return: None or the selected signature name

Help on function choose_name in module ida_kernwin:

choose_name(*args) -> 'ea_t'
    choose_name(title) -> ea_t
    
    
    Choose a name ( 'ui_choose' , 'chtype_name' ).
    
    @param title: chooser title (C++: const char *)
    @return: ea of selected name,  BADADDR  if none selected

Help on function choose_refresh in module ida_kernwin:

choose_refresh(*args) -> 'void'
    choose_refresh(_self)

Help on function choose_segm in module ida_kernwin:

choose_segm(*args) -> 'segment_t *'
    choose_segm(title, default_ea) -> segment_t *
    
    
    Choose a segment ( 'ui_choose' , 'chtype_segm' ).
    
    @param title: chooser title (C++: const char *)
    @param default_ea: ea of segment to select by default (C++: ea_t)
    @return: pointer to segment that was selected, NULL if none selected

Help on function choose_srcp in module ida_kernwin:

choose_srcp(*args) -> 'sreg_range_t *'
    choose_srcp(title) -> sreg_range_t *
    
    
    Choose a segment register change point ( 'ui_choose' , 'chtype_srcp'
    ).
    
    @param title: chooser title (C++: const char *)
    @return: pointer to segment register range of selected change point,
             NULL if none selected

Help on function choose_stkvar_xref in module ida_kernwin:

choose_stkvar_xref(*args) -> 'ea_t'
    choose_stkvar_xref(pfn, mptr) -> ea_t
    
    
    Choose an xref to a stack variable ( 'ui_choose' , 'chtype_name' ).
    
    @param pfn: function (C++: func_t  *)
    @param mptr: variable (C++: member_t  *)
    @return: ea of the selected xref, BADADDR if none selected

Help on function choose_struc in module ida_kernwin:

choose_struc(*args) -> 'struc_t *'
    choose_struc(title) -> struc_t *
    
    
    Choose a structure ( 'ui_choose' , 'chtype_segm' ).
    
    @param title: chooser title; (C++: const char *)
    @return: pointer to structure that was selected, NULL if none selected

Help on function choose_til in module ida_kernwin:

choose_til(*args) -> 'qstring *'
    choose_til() -> str
    
    
    Choose a type library ( 'ui_choose' , 'chtype_idatil' ).

Help on function choose_xref in module ida_kernwin:

choose_xref(*args) -> 'ea_t'
    choose_xref(to) -> ea_t
    
    
    Choose an xref to an address ( 'ui_choose' , 'chtype_xref' ).
    
    @param to: referenced address (C++: ea_t)
    @return: ea of selected xref, BADADDR if none selected

Help on class chooser_item_attrs_t in module ida_kernwin:

class chooser_item_attrs_t(builtins.object)
 |  Proxy of C++ chooser_item_attrs_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> chooser_item_attrs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_chooser_item_attrs_t(...)
 |      delete_chooser_item_attrs_t(self)
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  color
 |      chooser_item_attrs_t_color_get(self) -> bgcolor_t
 |  
 |  flags
 |      chooser_item_attrs_t_flags_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on function clear_refresh_request in module ida_kernwin:

clear_refresh_request(*args) -> 'void'
    clear_refresh_request(mask)

Help on class cli_t in module ida_kernwin:

class cli_t(ida_idaapi.pyidc_opaque_object_t)
 |  cli_t wrapper class.
 |  
 |  This class allows you to implement your own command line interface handlers.
 |  
 |  Method resolution order:
 |      cli_t
 |      ida_idaapi.pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __del__(self)
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  register(self, flags=0, sname=None, lname=None, hint=None)
 |      Registers the CLI.
 |      
 |      @param flags: Feature bits. No bits are defined yet, must be 0
 |      @param sname: Short name (displayed on the button)
 |      @param lname: Long name (displayed in the menu)
 |      @param hint:  Hint for the input line
 |      
 |      @return Boolean: True-Success, False-Failed
 |  
 |  unregister(self)
 |      Unregisters the CLI (if it was registered)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on function close_chooser in module ida_kernwin:

close_chooser(*args) -> 'bool'
    close_chooser(title) -> bool
    
    
    Close a non-modal chooser ( 'ui_close_chooser' ).
    
    @param title: window title of chooser to close (C++: const char *)
    @return: success

Help on function close_widget in module ida_kernwin:

close_widget(*args) -> 'void'
    close_widget(widget, options)
    
    
    Close widget ( 'ui_close_widget' , only gui version).
    
    @param widget: pointer to the widget to close (C++: TWidget *)
    @param options: Form close flags (C++: int)

Help on function clr_cancelled in module ida_kernwin:

clr_cancelled(*args) -> 'void'
    clr_cancelled()
    
    
    Clear "Cancelled" flag ( 'ui_clr_cancelled' )

Help on function create_code_viewer in module ida_kernwin:

create_code_viewer(*args) -> 'TWidget *'
    create_code_viewer(custview, flags=0, parent=None) -> TWidget *
    
    
    Create a code viewer ( 'ui_create_code_viewer' ). A code viewer
    contains on the left side a widget representing the line numbers, and
    on the right side, the child widget passed as parameter. It will
    inherit its title from the child widget.
    
    @param custview: the custom view to be added (C++: TWidget *)
    @param flags: Code viewer flags (C++: int)
    @param parent: widget to contain the new code viewer (C++: TWidget *)

Help on function create_empty_widget in module ida_kernwin:

create_empty_widget(*args) -> 'TWidget *'
    create_empty_widget(title, icon=-1) -> TWidget *
    
    
    Create an empty widget, serving as a container for custom user widgets
    
    @param title (C++: const char *)
    @param icon (C++: int)

Help on function create_menu in module ida_kernwin:

create_menu(*args) -> 'bool'
    create_menu(name, label, menupath=None) -> bool
    
    
    Create a menu with the given name, label and optional position, either
    in the menubar, or as a submenu. If 'menupath' is non-NULL, it
    provides information about where the menu should be positioned. First,
    IDA will try and resolve the corresponding menu by its name. If such
    an existing menu is found and is present in the menubar, then the new
    menu will be inserted in the menubar before it. Otherwise, IDA will
    try to resolve 'menupath' as it would for 'attach_action_to_menu()'
    and, if found, add the new menu like so:
    
    // The new 'My menu' submenu will appear in the 'Comments' submenu
    // before the 'Enter comment..." command
    create_menu("(...)", "My menu", "Edit/Comments/Enter comment...");
    
    or
    
    // The new 'My menu' submenu will appear at the end of the
    // 'Comments' submenu.
    create_menu("(...)", "My menu", "Edit/Comments/");
    
    If the above fails, the new menu will be appended to the menubar.
    
    @param name: name of menu (must be unique) (C++: const char *)
    @param label: label of menu (C++: const char *)
    @param menupath: where should the menu be inserted (C++: const char *)
    @return: success

Help on function create_toolbar in module ida_kernwin:

create_toolbar(*args) -> 'bool'
    create_toolbar(name, label, before=None, flags=0) -> bool
    
    
    Create a toolbar with the given name, label and optional position
    
    @param name: name of toolbar (must be unique) (C++: const char *)
    @param label: label of toolbar (C++: const char *)
    @param before: if non-NULL, the toolbar before which the new toolbar
                   will be inserted (C++: const char *)
    @param flags: a combination of  create toolbar flags , to determine
                  toolbar position (C++: int)
    @return: success

Help on function custom_viewer_jump in module ida_kernwin:

custom_viewer_jump(*args) -> 'bool'
    custom_viewer_jump(v, loc, flags=0) -> bool
    
    
    Append 'loc' to the viewer's history, and cause the viewer to display
    it.
    
    @param v: (TWidget *) (C++: TWidget *)
    @param loc: (const  lochist_entry_t  &) (C++: const  lochist_entry_t
                &)
    @param flags: (uint32) or'ed combination of CVNF_* values (C++:
                  uint32)
    @return: success

Help on function del_hotkey in module ida_kernwin:

del_hotkey(*args) -> 'bool'
    del_hotkey(pyctx) -> bool
    
    
    Deletes a previously registered function hotkey
    
    @param ctx: Hotkey context previously returned by add_hotkey()
    
    @return: Boolean.

Help on function del_idc_hotkey in module ida_kernwin:

del_idc_hotkey(*args) -> 'bool'
    del_idc_hotkey(hotkey) -> bool
    
    
    Delete IDC function hotkey ( 'ui_del_idckey' ).
    
    @param hotkey: hotkey name (C++: const char *)

Help on function delete_menu in module ida_kernwin:

delete_menu(*args) -> 'bool'
    delete_menu(name) -> bool
    
    
    Delete an existing menu
    
    @param name: name of menu (C++: const char *)
    @return: success

Help on function delete_toolbar in module ida_kernwin:

delete_toolbar(*args) -> 'bool'
    delete_toolbar(name) -> bool
    
    
    Delete an existing toolbar
    
    @param name: name of toolbar (C++: const char *)
    @return: success

Help on function detach_action_from_menu in module ida_kernwin:

detach_action_from_menu(*args) -> 'bool'
    detach_action_from_menu(menupath, name) -> bool
    
    
    Detach an action from the menu ( 'ui_detach_action_from_menu' ).
    
    @param menupath: path to the menu item (C++: const char *)
    @param name: the action name (C++: const char *)
    @return: success

Help on function detach_action_from_popup in module ida_kernwin:

detach_action_from_popup(*args) -> 'bool'
    detach_action_from_popup(widget, name) -> bool
    
    
    Remove a previously-registered action, from the list of 'permanent'
    context menu actions for this widget ( 'ui_detach_action_from_popup'
    ). This only makes sense if the action has been added to 'widget's
    list of permanent popup actions by calling attach_action_to_popup in
    'permanent' mode.
    
    @param widget: target widget (C++: TWidget *)
    @param name: action name (C++: const char *)

Help on function detach_action_from_toolbar in module ida_kernwin:

detach_action_from_toolbar(*args) -> 'bool'
    detach_action_from_toolbar(toolbar_name, name) -> bool
    
    
    Detach an action from the toolbar ( 'ui_detach_action_from_toolbar' ).
    
    @param toolbar_name: the name of the toolbar (C++: const char *)
    @param name: the action name (C++: const char *)
    @return: success

Help on class disasm_line_t in module ida_kernwin:

class disasm_line_t(builtins.object)
 |  Proxy of C++ disasm_line_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> disasm_line_t
 |      __init__(self, other) -> disasm_line_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_disasm_line_t(...)
 |      delete_disasm_line_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  at
 |      disasm_line_t_at_get(self) -> place_t
 |  
 |  bg_color
 |      disasm_line_t_bg_color_get(self) -> bgcolor_t
 |  
 |  is_default
 |      disasm_line_t_is_default_get(self) -> bool
 |  
 |  line
 |      disasm_line_t_line_get(self) -> qstring *
 |  
 |  prefix_color
 |      disasm_line_t_prefix_color_get(self) -> color_t
 |  
 |  thisown
 |      The membership flag

Help on class disasm_text_t in module ida_kernwin:

class disasm_text_t(builtins.object)
 |  Proxy of C++ qvector< disasm_line_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'disasm_line_t const &'
 |      __getitem__(self, i) -> disasm_line_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> disasm_text_t
 |      __init__(self, x) -> disasm_text_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_disasm_text_t(...)
 |      delete_disasm_text_t(self)
 |  
 |  at(self, *args) -> 'disasm_line_t const &'
 |      at(self, _idx) -> disasm_line_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< disasm_line_t >::const_iterator'
 |      begin(self) -> disasm_line_t
 |      begin(self) -> disasm_line_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< disasm_line_t >::const_iterator'
 |      end(self) -> disasm_line_t
 |      end(self) -> disasm_line_t
 |  
 |  erase(self, *args) -> 'qvector< disasm_line_t >::iterator'
 |      erase(self, it) -> disasm_line_t
 |      erase(self, first, last) -> disasm_line_t
 |  
 |  extract(self, *args) -> 'disasm_line_t *'
 |      extract(self) -> disasm_line_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=disasm_line_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< disasm_line_t >::iterator'
 |      insert(self, it, x) -> disasm_line_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'disasm_line_t &'
 |      push_back(self, x)
 |      push_back(self) -> disasm_line_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function display_copyright_warning in module ida_kernwin:

display_copyright_warning(*args) -> 'bool'
    display_copyright_warning() -> bool
    
    
    Display copyright warning ( 'ui_copywarn' ).
    
    @return: yes/no

Help on function display_widget in module ida_kernwin:

display_widget(*args) -> 'void'
    display_widget(widget, options, dest_ctrl=None)
    
    
    Display a widget, dock it if not done before
    
    @param widget: widget to display (C++: TWidget *)
    @param options: Widget open flags (C++: uint32)
    @param dest_ctrl: where to dock: if NULL or invalid then use the
                      active docker if there is not create a new tab
                      relative to current active tab (C++: const char *)

Help on function ea2str in module ida_kernwin:

ea2str(*args) -> 'size_t'
    ea2str(ea) -> str
    
    
    Convert linear address to UTF-8 string.
    
    
    @param ea (C++: ea_t)

Help on function ea_viewer_history_push_and_jump in module ida_kernwin:

ea_viewer_history_push_and_jump(*args) -> 'bool'
    ea_viewer_history_push_and_jump(v, ea, x, y, lnnum) -> bool
    
    
    Push current location in the history and jump to the given location (
    'ui_ea_viewer_history_push_and_jump' ). This will jump in the given ea
    viewer and also in other synchronized views.
    
    @param v: ea viewer (C++: TWidget *)
    @param ea: jump destination (C++: ea_t)
    @param x: coords on screen (C++: int)
    @param y: coords on screen (C++: int)
    @param lnnum: desired line number of given address (C++: int)

Help on function enable_chooser_item_attrs in module ida_kernwin:

enable_chooser_item_attrs(*args) -> 'bool'
    enable_chooser_item_attrs(chooser_caption, enable) -> bool
    
    
    Enable item-specific attributes for chooser items (
    'ui_enable_chooser_item_attrs' ). For example: color list items
    differently depending on a criterium.If enabled, the chooser will
    generate ui_get_chooser_item_attrsevents that can be intercepted by a
    plugin to modify the item attributes.This event is generated only in
    the GUI version of IDA.Specifying 'CH_ATTRS' bit at the chooser
    creation time has the same effect.
    
    @param chooser_caption (C++: const char *)
    @param enable (C++: bool)
    @return: success

Help on class enumplace_t in module ida_kernwin:

class enumplace_t(place_t)
 |  Proxy of C++ enumplace_t class.
 |  
 |  Method resolution order:
 |      enumplace_t
 |      place_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_enumplace_t(...)
 |      delete_enumplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bmask
 |      enumplace_t_bmask_get(self) -> bmask_t
 |  
 |  idx
 |      enumplace_t_idx_get(self) -> size_t
 |  
 |  serial
 |      enumplace_t_serial_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      enumplace_t_value_get(self) -> uval_t
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, out_buf, ud)
 |  
 |  adjust(self, *args) -> 'void'
 |      adjust(self, ud)
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self, ud) -> bool
 |  
 |  clone(self, *args) -> 'place_t *'
 |      clone(self) -> place_t
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, t2) -> int
 |  
 |  copyfrom(self, *args) -> 'void'
 |      copyfrom(self, _from)
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, _in) -> bool
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self, ud) -> bool
 |  
 |  enter(self, *args) -> 'place_t *'
 |      enter(self, arg2) -> place_t
 |  
 |  generate(self, *args) -> 'PyObject *'
 |      generate(self, ud, maxsize) -> PyObject *
 |  
 |  id(self, *args) -> 'int'
 |      id(self) -> int
 |  
 |  leave(self, *args) -> 'void'
 |      leave(self, arg2)
 |  
 |  makeplace(self, *args) -> 'place_t *'
 |      makeplace(self, ud, x, lnnum) -> place_t
 |  
 |  name(self, *args) -> 'char const *'
 |      name(self) -> char const *
 |  
 |  next(self, *args) -> 'bool'
 |      next(self, ud) -> bool
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, ud) -> bool
 |  
 |  rebase(self, *args) -> 'bool'
 |      rebase(self, arg2) -> bool
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self) -> ea_t
 |  
 |  touval(self, *args) -> 'uval_t'
 |      touval(self, ud) -> uval_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args) -> 'enumplace_t *'
 |      as_enumplace_t(p) -> enumplace_t
 |  
 |  as_idaplace_t(*args) -> 'idaplace_t *'
 |      as_idaplace_t(p) -> idaplace_t
 |  
 |  as_simpleline_place_t(*args) -> 'simpleline_place_t *'
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |  
 |  as_structplace_t(*args) -> 'structplace_t *'
 |      as_structplace_t(p) -> structplace_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      place_t_lnnum_get(self) -> int

Help on function error in module ida_kernwin:

error(*args) -> 'void'
    error(format)
    
    
    Display a fatal message in a message box and quit IDA
    
    @param format: message to print

Help on function execute_sync in module ida_kernwin:

execute_sync(*args) -> 'int'
    execute_sync(py_callable, reqf) -> int
    
    
    Executes a function in the context of the main thread.
    If the current thread not the main thread, then the call is queued and
    executed afterwards.
    
    @param callable: A python callable object, must return an integer value
    @param reqf: one of MFF_ flags
    @return: -1 or the return value of the callable

Help on function execute_ui_requests in module ida_kernwin:

execute_ui_requests(*args) -> 'bool'
    execute_ui_requests(py_list) -> bool
    
    
    Inserts a list of callables into the UI message processing queue.
    When the UI is ready it will call one callable.
    A callable can request to be called more than once if it returns True.
    
    @param callable_list: A list of python callable objects.
    @note: A callable should return True if it wants to be called more than once.
    @return: Boolean. False if the list contains a non callabale item

Help on function find_widget in module ida_kernwin:

find_widget(*args) -> 'TWidget *'
    find_widget(caption) -> TWidget *
    
    
    Find widget with the specified caption (only gui version) (
    'ui_find_widget' ). NB: this callback works only with the tabbed
    widgets!
    
    @param caption: title of tab, or window title if widget is not tabbed
                    (C++: const char *)
    @return: pointer to the TWidget, NULL if none is found

Help on function formchgcbfa_close in module ida_kernwin:

formchgcbfa_close(*args) -> 'void'
    formchgcbfa_close(p_fa, close_normally)

Help on function formchgcbfa_enable_field in module ida_kernwin:

formchgcbfa_enable_field(*args) -> 'bool'
    formchgcbfa_enable_field(p_fa, fid, enable) -> bool

Help on function formchgcbfa_get_field_value in module ida_kernwin:

formchgcbfa_get_field_value(*args) -> 'PyObject *'
    formchgcbfa_get_field_value(p_fa, fid, ft, sz) -> PyObject *

Help on function formchgcbfa_get_focused_field in module ida_kernwin:

formchgcbfa_get_focused_field(*args) -> 'int'
    formchgcbfa_get_focused_field(p_fa) -> int

Help on function formchgcbfa_move_field in module ida_kernwin:

formchgcbfa_move_field(*args) -> 'bool'
    formchgcbfa_move_field(p_fa, fid, x, y, w, h) -> bool

Help on function formchgcbfa_refresh_field in module ida_kernwin:

formchgcbfa_refresh_field(*args) -> 'void'
    formchgcbfa_refresh_field(p_fa, fid)

Help on function formchgcbfa_set_field_value in module ida_kernwin:

formchgcbfa_set_field_value(*args) -> 'bool'
    formchgcbfa_set_field_value(p_fa, fid, ft, py_val) -> bool

Help on function formchgcbfa_set_focused_field in module ida_kernwin:

formchgcbfa_set_focused_field(*args) -> 'bool'
    formchgcbfa_set_focused_field(p_fa, fid) -> bool

Help on function formchgcbfa_show_field in module ida_kernwin:

formchgcbfa_show_field(*args) -> 'bool'
    formchgcbfa_show_field(p_fa, fid, show) -> bool

Help on function free_custom_icon in module ida_kernwin:

free_custom_icon(*args) -> 'void'
    free_custom_icon(icon_id)
    
    
    Frees an icon loaded with load_custom_icon()

Help on function gen_disasm_text in module ida_kernwin:

gen_disasm_text(*args) -> 'void'
    gen_disasm_text(text, ea1, ea2, truncate_lines)
    
    
    Generate disassembly text for a range.
    
    @param text: result (C++: text_t  &)
    @param ea1: start address (C++: ea_t)
    @param ea2: end address (C++: ea_t)
    @param truncate_lines: (on  idainfo::margin ) (C++: bool)

Help on function get_action_checkable in module ida_kernwin:

get_action_checkable(*args) -> 'bool *'
    get_action_checkable(name) -> bool
    
    
    Get an action's checkability ( 'ui_get_action_attr' ).
    
    @param name: the action name (C++: const char *)
    @return: success

Help on function get_action_checked in module ida_kernwin:

get_action_checked(*args) -> 'bool *'
    get_action_checked(name) -> bool
    
    
    Get an action's checked state ( 'ui_get_action_attr' ).
    
    @param name: the action name (C++: const char *)
    @return: success

Help on function get_action_icon in module ida_kernwin:

get_action_icon(*args) -> 'int *'
    get_action_icon(name) -> bool
    
    
    Get an action's icon ( 'ui_get_action_attr' ).
    
    @param name: the action name (C++: const char *)
    @return: success

Help on function get_action_label in module ida_kernwin:

get_action_label(*args) -> 'qstring *'
    get_action_label(name) -> str
    
    
    Get an action's label ( 'ui_get_action_attr' ).
    
    @param name: the action name (C++: const char *)
    @return: success

Help on function get_action_shortcut in module ida_kernwin:

get_action_shortcut(*args) -> 'qstring *'
    get_action_shortcut(name) -> str
    
    
    Get an action's shortcut ( 'ui_get_action_attr' ).
    
    @param name: the action name (C++: const char *)
    @return: success

Help on function get_action_state in module ida_kernwin:

get_action_state(*args) -> 'action_state_t *'
    get_action_state(name) -> bool
    
    
    Get an action's state ( 'ui_get_action_attr' ).
    
    @param name: the action name (C++: const char *)
    @return: success

Help on function get_action_tooltip in module ida_kernwin:

get_action_tooltip(*args) -> 'qstring *'
    get_action_tooltip(name) -> str
    
    
    Get an action's tooltip ( 'ui_get_action_attr' ).
    
    @param name: the action name (C++: const char *)
    @return: success

Help on function get_action_visibility in module ida_kernwin:

get_action_visibility(*args) -> 'bool *'
    get_action_visibility(name) -> bool
    
    
    Get an action's visibility ( 'ui_get_action_attr' ).
    
    @param name: the action name (C++: const char *)
    @return: success

Help on function get_active_modal_widget in module ida_kernwin:

get_active_modal_widget(*args) -> 'TWidget *'
    get_active_modal_widget() -> TWidget *
    
    
    Get the current, active modal TWidget instance. Note that in this
    context, the "wait dialog" is not considered: this function will
    return NULL even if it is currently shown.
    
    @return: TWidget * the active modal widget, or NULL

Help on function get_addon_info in module ida_kernwin:

get_addon_info(*args) -> 'bool'
    get_addon_info(id, info) -> bool
    
    
    Get info about a registered addon with a given product code. info->cb
    must be valid! NB: all pointers are invalidated by next call to
    register_addon or get_addon_info
    
    @param id (C++: const char *)
    @param info (C++: addon_info_t  *)
    @return: false if not found

Help on function get_addon_info_idx in module ida_kernwin:

get_addon_info_idx(*args) -> 'bool'
    get_addon_info_idx(index, info) -> bool
    
    
    Get info about a registered addon with specific index. info->cb must
    be valid! NB: all pointers are invalidated by next call to
    register_addon or get_addon_info
    
    @param index (C++: int)
    @param info (C++: addon_info_t  *)
    @return: false if index is out of range

Help on function get_chooser_data in module ida_kernwin:

get_chooser_data(*args) -> 'PyObject *'
    get_chooser_data(chooser_caption, n) -> PyObject *
    
    
    Get the text corresponding to the index N in the chooser data. Use -1
    to get the header.
    
    @param chooser_caption (C++: const char *)
    @param n (C++: int)

Help on function get_chooser_obj in module ida_kernwin:

get_chooser_obj(*args) -> 'void *'
    get_chooser_obj(chooser_caption) -> void *
    
    
    Get the underlying object of the specified chooser (
    'ui_get_chooser_obj' ).This is object is chooser-specific.
    
    @param chooser_caption (C++: const char *)
    @return: the object that was used to create the chooser

Help on function get_curline in module ida_kernwin:

get_curline(*args) -> 'char const *'
    get_curline() -> char const *
    
    
    Get current line from the disassemble window ( 'ui_get_curline' ).
    
    @return: cptr current line with the color codes (use  tag_remove()  to
             remove the color codes)

Help on function get_current_viewer in module ida_kernwin:

get_current_viewer(*args) -> 'TWidget *'
    get_current_viewer() -> TWidget *
    
    
    Get current ida viewer (idaview or custom viewer) (
    'ui_get_current_viewer' )

Help on function get_current_widget in module ida_kernwin:

get_current_widget(*args) -> 'TWidget *'
    get_current_widget() -> TWidget *
    
    
    Get a pointer to the current widget ( 'ui_get_current_widget' ).

Help on function get_cursor in module ida_kernwin:

get_cursor(*args) -> 'int *, int *'
    get_cursor() -> bool
    
    
    Get the cursor position on the screen ( 'ui_get_cursor' ).coordinates
    are 0-based

Help on function get_custom_viewer_curline in module ida_kernwin:

get_custom_viewer_curline(*args) -> 'char const *'
    get_custom_viewer_curline(custom_viewer, mouse) -> char const *
    
    
    Get current line of custom viewer ( 'ui_get_custom_viewer_curline' ).
    The returned line contains color codes
    
    @param custom_viewer: view (C++: TWidget *)
    @param mouse: mouse position (otherwise cursor position) (C++: bool)
    @return: pointer to contents of current line

Help on function get_custom_viewer_location in module ida_kernwin:

get_custom_viewer_location(*args) -> 'bool'
    get_custom_viewer_location(out, custom_viewer, mouse=False) -> bool
    
    
    Get the current location in a custom viewer (
    'ui_get_custom_viewer_location' ).
    
    
    @param out (C++: lochist_entry_t  *)
    @param custom_viewer (C++: TWidget *)
    @param mouse (C++: bool)

Help on function get_custom_viewer_place in module ida_kernwin:

get_custom_viewer_place(*args) -> 'int *, int *'
    get_custom_viewer_place(custom_viewer, mouse) -> place_t
    
    
    Get current place in a custom viewer ( 'ui_get_curplace' ).See also
    the more complete 'get_custom_viewer_location()'
    
    @param custom_viewer: view (C++: TWidget *)
    @param mouse: mouse position (otherwise cursor position) (C++: bool)

Help on function get_ea_viewer_history_info in module ida_kernwin:

get_ea_viewer_history_info(*args) -> 'bool'
    get_ea_viewer_history_info(nback, nfwd, v) -> bool
    
    
    Get information about what's in the history (
    'ui_ea_viewer_history_info' ).
    
    @param nback: number of available back steps (C++: int *)
    @param nfwd: number of available forward steps (C++: int *)
    @param v: ea viewer (C++: TWidget *)

Help on function get_hexdump_ea in module ida_kernwin:

get_hexdump_ea(*args) -> 'ea_t'
    get_hexdump_ea(hexdump_num) -> ea_t
    
    
    Get the current address in a hex view.
    
    @param hexdump_num: number of hexview window (C++: int)

Help on function get_highlight in module ida_kernwin:

get_highlight(*args) -> 'PyObject *'
    get_highlight(v) -> PyObject *
    
    
    Returns the currently highlighted identifier and flags
    
    @return: a tuple (text, flags), or None if nothing
             is highlighted or in case of error.

Help on function get_kernel_version in module ida_kernwin:

get_kernel_version(*args) -> 'size_t'
    get_kernel_version() -> str
    
    
    Get IDA kernel version (in a string like "5.1").

Help on function get_key_code in module ida_kernwin:

get_key_code(*args) -> 'ushort'
    get_key_code(keyname) -> ushort
    
    
    Get keyboard key code by its name ( 'ui_get_key_code' )
    
    
    @param keyname (C++: const char *)

Help on function get_navband_ea in module ida_kernwin:

get_navband_ea(*args) -> 'ea_t'
    get_navband_ea(pixel) -> ea_t
    
    
    Translate the pixel position on the navigation band, into an address.
    
    
    @param pixel (C++: int)

Help on function get_navband_pixel in module ida_kernwin:

get_navband_pixel(*args) -> 'bool *'
    get_navband_pixel(ea) -> int
    
    
    Maps an address, onto a pixel coordinate within the navband
    
    @param ea: The address to map
    @return: a list [pixel, is_vertical]

Help on function get_opnum in module ida_kernwin:

get_opnum(*args) -> 'int'
    get_opnum() -> int
    
    
    Get current operand number, -1 means no operand ( 'ui_get_opnum' )

Help on function get_output_curline in module ida_kernwin:

get_output_curline(*args) -> 'qstring *'
    get_output_curline(mouse) -> str
    
    
    Get current line of output window ( 'ui_get_output_curline' ).
    
    @param mouse: current for mouse pointer? (C++: bool)
    @return: false if output contains no text

Help on function get_output_cursor in module ida_kernwin:

get_output_cursor(*args) -> 'int *, int *'
    get_output_cursor() -> bool
    
    
    Get coordinates of the output window's cursor ( 'ui_get_output_cursor'
    ).coordinates are 0-basedthis function will succeed even if the output
    window is not visible

Help on function get_output_selected_text in module ida_kernwin:

get_output_selected_text(*args) -> 'qstring *'
    get_output_selected_text() -> str
    
    
    Returns selected text from output window (
    'ui_get_output_selected_text' ).
    
    @return: true if there is a selection

Help on function get_place_class in module ida_kernwin:

get_place_class(*args) -> 'place_t const *'
    get_place_class(out_flags, out_sdk_version, id) -> place_t
    
    
    Get information about a previously-registered 'place_t' class. See
    also 'register_place_class()' .
    
    @param out_flags: output flags (can be NULL) (C++: int *)
    @param out_sdk_version: sdk version the place was created with (can be
                            NULL) (C++: int *)
    @param id: place class ID (C++: int)
    @return: the  place_t  template, or NULL if not found

Help on function get_place_class_id in module ida_kernwin:

get_place_class_id(*args) -> 'int'
    get_place_class_id(name) -> int
    
    
    Get the place class ID for the place that has been registered as
    'name'.
    
    @param name: the class name (C++: const char *)
    @return: the place class ID, or -1 if not found

Help on function get_place_class_template in module ida_kernwin:

get_place_class_template(*args) -> 'place_t const *'
    get_place_class_template(id) -> place_t
    
    
    See 'get_place_class()'
    
    
    @param id (C++: int)

Help on function get_registered_actions in module ida_kernwin:

get_registered_actions(*args) -> 'PyObject *'
    get_registered_actions() -> PyObject *
    
    
    Get a list of all currently-registered actions

Help on function get_screen_ea in module ida_kernwin:

get_screen_ea(*args) -> 'ea_t'
    get_screen_ea() -> ea_t
    
    
    Get the address at the screen cursor ( 'ui_screenea' )

Help on function get_tab_size in module ida_kernwin:

get_tab_size(*args) -> 'int'
    get_tab_size(path) -> int
    
    
    Get the size of a tab in spaces ( 'ui_get_tab_size' ).
    
    @param path: the path of the source view for which the tab size is
                 requested.   if NULL, the default size is returned. (C++:
                 const char *)

Help on function get_user_strlist_options in module ida_kernwin:

get_user_strlist_options(*args) -> 'void'
    get_user_strlist_options(out)

Help on function get_view_renderer_type in module ida_kernwin:

get_view_renderer_type(*args) -> 'tcc_renderer_type_t'
    get_view_renderer_type(v) -> tcc_renderer_type_t
    
    
    Get the type of renderer currently in use in the given view (
    'ui_get_renderer_type' )
    
    
    @param v (C++: TWidget *)

Help on function get_viewer_place_type in module ida_kernwin:

get_viewer_place_type(*args) -> 'tcc_place_type_t'
    get_viewer_place_type(viewer) -> tcc_place_type_t
    
    
    Get the type of 'place_t' instances a viewer uses & creates (
    'ui_get_viewer_place_type' ).
    
    
    @param viewer (C++: TWidget *)

Help on function get_viewer_user_data in module ida_kernwin:

get_viewer_user_data(*args) -> 'void *'
    get_viewer_user_data(viewer) -> void *
    
    
    Get the user data from a custom viewer ( 'ui_get_viewer_user_data' )
    
    
    @param viewer (C++: TWidget *)

Help on function get_widget_title in module ida_kernwin:

get_widget_title(*args) -> 'qstring *'
    get_widget_title(widget) -> str
    
    
    Get the TWidget's title ( 'ui_get_widget_title' ).
    
    
    @param widget (C++: TWidget *)

Help on function get_widget_type in module ida_kernwin:

get_widget_type(*args) -> 'twidget_type_t'
    get_widget_type(widget) -> twidget_type_t
    
    
    Get the type of the TWidget * ( 'ui_get_widget_type' ).
    
    
    @param widget (C++: TWidget *)

Help on function get_window_id in module ida_kernwin:

get_window_id(*args) -> 'void *'
    get_window_id(name=None) -> void *
    
    
    Get the system-specific window ID (GUI version only)
    
    @param name (C++: const char *)
    @return: the low-level window ID

Help on function hide_wait_box in module ida_kernwin:

hide_wait_box(*args) -> 'void'
    hide_wait_box()
    
    
    Hide the "Please wait dialog box".

Help on class idaplace_t in module ida_kernwin:

class idaplace_t(place_t)
 |  Proxy of C++ idaplace_t class.
 |  
 |  Method resolution order:
 |      idaplace_t
 |      place_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idaplace_t(...)
 |      delete_idaplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ea
 |      idaplace_t_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, out_buf, ud)
 |  
 |  adjust(self, *args) -> 'void'
 |      adjust(self, ud)
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self, ud) -> bool
 |  
 |  clone(self, *args) -> 'place_t *'
 |      clone(self) -> place_t
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, t2) -> int
 |  
 |  copyfrom(self, *args) -> 'void'
 |      copyfrom(self, _from)
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, _in) -> bool
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self, ud) -> bool
 |  
 |  enter(self, *args) -> 'place_t *'
 |      enter(self, arg2) -> place_t
 |  
 |  generate(self, *args) -> 'PyObject *'
 |      generate(self, ud, maxsize) -> PyObject *
 |  
 |  id(self, *args) -> 'int'
 |      id(self) -> int
 |  
 |  leave(self, *args) -> 'void'
 |      leave(self, arg2)
 |  
 |  makeplace(self, *args) -> 'place_t *'
 |      makeplace(self, ud, x, lnnum) -> place_t
 |  
 |  name(self, *args) -> 'char const *'
 |      name(self) -> char const *
 |  
 |  next(self, *args) -> 'bool'
 |      next(self, ud) -> bool
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, ud) -> bool
 |  
 |  rebase(self, *args) -> 'bool'
 |      rebase(self, arg2) -> bool
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self) -> ea_t
 |  
 |  touval(self, *args) -> 'uval_t'
 |      touval(self, ud) -> uval_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args) -> 'enumplace_t *'
 |      as_enumplace_t(p) -> enumplace_t
 |  
 |  as_idaplace_t(*args) -> 'idaplace_t *'
 |      as_idaplace_t(p) -> idaplace_t
 |  
 |  as_simpleline_place_t(*args) -> 'simpleline_place_t *'
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |  
 |  as_structplace_t(*args) -> 'structplace_t *'
 |      as_structplace_t(p) -> structplace_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      place_t_lnnum_get(self) -> int

Help on function info in module ida_kernwin:

info(*args) -> 'void'
    info(format)

Help on function install_command_interpreter in module ida_kernwin:

install_command_interpreter(*args) -> 'int'
    install_command_interpreter(py_obj) -> int
    
    
    Install command line interpreter ( 'ui_install_cli' )

Help on function internal_register_place_class in module ida_kernwin:

internal_register_place_class(*args) -> 'int'
    internal_register_place_class(tmplate, flags, owner, sdk_version) -> int

Help on function is_action_enabled in module ida_kernwin:

is_action_enabled(*args) -> 'bool'
    is_action_enabled(s) -> bool
    
    
    Check if the given action state is one of AST_ENABLE*.
    
    
    @param s (C++: action_state_t)

Help on function is_chooser_widget in module ida_kernwin:

is_chooser_widget(*args) -> 'bool'
    is_chooser_widget(t) -> bool
    
    
    Does the given widget type specify a chooser widget?
    
    
    @param t (C++: twidget_type_t)

Help on function is_idaq in module ida_kernwin:

is_idaq(*args) -> 'bool'
    is_idaq() -> bool
    
    
    Returns True or False depending if IDAPython is hosted by IDAQ

Help on function is_msg_inited in module ida_kernwin:

is_msg_inited(*args) -> 'bool'
    is_msg_inited() -> bool
    
    
    Can we use msg() functions?

Help on function is_place_class_ea_capable in module ida_kernwin:

is_place_class_ea_capable(*args) -> 'bool'
    is_place_class_ea_capable(id) -> bool
    
    
    See 'get_place_class()'
    
    
    @param id (C++: int)

Help on function is_refresh_requested in module ida_kernwin:

is_refresh_requested(*args) -> 'bool'
    is_refresh_requested(mask) -> bool
    
    
    Get a refresh request state
    
    @param mask: Window refresh flags (C++: uint64)
    @return: the state (set or cleared)

Help on class jobj_wrapper_t in module ida_kernwin:

class jobj_wrapper_t(builtins.object)
 |  Proxy of C++ jobj_wrapper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_dict(self, *args) -> 'PyObject *'
 |      get_dict(self) -> PyObject *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function jumpto in module ida_kernwin:

jumpto(*args) -> 'bool'
    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
    jumpto(custom_viewer, place, x, y) -> bool
    
    
    Jump to the specified address ( 'ui_jumpto' ).
    
    @param ea: destination (C++: ea_t)
    @param opnum: -1: don't change x coord (C++: int)
    @param uijmp_flags: Jump flags (C++: int)
    @return: success

Help on function load_custom_icon in module ida_kernwin:

load_custom_icon(file_name=None, data=None, format=None)
    Loads a custom icon and returns an identifier that can be used with other APIs
    
    If file_name is passed then the other two arguments are ignored.
    
    @param file_name: The icon file name
    @param data: The icon data
    @param format: The icon data format
    
    @return: Icon id or 0 on failure.
             Use free_custom_icon() to free it
    
    
    Load an icon from a file ( 'ui_load_custom_icon_file' ). Also see
    'load_custom_icon(const void *, unsigned int, const char *)'
    
    @return: icon id

Help on function load_dbg_dbginfo in module ida_kernwin:

load_dbg_dbginfo(*args) -> 'bool'
    load_dbg_dbginfo(path, li=None, base=BADADDR, verbose=False) -> bool
    
    
    Load debugging information from a file.
    
    @param path: path to file (C++: const char *)
    @param li: loader input. if NULL, check DBG_NAME_KEY (C++: linput_t *)
    @param base: loading address (C++: ea_t)
    @param verbose: dump status to message window (C++: bool)

Help on function lookup_key_code in module ida_kernwin:

lookup_key_code(*args) -> 'ushort'
    lookup_key_code(key, shift, is_qt) -> ushort
    
    
    Get shortcut code previously created by 'ui_get_key_code' .
    
    @param key: key constant (C++: int)
    @param shift: modifiers (C++: int)
    @param is_qt: are we using gui version? (C++: bool)

Help on function msg in module ida_kernwin:

msg(*args) -> 'PyObject *'
    msg(o) -> PyObject *
    
    
    Display an UTF-8 string in the message window
    
    The result of the stringification of the arguments
    will be treated as an UTF-8 string.
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts

Help on function msg_clear in module ida_kernwin:

msg_clear(*args) -> 'void'
    msg_clear()
    
    
    Clear the "Output window".

Help on function msg_get_lines in module ida_kernwin:

msg_get_lines(*args) -> 'PyObject *'
    msg_get_lines(count=-1) -> PyObject *
    
    
    Retrieve the last 'count' lines from the output window, in reverse
    order (from most recent, to least recent)
    
    @param count: The number of lines to retrieve. -1 means: all (C++:
                  int)

Help on function msg_save in module ida_kernwin:

msg_save(*args) -> 'bool'
    msg_save(path) -> bool
    
    
    Save the "Output window" contents into a file
    
    @param path: The path of the file to save the contents into. An empty
                 path means that the user will be prompted for the
                 destination and, if the file already exists, the user
                 will be asked to confirm before overriding its contents.
                 Upon return, 'path' will contain the path that the user
                 chose. (C++: qstring  &)
    @return: success

Help on function nomem in module ida_kernwin:

nomem(*args) -> 'void'
    nomem(format)

Help on function open_bpts_window in module ida_kernwin:

open_bpts_window(*args) -> 'TWidget *'
    open_bpts_window(ea) -> TWidget *
    
    
    Open the breakpoints window ( 'ui_open_builtin' ).
    
    @param ea: index of entry to select by default (C++: ea_t)
    @return: pointer to resulting window

Help on function open_calls_window in module ida_kernwin:

open_calls_window(*args) -> 'TWidget *'
    open_calls_window(ea) -> TWidget *
    
    
    Open the function calls window ( 'ui_open_builtin' ).
    
    @param ea (C++: ea_t)
    @return: pointer to resulting window

Help on function open_disasm_window in module ida_kernwin:

open_disasm_window(*args) -> 'TWidget *'
    open_disasm_window(window_title, ranges=None) -> TWidget *
    
    
    Open a disassembly view ( 'ui_open_builtin' ).
    
    @param window_title: title of view to open (C++: const char *)
    @param ranges: if != NULL, then display a flow chart with the
                   specified ranges (C++: const  rangevec_t  *)
    @return: pointer to resulting window

Help on function open_enums_window in module ida_kernwin:

open_enums_window(*args) -> 'TWidget *'
    open_enums_window(const_id=BADADDR) -> TWidget *
    
    
    Open the enums window ( 'ui_open_builtin' ).
    
    @param const_id: index of entry to select by default (C++: tid_t)
    @return: pointer to resulting window

Help on function open_exports_window in module ida_kernwin:

open_exports_window(*args) -> 'TWidget *'
    open_exports_window(ea) -> TWidget *
    
    
    Open the exports window ( 'ui_open_builtin' ).
    
    @param ea: index of entry to select by default (C++: ea_t)
    @return: pointer to resulting window

Help on function open_frame_window in module ida_kernwin:

open_frame_window(*args) -> 'TWidget *'
    open_frame_window(pfn, offset) -> TWidget *
    
    
    Open the frame window for the given function ( 'ui_open_builtin' ).
    
    @param pfn: function to analyze (C++: func_t  *)
    @param offset: offset where the cursor is placed (C++: uval_t)
    @return: pointer to resulting window if 'pfn' is a valid function and
             the window was displayed,    NULL otherwise

Help on function open_funcs_window in module ida_kernwin:

open_funcs_window(*args) -> 'TWidget *'
    open_funcs_window(ea) -> TWidget *
    
    
    Open the functions window ( 'ui_open_builtin' ).
    
    @param ea: index of entry to select by default (C++: ea_t)
    @return: pointer to resulting window

Help on function open_hexdump_window in module ida_kernwin:

open_hexdump_window(*args) -> 'TWidget *'
    open_hexdump_window(window_title) -> TWidget *
    
    
    Open a hexdump view ( 'ui_open_builtin' ).
    
    @param window_title: title of view to open (C++: const char *)
    @return: pointer to resulting window

Help on function open_imports_window in module ida_kernwin:

open_imports_window(*args) -> 'TWidget *'
    open_imports_window(ea) -> TWidget *
    
    
    Open the exports window ( 'ui_open_builtin' ).
    
    @param ea: index of entry to select by default (C++: ea_t)
    @return: pointer to resulting window

Help on function open_loctypes_window in module ida_kernwin:

open_loctypes_window(*args) -> 'TWidget *'
    open_loctypes_window(ordinal) -> TWidget *
    
    
    Open the local types window ( 'ui_open_builtin' ).
    
    @param ordinal: ordinal of type to select by default (C++: int)
    @return: pointer to resulting window

Help on function open_modules_window in module ida_kernwin:

open_modules_window(*args) -> 'TWidget *'
    open_modules_window() -> TWidget *
    
    
    Open the modules window ( 'ui_open_builtin' ).
    
    @return: pointer to resulting window

Help on function open_names_window in module ida_kernwin:

open_names_window(*args) -> 'TWidget *'
    open_names_window(ea) -> TWidget *
    
    
    Open the names window ( 'ui_open_builtin' ).
    
    @param ea: index of entry to select by default (C++: ea_t)
    @return: pointer to resulting window

Help on function open_navband_window in module ida_kernwin:

open_navband_window(*args) -> 'TWidget *'
    open_navband_window(ea, zoom) -> TWidget *
    
    
    Open the navigation band window ( 'ui_open_builtin' ).
    
    @param ea: sets the address of the navband arrow (C++: ea_t)
    @param zoom: sets the navband zoom level (C++: int)
    @return: pointer to resulting window

Help on function open_notepad_window in module ida_kernwin:

open_notepad_window(*args) -> 'TWidget *'
    open_notepad_window() -> TWidget *
    
    
    Open the notepad window ( 'ui_open_builtin' ).
    
    @return: pointer to resulting window

Help on function open_problems_window in module ida_kernwin:

open_problems_window(*args) -> 'TWidget *'
    open_problems_window(ea) -> TWidget *
    
    
    Open the problems window ( 'ui_open_builtin' ).
    
    @param ea: index of entry to select by default (C++: ea_t)
    @return: pointer to resulting window

Help on function open_segments_window in module ida_kernwin:

open_segments_window(*args) -> 'TWidget *'
    open_segments_window(ea) -> TWidget *
    
    
    Open the segments window ( 'ui_open_builtin' ).
    
    @param ea: index of entry to select by default (C++: ea_t)
    @return: pointer to resulting window

Help on function open_segregs_window in module ida_kernwin:

open_segregs_window(*args) -> 'TWidget *'
    open_segregs_window(ea) -> TWidget *
    
    
    Open the segment registers window ( 'ui_open_builtin' ).
    
    @param ea: index of entry to select by default (C++: ea_t)
    @return: pointer to resulting window

Help on function open_selectors_window in module ida_kernwin:

open_selectors_window(*args) -> 'TWidget *'
    open_selectors_window() -> TWidget *
    
    
    Open the selectors window ( 'ui_open_builtin' ).
    
    @return: pointer to resulting window

Help on function open_signatures_window in module ida_kernwin:

open_signatures_window(*args) -> 'TWidget *'
    open_signatures_window() -> TWidget *
    
    
    Open the signatures window ( 'ui_open_builtin' ).
    
    @return: pointer to resulting window

Help on function open_stack_window in module ida_kernwin:

open_stack_window(*args) -> 'TWidget *'
    open_stack_window() -> TWidget *
    
    
    Open the call stack window ( 'ui_open_builtin' ).
    
    @return: pointer to resulting window

Help on function open_strings_window in module ida_kernwin:

open_strings_window(*args) -> 'TWidget *'
    open_strings_window(ea, selstart=BADADDR, selend=BADADDR) -> TWidget *
    
    
    Open the strings window ( 'ui_open_builtin' ).
    
    @param ea: index of entry to select by default (C++: ea_t)
    @param selstart: only display strings that occur within this range
                     (C++: ea_t)
    @param selend: only display strings that occur within this range (C++:
                   ea_t)
    @return: pointer to resulting window

Help on function open_structs_window in module ida_kernwin:

open_structs_window(*args) -> 'TWidget *'
    open_structs_window(id=BADADDR, offset=0) -> TWidget *
    
    
    Open the structs window ( 'ui_open_builtin' ).
    
    @param id: index of entry to select by default (C++: tid_t)
    @param offset: offset where the cursor is placed (C++: uval_t)
    @return: pointer to resulting window

Help on function open_threads_window in module ida_kernwin:

open_threads_window(*args) -> 'TWidget *'
    open_threads_window() -> TWidget *
    
    
    Open the threads window ( 'ui_open_builtin' ).
    
    @return: pointer to resulting window

Help on function open_tils_window in module ida_kernwin:

open_tils_window(*args) -> 'TWidget *'
    open_tils_window() -> TWidget *
    
    
    Open the type libraries window ( 'ui_open_builtin' ).
    
    @return: pointer to resulting window

Help on function open_trace_window in module ida_kernwin:

open_trace_window(*args) -> 'TWidget *'
    open_trace_window() -> TWidget *
    
    
    Open the trace window ( 'ui_open_builtin' ).
    
    @return: pointer to resulting window

Help on function open_url in module ida_kernwin:

open_url(*args) -> 'void'
    open_url(url)
    
    
    Open the given url ( 'ui_open_url' )
    
    
    @param url (C++: const char *)

Help on function open_xrefs_window in module ida_kernwin:

open_xrefs_window(*args) -> 'TWidget *'
    open_xrefs_window(ea) -> TWidget *
    
    
    Open the cross references window ( 'ui_open_builtin' ).
    
    @param ea: index of entry to select by default (C++: ea_t)
    @return: pointer to resulting window

Help on class place_t in module ida_kernwin:

class place_t(builtins.object)
 |  Proxy of C++ place_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_place_t(...)
 |      delete_place_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, out_buf, ud)
 |  
 |  adjust(self, *args) -> 'void'
 |      adjust(self, ud)
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self, ud) -> bool
 |  
 |  clone(self, *args) -> 'place_t *'
 |      clone(self) -> place_t
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, t2) -> int
 |  
 |  copyfrom(self, *args) -> 'void'
 |      copyfrom(self, _from)
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, _in) -> bool
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self, ud) -> bool
 |  
 |  enter(self, *args) -> 'place_t *'
 |      enter(self, arg2) -> place_t
 |  
 |  generate(self, *args) -> 'PyObject *'
 |      generate(self, ud, maxsize) -> PyObject *
 |  
 |  id(self, *args) -> 'int'
 |      id(self) -> int
 |  
 |  leave(self, *args) -> 'void'
 |      leave(self, arg2)
 |  
 |  makeplace(self, *args) -> 'place_t *'
 |      makeplace(self, ud, x, lnnum) -> place_t
 |  
 |  name(self, *args) -> 'char const *'
 |      name(self) -> char const *
 |  
 |  next(self, *args) -> 'bool'
 |      next(self, ud) -> bool
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, ud) -> bool
 |  
 |  rebase(self, *args) -> 'bool'
 |      rebase(self, arg2) -> bool
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self) -> ea_t
 |  
 |  touval(self, *args) -> 'uval_t'
 |      touval(self, ud) -> uval_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  as_enumplace_t(*args) -> 'enumplace_t *'
 |      as_enumplace_t(p) -> enumplace_t
 |  
 |  as_idaplace_t(*args) -> 'idaplace_t *'
 |      as_idaplace_t(p) -> idaplace_t
 |  
 |  as_simpleline_place_t(*args) -> 'simpleline_place_t *'
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |  
 |  as_structplace_t(*args) -> 'structplace_t *'
 |      as_structplace_t(p) -> structplace_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      place_t_lnnum_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on function place_t_as_enumplace_t in module ida_kernwin:

place_t_as_enumplace_t(*args) -> 'enumplace_t *'
    place_t_as_enumplace_t(p) -> enumplace_t

Help on function place_t_as_idaplace_t in module ida_kernwin:

place_t_as_idaplace_t(*args) -> 'idaplace_t *'
    place_t_as_idaplace_t(p) -> idaplace_t

Help on function place_t_as_simpleline_place_t in module ida_kernwin:

place_t_as_simpleline_place_t(*args) -> 'simpleline_place_t *'
    place_t_as_simpleline_place_t(p) -> simpleline_place_t

Help on function place_t_as_structplace_t in module ida_kernwin:

place_t_as_structplace_t(*args) -> 'structplace_t *'
    place_t_as_structplace_t(p) -> structplace_t

Help on function plgform_close in module ida_kernwin:

plgform_close(*args) -> 'void'
    plgform_close(py_link, options)

Help on function plgform_get_widget in module ida_kernwin:

plgform_get_widget(*args) -> 'TWidget *'
    plgform_get_widget(py_link) -> TWidget *

Help on function plgform_new in module ida_kernwin:

plgform_new(*args) -> 'PyObject *'
    plgform_new() -> PyObject *

Help on function plgform_show in module ida_kernwin:

plgform_show(*args) -> 'bool'
    plgform_show(py_link, py_obj, caption, options=WOPN_DP_TAB|WOPN_RESTORE) -> bool

Help on function process_ui_action in module ida_kernwin:

process_ui_action(*args) -> 'bool'
    process_ui_action(name, flags=0) -> bool
    
    
    Invokes an IDA UI action by name
    
    @param name:  action name
    @return: Boolean

Help on function py_get_ask_form in module ida_kernwin:

py_get_ask_form(*args) -> 'size_t'
    py_get_ask_form() -> size_t

Help on function py_get_open_form in module ida_kernwin:

py_get_open_form(*args) -> 'size_t'
    py_get_open_form() -> size_t

Help on function py_load_custom_icon_data in module ida_kernwin:

py_load_custom_icon_data(*args) -> 'int'
    py_load_custom_icon_data(data, format) -> int

Help on function py_load_custom_icon_fn in module ida_kernwin:

py_load_custom_icon_fn(*args) -> 'int'
    py_load_custom_icon_fn(filename) -> int

Help on function py_register_compiled_form in module ida_kernwin:

py_register_compiled_form(*args) -> 'void'
    py_register_compiled_form(py_form)

Help on function py_ss_restore_callback in module ida_kernwin:

py_ss_restore_callback(*args) -> 'void'
    py_ss_restore_callback(err_msg, userdata)

Help on function py_unregister_compiled_form in module ida_kernwin:

py_unregister_compiled_form(*args) -> 'void'
    py_unregister_compiled_form(py_form)

Help on function pyidag_bind in module ida_kernwin:

pyidag_bind(*args) -> 'bool'
    pyidag_bind(_self) -> bool

Help on function pyidag_unbind in module ida_kernwin:

pyidag_unbind(*args) -> 'bool'
    pyidag_unbind(_self) -> bool

Help on function pyscv_add_line in module ida_kernwin:

pyscv_add_line(*args) -> 'bool'
    pyscv_add_line(py_this, py_sl) -> bool

Help on function pyscv_clear_lines in module ida_kernwin:

pyscv_clear_lines(*args) -> 'PyObject *'
    pyscv_clear_lines(py_this) -> PyObject *

Help on function pyscv_close in module ida_kernwin:

pyscv_close(*args) -> 'void'
    pyscv_close(py_this)

Help on function pyscv_count in module ida_kernwin:

pyscv_count(*args) -> 'size_t'
    pyscv_count(py_this) -> size_t

Help on function pyscv_del_line in module ida_kernwin:

pyscv_del_line(*args) -> 'bool'
    pyscv_del_line(py_this, nline) -> bool

Help on function pyscv_edit_line in module ida_kernwin:

pyscv_edit_line(*args) -> 'bool'
    pyscv_edit_line(py_this, nline, py_sl) -> bool

Help on function pyscv_get_current_line in module ida_kernwin:

pyscv_get_current_line(*args) -> 'PyObject *'
    pyscv_get_current_line(py_this, mouse, notags) -> PyObject *

Help on function pyscv_get_current_word in module ida_kernwin:

pyscv_get_current_word(*args) -> 'PyObject *'
    pyscv_get_current_word(py_this, mouse) -> PyObject *

Help on function pyscv_get_line in module ida_kernwin:

pyscv_get_line(*args) -> 'PyObject *'
    pyscv_get_line(py_this, nline) -> PyObject *

Help on function pyscv_get_pos in module ida_kernwin:

pyscv_get_pos(*args) -> 'PyObject *'
    pyscv_get_pos(py_this, mouse) -> PyObject *

Help on function pyscv_get_selection in module ida_kernwin:

pyscv_get_selection(*args) -> 'PyObject *'
    pyscv_get_selection(py_this) -> PyObject *

Help on function pyscv_get_widget in module ida_kernwin:

pyscv_get_widget(*args) -> 'TWidget *'
    pyscv_get_widget(py_this) -> TWidget *

Help on function pyscv_init in module ida_kernwin:

pyscv_init(*args) -> 'PyObject *'
    pyscv_init(py_link, title) -> PyObject *

Help on function pyscv_insert_line in module ida_kernwin:

pyscv_insert_line(*args) -> 'bool'
    pyscv_insert_line(py_this, nline, py_sl) -> bool

Help on function pyscv_is_focused in module ida_kernwin:

pyscv_is_focused(*args) -> 'bool'
    pyscv_is_focused(py_this) -> bool

Help on function pyscv_jumpto in module ida_kernwin:

pyscv_jumpto(*args) -> 'bool'
    pyscv_jumpto(py_this, ln, x, y) -> bool

Help on function pyscv_patch_line in module ida_kernwin:

pyscv_patch_line(*args) -> 'bool'
    pyscv_patch_line(py_this, nline, offs, value) -> bool

Help on function pyscv_refresh in module ida_kernwin:

pyscv_refresh(*args) -> 'bool'
    pyscv_refresh(py_this) -> bool

Help on function pyscv_show in module ida_kernwin:

pyscv_show(*args) -> 'bool'
    pyscv_show(py_this) -> bool

Help on function qcleanline in module ida_kernwin:

qcleanline(*args) -> 'qstring *'
    qcleanline(cmt_char='\0', flags=((1 << 0)|(1 << 1))|(1 << 2)) -> str
    
    
    Performs some cleanup operations to a line.
    
    @param cmt_char: character that denotes the start of a comment:   the
                     entire text is removed if the line begins with this
                     character (ignoring leading spaces)   all text after
                     (and including) this character is removed if flag
                     CLNL_FINDCMT is set (C++: char)
    @param flags: a combination of  line cleanup flags . defaults to
                  CLNL_TRIM (C++: uint32)
    @return: length of line

Help on class quick_widget_commands_t in module ida_kernwin:

class quick_widget_commands_t(builtins.object)
 |  # ----------------------------------------------------------------------
 |  # This provides an alternative to register_action()+attach_action_to_popup_menu()
 |  
 |  Methods defined here:
 |  
 |  __init__(self, callback)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  add(self, caption, flags, menu_index, icon, emb, shortcut)
 |  
 |  populate_popup(self, widget, popup)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  _ah_t = <class 'ida_kernwin.quick_widget_commands_t._ah_t'>
 |  
 |  
 |  _cmd_t = <class 'ida_kernwin.quick_widget_commands_t._cmd_t'>

Help on function read_range_selection in module ida_kernwin:

read_range_selection(*args) -> 'ea_t *, ea_t *'
    read_range_selection(v) -> bool
    
    
    Get the address range for the selected range boundaries, this is the
    convenient function for 'read_selection()'
    
    @param v: view, NULL means the last active window containing addresses
              (C++: TWidget *)

Help on function read_selection in module ida_kernwin:

read_selection(*args) -> 'bool'
    read_selection(v, p1, p2) -> bool
    
    
    Read the user selection, and store its information in p0 (from) and p1 (to).
    
    This can be used as follows:
    
    
    >>> p0 = idaapi.twinpos_t()
    p1 = idaapi.twinpos_t()
    view = idaapi.get_current_viewer()
    idaapi.read_selection(view, p0, p1)
    
    
    At that point, p0 and p1 hold information for the selection.
    But, the 'at' property of p0 and p1 is not properly typed.
    To specialize it, call #place() on it, passing it the view
    they were retrieved from. Like so:
    
    
    >>> place0 = p0.place(view)
    place1 = p1.place(view)
    
    
    This will effectively "cast" the place into a specialized type,
    holding proper information, depending on the view type (e.g.,
    disassembly, structures, enums, ...)
    
    @param view: The view to retrieve the selection for.
    @param p0: Storage for the "from" part of the selection.
    @param p1: Storage for the "to" part of the selection.
    @return: a bool value indicating success.

Help on function refresh_chooser in module ida_kernwin:

refresh_chooser(*args) -> 'bool'
    refresh_chooser(title) -> bool
    
    
    Mark a non-modal custom chooser for a refresh ( 'ui_refresh_chooser'
    ).
    
    @param title: title of chooser (C++: const char *)
    @return: success

Help on function refresh_choosers in module ida_kernwin:

refresh_choosers(*args) -> 'void'
    refresh_choosers()

Help on function refresh_idaview in module ida_kernwin:

refresh_idaview(*args) -> 'void'
    refresh_idaview()
    
    
    Refresh marked windows ( 'ui_refreshmarked' )

Help on function refresh_idaview_anyway in module ida_kernwin:

refresh_idaview_anyway(*args) -> 'void'
    refresh_idaview_anyway()
    
    
    Refresh all disassembly views ( 'ui_refresh' ), forces an immediate
    refresh. Please consider 'request_refresh()' instead

Help on function refresh_navband in module ida_kernwin:

refresh_navband(*args) -> 'void'
    refresh_navband(force)
    
    
    Refresh navigation band if changed ( 'ui_refresh_navband' ).
    
    @param force: refresh regardless (C++: bool)

Help on function register_action in module ida_kernwin:

register_action(*args) -> 'bool'
    register_action(desc) -> bool
    
    
    Create a new action ( 'ui_register_action' ). After an action has been
    created, it is possible to attach it to menu items (
    'attach_action_to_menu()' ), or to popup menus (
    'attach_action_to_popup()' ).Because the actions will need to call the
    handler's activate() and update() methods at any time, you shouldn't
    build your action handler on the stack.Please see the SDK's "ht_view"
    plugin for an example how to register actions.
    
    @param desc: action to register (C++: const  action_desc_t  &)
    @return: success

Help on function register_addon in module ida_kernwin:

register_addon(*args) -> 'int'
    register_addon(info) -> int
    
    
    Register an add-on. Show its info in the About box. For plugins,
    should be called from init() function (repeated calls with the same
    product code overwrite previous entries) returns: index of the add-on
    in the list, or -1 on error
    
    @param info (C++: const  addon_info_t  *)

Help on function register_and_attach_to_menu in module ida_kernwin:

register_and_attach_to_menu(*args) -> 'bool'
    register_and_attach_to_menu(menupath, name, label, shortcut, flags, handler, owner) -> bool
    
    
    Helper.You are not encouraged to use this, as it mixes flags for both
    'register_action()' , and 'attach_action_to_menu()' .The only reason
    for its existence is to make it simpler to port existing plugins to
    the new actions API.
    
    @param menupath (C++: const char *)
    @param name (C++: const char *)
    @param label (C++: const char *)
    @param shortcut (C++: const char *)
    @param flags (C++: int)
    @param handler (C++: action_handler_t  *)
    @param owner (C++: const  plugin_t  *)

Help on function register_timer in module ida_kernwin:

register_timer(*args) -> 'PyObject *'
    register_timer(interval, py_callback) -> PyObject *
    
    
    Register a timer
    
    @param interval: Interval in milliseconds
    @param callback: A Python callable that takes no parameters and returns an integer.
                     The callback may return:
                     -1   : to unregister the timer
                     >= 0 : the new or same timer interval
    @return: None or a timer object

Help on function remove_command_interpreter in module ida_kernwin:

remove_command_interpreter(*args) -> 'void'
    remove_command_interpreter(cli_idx)
    
    
    Remove command line interpreter ( 'ui_install_cli' )

Help on class renderer_pos_info_t in module ida_kernwin:

class renderer_pos_info_t(builtins.object)
 |  Proxy of C++ renderer_pos_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> renderer_pos_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_renderer_pos_info_t(...)
 |      delete_renderer_pos_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cx
 |      renderer_pos_info_t_cx_get(self) -> short
 |  
 |  cy
 |      renderer_pos_info_t_cy_get(self) -> short
 |  
 |  node
 |      renderer_pos_info_t_node_get(self) -> int
 |  
 |  sx
 |      renderer_pos_info_t_sx_get(self) -> short
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function repaint_custom_viewer in module ida_kernwin:

repaint_custom_viewer(*args) -> 'void'
    repaint_custom_viewer(custom_viewer)
    
    
    Repaint the given widget immediately ( 'ui_repaint_qwidget' )
    
    
    @param custom_viewer (C++: TWidget *)

Help on function replace_wait_box in module ida_kernwin:

replace_wait_box(*args) -> 'void'
    replace_wait_box(format)
    
    
    Replace the label of "Please wait dialog box".
    
    
    @param format (C++: const char *)

Help on function request_refresh in module ida_kernwin:

request_refresh(*args) -> 'void'
    request_refresh(mask, cnd=True)
    
    
    Request a refresh of a builtin window.
    
    @param mask: Window refresh flags (C++: uint64)
    @param cnd: set if true or clear flag otherwise (C++: bool)

Help on function restore_database_snapshot in module ida_kernwin:

restore_database_snapshot(*args) -> 'PyObject *'
    restore_database_snapshot(ss, pyfunc_or_none, pytuple_or_none) -> PyObject *
    
    
    Restore a database snapshot. Note: This call is asynchronous. When it
    is completed, the callback will be triggered.
    
    @param ss: snapshot instance (see  build_snapshot_tree() ) (C++: const
               snapshot_t  *)
    @return: false if restoration could not be started (snapshot file was
             not found).    If the returned value is True then check if
             the operation succeeded from the callback.

Help on function set_cancelled in module ida_kernwin:

set_cancelled(*args) -> 'void'
    set_cancelled()
    
    
    Set "Cancelled" flag ( 'ui_set_cancelled' )

Help on function set_code_viewer_handler in module ida_kernwin:

set_code_viewer_handler(*args) -> 'void *'
    set_code_viewer_handler(code_viewer, handler_id, handler_or_data) -> void *
    
    
    Set a handler for a code viewer event ( 'ui_set_custom_viewer_handler'
    ).
    
    @param code_viewer: the code viewer (C++: TWidget *)
    @param handler_id: one of CDVH_ in  custom_viewer_handler_id_t (C++:
                       custom_viewer_handler_id_t)
    @param handler_or_data: can be a handler or data. see examples in
                            Functions: custom viewer handlers (C++: void
                            *)
    @return: old value of the handler or data

Help on function set_code_viewer_is_source in module ida_kernwin:

set_code_viewer_is_source(*args) -> 'bool'
    set_code_viewer_is_source(code_viewer) -> bool
    
    
    Specify that the given code viewer is used to display source code (
    'ui_set_custom_viewer_handler' ).
    
    
    @param code_viewer (C++: TWidget *)

Help on function set_code_viewer_line_handlers in module ida_kernwin:

set_code_viewer_line_handlers(*args) -> 'void'
    set_code_viewer_line_handlers(code_viewer, click_handler, popup_handler, dblclick_handler, drawicon_handler, linenum_handler)
    
    
    Set handlers for code viewer line events. Any of these handlers may be
    NULL
    
    @param code_viewer (C++: TWidget *)
    @param click_handler (C++: code_viewer_lines_click_t  *)
    @param popup_handler (C++: code_viewer_lines_click_t  *)
    @param dblclick_handler (C++: code_viewer_lines_click_t  *)
    @param drawicon_handler (C++: code_viewer_lines_icon_t  *)
    @param linenum_handler (C++: code_viewer_lines_linenum_t  *)

Help on function set_code_viewer_lines_alignment in module ida_kernwin:

set_code_viewer_lines_alignment(*args) -> 'bool'
    set_code_viewer_lines_alignment(code_viewer, align) -> bool
    
    
    Set alignment for lines in a code viewer (
    'ui_set_custom_viewer_handler' ).
    
    
    @param code_viewer (C++: TWidget *)
    @param align (C++: int)

Help on function set_code_viewer_lines_icon_margin in module ida_kernwin:

set_code_viewer_lines_icon_margin(*args) -> 'bool'
    set_code_viewer_lines_icon_margin(code_viewer, margin) -> bool
    
    
    Set space allowed for icons in the margin of a code viewer (
    'ui_set_custom_viewer_handler' ).
    
    
    @param code_viewer (C++: TWidget *)
    @param margin (C++: int)

Help on function set_code_viewer_lines_radix in module ida_kernwin:

set_code_viewer_lines_radix(*args) -> 'bool'
    set_code_viewer_lines_radix(code_viewer, radix) -> bool
    
    
    Set radix for values displayed in a code viewer (
    'ui_set_custom_viewer_handler' ).
    
    
    @param code_viewer (C++: TWidget *)
    @param radix (C++: int)

Help on function set_code_viewer_user_data in module ida_kernwin:

set_code_viewer_user_data(*args) -> 'bool'
    set_code_viewer_user_data(code_viewer, ud) -> bool
    
    
    Set the user data on a code viewer ( 'ui_set_custom_viewer_handler' ).
    
    
    @param code_viewer (C++: TWidget *)
    @param ud (C++: void *)

Help on function set_custom_viewer_qt_aware in module ida_kernwin:

set_custom_viewer_qt_aware(*args) -> 'bool'
    set_custom_viewer_qt_aware(custom_viewer) -> bool
    
    
    Allow the given viewer to interpret Qt events (
    'ui_set_custom_viewer_handler' )
    
    
    @param custom_viewer (C++: TWidget *)

Help on function set_dock_pos in module ida_kernwin:

set_dock_pos(*args) -> 'bool'
    set_dock_pos(src_ctrl, dest_ctrl, orient, left=0, top=0, right=0, bottom=0) -> bool
    
    
    Sets the dock orientation of a window relatively to another window.
    
    @param src: Source docking control
    @param dest: Destination docking control
    @param orient: One of DOR_XXXX constants
    @param left, top, right, bottom: These parameter if DOR_FLOATING is used, or if you want to specify the width of docked windows
    @return: Boolean
    
    Example:
        set_dock_pos('Structures', 'Enums', DOR_RIGHT) <- docks the Structures window to the right of Enums window

Help on function set_highlight in module ida_kernwin:

set_highlight(*args) -> 'bool'
    set_highlight(viewer, str, flags) -> bool
    
    
    Set the highlighted identifier in the viewer ( 'ui_set_highlight' ).
    
    @param viewer: the viewer (C++: TWidget *)
    @param str: the text to match, or NULL to remove current (C++: const
                char *)
    @param flags: combination of HIF_... bits (see  set_highlightr flags )
                  (C++: int)
    @return: false if an error occurred

Help on function set_nav_colorizer in module ida_kernwin:

set_nav_colorizer(*args) -> 'PyObject *'
    set_nav_colorizer(new_py_colorizer) -> PyObject *
    
    
    Set a new colorizer for the navigation band.
    
    The 'callback' is a function of 2 arguments:
       - ea (the EA to colorize for)
       - nbytes (the number of bytes at that EA)
    and must return a 'long' value.
    
    The previous colorizer is returned, allowing
    the new 'callback' to use 'call_nav_colorizer'
    with it.
    
    Note that the previous colorizer is returned
    only the first time set_nav_colorizer() is called:
    due to the way the colorizers API is defined in C,
    it is impossible to chain more than 2 colorizers
    in IDAPython: the original, IDA-provided colorizer,
    and a user-provided one.
    
    Example: colorizer inverting the color provided by the IDA colorizer:
        def my_colorizer(ea, nbytes):
            global ida_colorizer
            orig = idaapi.call_nav_colorizer(ida_colorizer, ea, nbytes)
            return long(~orig)
    
        ida_colorizer = idaapi.set_nav_colorizer(my_colorizer)

Help on function set_view_renderer_type in module ida_kernwin:

set_view_renderer_type(*args) -> 'void'
    set_view_renderer_type(v, rt)
    
    
    Set the type of renderer to use in a view ( 'ui_set_renderer_type' )
    
    
    @param v (C++: TWidget *)
    @param rt (C++: tcc_renderer_type_t)

Help on function show_wait_box in module ida_kernwin:

show_wait_box(*args) -> 'void'
    show_wait_box(message)
    
    
    Display a dialog box with "Please wait...". If the text message starts
    with "HIDECANCEL\n", the cancel buttonwon't be displayed in the dialog
    box and you don't need to checkfor cancellations with
    'user_cancelled()' . Plugins must call 'hide_wait_box()' to close the
    dialog box, otherwise the user interface will be disabled.Note that,
    if the wait dialog is already visible, 'show_wait_box()' will1) push
    the currently-displayed text on a stack2) display the new textThen,
    when 'hide_wait_box()' is called, if that stack isn't empty its
    toplabel will be popped and restored in the wait dialog.This implies
    that a plugin should call 'hide_wait_box()' exactly as manytimes as it
    called 'show_wait_box()' , or the wait dialog might remainvisible and
    block the UI.Also, in case the plugin knows the wait dialog is
    currently displayed,alternatively it can call 'replace_wait_box()' ,
    to replace the text of thedialog without pushing the currently-
    displayed text on the stack.

Help on class simplecustviewer_t in module ida_kernwin:

class simplecustviewer_t(builtins.object)
 |  The base class for implementing simple custom viewers
 |  
 |  Methods defined here:
 |  
 |  AddLine(self, line, fgcolor=None, bgcolor=None)
 |      Adds a colored line to the view
 |      @return: Boolean
 |  
 |  ClearLines(self)
 |      Clears all the lines
 |  
 |  Close(self)
 |      Destroys the view.
 |      One has to call Create() afterwards.
 |      Show() can be called and it will call Create() internally.
 |      @return: Boolean
 |  
 |  Count(self)
 |      Returns the number of lines in the view
 |  
 |  Create(self, title)
 |      Creates the custom view. This should be the first method called after instantiation
 |      
 |      @param title: The title of the view
 |      @return: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
 |               In this case better close existing windows
 |  
 |  DelLine(self, lineno)
 |      Deletes an existing line
 |      @return: Boolean
 |  
 |  EditLine(self, lineno, line, fgcolor=None, bgcolor=None)
 |      Edits an existing line.
 |      @return: Boolean
 |  
 |  GetCurrentLine(self, mouse=0, notags=0)
 |      Returns the current line.
 |      @param mouse: Current line at mouse pos
 |      @param notags: If True then tag_remove() will be called before returning the line
 |      @return: Returns the current line (colored or uncolored) or None on failure
 |  
 |  GetCurrentWord(self, mouse=0)
 |      Returns the current word
 |      @param mouse: Use mouse position or cursor position
 |      @return: None if failed or a String containing the current word at mouse or cursor
 |  
 |  GetLine(self, lineno)
 |      Returns a line
 |      @param lineno: The line number
 |      @return:
 |          Returns a tuple (colored_line, fgcolor, bgcolor) or None
 |  
 |  GetLineNo(self, mouse=0)
 |      Calls GetPos() and returns the current line number or -1 on failure
 |  
 |  GetPos(self, mouse=0)
 |      Returns the current cursor or mouse position.
 |      @param mouse: return mouse position
 |      @return: Returns a tuple (lineno, x, y)
 |  
 |  GetSelection(self)
 |      Returns the selected range or None
 |      @return:
 |          - tuple(x1, y1, x2, y2)
 |          - None if no selection
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  InsertLine(self, lineno, line, fgcolor=None, bgcolor=None)
 |      Inserts a line in the given position
 |      @return: Boolean
 |  
 |  IsFocused(self)
 |      Returns True if the current view is the focused view
 |  
 |  Jump(self, lineno, x=0, y=0)
 |  
 |  OnPopup(self, form, popup_handle)
 |      Context menu popup is about to be shown. Create items dynamically if you wish
 |      @return: Boolean. True if you handled the event
 |  
 |  PatchLine(self, lineno, offs, value)
 |      Patches an existing line character at the given offset. This is a low level function. You must know what you're doing
 |  
 |  Refresh(self)
 |  
 |  RefreshCurrent(self)
 |      Refreshes the current line only
 |  
 |  Show(self)
 |      Shows an already created view. It the view was close, then it will call Create() for you
 |      @return: Boolean
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  _simplecustviewer_t__make_sl_arg = __make_sl_arg(line, fgcolor=None, bgcolor=None)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  UI_Hooks_Trampoline = <class 'ida_kernwin.simplecustviewer_t.UI_Hooks_...
 |      Proxy of C++ UI_Hooks class.

Help on class simpleline_place_t in module ida_kernwin:

class simpleline_place_t(place_t)
 |  Proxy of C++ simpleline_place_t class.
 |  
 |  Method resolution order:
 |      simpleline_place_t
 |      place_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_simpleline_place_t(...)
 |      delete_simpleline_place_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  n
 |      simpleline_place_t_n_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, out_buf, ud)
 |  
 |  adjust(self, *args) -> 'void'
 |      adjust(self, ud)
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self, ud) -> bool
 |  
 |  clone(self, *args) -> 'place_t *'
 |      clone(self) -> place_t
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, t2) -> int
 |  
 |  copyfrom(self, *args) -> 'void'
 |      copyfrom(self, _from)
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, _in) -> bool
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self, ud) -> bool
 |  
 |  enter(self, *args) -> 'place_t *'
 |      enter(self, arg2) -> place_t
 |  
 |  generate(self, *args) -> 'PyObject *'
 |      generate(self, ud, maxsize) -> PyObject *
 |  
 |  id(self, *args) -> 'int'
 |      id(self) -> int
 |  
 |  leave(self, *args) -> 'void'
 |      leave(self, arg2)
 |  
 |  makeplace(self, *args) -> 'place_t *'
 |      makeplace(self, ud, x, lnnum) -> place_t
 |  
 |  name(self, *args) -> 'char const *'
 |      name(self) -> char const *
 |  
 |  next(self, *args) -> 'bool'
 |      next(self, ud) -> bool
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, ud) -> bool
 |  
 |  rebase(self, *args) -> 'bool'
 |      rebase(self, arg2) -> bool
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self) -> ea_t
 |  
 |  touval(self, *args) -> 'uval_t'
 |      touval(self, ud) -> uval_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args) -> 'enumplace_t *'
 |      as_enumplace_t(p) -> enumplace_t
 |  
 |  as_idaplace_t(*args) -> 'idaplace_t *'
 |      as_idaplace_t(p) -> idaplace_t
 |  
 |  as_simpleline_place_t(*args) -> 'simpleline_place_t *'
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |  
 |  as_structplace_t(*args) -> 'structplace_t *'
 |      as_structplace_t(p) -> structplace_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      place_t_lnnum_get(self) -> int

Help on class simpleline_t in module ida_kernwin:

class simpleline_t(builtins.object)
 |  Proxy of C++ simpleline_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> simpleline_t
 |      __init__(self, c, str) -> simpleline_t
 |      __init__(self, str) -> simpleline_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_simpleline_t(...)
 |      delete_simpleline_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bgcolor
 |      simpleline_t_bgcolor_get(self) -> bgcolor_t
 |  
 |  color
 |      simpleline_t_color_get(self) -> color_t
 |  
 |  line
 |      simpleline_t_line_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on function str2ea in module ida_kernwin:

str2ea(*args) -> 'ea_t'
    str2ea(str, screenEA=BADADDR) -> ea_t
    
    
    Converts a string express to EA. The expression evaluator may be called as well.
    
    @return: BADADDR or address value

Help on function str2user in module ida_pro:

str2user(*args) -> 'PyObject *'
    str2user(str) -> PyObject *
    
    
    Insert C-style escape characters to string
    
    @return: new string with escape characters inserted

Help on function strarray in module ida_kernwin:

strarray(*args) -> 'char const *'
    strarray(array, array_size, code) -> char const *
    
    
    Find a line with the specified code in the 'strarray_t' array. If the
    last element of the array has code==0 then it is considered as the
    default entry.If no default entry exists and the code is not found,
    'strarray()' returns "".
    
    @param array (C++: const  strarray_t  *)
    @param array_size (C++: size_t)
    @param code (C++: int)

Help on class strarray_t in module ida_kernwin:

class strarray_t(builtins.object)
 |  Proxy of C++ strarray_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strarray_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_strarray_t(...)
 |      delete_strarray_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  code
 |      strarray_t_code_get(self) -> int
 |  
 |  text
 |      strarray_t_text_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag

Help on class structplace_t in module ida_kernwin:

class structplace_t(place_t)
 |  Proxy of C++ structplace_t class.
 |  
 |  Method resolution order:
 |      structplace_t
 |      place_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_structplace_t(...)
 |      delete_structplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  idx
 |      structplace_t_idx_get(self) -> uval_t
 |  
 |  offset
 |      structplace_t_offset_get(self) -> uval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, out_buf, ud)
 |  
 |  adjust(self, *args) -> 'void'
 |      adjust(self, ud)
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self, ud) -> bool
 |  
 |  clone(self, *args) -> 'place_t *'
 |      clone(self) -> place_t
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, t2) -> int
 |  
 |  copyfrom(self, *args) -> 'void'
 |      copyfrom(self, _from)
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, _in) -> bool
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self, ud) -> bool
 |  
 |  enter(self, *args) -> 'place_t *'
 |      enter(self, arg2) -> place_t
 |  
 |  generate(self, *args) -> 'PyObject *'
 |      generate(self, ud, maxsize) -> PyObject *
 |  
 |  id(self, *args) -> 'int'
 |      id(self) -> int
 |  
 |  leave(self, *args) -> 'void'
 |      leave(self, arg2)
 |  
 |  makeplace(self, *args) -> 'place_t *'
 |      makeplace(self, ud, x, lnnum) -> place_t
 |  
 |  name(self, *args) -> 'char const *'
 |      name(self) -> char const *
 |  
 |  next(self, *args) -> 'bool'
 |      next(self, ud) -> bool
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, ud) -> bool
 |  
 |  rebase(self, *args) -> 'bool'
 |      rebase(self, arg2) -> bool
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self) -> ea_t
 |  
 |  touval(self, *args) -> 'uval_t'
 |      touval(self, ud) -> uval_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args) -> 'enumplace_t *'
 |      as_enumplace_t(p) -> enumplace_t
 |  
 |  as_idaplace_t(*args) -> 'idaplace_t *'
 |      as_idaplace_t(p) -> idaplace_t
 |  
 |  as_simpleline_place_t(*args) -> 'simpleline_place_t *'
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |  
 |  as_structplace_t(*args) -> 'structplace_t *'
 |      as_structplace_t(p) -> structplace_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      place_t_lnnum_get(self) -> int

Help on class sync_source_t in module ida_kernwin:

class sync_source_t(builtins.object)
 |  Proxy of C++ sync_source_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, _o) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, _view) -> sync_source_t
 |      __init__(self, _regname) -> sync_source_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, _o) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_sync_source_t(...)
 |      delete_sync_source_t(self)
 |  
 |  get_register(self, *args) -> 'char const *'
 |      get_register(self) -> char const *
 |  
 |  get_widget(self, *args) -> 'TWidget const *'
 |      get_widget(self) -> TWidget const *
 |  
 |  is_register(self, *args) -> 'bool'
 |      is_register(self) -> bool
 |  
 |  is_widget(self, *args) -> 'bool'
 |      is_widget(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function sync_sources in module ida_kernwin:

sync_sources(*args) -> 'bool'
    sync_sources(what, _with, sync) -> bool
    
    
    [Un]synchronize sources
    
    @param what (C++: const  sync_source_t  &)
    @param _with (C++: const  sync_source_t  &)
    @param sync (C++: bool)
    @return: success

Help on function take_database_snapshot in module ida_kernwin:

take_database_snapshot(*args) -> 'PyObject *'
    take_database_snapshot(ss) -> PyObject *
    
    
    Take a database snapshot ( 'ui_take_database_snapshot' ).
    
    @param ss: in/out parameter.   in: description, flags   out: filename,
               id (C++: snapshot_t  *)
    @return: success

Help on class textctrl_info_t in module ida_kernwin:

class textctrl_info_t(ida_idaapi.py_clinked_object_t)
 |  Class representing textctrl_info_t
 |  
 |  Method resolution order:
 |      textctrl_info_t
 |      ida_idaapi.py_clinked_object_t
 |      ida_idaapi.pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __get_flags__(self)
 |      Returns the flags value
 |  
 |  __get_tabsize__(self)
 |      Returns the tabsize value
 |  
 |  __init__(self, text='', flags=0, tabsize=0)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __set_flags__(self, flags)
 |      Sets the flags value
 |  
 |  __set_tabsize__(self, tabsize)
 |      Sets the tabsize value
 |  
 |  _create_clink(self)
 |      Overwrite me.
 |      Creates a new clink
 |      @return: PyCapsule representing the C link
 |  
 |  _del_clink(self, lnk)
 |      Overwrite me.
 |      This method deletes the link
 |  
 |  _get_clink_ptr(self)
 |      Overwrite me.
 |      Returns the C link pointer as a 64bit number
 |  
 |  _textctrl_info_t__get_text = __get_text(self)
 |      Sets the text value
 |  
 |  _textctrl_info_t__set_text = __set_text(self, s)
 |      Sets the text value
 |  
 |  assign(self, other)
 |      Copies the contents of 'other' to 'self'
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  flags
 |      Returns the flags value
 |  
 |  tabsize
 |      Returns the tabsize value
 |  
 |  text
 |      Sets the text value
 |  
 |  value
 |      Sets the text value
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  TXTF_ACCEPTTABS = 2
 |  
 |  TXTF_AUTOINDENT = 1
 |  
 |  TXTF_FIXEDFONT = 32
 |  
 |  TXTF_MODIFIED = 16
 |  
 |  TXTF_READONLY = 4
 |  
 |  TXTF_SELECTED = 8
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  __del__(self)
 |      Delete the link upon object destruction (only if not static)
 |  
 |  _free(self)
 |      Explicitly delete the link (only if not static)
 |  
 |  copy(self)
 |      Returns a new copy of this class
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  clink
 |  
 |  clink_ptr
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on function textctrl_info_t_assign in module ida_kernwin:

textctrl_info_t_assign(*args) -> 'bool'
    textctrl_info_t_assign(_self, other) -> bool

Help on function textctrl_info_t_create in module ida_kernwin:

textctrl_info_t_create(*args) -> 'PyObject *'
    textctrl_info_t_create() -> PyObject *

Help on function textctrl_info_t_destroy in module ida_kernwin:

textctrl_info_t_destroy(*args) -> 'bool'
    textctrl_info_t_destroy(py_obj) -> bool

Help on function textctrl_info_t_get_clink in module ida_kernwin:

textctrl_info_t_get_clink(*args) -> 'textctrl_info_t *'
    textctrl_info_t_get_clink(_self) -> textctrl_info_t *

Help on function textctrl_info_t_get_clink_ptr in module ida_kernwin:

textctrl_info_t_get_clink_ptr(*args) -> 'PyObject *'
    textctrl_info_t_get_clink_ptr(_self) -> PyObject *

Help on function textctrl_info_t_get_flags in module ida_kernwin:

textctrl_info_t_get_flags(*args) -> 'unsigned int'
    textctrl_info_t_get_flags(_self) -> unsigned int

Help on function textctrl_info_t_get_tabsize in module ida_kernwin:

textctrl_info_t_get_tabsize(*args) -> 'unsigned int'
    textctrl_info_t_get_tabsize(_self) -> unsigned int

Help on function textctrl_info_t_get_text in module ida_kernwin:

textctrl_info_t_get_text(*args) -> 'char const *'
    textctrl_info_t_get_text(_self) -> char const *

Help on function textctrl_info_t_set_flags in module ida_kernwin:

textctrl_info_t_set_flags(*args) -> 'bool'
    textctrl_info_t_set_flags(_self, flags) -> bool

Help on function textctrl_info_t_set_tabsize in module ida_kernwin:

textctrl_info_t_set_tabsize(*args) -> 'bool'
    textctrl_info_t_set_tabsize(_self, tabsize) -> bool

Help on function textctrl_info_t_set_text in module ida_kernwin:

textctrl_info_t_set_text(*args) -> 'bool'
    textctrl_info_t_set_text(_self, s) -> bool

Help on class twinpos_t in module ida_kernwin:

class twinpos_t(builtins.object)
 |  Proxy of C++ twinpos_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> twinpos_t
 |      __init__(self, t) -> twinpos_t
 |      __init__(self, t, x0) -> twinpos_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_twinpos_t(...)
 |      delete_twinpos_t(self)
 |  
 |  place(self, view)
 |  
 |  place_as_enumplace_t(self)
 |  
 |  place_as_idaplace_t(self)
 |  
 |  place_as_simpleline_place_t(self)
 |  
 |  place_as_structplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  at
 |      twinpos_t_at_get(self) -> place_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      twinpos_t_x_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function ui_load_new_file in module ida_kernwin:

ui_load_new_file(*args) -> 'bool'
    ui_load_new_file(temp_file, filename, pli, neflags, ploaders) -> bool
    
    
    Display a load file dialog and load file ( 'ui_load_file' ).
    
    @param temp_file: name of the file with the extracted archive member.
                      (C++: qstring  *)
    @param filename: the name of input file as is, library or archive name
                     (C++: qstring  *)
    @param pli: loader input source, may be changed to point to temp_file
                (C++: linput_t **)
    @param neflags: combination of NEF_... bits (see  Load file flags )
                    (C++: ushort)
    @param ploaders: list of loaders which accept file, may be changed for
                     loaders of temp_file (C++: load_info_t  **)

Help on class ui_requests_t in module ida_kernwin:

class ui_requests_t(builtins.object)
 |  Proxy of C++ ui_requests_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_requests_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ui_requests_t(...)
 |      delete_ui_requests_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function ui_run_debugger in module ida_kernwin:

ui_run_debugger(*args) -> 'bool'
    ui_run_debugger(dbgopts, exename, argc, argv) -> bool
    
    
    Load a debugger plugin and run the specified program ( 'ui_run_dbg' ).
    
    @param dbgopts: value of the -r command line switch (C++: const char
                    *)
    @param exename: name of the file to run (C++: const char *)
    @param argc: number of arguments for the executable (C++: int)
    @param argv: argument vector (C++: const char *const *)
    @return: success

Help on function unmark_selection in module ida_kernwin:

unmark_selection(*args) -> 'void'
    unmark_selection()
    
    
    Unmark selection ( 'ui_unmarksel' )

Help on function unregister_action in module ida_kernwin:

unregister_action(*args) -> 'bool'
    unregister_action(name) -> bool
    
    
    Delete a previously-registered action ( 'ui_unregister_action' ).
    
    @param name: name of action (C++: const char *)
    @return: success

Help on function unregister_timer in module ida_kernwin:

unregister_timer(*args) -> 'bool'
    unregister_timer(py_timerctx) -> bool
    
    
    Unregister a timer
    
    @param timer_obj: a timer object previously returned by a register_timer()
    @return: Boolean
    @note: After the timer has been deleted, the timer_obj will become invalid.

Help on function update_action_checkable in module ida_kernwin:

update_action_checkable(*args) -> 'bool'
    update_action_checkable(name, checkable) -> bool
    
    
    Update an action's checkability ( 'ui_update_action_attr' ).
    
    @param name: action name (C++: const char *)
    @param checkable: new checkability (C++: bool)
    @return: success

Help on function update_action_checked in module ida_kernwin:

update_action_checked(*args) -> 'bool'
    update_action_checked(name, checked) -> bool
    
    
    Update an action's checked state ( 'ui_update_action_attr' ).
    
    @param name: action name (C++: const char *)
    @param checked: new checked state (C++: bool)
    @return: success

Help on function update_action_icon in module ida_kernwin:

update_action_icon(*args) -> 'bool'
    update_action_icon(name, icon) -> bool
    
    
    Update an action's icon ( 'ui_update_action_attr' ).
    
    @param name: action name (C++: const char *)
    @param icon: new icon id (C++: int)
    @return: success

Help on function update_action_label in module ida_kernwin:

update_action_label(*args) -> 'bool'
    update_action_label(name, label) -> bool
    
    
    Update an action's label ( 'ui_update_action_attr' ).
    
    @param name: action name (C++: const char *)
    @param label: new label (C++: const char *)
    @return: success

Help on function update_action_shortcut in module ida_kernwin:

update_action_shortcut(*args) -> 'bool'
    update_action_shortcut(name, shortcut) -> bool
    
    
    Update an action's shortcut ( 'ui_update_action_attr' ).
    
    @param name: action name (C++: const char *)
    @param shortcut: new shortcut (C++: const char *)
    @return: success

Help on function update_action_state in module ida_kernwin:

update_action_state(*args) -> 'bool'
    update_action_state(name, state) -> bool
    
    
    Update an action's state ( 'ui_update_action_attr' ).
    
    @param name: action name (C++: const char *)
    @param state: new state (C++: action_state_t)
    @return: success

Help on function update_action_tooltip in module ida_kernwin:

update_action_tooltip(*args) -> 'bool'
    update_action_tooltip(name, tooltip) -> bool
    
    
    Update an action's tooltip ( 'ui_update_action_attr' ).
    
    @param name: action name (C++: const char *)
    @param tooltip: new tooltip (C++: const char *)
    @return: success

Help on function update_action_visibility in module ida_kernwin:

update_action_visibility(*args) -> 'bool'
    update_action_visibility(name, visible) -> bool
    
    
    Update an action's visibility ( 'ui_update_action_attr' ).
    
    @param name: action name (C++: const char *)
    @param visible: new visibility (C++: bool)
    @return: success

Help on function user_cancelled in module ida_kernwin:

user_cancelled(*args) -> 'bool'
    user_cancelled() -> bool
    
    
    Test the ctrl-break flag ( 'ui_test_cancelled' ).

Help on class view_mouse_event_location_t in module ida_kernwin:

class view_mouse_event_location_t(builtins.object)
 |  Proxy of C++ view_mouse_event_location_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> view_mouse_event_location_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_view_mouse_event_location_t(...)
 |      delete_view_mouse_event_location_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      view_mouse_event_location_t_ea_get(self) -> ea_t
 |  
 |  item
 |      view_mouse_event_location_t_item_get(self) -> selection_item_t const *
 |  
 |  thisown
 |      The membership flag

Help on class view_mouse_event_t in module ida_kernwin:

class view_mouse_event_t(builtins.object)
 |  Proxy of C++ view_mouse_event_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> view_mouse_event_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_view_mouse_event_t(...)
 |      delete_view_mouse_event_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  button
 |      view_mouse_event_t_button_get(self) -> vme_button_t
 |  
 |  location
 |      view_mouse_event_t_location_get(self) -> view_mouse_event_location_t
 |  
 |  renderer_pos
 |      view_mouse_event_t_renderer_pos_get(self) -> renderer_pos_info_t
 |  
 |  rtype
 |      view_mouse_event_t_rtype_get(self) -> tcc_renderer_type_t
 |  
 |  state
 |      view_mouse_event_t_state_get(self) -> view_event_state_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      view_mouse_event_t_x_get(self) -> uint32
 |  
 |  y
 |      view_mouse_event_t_y_get(self) -> uint32

Help on function warning in module ida_kernwin:

warning(*args) -> 'void'
    warning(format)
    
    
    Display a message in a message box
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts
    The user will be able to hide messages if they appear twice in a row on
    the screen

=== ida_kernwin EPYDOC INJECTIONS ===
ida_kernwin.ACF_HAS_SELECTION
"""
there is currently a valid selection
"""

ida_kernwin.ACF_XTRN_EA
"""
cur_ea is in 'externs' segment
"""

ida_kernwin.ADF_NO_UNDO
"""
useful for actions that do not modify the database.

the action does not create an undo point.
"""

ida_kernwin.ADF_OWN_HANDLER
"""
handler is owned by the action; it'll be destroyed when the action is
unregistered. You shouldn't have to use this.
"""

ida_kernwin.AHF_VERSION
"""
action handler version (used by 'action_handler_t::flags' )
"""

ida_kernwin.AHF_VERSION_MASK
"""
mask for 'action_handler_t::flags'
"""

ida_kernwin.ASKBTN_BTN1
"""
First (Yes) button.
"""

ida_kernwin.ASKBTN_BTN2
"""
Second (No) button.
"""

ida_kernwin.ASKBTN_BTN3
"""
Third (Cancel) button.
"""

ida_kernwin.ASKBTN_CANCEL
"""
Cancel button.
"""

ida_kernwin.ASKBTN_NO
"""
No button.
"""

ida_kernwin.ASKBTN_YES
"""
Yes button.
"""

ida_kernwin.BWN_ADDRWATCH
"""
the 'Watch List' window
"""

ida_kernwin.BWN_BPTS
"""
breakpoints
"""

ida_kernwin.BWN_CALLS
"""
function calls
"""

ida_kernwin.BWN_CALLS_CALLEES
"""
function calls, callees
"""

ida_kernwin.BWN_CALLS_CALLERS
"""
function calls, callers
"""

ida_kernwin.BWN_CALL_STACK
"""
call stack
"""

ida_kernwin.BWN_CHOOSER
"""
a non-builtin chooser
"""

ida_kernwin.BWN_CLI
"""
the command-line, in the output window
"""

ida_kernwin.BWN_CMDPALCSR
"""
the command palette chooser (Qt version only)
"""

ida_kernwin.BWN_CMDPALWIN
"""
the command palette window (Qt version only)
"""

ida_kernwin.BWN_CPUREGS
"""
one of the 'General registers', 'FPU register', ... debugger windows
"""

ida_kernwin.BWN_CUSTVIEW
"""
custom viewers
"""

ida_kernwin.BWN_CV_LINE_INFOS
"""
custom viewers' lineinfo widget
"""

ida_kernwin.BWN_DISASM
"""
disassembly views
"""

ida_kernwin.BWN_DISASMS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_DISASM_ARROWS
"""
disassembly arrows widget
"""

ida_kernwin.BWN_DUMP
"""
hex dumps
"""

ida_kernwin.BWN_DUMPS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_ENUMS
"""
enumerations
"""

ida_kernwin.BWN_EXPORTS
"""
exports
"""

ida_kernwin.BWN_FRAME
"""
function frame
"""

ida_kernwin.BWN_FUNCS
"""
functions
"""

ida_kernwin.BWN_IMPORTS
"""
imports
"""

ida_kernwin.BWN_LOCALS
"""
the 'locals' debugger window
"""

ida_kernwin.BWN_LOCTYPS
"""
local types
"""

ida_kernwin.BWN_MDVIEWCSR
"""
lumina metadata view chooser
"""

ida_kernwin.BWN_MODULES
"""
modules
"""

ida_kernwin.BWN_NAMES
"""
names
"""

ida_kernwin.BWN_NAVBAND
"""
navigation band
"""

ida_kernwin.BWN_NOTEPAD
"""
notepad
"""

ida_kernwin.BWN_OUTPUT
"""
the text area, in the output window
"""

ida_kernwin.BWN_PROBS
"""
problems
"""

ida_kernwin.BWN_PSEUDOCODE
"""
hexrays decompiler views
"""

ida_kernwin.BWN_SCRIPTS_CSR
"""
the "Recent scripts" chooser
"""

ida_kernwin.BWN_SEARCH
"""
search results
"""

ida_kernwin.BWN_SEARCHS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_SEGREGS
"""
segment registers
"""

ida_kernwin.BWN_SEGS
"""
segments
"""

ida_kernwin.BWN_SELS
"""
selectors
"""

ida_kernwin.BWN_SHORTCUTCSR
"""
the shortcuts chooser (Qt version only)
"""

ida_kernwin.BWN_SHORTCUTWIN
"""
the shortcuts window (Qt version only)
"""

ida_kernwin.BWN_SIGNS
"""
signatures
"""

ida_kernwin.BWN_SNIPPETS
"""
the 'Execute script' window
"""

ida_kernwin.BWN_SNIPPETS_CSR
"""
the list of snippets in the 'Execute script' window
"""

ida_kernwin.BWN_SO_OFFSETS
"""
the 'Structure offsets' dialog's offset panel
"""

ida_kernwin.BWN_SO_STRUCTS
"""
the 'Structure offsets' dialog's 'Structures and Unions' panel
"""

ida_kernwin.BWN_SRCPTHMAP_CSR
"""
"Source paths..."'s path mappings chooser
"""

ida_kernwin.BWN_SRCPTHUND_CSR
"""
"Source paths..."'s undesired paths chooser
"""

ida_kernwin.BWN_STACK
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_STKVIEW
"""
the 'Stack view' debugger window
"""

ida_kernwin.BWN_STRINGS
"""
strings
"""

ida_kernwin.BWN_STRUCTS
"""
structures
"""

ida_kernwin.BWN_THREADS
"""
threads
"""

ida_kernwin.BWN_TILS
"""
type libraries
"""

ida_kernwin.BWN_TRACE
"""
trace view
"""

ida_kernwin.BWN_UNDOHIST
"""
Undo history.
"""

ida_kernwin.BWN_UNKNOWN
"""
unknown window
"""

ida_kernwin.BWN_WATCH
"""
the 'watches' debugger window
"""

ida_kernwin.BWN_XREFS
"""
xrefs
"""

ida_kernwin.CHCOL_DEC
"""
decimal number
"""

ida_kernwin.CHCOL_DEFHIDDEN
"""
column should be hidden by default
"""

ida_kernwin.CHCOL_EA
"""
address
"""

ida_kernwin.CHCOL_FNAME
"""
function name
"""

ida_kernwin.CHCOL_FORMAT
"""
column format mask
"""

ida_kernwin.CHCOL_HEX
"""
hexadecimal number
"""

ida_kernwin.CHCOL_PATH
"""
file path
"""

ida_kernwin.CHCOL_PLAIN
"""
plain string
"""

ida_kernwin.CHITEM_BOLD
"""
display the item in bold
"""

ida_kernwin.CHITEM_GRAY
"""
gray out the item
"""

ida_kernwin.CHITEM_ITALIC
"""
display the item in italic
"""

ida_kernwin.CHITEM_STRIKE
"""
strikeout the item
"""

ida_kernwin.CHITEM_UNDER
"""
underline the item
"""

ida_kernwin.CHOOSER_MENU_EDIT
"""
Values of the 'menu_index' parameter.

Obsolete. Please don't use
"""

ida_kernwin.CHOOSER_MENU_JUMP
"""
Obsolete. Please don't use.
"""

ida_kernwin.CHOOSER_MENU_SEARCH
"""
Obsolete. Please don't use.
"""

ida_kernwin.CHOOSER_MULTI_SELECTION
"""
enable for multiple selections. A callback of type
'chooser_multi_cb_t' will be called for all selected items.
"""

ida_kernwin.CHOOSER_NO_SELECTION
"""
Flags.

enable even if there's no selected item. 'n' will be NO_SELECTION for
a callback.
"""

ida_kernwin.CHOOSER_POPUP_MENU
"""
Add command to the popup menu.
"""

ida_kernwin.CH_ATTRS
"""
generate ui_get_chooser_item_attrs (gui only)
"""

ida_kernwin.CH_BUILTIN_MASK
"""
Mask for builtin chooser numbers. Plugins should not use them.
"""

ida_kernwin.CH_CAN_DEL
"""
allow to delete existing item(s)
"""

ida_kernwin.CH_CAN_EDIT
"""
allow to edit existing item(s)
"""

ida_kernwin.CH_CAN_INS
"""
allow to insert new items
"""

ida_kernwin.CH_CAN_REFRESH
"""
allow to refresh chooser
"""

ida_kernwin.CH_FORCE_DEFAULT
"""
if a non-modal chooser was already open, change selection to the
default one
"""

ida_kernwin.CH_KEEP
"""
The chooser instance's lifecycle is not tied to the lifecycle of the
widget showing its contents. Closing the widget will not destroy the
chooser structure. This allows for, e.g., static global chooser
instances that don't need to be allocated on the heap. Also stack-
allocated chooser instances must set this bit.
"""

ida_kernwin.CH_MODAL
"""
Modal chooser.
"""

ida_kernwin.CH_MULTI
"""
Obsolete.

The chooser will allow multi-selection (only for GUI choosers). This
bit is set when using the 'chooser_multi_t' structure.
"""

ida_kernwin.CH_NOBTNS
"""
do not display ok/cancel/help/search buttons. Meaningful only for gui
modal windows because non-modal windows do not have any buttons
anyway. Text mode does not have them neither.
"""

ida_kernwin.CH_NOIDB
"""
use the chooser before opening the database
"""

ida_kernwin.CH_NO_STATUS_BAR
"""
don't show a status bar
"""

ida_kernwin.CH_QFLT
"""
open with quick filter enabled and focused
"""

ida_kernwin.CH_QFTYP_DEFAULT
"""
set quick filtering type to the possible existing default for this
chooser
"""

ida_kernwin.CH_QFTYP_FUZZY
"""
fuzzy search quick filter type
"""

ida_kernwin.CH_QFTYP_NORMAL
"""
normal (i.e., lexicographical) quick filter type
"""

ida_kernwin.CH_QFTYP_REGEX
"""
regex quick filter type
"""

ida_kernwin.CH_QFTYP_WHOLE_WORDS
"""
whole words quick filter type
"""

ida_kernwin.CH_RESTORE
"""
restore floating position if present (equivalent of WOPN_RESTORE) (GUI
version only)
"""

ida_kernwin.CLNL_FINDCMT
"""
Search for the comment symbol everywhere in the line, not only at the
beginning.
"""

ida_kernwin.CLNL_LTRIM
"""
Remove leading space characters.
"""

ida_kernwin.CLNL_RTRIM
"""
Remove trailing space characters.
"""

ida_kernwin.CREATETB_ADV
"""
toolbar is for 'advanced mode' only
"""

ida_kernwin.DP_BEFORE
"""
used with 'DP_INSIDE' .

place src_form before dst_form in the tab bar instead of after
"""

ida_kernwin.DP_BOTTOM
"""
Dock src_form below dest_form.
"""

ida_kernwin.DP_FLOATING
"""
Make src_form floating.
"""

ida_kernwin.DP_INSIDE
"""
Create a new tab bar with both src_form and dest_form.
"""

ida_kernwin.DP_LEFT
"""
Dock src_form to the left of dest_form.
"""

ida_kernwin.DP_RIGHT
"""
Dock src_form to the right of dest_form.
"""

ida_kernwin.DP_TAB
"""
Place src_form into a tab next to dest_form, if dest_form is in a tab
bar (otherwise the same as 'DP_INSIDE' )
"""

ida_kernwin.DP_TOP
"""
Dock src_form above dest_form.
"""

ida_kernwin.HIF_IDENTIFIER
"""
text is an identifier (i.e., when searching for the current highlight,
SEARCH_IDENT will be used)
"""

ida_kernwin.HIF_LOCKED
"""
locked; clicking/moving the cursor around doesn't change the highlight
"""

ida_kernwin.HIF_NOCASE
"""
case insensitive
"""

ida_kernwin.HIF_REGISTER
"""
text represents a register (aliases/subregisters will be highlit as
well)
"""

ida_kernwin.HIST_CMD
"""
commands
"""

ida_kernwin.HIST_CMT
"""
comments
"""

ida_kernwin.HIST_DIR
"""
directory names (text version only)
"""

ida_kernwin.HIST_FILE
"""
file names
"""

ida_kernwin.HIST_IDENT
"""
names
"""

ida_kernwin.HIST_SEG
"""
segment names
"""

ida_kernwin.HIST_SRCH
"""
search substrings
"""

ida_kernwin.HIST_TYPE
"""
type declarations
"""

ida_kernwin.IWID_ADDRWATCH
"""
address watches (47)
"""

ida_kernwin.IWID_ALL
"""
mask
"""

ida_kernwin.IWID_BPTS
"""
breakpoints (13)
"""

ida_kernwin.IWID_CALLS
"""
function calls (11)
"""

ida_kernwin.IWID_CALLS_CALLEES
"""
funcalls, callees (50)
"""

ida_kernwin.IWID_CALLS_CALLERS
"""
funcalls, callers (49)
"""

ida_kernwin.IWID_CALL_STACK
"""
call stack (17)
"""

ida_kernwin.IWID_CHOOSER
"""
chooser (37)
"""

ida_kernwin.IWID_CLI
"""
input line (33)
"""

ida_kernwin.IWID_CMDPALCSR
"""
command palette (43)
"""

ida_kernwin.IWID_CMDPALWIN
"""
command palette (44)
"""

ida_kernwin.IWID_CPUREGS
"""
registers (40)
"""

ida_kernwin.IWID_CUSTVIEW
"""
custom viewers (46)
"""

ida_kernwin.IWID_CV_LINE_INFOS
"""
lineinfo widget (53)
"""

ida_kernwin.IWID_DISASM
"""
disassembly views (29)
"""

ida_kernwin.IWID_DISASM_ARROWS
"""
arrows widget (52)
"""

ida_kernwin.IWID_DUMP
"""
hex dumps (30)
"""

ida_kernwin.IWID_ENUMS
"""
enumerations (27)
"""

ida_kernwin.IWID_EXPORTS
"""
exports (0)
"""

ida_kernwin.IWID_FRAME
"""
function frame (25)
"""

ida_kernwin.IWID_FUNCS
"""
functions (3)
"""

ida_kernwin.IWID_IMPORTS
"""
imports (1)
"""

ida_kernwin.IWID_LOCALS
"""
locals (35)
"""

ida_kernwin.IWID_LOCTYPS
"""
local types (10)
"""

ida_kernwin.IWID_MDVIEWCSR
"""
lumina md view (51)
"""

ida_kernwin.IWID_MODULES
"""
modules (15)
"""

ida_kernwin.IWID_NAMES
"""
names (2)
"""

ida_kernwin.IWID_NAVBAND
"""
navigation band (26)
"""

ida_kernwin.IWID_NOTEPAD
"""
notepad (31)
"""

ida_kernwin.IWID_OUTPUT
"""
output (32)
"""

ida_kernwin.IWID_PROBS
"""
problems (12)
"""

ida_kernwin.IWID_PSEUDOCODE
"""
decompiler (48)
"""

ida_kernwin.IWID_SCRIPTS_CSR
"""
recent scripts (58)
"""

ida_kernwin.IWID_SEARCH
"""
search results (19)
"""

ida_kernwin.IWID_SEGREGS
"""
segment registers (6)
"""

ida_kernwin.IWID_SEGS
"""
segments (5)
"""

ida_kernwin.IWID_SELS
"""
selectors (7)
"""

ida_kernwin.IWID_SHORTCUTCSR
"""
shortcuts chooser (38)
"""

ida_kernwin.IWID_SHORTCUTWIN
"""
shortcuts window (39)
"""

ida_kernwin.IWID_SIGNS
"""
signatures (8)
"""

ida_kernwin.IWID_SNIPPETS
"""
snippets (45)
"""

ida_kernwin.IWID_SNIPPETS_CSR
"""
snippets chooser (57)
"""

ida_kernwin.IWID_SO_OFFSETS
"""
stroff (42)
"""

ida_kernwin.IWID_SO_STRUCTS
"""
stroff (41)
"""

ida_kernwin.IWID_SRCPTHMAP_CSR
"""
mappings chooser (54)
"""

ida_kernwin.IWID_SRCPTHUND_CSR
"""
undesired chooser (55)
"""

ida_kernwin.IWID_STACK
"""
Alias. Some IWID_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.IWID_STKVIEW
"""
stack view (36)
"""

ida_kernwin.IWID_STRINGS
"""
strings (4)
"""

ida_kernwin.IWID_STRUCTS
"""
structures (28)
"""

ida_kernwin.IWID_THREADS
"""
threads (14)
"""

ida_kernwin.IWID_TILS
"""
type libraries (9)
"""

ida_kernwin.IWID_TRACE
"""
trace view (16)
"""

ida_kernwin.IWID_UNDOHIST
"""
Undo history (56)
"""

ida_kernwin.IWID_WATCH
"""
watches (34)
"""

ida_kernwin.IWID_XREFS
"""
xrefs (18)
"""

ida_kernwin.MFF_FAST
"""
Execute code as soon as possible. this mode is ok for calling ui
related functions that do not query the database.
"""

ida_kernwin.MFF_NOWAIT
"""
Do not wait for the request to be executed. the caller should ensure
that the request is not destroyed until the execution completes. if
not, the request will be ignored. 'execute_sync()' returns the request
id in this case. it can be used in 'cancel_exec_request()' . This flag
can be used to delay the code execution until the next UI loop run
even from the main thread.
"""

ida_kernwin.MFF_READ
"""
Execute code only when ida is idle and it is safe to query the
database. this mode is recommended only for code that does not modify
the database. (nb: ida may be in the middle of executing another user
request, for example it may be waiting for him to enter values into a
modal dialog box)
"""

ida_kernwin.MFF_WRITE
"""
Execute code only when ida is idle and it is safe to modify the
database. in particular, this flag will suspend execution if there is
a modal dialog box on the screen this mode can be used to call any ida
api function 'MFF_WRITE' implies 'MFF_READ'
"""

ida_kernwin.SETMENU_APP
"""
add menu item after the specified path
"""

ida_kernwin.SETMENU_FIRST
"""
add item to the beginning of menu
"""

ida_kernwin.SETMENU_INS
"""
add menu item before the specified path (default)
"""

ida_kernwin.UIJMP_ACTIVATE
"""
activate the new window
"""

ida_kernwin.UIJMP_ANYVIEW
"""
jump in any ea_t-capable view
"""

ida_kernwin.UIJMP_DONTPUSH
"""
in the navigation history

do not remember the current address
"""

ida_kernwin.UIJMP_IDAVIEW
"""
jump in idaview
"""

ida_kernwin.UIJMP_IDAVIEW_NEW
"""
jump in new idaview
"""

ida_kernwin.VES_SHIFT
"""
state & 1 => Shift is pressedstate & 2 => Alt is pressedstate & 4 =>
Ctrl is pressedstate & 8 => Mouse left button is pressedstate & 16 =>
Mouse right button is pressedstate & 32 => Mouse middle button is
pressedstate & 128 => Meta is pressed (OSX only)
"""
=== ida_kernwin EPYDOC INJECTIONS END ===
Help on function COLSTR in module ida_lines:

COLSTR(str, tag)
    Utility function to create a colored line
    @param str: The string
    @param tag: Color tag constant. One of SCOLOR_XXXX

Help on function add_extra_cmt in module ida_lines:

add_extra_cmt(*args) -> 'bool'
    add_extra_cmt(ea, isprev, format) -> bool
    
    
    Add anterior/posterior comment line(s).
    
    @param ea: linear address (C++: ea_t)
    @param isprev: do we add anterior lines? (0-no, posterior) (C++: bool)
    @param format: printf() style format string. may contain \n to denote
                   new lines. The resulting string should not contain
                   comment characters (;), the kernel will add them
                   automatically. (C++: const char *)
    @return: true if success

Help on function add_extra_line in module ida_lines:

add_extra_line(*args) -> 'bool'
    add_extra_line(ea, isprev, format) -> bool
    
    
    Add anterior/posterior non-comment line(s).
    
    @param ea: linear address (C++: ea_t)
    @param isprev: do we add anterior lines? (0-no, posterior) (C++: bool)
    @param format: printf() style format string. may contain \n to denote
                   new lines. (C++: const char *)
    @return: true if success

Help on function add_pgm_cmt in module ida_lines:

add_pgm_cmt(*args) -> 'bool'
    add_pgm_cmt(format) -> bool
    
    
    Add anterior comment line(s) at the start of program.
    
    @param format: printf() style format string. may contain \n to denote
                   new lines. The resulting string should not contain
                   comment characters (;), the kernel will add them
                   automatically. (C++: const char *)
    @return: true if success

Help on function add_sourcefile in module ida_lines:

add_sourcefile(*args) -> 'bool'
    add_sourcefile(ea1, ea2, filename) -> bool
    
    
    Mark a range of address as belonging to a source file. An address
    range may belong only to one source file. A source file may be
    represented by several address ranges.
    
    @param ea1: linear address of start of the address range (C++: ea_t)
    @param ea2: linear address of end of the address range (excluded)
                (C++: ea_t)
    @param filename: name of source file. (C++: const char *)
    @return: success

Help on class bgcolors_t in module ida_lines:

class bgcolors_t(builtins.object)
 |  Proxy of C++ bgcolors_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bgcolors_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bgcolors_t(...)
 |      delete_bgcolors_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  epilog_color
 |      bgcolors_t_epilog_color_get(self) -> bgcolor_t
 |  
 |  prolog_color
 |      bgcolors_t_prolog_color_get(self) -> bgcolor_t
 |  
 |  switch_color
 |      bgcolors_t_switch_color_get(self) -> bgcolor_t
 |  
 |  thisown
 |      The membership flag

Help on function calc_bg_color in module ida_lines:

calc_bg_color(*args) -> 'bgcolor_t'
    calc_bg_color(ea) -> bgcolor_t
    
    
    Get background color for line at 'ea'
    
    @param ea (C++: ea_t)
    @return: RGB color

Help on function calc_prefix_color in module ida_lines:

calc_prefix_color(*args) -> 'color_t'
    calc_prefix_color(ea) -> color_t
    
    
    Get prefix color for line at 'ea'
    
    @param ea (C++: ea_t)
    @return: Line prefix colors

Help on function create_encoding_helper in module ida_lines:

create_encoding_helper(*args) -> 'encoder_t *'
    create_encoding_helper(encidx=-1, nr=nr_once) -> encoder_t *

Help on function del_extra_cmt in module ida_lines:

del_extra_cmt(*args) -> 'void'
    del_extra_cmt(ea, what)

Help on function del_sourcefile in module ida_lines:

del_sourcefile(*args) -> 'bool'
    del_sourcefile(ea) -> bool
    
    
    Delete information about the source file.
    
    @param ea: linear address (C++: ea_t)
    @return: success

Help on function delete_extra_cmts in module ida_lines:

delete_extra_cmts(*args) -> 'void'
    delete_extra_cmts(ea, what)

Help on function generate_disasm_line in module ida_lines:

generate_disasm_line(*args) -> 'qstring *'
    generate_disasm_line(ea, flags=0) -> str

Help on function generate_disassembly in module ida_lines:

generate_disassembly(*args) -> 'PyObject *'
    generate_disassembly(ea, max_lines, as_stack, notags) -> PyObject *
    
    
    Generate disassembly lines (many lines) and put them into a buffer
    
    @param ea: address to generate disassembly for
    @param max_lines: how many lines max to generate
    @param as_stack: Display undefined items as 2/4/8 bytes
    @return:
        - None on failure
        - tuple(most_important_line_number, tuple(lines)) : Returns a tuple containing
          the most important line number and a tuple of generated lines

Help on function get_extra_cmt in module ida_lines:

get_extra_cmt(*args) -> 'int'
    get_extra_cmt(ea, what) -> ssize_t

Help on function get_first_free_extra_cmtidx in module ida_lines:

get_first_free_extra_cmtidx(*args) -> 'int'
    get_first_free_extra_cmtidx(ea, start) -> int

Help on function get_sourcefile in module ida_lines:

get_sourcefile(*args) -> 'char const *'
    get_sourcefile(ea, bounds=None) -> char const *
    
    
    Get name of source file occupying the given address.
    
    @param ea: linear address (C++: ea_t)
    @param bounds: pointer to the output buffer with the address range for
                   the current file. May be NULL. (C++: range_t  *)
    @return: NULL if source file information is not found, otherwise
             returns pointer to file name

Help on function requires_color_esc in module ida_lines:

requires_color_esc(c)
    Checks if the given character requires escaping
    @param c: character (string of one char)
    @return: Boolean
    
    
    Is the given char a color escape character?

Help on function set_user_defined_prefix in module ida_lines:

set_user_defined_prefix(*args) -> 'PyObject *'
    set_user_defined_prefix(width, pycb) -> PyObject *
    
    
    User-defined line-prefixes are displayed just after the autogenerated
    line prefixes. In order to use them, the plugin should call the
    following function to specify its width and contents.
    @param width: the width of the user-defined prefix
    @param callback: a get_user_defined_prefix callback to get the contents of the prefix.
        Its arguments:
          ea     - linear address
          lnnum  - line number
          indent - indent of the line contents (-1 means the default instruction)
                   indent and is used for instruction itself. see explanations for printf_line()
          line   - the line to be generated. the line usually contains color tags this argument
                   can be examined to decide whether to generated the prefix
        It returns a buffer of size < bufsize
    
    In order to remove the callback before unloading the plugin, specify the width = 0 or the callback = None

Help on function tag_addr in module ida_lines:

tag_addr(*args) -> 'PyObject *'
    tag_addr(ea) -> PyObject *
    
    
    Insert an address mark into a string.
    
    @param ea: address to include (C++: ea_t)

Help on function tag_advance in module ida_lines:

tag_advance(*args) -> 'int'
    tag_advance(line, cnt) -> int
    
    
    Move pointer to a 'line' to 'cnt' positions right. Take into account
    escape sequences.
    
    @param line: pointer to string (C++: const char *)
    @param cnt: number of positions to move right (C++: int)
    @return: moved pointer

Help on function tag_remove in module ida_lines:

tag_remove(*args) -> 'PyObject *'
    tag_remove(nonnul_instr) -> PyObject *
    
    
    Remove color escape sequences from a string
    @param colstr: the colored string with embedded tags
    @return: a new string w/o the tags

Help on function tag_skipcode in module ida_lines:

tag_skipcode(*args) -> 'int'
    tag_skipcode(line) -> int
    
    
    Skip one color code. This function should be used if you are
    interested in color codes and want to analyze all of them. Otherwise
    'tag_skipcodes()' function is better since it will skip all colors at
    once. This function will skip the current color code if there is one.
    If the current symbol is not a color code, it will return the input.
    
    @param line (C++: const char *)
    @return: moved pointer

Help on function tag_skipcodes in module ida_lines:

tag_skipcodes(*args) -> 'int'
    tag_skipcodes(line) -> int
    
    
    Move the pointer past all color codes.
    
    @param line: can't be NULL (C++: const char *)
    @return: moved pointer, can't be NULL

Help on function tag_strlen in module ida_lines:

tag_strlen(*args) -> 'ssize_t'
    tag_strlen(line) -> ssize_t
    
    
    Calculate length of a colored string This function computes the length
    in unicode codepoints of a line
    
    @param line (C++: const char *)
    @return: the number of codepoints in the line, or -1 on error

Help on function update_extra_cmt in module ida_lines:

update_extra_cmt(*args) -> 'void'
    update_extra_cmt(ea, what, str)

=== ida_lines EPYDOC INJECTIONS ===
ida_lines.COLOR_ADDR_SIZE
"""
Size of a tagged address (see 'COLOR_ADDR' )
"""

ida_lines.COLOR_BG_MAX
"""
Max color number.
"""

ida_lines.COLOR_CODE
"""
Single instruction.
"""

ida_lines.COLOR_CURITEM
"""
Current item.
"""

ida_lines.COLOR_CURLINE
"""
Current line.
"""

ida_lines.COLOR_DATA
"""
Data bytes.
"""

ida_lines.COLOR_DEFAULT
"""
Default.
"""

ida_lines.COLOR_ESC
"""
Escape character (Quote next character). This is needed to output '\\1'
and '\\2' characters.
"""

ida_lines.COLOR_EXTERN
"""
External name definition segment.
"""

ida_lines.COLOR_HIDLINE
"""
Hidden line.
"""

ida_lines.COLOR_INV
"""
Escape character (Inverse foreground and background colors). This
escape character has no corresponding 'COLOR_OFF' . Its action
continues until the next 'COLOR_INV' or end of line.
"""

ida_lines.COLOR_LIBFUNC
"""
Library function.
"""

ida_lines.COLOR_LUMFUNC
"""
Lumina function.
"""

ida_lines.COLOR_OFF
"""
Followed by a color code ( 'color_t' ).

Escape character (OFF).
"""

ida_lines.COLOR_ON
"""
Followed by a color code ( 'color_t' ).

Escape character (ON).
"""

ida_lines.COLOR_REGFUNC
"""
Regular function.
"""

ida_lines.COLOR_SELECTED
"""
Selected.
"""

ida_lines.COLOR_UNKNOWN
"""
Unexplored byte.
"""

ida_lines.SCOLOR_ADDR
"""
Hidden address mark.
"""

ida_lines.SCOLOR_ALTOP
"""
Alternative operand.
"""

ida_lines.SCOLOR_ASMDIR
"""
Assembler directive.
"""

ida_lines.SCOLOR_AUTOCMT
"""
Automatic comment.
"""

ida_lines.SCOLOR_BINPREF
"""
Binary line prefix bytes.
"""

ida_lines.SCOLOR_CHAR
"""
Char constant in instruction.
"""

ida_lines.SCOLOR_CNAME
"""
Regular code name.
"""

ida_lines.SCOLOR_CODNAME
"""
Dummy code name.
"""

ida_lines.SCOLOR_COLLAPSED
"""
Collapsed line.
"""

ida_lines.SCOLOR_CREF
"""
Code reference.
"""

ida_lines.SCOLOR_CREFTAIL
"""
Code reference to tail byte.
"""

ida_lines.SCOLOR_DATNAME
"""
Dummy Data Name.
"""

ida_lines.SCOLOR_DCHAR
"""
Char constant in data directive.
"""

ida_lines.SCOLOR_DEFAULT
"""
Default.
"""

ida_lines.SCOLOR_DEMNAME
"""
Demangled Name.
"""

ida_lines.SCOLOR_DNAME
"""
Regular Data Name.
"""

ida_lines.SCOLOR_DNUM
"""
Numeric constant in data directive.
"""

ida_lines.SCOLOR_DREF
"""
Data reference.
"""

ida_lines.SCOLOR_DREFTAIL
"""
Data reference to tail byte.
"""

ida_lines.SCOLOR_DSTR
"""
String constant in data directive.
"""

ida_lines.SCOLOR_ERROR
"""
Error or problem.
"""

ida_lines.SCOLOR_ESC
"""
Escape character (Quote next character)
"""

ida_lines.SCOLOR_EXTRA
"""
Extra line.
"""

ida_lines.SCOLOR_HIDNAME
"""
Hidden name.
"""

ida_lines.SCOLOR_IMPNAME
"""
Imported name.
"""

ida_lines.SCOLOR_INSN
"""
Instruction.
"""

ida_lines.SCOLOR_INV
"""
Escape character (Inverse colors)
"""

ida_lines.SCOLOR_KEYWORD
"""
Keywords.
"""

ida_lines.SCOLOR_LIBNAME
"""
Library function name.
"""

ida_lines.SCOLOR_LOCNAME
"""
Local variable name.
"""

ida_lines.SCOLOR_MACRO
"""
Macro.
"""

ida_lines.SCOLOR_NUMBER
"""
Numeric constant in instruction.
"""

ida_lines.SCOLOR_OFF
"""
Escape character (OFF)
"""

ida_lines.SCOLOR_ON
"""
Escape character (ON)
"""

ida_lines.SCOLOR_PREFIX
"""
Line prefix.
"""

ida_lines.SCOLOR_REG
"""
Register name.
"""

ida_lines.SCOLOR_REGCMT
"""
Regular comment.
"""

ida_lines.SCOLOR_RPTCMT
"""
Repeatable comment (defined not here)
"""

ida_lines.SCOLOR_SEGNAME
"""
Segment name.
"""

ida_lines.SCOLOR_STRING
"""
String constant in instruction.
"""

ida_lines.SCOLOR_SYMBOL
"""
Punctuation.
"""

ida_lines.SCOLOR_UNAME
"""
Regular unknown name.
"""

ida_lines.SCOLOR_UNKNAME
"""
Dummy unknown name.
"""

ida_lines.SCOLOR_VOIDOP
"""
Void operand.
"""
=== ida_lines EPYDOC INJECTIONS END ===
Help on function base2file in module ida_loader:

base2file(*args) -> 'int'
    base2file(fp, pos, ea1, ea2) -> int
    
    
    Unload database to a binary file. This function works for wide byte
    processors too.
    
    @param fp: pointer to file (C++: FILE *)
    @param pos: position in the file (C++: qoff64_t)
    @param ea1: range of source linear addresses (C++: ea_t)
    @param ea2: range of source linear addresses (C++: ea_t)
    @return: 1-ok(always), write error leads to immediate exit

Help on function build_snapshot_tree in module ida_loader:

build_snapshot_tree(*args) -> 'bool'
    build_snapshot_tree(root) -> bool
    
    
    Build the snapshot tree.
    
    @param root: snapshot root that will contain the snapshot tree
                 elements. (C++: snapshot_t  *)
    @return: success

Help on function clr_database_flag in module ida_loader:

clr_database_flag(*args) -> 'void'
    clr_database_flag(dbfl)

Help on function extract_module_from_archive in module ida_loader:

extract_module_from_archive(*args) -> 'PyObject *'
    extract_module_from_archive(fname, is_remote=False) -> PyObject *
    
    
    Extract a module for an archive file. Parse an archive file, show the
    list of modules to the user, allow him to select a module, extract the
    selected module to a file (if the extract module is an archive, repeat
    the process). This function can handle ZIP, AR, AIXAR, OMFLIB files.
    The temporary file will be automatically deleted by IDA at the end.
    
    @param is_remote: is the input file remote? (C++: bool)

Help on function file2base in module ida_loader:

file2base(*args) -> 'int'
    file2base(li, pos, ea1, ea2, patchable) -> int
    
    
    Load portion of file into the database. This function will include
    (ea1..ea2) into the addressing space of the program (make it enabled)
    
    @param li: pointer of input source (C++: linput_t *)
    @param pos: position in the file (C++: qoff64_t)
    @param ea1: range of destination linear addresses (C++: ea_t)
    @param ea2: range of destination linear addresses (C++: ea_t)
    @param patchable: should the kernel remember correspondence of file
                      offsets to linear addresses. (C++: int)

Help on function find_plugin in module ida_loader:

find_plugin(*args) -> 'plugin_t *'
    find_plugin(name, load_if_needed=False) -> plugin_t *
    
    
    Find a user-defined plugin and optionally load it.
    
    @param name: short plugin name without path and extension, or absolute
                 path to the file name (C++: const char *)
    @param load_if_needed: if the plugin is not present in the memory, try
                           to load it (C++: bool)
    @return: pointer to plugin description block

Help on function flush_buffers in module ida_loader:

flush_buffers(*args) -> 'int'
    flush_buffers() -> int
    
    
    Flush buffers to the disk.

Help on function gen_exe_file in module ida_loader:

gen_exe_file(*args) -> 'int'
    gen_exe_file(fp) -> int
    
    
    Generate an exe file (unload the database in binary form).
    
    @param fp (C++: FILE *)
    @return: fp the output file handle. if fp == NULL then return:   1:
             can generate an executable file   0: can't generate an
             executable file

Help on function gen_file in module ida_loader:

gen_file(*args) -> 'int'
    gen_file(otype, fp, ea1, ea2, flags) -> int
    
    
    Generate an output file. 'OFILE_EXE' :
    
    @param otype: type of output file. (C++: ofile_type_t)
    @param fp: the output file handle (C++: FILE *)
    @param ea1: start address. For some file types this argument is
                ignored (C++: ea_t)
    @param ea2: end address. For some file types this argument is ignored
                as usual in ida, the end address of the range is not
                included (C++: ea_t)
    @param flags: Generate file flags (C++: int)
    @return: number of the generated lines. -1 if an error occurred

Help on function get_basic_file_type in module ida_loader:

get_basic_file_type(*args) -> 'filetype_t'
    get_basic_file_type(li) -> filetype_t
    
    
    Get the input file type. This function can recognize libraries and zip
    files.
    
    @param li (C++: linput_t *)

Help on function get_elf_debug_file_directory in module ida_loader:

get_elf_debug_file_directory(*args) -> 'char const *'
    get_elf_debug_file_directory() -> char const *
    
    
    Get the value of the ELF_DEBUG_FILE_DIRECTORY configuration directive.

Help on function get_file_type_name in module ida_loader:

get_file_type_name(*args) -> 'size_t'
    get_file_type_name() -> str
    
    
    Get name of the current file type. The current file type is kept in
    \inf{filetype}.
    
    @return: size of answer, this function always succeeds

Help on function get_fileregion_ea in module ida_loader:

get_fileregion_ea(*args) -> 'ea_t'
    get_fileregion_ea(offset) -> ea_t
    
    
    Get linear address which corresponds to the specified input file
    offset. If can't be found, return 'BADADDR'
    
    @param offset (C++: qoff64_t)

Help on function get_fileregion_offset in module ida_loader:

get_fileregion_offset(*args) -> 'qoff64_t'
    get_fileregion_offset(ea) -> qoff64_t
    
    
    Get offset in the input file which corresponds to the given ea. If the
    specified ea can't be mapped into the input file offset, return -1.
    
    @param ea (C++: ea_t)

Help on function get_path in module ida_loader:

get_path(*args) -> 'char const *'
    get_path(pt) -> char const *
    
    
    Get the file path
    
    @param pt: file path type  Types of the file pathes (C++: path_type_t)
    @return: file path, never returns NULL

Help on function get_plugin_options in module ida_loader:

get_plugin_options(*args) -> 'char const *'
    get_plugin_options(plugin) -> char const *
    
    
    Get plugin options from the command line. If the user has specified
    the options in the -Oplugin_name:options format, them this function
    will return the 'options' part of it The 'plugin' parameter should
    denote the plugin name Returns NULL if there we no options specified
    
    @param plugin (C++: const char *)

Help on class idp_desc_t in module ida_loader:

class idp_desc_t(builtins.object)
 |  Proxy of C++ idp_desc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idp_desc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idp_desc_t(...)
 |      delete_idp_desc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  checked
 |      idp_desc_t_checked_get(self) -> bool
 |  
 |  family
 |      idp_desc_t_family_get(self) -> qstring *
 |  
 |  is_script
 |      idp_desc_t_is_script_get(self) -> bool
 |  
 |  mtime
 |      idp_desc_t_mtime_get(self) -> time_t
 |  
 |  names
 |      idp_desc_t_names_get(self) -> idp_names_t *
 |  
 |  path
 |      idp_desc_t_path_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on class idp_name_t in module ida_loader:

class idp_name_t(builtins.object)
 |  Proxy of C++ idp_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idp_name_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idp_name_t(...)
 |      delete_idp_name_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hidden
 |      idp_name_t_hidden_get(self) -> bool
 |  
 |  lname
 |      idp_name_t_lname_get(self) -> qstring *
 |  
 |  sname
 |      idp_name_t_sname_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on function is_database_flag in module ida_loader:

is_database_flag(*args) -> 'bool'
    is_database_flag(dbfl) -> bool
    
    
    Get the current database flag
    
    @param dbfl: flag  Database flags (C++: uint32)
    @return: the state of the flag (set or cleared)

Help on function is_trusted_idb in module ida_loader:

is_trusted_idb(*args) -> 'bool'
    is_trusted_idb() -> bool
    
    
    Is the database considered as trusted?

Help on function load_and_run_plugin in module ida_loader:

load_and_run_plugin(*args) -> 'bool'
    load_and_run_plugin(name, arg) -> bool
    
    
    Load & run a plugin.
    
    
    @param name (C++: const char *)
    @param arg (C++: size_t)

Help on function load_binary_file in module ida_loader:

load_binary_file(*args) -> 'bool'
    load_binary_file(filename, li, _neflags, fileoff, basepara, binoff, nbytes) -> bool
    
    
    Load a binary file into the database. This function usually is called
    from ui.
    
    @param filename: the name of input file as is (if the input file is
                     from library, then this is the name from the library)
                     (C++: const char *)
    @param li: loader input source (C++: linput_t *)
    @param _neflags: Load file flags . For the first file, the flag
                     NEF_FIRST  must be set. (C++: ushort)
    @param fileoff: Offset in the input file (C++: qoff64_t)
    @param basepara: Load address in paragraphs (C++: ea_t)
    @param binoff: Load offset (load_address=(basepara<<4)+binoff) (C++:
                   ea_t)
    @param nbytes: Number of bytes to load from the file.   0: up to the
                   end of the file (C++: uint64)

Help on function load_ids_module in module ida_loader:

load_ids_module(*args) -> 'int'
    load_ids_module(fname) -> int
    
    
    Load and apply IDS file. This function loads the specified IDS file
    and applies it to the database. If the program imports functions from
    a module with the same name as the name of the ids file being loaded,
    then only functions from this module will be affected. Otherwise (i.e.
    when the program does not import a module with this name) any function
    in the program may be affected.
    
    @param fname: name of file to apply (C++: char *)

Help on function load_plugin in module ida_loader:

load_plugin(*args) -> 'PyObject *'
    load_plugin(name) -> PyObject *
    
    
    Loads a plugin
    @return:
        - None if plugin could not be loaded
        - An opaque object representing the loaded plugin

Help on class loader_t in module ida_loader:

class loader_t(builtins.object)
 |  Proxy of C++ loader_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> loader_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_loader_t(...)
 |      delete_loader_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      loader_t_flags_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  version
 |      loader_t_version_get(self) -> uint32

Help on function mem2base in module ida_loader:

mem2base(*args) -> 'int'
    mem2base(py_mem, ea, fpos=-1) -> int
    
    
    Load database from the memory.
    @param mem: the buffer
    @param ea: start linear addresses
    @param fpos: position in the input file the data is taken from.
                 if == -1, then no file position correspond to the data.
    @return:
        - Returns zero if the passed buffer was not a string
        - Otherwise 1 is returned

Help on class plugin_info_t in module ida_loader:

class plugin_info_t(builtins.object)
 |  Proxy of C++ plugin_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> plugin_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_plugin_info_t(...)
 |      delete_plugin_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  arg
 |      plugin_info_t_arg_get(self) -> size_t
 |  
 |  comment
 |      plugin_info_t_comment_get(self) -> char *
 |  
 |  dllmem
 |      plugin_info_t_dllmem_get(self) -> idadll_t *
 |  
 |  entry
 |      plugin_info_t_entry_get(self) -> plugin_t *
 |  
 |  flags
 |      plugin_info_t_flags_get(self) -> int
 |  
 |  hotkey
 |      plugin_info_t_hotkey_get(self) -> ushort
 |  
 |  name
 |      plugin_info_t_name_get(self) -> char *
 |  
 |  next
 |      plugin_info_t_next_get(self) -> plugin_info_t
 |  
 |  org_hotkey
 |      plugin_info_t_org_hotkey_get(self) -> ushort
 |  
 |  org_name
 |      plugin_info_t_org_name_get(self) -> char *
 |  
 |  path
 |      plugin_info_t_path_get(self) -> char *
 |  
 |  thisown
 |      The membership flag

Help on function process_archive in module ida_loader:

process_archive(*args) -> 'qstring *'
    process_archive(temp_file, li, module_name, neflags, defmember, loader) -> str
    
    
    Calls 'loader_t::process_archive()' For parameters and return value
    description look at 'loader_t::process_archive()' . Additional
    parameter:
    
    @param temp_file (C++: qstring  *)
    @param li (C++: linput_t *)
    @param module_name (C++: qstring  *)
    @param neflags (C++: ushort  *)
    @param defmember (C++: const char *)
    @param loader: pointer to  load_info_t  structure. (C++: const
                   load_info_t  *)

Help on class qvector_snapshotvec_t in module ida_loader:

class qvector_snapshotvec_t(builtins.object)
 |  Proxy of C++ qvector< snapshot_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'snapshot_t *const &'
 |      __getitem__(self, i) -> snapshot_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_snapshotvec_t
 |      __init__(self, x) -> qvector_snapshotvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_qvector_snapshotvec_t(...)
 |      delete_qvector_snapshotvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'snapshot_t *const &'
 |      at(self, _idx) -> snapshot_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< snapshot_t * >::const_iterator'
 |      begin(self) -> qvector< snapshot_t * >::iterator
 |      begin(self) -> qvector< snapshot_t * >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< snapshot_t * >::const_iterator'
 |      end(self) -> qvector< snapshot_t * >::iterator
 |      end(self) -> qvector< snapshot_t * >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< snapshot_t * >::iterator'
 |      erase(self, it) -> qvector< snapshot_t * >::iterator
 |      erase(self, first, last) -> qvector< snapshot_t * >::iterator
 |  
 |  extract(self, *args) -> 'snapshot_t **'
 |      extract(self) -> snapshot_t **
 |  
 |  find(self, *args) -> 'qvector< snapshot_t * >::const_iterator'
 |      find(self, x) -> qvector< snapshot_t * >::iterator
 |      find(self, x) -> qvector< snapshot_t * >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< snapshot_t * >::iterator'
 |      insert(self, it, x) -> qvector< snapshot_t * >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'snapshot_t *&'
 |      push_back(self, x)
 |      push_back(self) -> snapshot_t *&
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function reload_file in module ida_loader:

reload_file(*args) -> 'bool'
    reload_file(file, is_remote) -> bool
    
    
    Reload the input file. This function reloads the byte values from the
    input file. It doesn't modify the segmentation, names, comments, etc.
    
    @param file: name of the input file. if file == NULL then returns:
                 1: can reload the input file   0: can't reload the input
                 file (C++: const char *)
    @param is_remote: is the file located on a remote computer with the
                      debugger server? (C++: bool)
    @return: success

Help on function run_plugin in module ida_loader:

run_plugin(*args) -> 'bool'
    run_plugin(plg, arg) -> bool
    
    
    Runs a plugin
    @param plg: A plugin object (returned by load_plugin())
    @return: Boolean

Help on function save_database in module ida_loader:

save_database(*args) -> 'bool'
    save_database(outfile, flags, root=None, attr=None) -> bool
    
    
    Save current database using a new file name.when both root and attr
    are not NULL then the snapshot attributes will be updated, otherwise
    the snapshot attributes will be inherited from the current database.
    
    @param outfile: output database file name (C++: const char *)
    @param flags: Database flags (C++: uint32)
    @param root: optional: snapshot tree root. (C++: const  snapshot_t  *)
    @param attr: optional: snapshot attributes (C++: const  snapshot_t  *)
    @return: success

Help on function set_database_flag in module ida_loader:

set_database_flag(*args) -> 'void'
    set_database_flag(dbfl, cnd=True)
    
    
    Set or clear database flag
    
    @param dbfl: flag  Database flags (C++: uint32)
    @param cnd: set if true or clear flag otherwise (C++: bool)

Help on function set_path in module ida_loader:

set_path(*args) -> 'void'
    set_path(pt, path)
    
    
    Set the file path
    
    @param pt: file path type  Types of the file pathes (C++: path_type_t)
    @param path: new file path, use NULL or empty string to clear the file
                 path (C++: const char *)

Help on class snapshot_t in module ida_loader:

class snapshot_t(builtins.object)
 |  Proxy of C++ snapshot_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> snapshot_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_snapshot_t(...)
 |      delete_snapshot_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  children
 |      snapshot_t_children_get(self) -> qvector_snapshotvec_t
 |  
 |  desc
 |      snapshot_t_desc_get(self) -> char [128]
 |  
 |  filename
 |      snapshot_t_filename_get(self) -> char [QMAXPATH]
 |  
 |  flags
 |      snapshot_t_flags_get(self) -> uint16
 |  
 |  id
 |      snapshot_t_id_get(self) -> qtime64_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

=== ida_loader EPYDOC INJECTIONS ===
ida_loader.ACCEPT_ARCHIVE
"""
Specify that a file format is served by archive loader See
'loader_t::accept_file'
"""

ida_loader.ACCEPT_CONTINUE
"""
Specify that the function must be called another time See
'loader_t::accept_file'
"""

ida_loader.ACCEPT_FIRST
"""
Specify that a file format should be place first in "load file" dialog
box. See 'loader_t::accept_file'
"""

ida_loader.DBFL_BAK
"""
create backup file (if !DBFL_KILL)
"""

ida_loader.DBFL_COMP
"""
collect garbage
"""

ida_loader.DBFL_KILL
"""
delete unpacked database
"""

ida_loader.DBFL_TEMP
"""
temporary database
"""

ida_loader.FILEREG_NOTPATCHABLE
"""
form in the file.

the data is kept in some encoded
"""

ida_loader.FILEREG_PATCHABLE
"""
means that the input file may be patched (i.e. no compression, no
iterated data, etc)
"""

ida_loader.GENFLG_ASMINC
"""
 'OFILE_ASM' , 'OFILE_LST' : gen information only about types
"""

ida_loader.GENFLG_ASMTYPE
"""
 'OFILE_ASM' , 'OFILE_LST' : gen information about types too
"""

ida_loader.GENFLG_GENHTML
"""
 'OFILE_ASM' , 'OFILE_LST' : generate html ( 'ui_genfile_callback'
will be used)
"""

ida_loader.GENFLG_IDCTYPE
"""
 'OFILE_IDC' : gen only information about types
"""

ida_loader.GENFLG_MAPDMNG
"""
 'OFILE_MAP' : demangle names
"""

ida_loader.GENFLG_MAPLOC
"""
 'OFILE_MAP' : include local names
"""

ida_loader.GENFLG_MAPNAME
"""
 'OFILE_MAP' : include dummy names
"""

ida_loader.GENFLG_MAPSEG
"""
 'OFILE_MAP' : generate map of segments
"""

ida_loader.LDRF_RELOAD
"""
loader recognizes 'NEF_RELOAD' flag
"""

ida_loader.LDRF_REQ_PROC
"""
Requires a processor to be set. if this bit is not set, load_file()
must call set_processor_type(..., SETPROC_LOADER)
"""

ida_loader.MAX_DATABASE_DESCRIPTION
"""
Maximum database snapshot description length.
"""

ida_loader.NEF_CODE
"""
load as a code segment

for 'load_binary_file()' :
"""

ida_loader.NEF_FILL
"""
Fill segment gaps.
"""

ida_loader.NEF_FIRST
"""
into the database.

This is the first file loaded
"""

ida_loader.NEF_FLAT
"""
Autocreate FLAT group (PE)
"""

ida_loader.NEF_IMPS
"""
Create import segment.
"""

ida_loader.NEF_LALL
"""
Load all segments without questions.
"""

ida_loader.NEF_LOPT
"""
Display additional loader options dialog.
"""

ida_loader.NEF_MAN
"""
Manual load.
"""

ida_loader.NEF_MINI
"""
Create mini database (do not copy segment bytes from the input file;
use only the file header metadata)
"""

ida_loader.NEF_NAME
"""
Rename entries.
"""

ida_loader.NEF_RELOAD
"""
reload the file at the same place: - don't create segmentsdon't create
fixup infodon't import segmentsetc load only the bytes into the base.
a loader should have 'LDRF_RELOAD' bit set
"""

ida_loader.NEF_RSCS
"""
Load resources.
"""

ida_loader.NEF_SEGS
"""
Create segments.
"""

ida_loader.PLUGIN_DLL
"""
Pattern to find plugin files.
"""

ida_loader.SSF_AUTOMATIC
"""
automatic snapshot
"""

ida_loader.SSUF_DESC
"""
Update the description.
"""

ida_loader.SSUF_FLAGS
"""
Update the flags.
"""

ida_loader.SSUF_PATH
"""
Update the path.
"""
=== ida_loader EPYDOC INJECTIONS END ===
Help on function apply_metadata in module ida_lumina:

apply_metadata(*args) -> 'void'
    apply_metadata(ea, fi, flags=0)

Help on function backup_metadata in module ida_lumina:

backup_metadata(*args) -> 'bool'
    backup_metadata(ea) -> bool

Help on function calc_func_metadata in module ida_lumina:

calc_func_metadata(*args) -> 'md5_t *'
    calc_func_metadata(out_fi, pfn, append_metadata=None) -> asize_t

Help on function create_simple_diff_handler in module ida_lumina:

create_simple_diff_handler(*args) -> 'simple_diff_handler_t *'
    create_simple_diff_handler() -> simple_diff_handler_t

Help on function create_simple_idb_diff_handler in module ida_lumina:

create_simple_idb_diff_handler(*args) -> 'simple_idb_diff_handler_t *'
    create_simple_idb_diff_handler(pfn) -> simple_idb_diff_handler_t

Help on function diff_metadata in module ida_lumina:

diff_metadata(*args) -> 'bool'
    diff_metadata(handler, left, right, flags=0) -> bool

Help on function ea_to_ea64 in module ida_lumina:

ea_to_ea64(*args) -> 'ea64_t'
    ea_to_ea64(ea) -> ea64_t

Help on class extra_cmt_t in module ida_lumina:

class extra_cmt_t(insn_site_t)
 |  Proxy of C++ extra_cmt_t class.
 |  
 |  Method resolution order:
 |      extra_cmt_t
 |      insn_site_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> extra_cmt_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_extra_cmt_t(...)
 |      delete_extra_cmt_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  next
 |      extra_cmt_t_next_get(self) -> qstring *
 |  
 |  prev
 |      extra_cmt_t_prev_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from insn_site_t:
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self, pfn) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from insn_site_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fchunk_nr
 |      insn_site_t_fchunk_nr_get(self) -> uint32
 |  
 |  fchunk_off
 |      insn_site_t_fchunk_off_get(self) -> uint32

Help on class extra_cmts_t in module ida_lumina:

class extra_cmts_t(builtins.object)
 |  Proxy of C++ qvector< extra_cmt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'extra_cmt_t const &'
 |      __getitem__(self, i) -> extra_cmt_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> extra_cmts_t
 |      __init__(self, x) -> extra_cmts_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_extra_cmts_t(...)
 |      delete_extra_cmts_t(self)
 |  
 |  at(self, *args) -> 'extra_cmt_t const &'
 |      at(self, _idx) -> extra_cmt_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< extra_cmt_t >::const_iterator'
 |      begin(self) -> extra_cmt_t
 |      begin(self) -> extra_cmt_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< extra_cmt_t >::const_iterator'
 |      end(self) -> extra_cmt_t
 |      end(self) -> extra_cmt_t
 |  
 |  erase(self, *args) -> 'qvector< extra_cmt_t >::iterator'
 |      erase(self, it) -> extra_cmt_t
 |      erase(self, first, last) -> extra_cmt_t
 |  
 |  extract(self, *args) -> 'extra_cmt_t *'
 |      extract(self) -> extra_cmt_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=extra_cmt_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< extra_cmt_t >::iterator'
 |      insert(self, it, x) -> extra_cmt_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'extra_cmt_t &'
 |      push_back(self, x)
 |      push_back(self) -> extra_cmt_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function extract_extra_cmts_from_metadata in module ida_lumina:

extract_extra_cmts_from_metadata(*args) -> 'void'
    extract_extra_cmts_from_metadata(out, ptr)

Help on function extract_frame_desc_from_metadata in module ida_lumina:

extract_frame_desc_from_metadata(*args) -> 'void'
    extract_frame_desc_from_metadata(out, ptr)

Help on function extract_insn_cmts_from_metadata in module ida_lumina:

extract_insn_cmts_from_metadata(*args) -> 'void'
    extract_insn_cmts_from_metadata(out, ptr)

Help on function extract_insn_opreprs_from_metadata in module ida_lumina:

extract_insn_opreprs_from_metadata(*args) -> 'void'
    extract_insn_opreprs_from_metadata(out, ptr)

Help on function extract_type_from_metadata in module ida_lumina:

extract_type_from_metadata(*args) -> 'bool'
    extract_type_from_metadata(out, _in) -> bool

Help on function extract_user_stkpnts_from_metadata in module ida_lumina:

extract_user_stkpnts_from_metadata(*args) -> 'void'
    extract_user_stkpnts_from_metadata(out, ptr)

Help on class frame_desc_t in module ida_lumina:

class frame_desc_t(builtins.object)
 |  Proxy of C++ frame_desc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> frame_desc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_frame_desc_t(...)
 |      delete_frame_desc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  argsize
 |      frame_desc_t_argsize_get(self) -> asize_t
 |  
 |  frregs
 |      frame_desc_t_frregs_get(self) -> ushort
 |  
 |  frsize
 |      frame_desc_t_frsize_get(self) -> sval_t
 |  
 |  members
 |      frame_desc_t_members_get(self) -> frame_mems_t
 |  
 |  thisown
 |      The membership flag

Help on class frame_mem_t in module ida_lumina:

class frame_mem_t(builtins.object)
 |  Proxy of C++ frame_mem_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> frame_mem_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_frame_mem_t(...)
 |      delete_frame_mem_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      frame_mem_t_cmt_get(self) -> qstring *
 |  
 |  info
 |      frame_mem_t_info_get(self) -> oprepr_t
 |  
 |  name
 |      frame_mem_t_name_get(self) -> qstring *
 |  
 |  nbytes
 |      frame_mem_t_nbytes_get(self) -> asize_t
 |  
 |  offset
 |      frame_mem_t_offset_get(self) -> ea64_t
 |  
 |  rptcmt
 |      frame_mem_t_rptcmt_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      frame_mem_t_type_get(self) -> serialized_tinfo

Help on class frame_mems_t in module ida_lumina:

class frame_mems_t(builtins.object)
 |  Proxy of C++ qvector< frame_mem_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'frame_mem_t const &'
 |      __getitem__(self, i) -> frame_mem_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> frame_mems_t
 |      __init__(self, x) -> frame_mems_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_frame_mems_t(...)
 |      delete_frame_mems_t(self)
 |  
 |  at(self, *args) -> 'frame_mem_t const &'
 |      at(self, _idx) -> frame_mem_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< frame_mem_t >::const_iterator'
 |      begin(self) -> frame_mem_t
 |      begin(self) -> frame_mem_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< frame_mem_t >::const_iterator'
 |      end(self) -> frame_mem_t
 |      end(self) -> frame_mem_t
 |  
 |  erase(self, *args) -> 'qvector< frame_mem_t >::iterator'
 |      erase(self, it) -> frame_mem_t
 |      erase(self, first, last) -> frame_mem_t
 |  
 |  extract(self, *args) -> 'frame_mem_t *'
 |      extract(self) -> frame_mem_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=frame_mem_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< frame_mem_t >::iterator'
 |      insert(self, it, x) -> frame_mem_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'frame_mem_t &'
 |      push_back(self, x)
 |      push_back(self) -> frame_mem_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class func_info_and_frequency_t in module ida_lumina:

class func_info_and_frequency_t(func_info_t)
 |  Proxy of C++ func_info_and_frequency_t class.
 |  
 |  Method resolution order:
 |      func_info_and_frequency_t
 |      func_info_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_info_and_frequency_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_info_and_frequency_t(...)
 |      delete_func_info_and_frequency_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  frequency
 |      func_info_and_frequency_t_frequency_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from func_info_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  metadata
 |      func_info_t_metadata_get(self) -> metadata_t *
 |  
 |  name
 |      func_info_t_name_get(self) -> qstring *
 |  
 |  size
 |      func_info_t_size_get(self) -> uint32

Help on class func_info_and_frequency_vec_t in module ida_lumina:

class func_info_and_frequency_vec_t(builtins.object)
 |  Proxy of C++ qvector< func_info_and_frequency_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'func_info_and_frequency_t const &'
 |      __getitem__(self, i) -> func_info_and_frequency_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_info_and_frequency_vec_t
 |      __init__(self, x) -> func_info_and_frequency_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_func_info_and_frequency_vec_t(...)
 |      delete_func_info_and_frequency_vec_t(self)
 |  
 |  at(self, *args) -> 'func_info_and_frequency_t const &'
 |      at(self, _idx) -> func_info_and_frequency_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< func_info_and_frequency_t >::const_iterator'
 |      begin(self) -> func_info_and_frequency_t
 |      begin(self) -> func_info_and_frequency_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< func_info_and_frequency_t >::const_iterator'
 |      end(self) -> func_info_and_frequency_t
 |      end(self) -> func_info_and_frequency_t
 |  
 |  erase(self, *args) -> 'qvector< func_info_and_frequency_t >::iterator'
 |      erase(self, it) -> func_info_and_frequency_t
 |      erase(self, first, last) -> func_info_and_frequency_t
 |  
 |  extract(self, *args) -> 'func_info_and_frequency_t *'
 |      extract(self) -> func_info_and_frequency_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=func_info_and_frequency_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< func_info_and_frequency_t >::iterator'
 |      insert(self, it, x) -> func_info_and_frequency_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'func_info_and_frequency_t &'
 |      push_back(self, x)
 |      push_back(self) -> func_info_and_frequency_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class func_info_and_pattern_t in module ida_lumina:

class func_info_and_pattern_t(func_info_t)
 |  Proxy of C++ func_info_and_pattern_t class.
 |  
 |  Method resolution order:
 |      func_info_and_pattern_t
 |      func_info_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_info_and_pattern_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_info_and_pattern_t(...)
 |      delete_func_info_and_pattern_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  pattern_id
 |      func_info_and_pattern_t_pattern_id_get(self) -> pattern_id_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from func_info_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  metadata
 |      func_info_t_metadata_get(self) -> metadata_t *
 |  
 |  name
 |      func_info_t_name_get(self) -> qstring *
 |  
 |  size
 |      func_info_t_size_get(self) -> uint32

Help on class func_info_and_pattern_vec_t in module ida_lumina:

class func_info_and_pattern_vec_t(builtins.object)
 |  Proxy of C++ qvector< func_info_and_pattern_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'func_info_and_pattern_t const &'
 |      __getitem__(self, i) -> func_info_and_pattern_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_info_and_pattern_vec_t
 |      __init__(self, x) -> func_info_and_pattern_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_func_info_and_pattern_vec_t(...)
 |      delete_func_info_and_pattern_vec_t(self)
 |  
 |  at(self, *args) -> 'func_info_and_pattern_t const &'
 |      at(self, _idx) -> func_info_and_pattern_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< func_info_and_pattern_t >::const_iterator'
 |      begin(self) -> func_info_and_pattern_t
 |      begin(self) -> func_info_and_pattern_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< func_info_and_pattern_t >::const_iterator'
 |      end(self) -> func_info_and_pattern_t
 |      end(self) -> func_info_and_pattern_t
 |  
 |  erase(self, *args) -> 'qvector< func_info_and_pattern_t >::iterator'
 |      erase(self, it) -> func_info_and_pattern_t
 |      erase(self, first, last) -> func_info_and_pattern_t
 |  
 |  extract(self, *args) -> 'func_info_and_pattern_t *'
 |      extract(self) -> func_info_and_pattern_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=func_info_and_pattern_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< func_info_and_pattern_t >::iterator'
 |      insert(self, it, x) -> func_info_and_pattern_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'func_info_and_pattern_t &'
 |      push_back(self, x)
 |      push_back(self) -> func_info_and_pattern_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class func_info_base_t in module ida_lumina:

class func_info_base_t(builtins.object)
 |  Proxy of C++ func_info_base_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_info_base_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_info_base_t(...)
 |      delete_func_info_base_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  metadata
 |      func_info_base_t_metadata_get(self) -> metadata_t *
 |  
 |  name
 |      func_info_base_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on class func_info_pattern_and_frequency_t in module ida_lumina:

class func_info_pattern_and_frequency_t(func_info_and_pattern_t)
 |  Proxy of C++ func_info_pattern_and_frequency_t class.
 |  
 |  Method resolution order:
 |      func_info_pattern_and_frequency_t
 |      func_info_and_pattern_t
 |      func_info_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_info_pattern_and_frequency_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_info_pattern_and_frequency_t(...)
 |      delete_func_info_pattern_and_frequency_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  frequency
 |      func_info_pattern_and_frequency_t_frequency_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from func_info_and_pattern_t:
 |  
 |  pattern_id
 |      func_info_and_pattern_t_pattern_id_get(self) -> pattern_id_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from func_info_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  metadata
 |      func_info_t_metadata_get(self) -> metadata_t *
 |  
 |  name
 |      func_info_t_name_get(self) -> qstring *
 |  
 |  size
 |      func_info_t_size_get(self) -> uint32

Help on class func_info_pattern_and_frequency_vec_t in module ida_lumina:

class func_info_pattern_and_frequency_vec_t(builtins.object)
 |  Proxy of C++ qvector< func_info_pattern_and_frequency_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'func_info_pattern_and_frequency_t const &'
 |      __getitem__(self, i) -> func_info_pattern_and_frequency_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_info_pattern_and_frequency_vec_t
 |      __init__(self, x) -> func_info_pattern_and_frequency_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_func_info_pattern_and_frequency_vec_t(...)
 |      delete_func_info_pattern_and_frequency_vec_t(self)
 |  
 |  at(self, *args) -> 'func_info_pattern_and_frequency_t const &'
 |      at(self, _idx) -> func_info_pattern_and_frequency_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< func_info_pattern_and_frequency_t >::const_iterator'
 |      begin(self) -> func_info_pattern_and_frequency_t
 |      begin(self) -> func_info_pattern_and_frequency_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< func_info_pattern_and_frequency_t >::const_iterator'
 |      end(self) -> func_info_pattern_and_frequency_t
 |      end(self) -> func_info_pattern_and_frequency_t
 |  
 |  erase(self, *args) -> 'qvector< func_info_pattern_and_frequency_t >::iterator'
 |      erase(self, it) -> func_info_pattern_and_frequency_t
 |      erase(self, first, last) -> func_info_pattern_and_frequency_t
 |  
 |  extract(self, *args) -> 'func_info_pattern_and_frequency_t *'
 |      extract(self) -> func_info_pattern_and_frequency_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=func_info_pattern_and_frequency_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< func_info_pattern_and_frequency_t >::iterator'
 |      insert(self, it, x) -> func_info_pattern_and_frequency_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'func_info_pattern_and_frequency_t &'
 |      push_back(self, x)
 |      push_back(self) -> func_info_pattern_and_frequency_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class func_info_t in module ida_lumina:

class func_info_t(builtins.object)
 |  Proxy of C++ func_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_info_t(...)
 |      delete_func_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  metadata
 |      func_info_t_metadata_get(self) -> metadata_t *
 |  
 |  name
 |      func_info_t_name_get(self) -> qstring *
 |  
 |  size
 |      func_info_t_size_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag

Help on class func_info_vec_t in module ida_lumina:

class func_info_vec_t(builtins.object)
 |  Proxy of C++ qvector< func_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'func_info_t const &'
 |      __getitem__(self, i) -> func_info_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_info_vec_t
 |      __init__(self, x) -> func_info_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_func_info_vec_t(...)
 |      delete_func_info_vec_t(self)
 |  
 |  at(self, *args) -> 'func_info_t const &'
 |      at(self, _idx) -> func_info_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< func_info_t >::const_iterator'
 |      begin(self) -> func_info_t
 |      begin(self) -> func_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< func_info_t >::const_iterator'
 |      end(self) -> func_info_t
 |      end(self) -> func_info_t
 |  
 |  erase(self, *args) -> 'qvector< func_info_t >::iterator'
 |      erase(self, it) -> func_info_t
 |      erase(self, first, last) -> func_info_t
 |  
 |  extract(self, *args) -> 'func_info_t *'
 |      extract(self) -> func_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=func_info_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< func_info_t >::iterator'
 |      insert(self, it, x) -> func_info_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'func_info_t &'
 |      push_back(self, x)
 |      push_back(self) -> func_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class func_md_diff_handler_t in module ida_lumina:

class func_md_diff_handler_t(builtins.object)
 |  Proxy of C++ func_md_diff_handler_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_md_diff_handler_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_md_diff_handler_t(...)
 |      delete_func_md_diff_handler_t(self)
 |  
 |  on_comment_changed(self, *args) -> 'void'
 |      on_comment_changed(self, fchunk_nr, fchunk_off, l, r, rep)
 |  
 |  on_extra_comment_changed(self, *args) -> 'void'
 |      on_extra_comment_changed(self, fchunk_nr, fchunk_off, l, r, is_prev)
 |  
 |  on_frame_member_changed(self, *args) -> 'void'
 |      on_frame_member_changed(self, offset, l, r)
 |  
 |  on_function_comment_changed(self, *args) -> 'void'
 |      on_function_comment_changed(self, l, r, rep)
 |  
 |  on_insn_ops_repr_changed(self, *args) -> 'void'
 |      on_insn_ops_repr_changed(self, fchunk_nr, fchunk_off, l, r)
 |  
 |  on_name_changed(self, *args) -> 'void'
 |      on_name_changed(self, l, r)
 |  
 |  on_proto_changed(self, *args) -> 'void'
 |      on_proto_changed(self, l, r)
 |  
 |  on_score_changed(self, *args) -> 'void'
 |      on_score_changed(self, l, r)
 |  
 |  on_user_stkpnt_changed(self, *args) -> 'void'
 |      on_user_stkpnt_changed(self, fchunk_nr, fchunk_off, l, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function get_lumina_rpc_packet_t_index_from_base in module ida_lumina:

get_lumina_rpc_packet_t_index_from_base(*args) -> 'uchar'
    get_lumina_rpc_packet_t_index_from_base(code) -> uchar

Help on function get_server_connection in module ida_lumina:

get_server_connection(*args) -> 'lumina_client_t *'
    get_server_connection() -> lumina_client_t

Help on function has_backup_metadata in module ida_lumina:

has_backup_metadata(*args) -> 'bool'
    has_backup_metadata(ea) -> bool

Help on class history_entries_helper_t in module ida_lumina:

class history_entries_helper_t(builtins.object)
 |  Proxy of C++ history_entries_helper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _r) -> history_entries_helper_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_history_entries_helper_t(...)
 |      delete_history_entries_helper_t(self)
 |  
 |  next_entry(self, *args) -> 'change_desc_base_t const &'
 |      next_entry(self, _from) -> change_desc_base_t const &
 |  
 |  next_entry_index(self, *args) -> 'bool'
 |      next_entry_index(self, out_index, _from) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  res
 |      history_entries_helper_t_res_get(self) -> pkt_show_entries_result_t const &
 |  
 |  thisown
 |      The membership flag

Help on class input_file_t in module ida_lumina:

class input_file_t(builtins.object)
 |  Proxy of C++ input_file_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> input_file_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_input_file_t(...)
 |      delete_input_file_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  md5
 |      input_file_t_md5_get(self) -> md5_t *
 |  
 |  path
 |      input_file_t_path_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on class insn_cmt_t in module ida_lumina:

class insn_cmt_t(insn_site_t)
 |  Proxy of C++ insn_cmt_t class.
 |  
 |  Method resolution order:
 |      insn_cmt_t
 |      insn_site_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> insn_cmt_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_insn_cmt_t(...)
 |      delete_insn_cmt_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cmt
 |      insn_cmt_t_cmt_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from insn_site_t:
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self, pfn) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from insn_site_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fchunk_nr
 |      insn_site_t_fchunk_nr_get(self) -> uint32
 |  
 |  fchunk_off
 |      insn_site_t_fchunk_off_get(self) -> uint32

Help on class insn_cmts_t in module ida_lumina:

class insn_cmts_t(builtins.object)
 |  Proxy of C++ qvector< insn_cmt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'insn_cmt_t const &'
 |      __getitem__(self, i) -> insn_cmt_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> insn_cmts_t
 |      __init__(self, x) -> insn_cmts_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_insn_cmts_t(...)
 |      delete_insn_cmts_t(self)
 |  
 |  at(self, *args) -> 'insn_cmt_t const &'
 |      at(self, _idx) -> insn_cmt_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< insn_cmt_t >::const_iterator'
 |      begin(self) -> insn_cmt_t
 |      begin(self) -> insn_cmt_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< insn_cmt_t >::const_iterator'
 |      end(self) -> insn_cmt_t
 |      end(self) -> insn_cmt_t
 |  
 |  erase(self, *args) -> 'qvector< insn_cmt_t >::iterator'
 |      erase(self, it) -> insn_cmt_t
 |      erase(self, first, last) -> insn_cmt_t
 |  
 |  extract(self, *args) -> 'insn_cmt_t *'
 |      extract(self) -> insn_cmt_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=insn_cmt_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< insn_cmt_t >::iterator'
 |      insert(self, it, x) -> insn_cmt_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'insn_cmt_t &'
 |      push_back(self, x)
 |      push_back(self) -> insn_cmt_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class insn_ops_repr_t in module ida_lumina:

class insn_ops_repr_t(insn_site_t)
 |  Proxy of C++ insn_ops_repr_t class.
 |  
 |  Method resolution order:
 |      insn_ops_repr_t
 |      insn_site_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> insn_ops_repr_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_insn_ops_repr_t(...)
 |      delete_insn_ops_repr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  flags
 |      insn_ops_repr_t_flags_get(self) -> flags_t
 |  
 |  op0
 |      insn_ops_repr_t_op0_get(self) -> opinfo_t
 |  
 |  op1
 |      insn_ops_repr_t_op1_get(self) -> opinfo_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from insn_site_t:
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self, pfn) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from insn_site_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fchunk_nr
 |      insn_site_t_fchunk_nr_get(self) -> uint32
 |  
 |  fchunk_off
 |      insn_site_t_fchunk_off_get(self) -> uint32

Help on class insn_ops_reprs_t in module ida_lumina:

class insn_ops_reprs_t(builtins.object)
 |  Proxy of C++ qvector< insn_ops_repr_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'insn_ops_repr_t const &'
 |      __getitem__(self, i) -> insn_ops_repr_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> insn_ops_reprs_t
 |      __init__(self, x) -> insn_ops_reprs_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_insn_ops_reprs_t(...)
 |      delete_insn_ops_reprs_t(self)
 |  
 |  at(self, *args) -> 'insn_ops_repr_t const &'
 |      at(self, _idx) -> insn_ops_repr_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< insn_ops_repr_t >::const_iterator'
 |      begin(self) -> insn_ops_repr_t
 |      begin(self) -> insn_ops_repr_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< insn_ops_repr_t >::const_iterator'
 |      end(self) -> insn_ops_repr_t
 |      end(self) -> insn_ops_repr_t
 |  
 |  erase(self, *args) -> 'qvector< insn_ops_repr_t >::iterator'
 |      erase(self, it) -> insn_ops_repr_t
 |      erase(self, first, last) -> insn_ops_repr_t
 |  
 |  extract(self, *args) -> 'insn_ops_repr_t *'
 |      extract(self) -> insn_ops_repr_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=insn_ops_repr_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< insn_ops_repr_t >::iterator'
 |      insert(self, it, x) -> insn_ops_repr_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'insn_ops_repr_t &'
 |      push_back(self, x)
 |      push_back(self) -> insn_ops_repr_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class insn_site_t in module ida_lumina:

class insn_site_t(builtins.object)
 |  Proxy of C++ insn_site_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> insn_site_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_insn_site_t(...)
 |      delete_insn_site_t(self)
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self, pfn) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fchunk_nr
 |      insn_site_t_fchunk_nr_get(self) -> uint32
 |  
 |  fchunk_off
 |      insn_site_t_fchunk_off_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag

Help on class lumina_client_t in module ida_lumina:

class lumina_client_t(builtins.object)
 |  Proxy of C++ lumina_client_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lumina_client_t(...)
 |      delete_lumina_client_t(self)
 |  
 |  get_pop(self, *args) -> 'pkt_get_pop_result_t *'
 |      get_pop(self, nresults=10) -> pkt_get_pop_result_t
 |  
 |  is_pattern_id(self, *args) -> 'bool'
 |      is_pattern_id(self, pid, md5) -> bool
 |  
 |  pull_md(self, *args) -> 'pkt_pull_md_result_t *'
 |      pull_md(self, pattern_ids, pull_md_flags=0) -> pkt_pull_md_result_t
 |      pull_md(self, funcs, pull_md_flags=0) -> pkt_pull_md_result_t
 |  
 |  push_md(self, *args) -> 'bool'
 |      push_md(self, result, opts, append_metadata=None, flags=0) -> bool
 |  
 |  set_pattern_id_md5(self, *args) -> 'void'
 |      set_pattern_id_md5(self, out, md5)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class lumina_op_res_vec_t in module ida_lumina:

class lumina_op_res_vec_t(builtins.object)
 |  Proxy of C++ qvector< lumina_op_res_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'lumina_op_res_t const &'
 |      __getitem__(self, i) -> lumina_op_res_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lumina_op_res_vec_t
 |      __init__(self, x) -> lumina_op_res_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_lumina_op_res_vec_t(...)
 |      delete_lumina_op_res_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'lumina_op_res_t const &'
 |      at(self, _idx) -> lumina_op_res_t const &
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< lumina_op_res_t >::const_iterator'
 |      begin(self) -> qvector< lumina_op_res_t >::iterator
 |      begin(self) -> qvector< lumina_op_res_t >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< lumina_op_res_t >::const_iterator'
 |      end(self) -> qvector< lumina_op_res_t >::iterator
 |      end(self) -> qvector< lumina_op_res_t >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< lumina_op_res_t >::iterator'
 |      erase(self, it) -> qvector< lumina_op_res_t >::iterator
 |      erase(self, first, last) -> qvector< lumina_op_res_t >::iterator
 |  
 |  extract(self, *args) -> 'lumina_op_res_t *'
 |      extract(self) -> lumina_op_res_t *
 |  
 |  find(self, *args) -> 'qvector< lumina_op_res_t >::const_iterator'
 |      find(self, x) -> qvector< lumina_op_res_t >::iterator
 |      find(self, x) -> qvector< lumina_op_res_t >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=lumina_op_res_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< lumina_op_res_t >::iterator'
 |      insert(self, it, x) -> qvector< lumina_op_res_t >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'lumina_op_res_t &'
 |      push_back(self, x)
 |      push_back(self) -> lumina_op_res_t &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class md_type_parts_t in module ida_lumina:

class md_type_parts_t(builtins.object)
 |  Proxy of C++ md_type_parts_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> md_type_parts_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_md_type_parts_t(...)
 |      delete_md_type_parts_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fields
 |      md_type_parts_t_fields_get(self) -> qtype *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      md_type_parts_t_type_get(self) -> qtype *
 |  
 |  userti
 |      md_type_parts_t_userti_get(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class metadata_iterator_t in module ida_lumina:

class metadata_iterator_t(builtins.object)
 |  Proxy of C++ metadata_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _md) -> metadata_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_metadata_iterator_t(...)
 |      delete_metadata_iterator_t(self)
 |  
 |  data_end(self, *args) -> 'uchar const *'
 |      data_end(self) -> uchar const *
 |  
 |  next(self, *args) -> 'bool'
 |      next(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  data
 |      metadata_iterator_t_data_get(self) -> uchar const *
 |  
 |  key
 |      metadata_iterator_t_key_get(self) -> mdkey_t
 |  
 |  size
 |      metadata_iterator_t_size_get(self) -> size_t
 |  
 |  thisown
 |      The membership flag

Help on function new_packet in module ida_lumina:

new_packet(*args) -> 'rpc_packet_data_t *'
    new_packet(code, ptr=None, len=0, version=-1) -> rpc_packet_data_t *

Help on class oprepr_t in module ida_lumina:

class oprepr_t(builtins.object)
 |  Proxy of C++ oprepr_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> oprepr_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_oprepr_t(...)
 |      delete_oprepr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      oprepr_t_flags_get(self) -> flags_t
 |  
 |  opinfo
 |      oprepr_t_opinfo_get(self) -> opinfo_t
 |  
 |  thisown
 |      The membership flag

Help on class pattern_id_t in module ida_lumina:

class pattern_id_t(builtins.object)
 |  Proxy of C++ pattern_id_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pattern_id_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pattern_id_t(...)
 |      delete_pattern_id_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  data
 |      pattern_id_t_data_get(self) -> bytevec_t *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      pattern_id_t_type_get(self) -> pattern_type_t

Help on class pkt_clean_db_t in module ida_lumina:

class pkt_clean_db_t(builtins.object)
 |  Proxy of C++ pkt_clean_db_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_clean_db_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_clean_db_t(...)
 |      delete_pkt_clean_db_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class pkt_debugctl_t in module ida_lumina:

class pkt_debugctl_t(builtins.object)
 |  Proxy of C++ pkt_debugctl_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_debugctl_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_debugctl_t(...)
 |      delete_pkt_debugctl_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  args
 |      pkt_debugctl_t_args_get(self) -> qstrvec_t *
 |  
 |  thisown
 |      The membership flag

Help on class pkt_dump_md_result_t in module ida_lumina:

class pkt_dump_md_result_t(builtins.object)
 |  Proxy of C++ pkt_dump_md_result_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_dump_md_result_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_dump_md_result_t(...)
 |      delete_pkt_dump_md_result_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  contents
 |      pkt_dump_md_result_t_contents_get(self) -> func_info_pattern_and_frequency_vec_t
 |  
 |  thisown
 |      The membership flag

Help on class pkt_dump_md_t in module ida_lumina:

class pkt_dump_md_t(builtins.object)
 |  Proxy of C++ pkt_dump_md_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_dump_md_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_dump_md_t(...)
 |      delete_pkt_dump_md_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  sort
 |      pkt_dump_md_t_sort_get(self) -> dump_md_sort_type_t
 |  
 |  thisown
 |      The membership flag

Help on class pkt_get_pop_result_t in module ida_lumina:

class pkt_get_pop_result_t(builtins.object)
 |  Proxy of C++ pkt_get_pop_result_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_get_pop_result_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_get_pop_result_t(...)
 |      delete_pkt_get_pop_result_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  results
 |      pkt_get_pop_result_t_results_get(self) -> pop_fun_vec_t *
 |  
 |  thisown
 |      The membership flag

Help on class pkt_get_pop_t in module ida_lumina:

class pkt_get_pop_t(builtins.object)
 |  Proxy of C++ pkt_get_pop_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_get_pop_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_get_pop_t(...)
 |      delete_pkt_get_pop_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  nresults
 |      pkt_get_pop_t_nresults_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag

Help on class pkt_helo_t in module ida_lumina:

class pkt_helo_t(builtins.object)
 |  Proxy of C++ pkt_helo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_helo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_helo_t(...)
 |      delete_pkt_helo_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  client_version
 |      pkt_helo_t_client_version_get(self) -> int
 |  
 |  key
 |      pkt_helo_t_key_get(self) -> bytevec_t *
 |  
 |  license_id
 |      pkt_helo_t_license_id_get(self) -> uchar [6]
 |  
 |  record_conv
 |      pkt_helo_t_record_conv_get(self) -> bool
 |  
 |  thisown
 |      The membership flag

Help on class pkt_pull_md_result_t in module ida_lumina:

class pkt_pull_md_result_t(builtins.object)
 |  Proxy of C++ pkt_pull_md_result_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_pull_md_result_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_pull_md_result_t(...)
 |      delete_pkt_pull_md_result_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  codes
 |      pkt_pull_md_result_t_codes_get(self) -> lumina_op_res_vec_t
 |  
 |  results
 |      pkt_pull_md_result_t_results_get(self) -> func_info_and_frequency_vec_t
 |  
 |  thisown
 |      The membership flag

Help on class pkt_pull_md_t in module ida_lumina:

class pkt_pull_md_t(builtins.object)
 |  Proxy of C++ pkt_pull_md_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_pull_md_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_pull_md_t(...)
 |      delete_pkt_pull_md_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      pkt_pull_md_t_flags_get(self) -> uint32
 |  
 |  keys
 |      pkt_pull_md_t_keys_get(self) -> mdkey_vec_t *
 |  
 |  pattern_ids
 |      pkt_pull_md_t_pattern_ids_get(self) -> pattern_ids_t *
 |  
 |  thisown
 |      The membership flag

Help on class pkt_push_md_result_t in module ida_lumina:

class pkt_push_md_result_t(builtins.object)
 |  Proxy of C++ pkt_push_md_result_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_push_md_result_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_push_md_result_t(...)
 |      delete_pkt_push_md_result_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  codes
 |      pkt_push_md_result_t_codes_get(self) -> lumina_op_res_vec_t
 |  
 |  thisown
 |      The membership flag

Help on class pkt_push_md_t in module ida_lumina:

class pkt_push_md_t(builtins.object)
 |  Proxy of C++ pkt_push_md_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_push_md_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_push_md_t(...)
 |      delete_pkt_push_md_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  contents
 |      pkt_push_md_t_contents_get(self) -> func_info_and_pattern_vec_t
 |  
 |  ea64s
 |      pkt_push_md_t_ea64s_get(self) -> ea64vec_t *
 |  
 |  flags
 |      pkt_push_md_t_flags_get(self) -> uint32
 |  
 |  hostname
 |      pkt_push_md_t_hostname_get(self) -> qstring *
 |  
 |  idb
 |      pkt_push_md_t_idb_get(self) -> qstring *
 |  
 |  input
 |      pkt_push_md_t_input_get(self) -> input_file_t
 |  
 |  thisown
 |      The membership flag

Help on class pkt_rpc_fail_t in module ida_lumina:

class pkt_rpc_fail_t(builtins.object)
 |  Proxy of C++ pkt_rpc_fail_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_rpc_fail_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_rpc_fail_t(...)
 |      delete_pkt_rpc_fail_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  error
 |      pkt_rpc_fail_t_error_get(self) -> qstring *
 |  
 |  result
 |      pkt_rpc_fail_t_result_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on class pkt_rpc_notify_t in module ida_lumina:

class pkt_rpc_notify_t(builtins.object)
 |  Proxy of C++ pkt_rpc_notify_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_rpc_notify_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_rpc_notify_t(...)
 |      delete_pkt_rpc_notify_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  text
 |      pkt_rpc_notify_t_text_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      pkt_rpc_notify_t_type_get(self) -> rpc_notification_type_t

Help on class pkt_rpc_ok_t in module ida_lumina:

class pkt_rpc_ok_t(builtins.object)
 |  Proxy of C++ pkt_rpc_ok_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pkt_rpc_ok_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pkt_rpc_ok_t(...)
 |      delete_pkt_rpc_ok_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class pop_fun_t in module ida_lumina:

class pop_fun_t(func_info_pattern_and_frequency_t)
 |  Proxy of C++ pop_fun_t class.
 |  
 |  Method resolution order:
 |      pop_fun_t
 |      func_info_pattern_and_frequency_t
 |      func_info_and_pattern_t
 |      func_info_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pop_fun_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pop_fun_t(...)
 |      delete_pop_fun_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ea64
 |      pop_fun_t_ea64_get(self) -> ea64_t
 |  
 |  hostname
 |      pop_fun_t_hostname_get(self) -> qstring *
 |  
 |  input
 |      pop_fun_t_input_get(self) -> input_file_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from func_info_pattern_and_frequency_t:
 |  
 |  frequency
 |      func_info_pattern_and_frequency_t_frequency_get(self) -> uint32
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from func_info_and_pattern_t:
 |  
 |  pattern_id
 |      func_info_and_pattern_t_pattern_id_get(self) -> pattern_id_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from func_info_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  metadata
 |      func_info_t_metadata_get(self) -> metadata_t *
 |  
 |  name
 |      func_info_t_name_get(self) -> qstring *
 |  
 |  size
 |      func_info_t_size_get(self) -> uint32

Help on class push_md_opts_t in module ida_lumina:

class push_md_opts_t(builtins.object)
 |  Proxy of C++ push_md_opts_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, mfs=size_t(-1)) -> push_md_opts_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_push_md_opts_t(...)
 |      delete_push_md_opts_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  eas
 |      push_md_opts_t_eas_get(self) -> eavec_t *
 |  
 |  min_func_size
 |      push_md_opts_t_min_func_size_get(self) -> size_t
 |  
 |  thisown
 |      The membership flag

Help on class push_md_result_t in module ida_lumina:

class push_md_result_t(builtins.object)
 |  Proxy of C++ push_md_result_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> push_md_result_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_push_md_result_t(...)
 |      delete_push_md_result_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  codes
 |      push_md_result_t_codes_get(self) -> lumina_op_res_vec_t
 |  
 |  contents
 |      push_md_result_t_contents_get(self) -> func_info_and_pattern_vec_t
 |  
 |  eas
 |      push_md_result_t_eas_get(self) -> eavec_t *
 |  
 |  thisown
 |      The membership flag

Help on function revert_metadata in module ida_lumina:

revert_metadata(*args) -> 'bool'
    revert_metadata(ea) -> bool

Help on function score_metadata in module ida_lumina:

score_metadata(*args) -> 'uint32'
    score_metadata(fi) -> uint32

Help on class serialized_tinfo in module ida_lumina:

class serialized_tinfo(builtins.object)
 |  Proxy of C++ serialized_tinfo class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> serialized_tinfo
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_serialized_tinfo(...)
 |      delete_serialized_tinfo(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fields
 |      serialized_tinfo_fields_get(self) -> qtype *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      serialized_tinfo_type_get(self) -> qtype *

Help on class simple_diff_handler_t in module ida_lumina:

class simple_diff_handler_t(func_md_diff_handler_t)
 |  Proxy of C++ simple_diff_handler_t class.
 |  
 |  Method resolution order:
 |      simple_diff_handler_t
 |      func_md_diff_handler_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      __init__(self) -> func_md_diff_handler_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_simple_diff_handler_t(...)
 |      delete_simple_diff_handler_t(self)
 |  
 |  on_comment_changed(self, *args) -> 'void'
 |      on_comment_changed(self, fchunk_nr, fchunk_off, l, r, rep)
 |  
 |  on_extra_comment_changed(self, *args) -> 'void'
 |      on_extra_comment_changed(self, fchunk_nr, fchunk_off, l, r, is_prev)
 |  
 |  on_frame_member_changed(self, *args) -> 'void'
 |      on_frame_member_changed(self, offset, l, r)
 |  
 |  on_function_comment_changed(self, *args) -> 'void'
 |      on_function_comment_changed(self, l, r, rep)
 |  
 |  on_insn_ops_repr_changed(self, *args) -> 'void'
 |      on_insn_ops_repr_changed(self, fchunk_nr, fchunk_off, l, r)
 |  
 |  on_name_changed(self, *args) -> 'void'
 |      on_name_changed(self, l, r)
 |  
 |  on_proto_changed(self, *args) -> 'void'
 |      on_proto_changed(self, l, r)
 |  
 |  on_score_changed(self, *args) -> 'void'
 |      on_score_changed(self, l, r)
 |  
 |  on_user_stkpnt_changed(self, *args) -> 'void'
 |      on_user_stkpnt_changed(self, fchunk_nr, fchunk_off, l, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  indent
 |      simple_diff_handler_t_indent_get(self) -> uint32
 |  
 |  lines
 |      simple_diff_handler_t_lines_get(self) -> qstrvec_t *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from func_md_diff_handler_t:
 |  
 |  __disown__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from func_md_diff_handler_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class simple_idb_diff_handler_t in module ida_lumina:

class simple_idb_diff_handler_t(simple_diff_handler_t)
 |  Proxy of C++ simple_idb_diff_handler_t class.
 |  
 |  Method resolution order:
 |      simple_idb_diff_handler_t
 |      simple_diff_handler_t
 |      func_md_diff_handler_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      __init__(self) -> func_md_diff_handler_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_simple_idb_diff_handler_t(...)
 |      delete_simple_idb_diff_handler_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  header_generated
 |      simple_idb_diff_handler_t_header_generated_get(self) -> bool
 |  
 |  pfn
 |      simple_idb_diff_handler_t_pfn_get(self) -> func_t const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from simple_diff_handler_t:
 |  
 |  on_comment_changed(self, *args) -> 'void'
 |      on_comment_changed(self, fchunk_nr, fchunk_off, l, r, rep)
 |  
 |  on_extra_comment_changed(self, *args) -> 'void'
 |      on_extra_comment_changed(self, fchunk_nr, fchunk_off, l, r, is_prev)
 |  
 |  on_frame_member_changed(self, *args) -> 'void'
 |      on_frame_member_changed(self, offset, l, r)
 |  
 |  on_function_comment_changed(self, *args) -> 'void'
 |      on_function_comment_changed(self, l, r, rep)
 |  
 |  on_insn_ops_repr_changed(self, *args) -> 'void'
 |      on_insn_ops_repr_changed(self, fchunk_nr, fchunk_off, l, r)
 |  
 |  on_name_changed(self, *args) -> 'void'
 |      on_name_changed(self, l, r)
 |  
 |  on_proto_changed(self, *args) -> 'void'
 |      on_proto_changed(self, l, r)
 |  
 |  on_score_changed(self, *args) -> 'void'
 |      on_score_changed(self, l, r)
 |  
 |  on_user_stkpnt_changed(self, *args) -> 'void'
 |      on_user_stkpnt_changed(self, fchunk_nr, fchunk_off, l, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from simple_diff_handler_t:
 |  
 |  indent
 |      simple_diff_handler_t_indent_get(self) -> uint32
 |  
 |  lines
 |      simple_diff_handler_t_lines_get(self) -> qstrvec_t *
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from func_md_diff_handler_t:
 |  
 |  __disown__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from func_md_diff_handler_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class skipped_func_t in module ida_lumina:

class skipped_func_t(builtins.object)
 |  Proxy of C++ skipped_func_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> skipped_func_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_skipped_func_t(...)
 |      delete_skipped_func_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      skipped_func_t_count_get(self) -> uint32
 |  
 |  pattern_id
 |      skipped_func_t_pattern_id_get(self) -> pattern_id_t
 |  
 |  thisown
 |      The membership flag

Help on class skipped_funcs_t in module ida_lumina:

class skipped_funcs_t(builtins.object)
 |  Proxy of C++ qvector< skipped_func_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'skipped_func_t const &'
 |      __getitem__(self, i) -> skipped_func_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> skipped_funcs_t
 |      __init__(self, x) -> skipped_funcs_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_skipped_funcs_t(...)
 |      delete_skipped_funcs_t(self)
 |  
 |  at(self, *args) -> 'skipped_func_t const &'
 |      at(self, _idx) -> skipped_func_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< skipped_func_t >::const_iterator'
 |      begin(self) -> skipped_func_t
 |      begin(self) -> skipped_func_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< skipped_func_t >::const_iterator'
 |      end(self) -> skipped_func_t
 |      end(self) -> skipped_func_t
 |  
 |  erase(self, *args) -> 'qvector< skipped_func_t >::iterator'
 |      erase(self, it) -> skipped_func_t
 |      erase(self, first, last) -> skipped_func_t
 |  
 |  extract(self, *args) -> 'skipped_func_t *'
 |      extract(self) -> skipped_func_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=skipped_func_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< skipped_func_t >::iterator'
 |      insert(self, it, x) -> skipped_func_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'skipped_func_t &'
 |      push_back(self, x)
 |      push_back(self) -> skipped_func_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function split_metadata in module ida_lumina:

split_metadata(*args) -> 'PyObject *'
    split_metadata(md) -> PyObject *

Help on class user_identification_t in module ida_lumina:

class user_identification_t(builtins.object)
 |  Proxy of C++ user_identification_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_identification_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_identification_t(...)
 |      delete_user_identification_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  email
 |      user_identification_t_email_get(self) -> qstring *
 |  
 |  license_id
 |      user_identification_t_license_id_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  user_name
 |      user_identification_t_user_name_get(self) -> qstring *

Help on class user_stkpnt_t in module ida_lumina:

class user_stkpnt_t(insn_site_t)
 |  Proxy of C++ user_stkpnt_t class.
 |  
 |  Method resolution order:
 |      user_stkpnt_t
 |      insn_site_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_stkpnt_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_stkpnt_t(...)
 |      delete_user_stkpnt_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  delta
 |      user_stkpnt_t_delta_get(self) -> int64
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from insn_site_t:
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self, pfn) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from insn_site_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fchunk_nr
 |      insn_site_t_fchunk_nr_get(self) -> uint32
 |  
 |  fchunk_off
 |      insn_site_t_fchunk_off_get(self) -> uint32

Help on class user_stkpnts_t in module ida_lumina:

class user_stkpnts_t(builtins.object)
 |  Proxy of C++ qvector< user_stkpnt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'user_stkpnt_t const &'
 |      __getitem__(self, i) -> user_stkpnt_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_stkpnts_t
 |      __init__(self, x) -> user_stkpnts_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_user_stkpnts_t(...)
 |      delete_user_stkpnts_t(self)
 |  
 |  at(self, *args) -> 'user_stkpnt_t const &'
 |      at(self, _idx) -> user_stkpnt_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< user_stkpnt_t >::const_iterator'
 |      begin(self) -> user_stkpnt_t
 |      begin(self) -> user_stkpnt_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< user_stkpnt_t >::const_iterator'
 |      end(self) -> user_stkpnt_t
 |      end(self) -> user_stkpnt_t
 |  
 |  erase(self, *args) -> 'qvector< user_stkpnt_t >::iterator'
 |      erase(self, it) -> user_stkpnt_t
 |      erase(self, first, last) -> user_stkpnt_t
 |  
 |  extract(self, *args) -> 'user_stkpnt_t *'
 |      extract(self) -> user_stkpnt_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=user_stkpnt_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< user_stkpnt_t >::iterator'
 |      insert(self, it, x) -> user_stkpnt_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'user_stkpnt_t &'
 |      push_back(self, x)
 |      push_back(self) -> user_stkpnt_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

=== ida_lumina EPYDOC INJECTIONS ===
ida_lumina.AMDF_FORCE
"""
apply kvps regardless of what's currently in the IDB, possibly
removing some attributes currently present (e.g., name, or prototype
could be lost)
"""

ida_lumina.AMDF_UPGRADE
"""
"quality" than what's currently in the IDB

apply kvps that seem to be of higher
"""

ida_lumina.PMF_PUSH_MODE_MASK
"""
Conflict resolution mode.
"""
=== ida_lumina EPYDOC INJECTIONS END ===
Help on class bookmarks_t in module ida_moves:

class bookmarks_t(builtins.object)
 |  Proxy of C++ bookmarks_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  erase(*args) -> 'bool'
 |      erase(e, index, ud) -> bool
 |  
 |  find_index(*args) -> 'uint32'
 |      find_index(e, ud) -> uint32
 |  
 |  get(*args) -> 'bool'
 |      get(out_entry, out_desc, index, ud) -> bool
 |  
 |  get_desc(*args) -> 'qstring *'
 |      get_desc(e, index, ud) -> bool
 |  
 |  mark(*args) -> 'uint32'
 |      mark(e, index, title, desc, ud) -> uint32
 |  
 |  size(*args) -> 'uint32'
 |      size(e, ud) -> uint32
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function bookmarks_t_erase in module ida_moves:

bookmarks_t_erase(*args) -> 'bool'
    bookmarks_t_erase(e, index, ud) -> bool

Help on function bookmarks_t_find_index in module ida_moves:

bookmarks_t_find_index(*args) -> 'uint32'
    bookmarks_t_find_index(e, ud) -> uint32

Help on function bookmarks_t_get in module ida_moves:

bookmarks_t_get(*args) -> 'bool'
    bookmarks_t_get(out_entry, out_desc, index, ud) -> bool

Help on function bookmarks_t_get_desc in module ida_moves:

bookmarks_t_get_desc(*args) -> 'qstring *'
    bookmarks_t_get_desc(e, index, ud) -> str

Help on function bookmarks_t_mark in module ida_moves:

bookmarks_t_mark(*args) -> 'uint32'
    bookmarks_t_mark(e, index, title, desc, ud) -> uint32

Help on function bookmarks_t_size in module ida_moves:

bookmarks_t_size(*args) -> 'uint32'
    bookmarks_t_size(e, ud) -> uint32

Help on class graph_location_info_t in module ida_moves:

class graph_location_info_t(builtins.object)
 |  Proxy of C++ graph_location_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_location_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_location_info_t(...)
 |      delete_graph_location_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  orgx
 |      graph_location_info_t_orgx_get(self) -> double
 |  
 |  orgy
 |      graph_location_info_t_orgy_get(self) -> double
 |  
 |  thisown
 |      The membership flag
 |  
 |  zoom
 |      graph_location_info_t_zoom_get(self) -> double
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class lochist_entry_t in module ida_moves:

class lochist_entry_t(builtins.object)
 |  Proxy of C++ lochist_entry_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lochist_entry_t
 |      __init__(self, p, r) -> lochist_entry_t
 |      __init__(self, other) -> lochist_entry_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lochist_entry_t(...)
 |      delete_lochist_entry_t(self)
 |  
 |  acquire_place(self, *args) -> 'void'
 |      acquire_place(self, in_p)
 |  
 |  is_valid(self, *args) -> 'bool'
 |      is_valid(self) -> bool
 |  
 |  place(self, *args) -> 'place_t *'
 |      place(self) -> place_t
 |      place(self) -> place_t
 |  
 |  renderer_info(self, *args) -> 'renderer_info_t &'
 |      renderer_info(self) -> renderer_info_t
 |      renderer_info(self) -> renderer_info_t
 |  
 |  set_place(self, *args) -> 'void'
 |      set_place(self, p)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  plce
 |      lochist_entry_t_plce_get(self) -> place_t
 |  
 |  rinfo
 |      lochist_entry_t_rinfo_get(self) -> renderer_info_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class lochist_t in module ida_moves:

class lochist_t(builtins.object)
 |  Proxy of C++ lochist_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lochist_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lochist_t(...)
 |      delete_lochist_t(self)
 |  
 |  back(self, *args) -> 'bool'
 |      back(self, cnt, try_to_unhide) -> bool
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  current_index(self, *args) -> 'uint32'
 |      current_index(self) -> uint32
 |  
 |  fwd(self, *args) -> 'bool'
 |      fwd(self, cnt, try_to_unhide) -> bool
 |  
 |  get(self, *args) -> 'bool'
 |      get(self, out, index) -> bool
 |  
 |  get_current(self, *args) -> 'lochist_entry_t const &'
 |      get_current(self) -> lochist_entry_t
 |  
 |  get_place_id(self, *args) -> 'int'
 |      get_place_id(self) -> int
 |  
 |  get_template_place(self, *args) -> 'place_t const *'
 |      get_template_place(self) -> place_t
 |  
 |  init(self, *args) -> 'bool'
 |      init(self, stream_name, _defpos, _ud, _flags) -> bool
 |  
 |  is_history_enabled(self, *args) -> 'bool'
 |      is_history_enabled(self) -> bool
 |  
 |  jump(self, *args) -> 'void'
 |      jump(self, try_to_unhide, e)
 |  
 |  netcode(self, *args) -> 'nodeidx_t'
 |      netcode(self) -> nodeidx_t
 |  
 |  save(self, *args) -> 'void'
 |      save(self)
 |  
 |  seek(self, *args) -> 'bool'
 |      seek(self, index, try_to_unhide) -> bool
 |  
 |  set(self, *args) -> 'void'
 |      set(self, index, e)
 |  
 |  set_current(self, *args) -> 'void'
 |      set_current(self, e)
 |  
 |  size(self, *args) -> 'uint32'
 |      size(self) -> uint32
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class renderer_info_pos_t in module ida_moves:

class renderer_info_pos_t(builtins.object)
 |  Proxy of C++ renderer_info_pos_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> renderer_info_pos_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_renderer_info_pos_t(...)
 |      delete_renderer_info_pos_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cx
 |      renderer_info_pos_t_cx_get(self) -> short
 |  
 |  cy
 |      renderer_info_pos_t_cy_get(self) -> short
 |  
 |  node
 |      renderer_info_pos_t_node_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class renderer_info_t in module ida_moves:

class renderer_info_t(builtins.object)
 |  Proxy of C++ renderer_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> renderer_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_renderer_info_t(...)
 |      delete_renderer_info_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  gli
 |      renderer_info_t_gli_get(self) -> graph_location_info_t
 |  
 |  pos
 |      renderer_info_t_pos_get(self) -> renderer_info_pos_t
 |  
 |  rtype
 |      renderer_info_t_rtype_get(self) -> tcc_renderer_type_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class segm_move_info_t in module ida_moves:

class segm_move_info_t(builtins.object)
 |  Proxy of C++ segm_move_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, _from=0, _to=0, _sz=0) -> segm_move_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_segm_move_info_t(...)
 |      delete_segm_move_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  _from
 |      segm_move_info_t__from_get(self) -> ea_t
 |  
 |  size
 |      segm_move_info_t_size_get(self) -> size_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  to
 |      segm_move_info_t_to_get(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class segm_move_info_vec_t in module ida_moves:

class segm_move_info_vec_t(builtins.object)
 |  Proxy of C++ qvector< segm_move_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'segm_move_info_t const &'
 |      __getitem__(self, i) -> segm_move_info_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> segm_move_info_vec_t
 |      __init__(self, x) -> segm_move_info_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_segm_move_info_vec_t(...)
 |      delete_segm_move_info_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'segm_move_info_t const &'
 |      at(self, _idx) -> segm_move_info_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< segm_move_info_t >::const_iterator'
 |      begin(self) -> segm_move_info_t
 |      begin(self) -> segm_move_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< segm_move_info_t >::const_iterator'
 |      end(self) -> segm_move_info_t
 |      end(self) -> segm_move_info_t
 |  
 |  erase(self, *args) -> 'qvector< segm_move_info_t >::iterator'
 |      erase(self, it) -> segm_move_info_t
 |      erase(self, first, last) -> segm_move_info_t
 |  
 |  extract(self, *args) -> 'segm_move_info_t *'
 |      extract(self) -> segm_move_info_t
 |  
 |  find(self, *args) -> 'qvector< segm_move_info_t >::const_iterator'
 |      find(self, x) -> segm_move_info_t
 |      find(self, x) -> segm_move_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=segm_move_info_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< segm_move_info_t >::iterator'
 |      insert(self, it, x) -> segm_move_info_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'segm_move_info_t &'
 |      push_back(self, x)
 |      push_back(self) -> segm_move_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class segm_move_infos_t in module ida_moves:

class segm_move_infos_t(segm_move_info_vec_t)
 |  Proxy of C++ segm_move_infos_t class.
 |  
 |  Method resolution order:
 |      segm_move_infos_t
 |      segm_move_info_vec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> segm_move_infos_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_segm_move_infos_t(...)
 |      delete_segm_move_infos_t(self)
 |  
 |  find(self, *args) -> 'segm_move_info_t const *'
 |      find(self, ea) -> segm_move_info_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from segm_move_info_vec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'segm_move_info_t const &'
 |      __getitem__(self, i) -> segm_move_info_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'segm_move_info_t const &'
 |      at(self, _idx) -> segm_move_info_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< segm_move_info_t >::const_iterator'
 |      begin(self) -> segm_move_info_t
 |      begin(self) -> segm_move_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< segm_move_info_t >::const_iterator'
 |      end(self) -> segm_move_info_t
 |      end(self) -> segm_move_info_t
 |  
 |  erase(self, *args) -> 'qvector< segm_move_info_t >::iterator'
 |      erase(self, it) -> segm_move_info_t
 |      erase(self, first, last) -> segm_move_info_t
 |  
 |  extract(self, *args) -> 'segm_move_info_t *'
 |      extract(self) -> segm_move_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=segm_move_info_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< segm_move_info_t >::iterator'
 |      insert(self, it, x) -> segm_move_info_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'segm_move_info_t &'
 |      push_back(self, x)
 |      push_back(self) -> segm_move_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from segm_move_info_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from segm_move_info_vec_t:
 |  
 |  __hash__ = None

Help on function get_switch_info in module ida_nalt:

get_switch_info(*args) -> 'ssize_t'
    get_switch_info(out, ea) -> ssize_t

Help on function add_encoding in module ida_nalt:

add_encoding(*args) -> 'int'
    add_encoding(encoding) -> int
    
    
    Add a new encoding (e.g. "UTF-8").
    
    @param encoding (C++: const char *)
    @return: its index (1-based) if it's already in the list, return its
             index

Help on class array_parameters_t in module ida_nalt:

class array_parameters_t(builtins.object)
 |  Proxy of C++ array_parameters_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_parameters_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_array_parameters_t(...)
 |      delete_array_parameters_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  alignment
 |      array_parameters_t_alignment_get(self) -> int32
 |  
 |  flags
 |      array_parameters_t_flags_get(self) -> int32
 |  
 |  lineitems
 |      array_parameters_t_lineitems_get(self) -> int32
 |  
 |  thisown
 |      The membership flag

Help on function clr__bnot0 in module ida_nalt:

clr__bnot0(*args) -> 'void'
    clr__bnot0(ea)

Help on function clr__bnot1 in module ida_nalt:

clr__bnot1(*args) -> 'void'
    clr__bnot1(ea)

Help on function clr__invsign0 in module ida_nalt:

clr__invsign0(*args) -> 'void'
    clr__invsign0(ea)

Help on function clr__invsign1 in module ida_nalt:

clr__invsign1(*args) -> 'void'
    clr__invsign1(ea)

Help on function clr_abits in module ida_nalt:

clr_abits(*args) -> 'void'
    clr_abits(ea, bits)

Help on function clr_align_flow in module ida_nalt:

clr_align_flow(*args) -> 'void'
    clr_align_flow(ea)

Help on function clr_colored_item in module ida_nalt:

clr_colored_item(*args) -> 'void'
    clr_colored_item(ea)

Help on function clr_fixed_spd in module ida_nalt:

clr_fixed_spd(*args) -> 'void'
    clr_fixed_spd(ea)

Help on function clr_has_lname in module ida_nalt:

clr_has_lname(*args) -> 'void'
    clr_has_lname(ea)

Help on function clr_has_ti in module ida_nalt:

clr_has_ti(*args) -> 'void'
    clr_has_ti(ea)

Help on function clr_has_ti0 in module ida_nalt:

clr_has_ti0(*args) -> 'void'
    clr_has_ti0(ea)

Help on function clr_has_ti1 in module ida_nalt:

clr_has_ti1(*args) -> 'void'
    clr_has_ti1(ea)

Help on function clr_libitem in module ida_nalt:

clr_libitem(*args) -> 'void'
    clr_libitem(ea)

Help on function clr_lzero0 in module ida_nalt:

clr_lzero0(*args) -> 'void'
    clr_lzero0(ea)

Help on function clr_lzero1 in module ida_nalt:

clr_lzero1(*args) -> 'void'
    clr_lzero1(ea)

Help on function clr_noret in module ida_nalt:

clr_noret(*args) -> 'void'
    clr_noret(ea)

Help on function clr_notcode in module ida_nalt:

clr_notcode(*args) -> 'void'
    clr_notcode(ea)
    
    
    Clear not-code mark.
    
    
    @param ea (C++: ea_t)

Help on function clr_notproc in module ida_nalt:

clr_notproc(*args) -> 'void'
    clr_notproc(ea)

Help on function clr_retfp in module ida_nalt:

clr_retfp(*args) -> 'void'
    clr_retfp(ea)

Help on function clr_terse_struc in module ida_nalt:

clr_terse_struc(*args) -> 'void'
    clr_terse_struc(ea)

Help on function clr_tilcmt in module ida_nalt:

clr_tilcmt(*args) -> 'void'
    clr_tilcmt(ea)

Help on function clr_usemodsp in module ida_nalt:

clr_usemodsp(*args) -> 'void'
    clr_usemodsp(ea)

Help on function clr_usersp in module ida_nalt:

clr_usersp(*args) -> 'void'
    clr_usersp(ea)

Help on function clr_userti in module ida_nalt:

clr_userti(*args) -> 'void'
    clr_userti(ea)

Help on function clr_zstroff in module ida_nalt:

clr_zstroff(*args) -> 'void'
    clr_zstroff(ea)

Help on class custom_data_type_ids_fids_array in module ida_nalt:

class custom_data_type_ids_fids_array(builtins.object)
 |  Proxy of C++ wrapped_array_t< int16,8 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'short const &'
 |      __getitem__(self, i) -> short const &
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> custom_data_type_ids_fids_array
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_custom_data_type_ids_fids_array(...)
 |      delete_custom_data_type_ids_fids_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  data
 |      custom_data_type_ids_fids_array_data_get(self) -> short (&)[8]
 |  
 |  thisown
 |      The membership flag

Help on class custom_data_type_ids_t in module ida_nalt:

class custom_data_type_ids_t(builtins.object)
 |  Proxy of C++ custom_data_type_ids_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> custom_data_type_ids_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_custom_data_type_ids_t(...)
 |      delete_custom_data_type_ids_t(self)
 |  
 |  _custom_data_type_ids_t__getFids = __getFids(self, *args) -> 'wrapped_array_t< int16,8 >'
 |      __getFids(self) -> custom_data_type_ids_fids_array
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dtid
 |      custom_data_type_ids_t_dtid_get(self) -> int16
 |  
 |  fids
 |      __getFids(self) -> custom_data_type_ids_fids_array
 |  
 |  thisown
 |      The membership flag

Help on function dbg_get_input_path in module ida_nalt:

dbg_get_input_path(*args) -> 'size_t'
    dbg_get_input_path() -> str
    
    
    Get debugger input file name/path (see 'LFLG_DBG_NOPATH' )

Help on function del_absbase in module ida_nalt:

del_absbase(*args) -> 'void'
    del_absbase(ea)

Help on function del_aflags in module ida_nalt:

del_aflags(*args) -> 'void'
    del_aflags(ea)

Help on function del_alignment in module ida_nalt:

del_alignment(*args) -> 'void'
    del_alignment(ea)

Help on function del_array_parameters in module ida_nalt:

del_array_parameters(*args) -> 'void'
    del_array_parameters(ea)

Help on function del_custom_data_type_ids in module ida_nalt:

del_custom_data_type_ids(*args) -> 'void'
    del_custom_data_type_ids(ea)

Help on function del_encoding in module ida_nalt:

del_encoding(*args) -> 'bool'
    del_encoding(idx) -> bool
    
    
    Delete an encoding (1-based)
    
    
    @param idx (C++: int)

Help on function del_ind_purged in module ida_nalt:

del_ind_purged(*args) -> 'void'
    del_ind_purged(ea)

Help on function del_item_color in module ida_nalt:

del_item_color(*args) -> 'bool'
    del_item_color(ea) -> bool

Help on function del_op_tinfo in module ida_nalt:

del_op_tinfo(*args) -> 'void'
    del_op_tinfo(ea, n)

Help on function del_refinfo in module ida_nalt:

del_refinfo(*args) -> 'bool'
    del_refinfo(ea, n) -> bool

Help on function del_source_linnum in module ida_nalt:

del_source_linnum(*args) -> 'void'
    del_source_linnum(ea)

Help on function del_str_type in module ida_nalt:

del_str_type(*args) -> 'void'
    del_str_type(ea)

Help on function del_switch_info in module ida_nalt:

del_switch_info(*args) -> 'void'
    del_switch_info(ea)

Help on function del_switch_parent in module ida_nalt:

del_switch_parent(*args) -> 'void'
    del_switch_parent(ea)

Help on function del_tinfo in module ida_nalt:

del_tinfo(*args) -> 'void'
    del_tinfo(ea)

Help on function delete_imports in module ida_nalt:

delete_imports(*args) -> 'void'
    delete_imports()
    
    
    Delete all imported modules information.

Help on function ea2node in module ida_nalt:

ea2node(*args) -> 'nodeidx_t'
    ea2node(ea) -> nodeidx_t
    
    
    Get netnode for the specified address.
    
    
    @param ea (C++: ea_t)

Help on function encoding_from_strtype in module ida_nalt:

encoding_from_strtype(*args) -> 'char const *'
    encoding_from_strtype(strtype) -> char const *
    
    
    Get encoding name for this strtype.
    
    
    @param strtype (C++: int32)

Help on class enum_const_t in module ida_nalt:

class enum_const_t(builtins.object)
 |  Proxy of C++ enum_const_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_const_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_enum_const_t(...)
 |      delete_enum_const_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  serial
 |      enum_const_t_serial_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      enum_const_t_tid_get(self) -> tid_t

Help on function enum_import_names in module ida_nalt:

enum_import_names(*args) -> 'int'
    enum_import_names(mod_index, py_cb) -> int
    
    
    Enumerate imports from a specific module.
    Please refer to ex_imports.py example.
    
    @param mod_index: The module index
    @param callback: A callable object that will be invoked with an ea, name (could be None) and ordinal.
    @return: 1-finished ok, -1 on error, otherwise callback return value (<=0)

Help on function find_custom_refinfo in module ida_nalt:

find_custom_refinfo(*args) -> 'int'
    find_custom_refinfo(name) -> int
    
    
    Get id of a custom refinfo type.
    
    
    @param name (C++: const char *)

Help on function get_abi_name in module ida_nalt:

get_abi_name(*args)

Help on function get_absbase in module ida_nalt:

get_absbase(*args) -> 'ea_t'
    get_absbase(ea) -> ea_t

Help on function get_aflags in module ida_nalt:

get_aflags(*args) -> 'uint32'
    get_aflags(ea) -> uint32

Help on function get_alignment in module ida_nalt:

get_alignment(*args) -> 'uint32'
    get_alignment(ea) -> uint32

Help on function get_archive_path in module ida_nalt:

get_archive_path(*args) -> 'qstring *'
    get_archive_path() -> str
    
    
    Get archive file path from which input file was extracted.

Help on function get_array_parameters in module ida_nalt:

get_array_parameters(*args) -> 'ssize_t'
    get_array_parameters(out, ea) -> ssize_t

Help on function get_asm_inc_file in module ida_nalt:

get_asm_inc_file(*args) -> 'qstring *'
    get_asm_inc_file() -> str
    
    
    Get name of the include file.

Help on function get_custom_data_type_ids in module ida_nalt:

get_custom_data_type_ids(*args) -> 'int'
    get_custom_data_type_ids(cdis, ea) -> int

Help on function get_custom_refinfo in module ida_nalt:

get_custom_refinfo(*args) -> 'custom_refinfo_handler_t const *'
    get_custom_refinfo(crid) -> custom_refinfo_handler_t const *
    
    
    Get definition of a registered custom refinfo type.
    
    
    @param crid (C++: int)

Help on function get_default_encoding_idx in module ida_nalt:

get_default_encoding_idx(*args) -> 'int'
    get_default_encoding_idx(bpu) -> int
    
    
    Get default encoding index for a specific string type.
    
    @param bpu: the amount of bytes per unit (e.g., 1 for ASCII, CP1252,
                UTF-8..., 2 for UTF-16, 4 for UTF-32) 0 means no specific
                encoding is set - byte values are displayed without
                conversion. (C++: int)

Help on function get_encoding_bpu in module ida_nalt:

get_encoding_bpu(*args) -> 'int'
    get_encoding_bpu(idx) -> int
    
    
    Get the amount of bytes per unit (e.g., 2 for UTF-16, 4 for UTF-32)
    for the encoding with the given index.
    
    @param idx: the encoding index (C++: int)
    @return: the number of bytes per units (1/2/4); -1 means error

Help on function get_encoding_name in module ida_nalt:

get_encoding_name(*args) -> 'char const *'
    get_encoding_name(idx) -> char const *
    
    
    Get encoding name for specific index (1-based).
    
    @param idx (C++: int)
    @return: NULL if idx is out of bounds

Help on function get_encoding_qty in module ida_nalt:

get_encoding_qty(*args) -> 'int'
    get_encoding_qty() -> int
    
    
    Get total number of encodings (counted from 0)

Help on function get_gotea in module ida_nalt:

get_gotea(*args) -> 'ea_t'
    get_gotea() -> ea_t

Help on function get_ids_modnode in module ida_nalt:

get_ids_modnode(*args) -> 'netnode'
    get_ids_modnode() -> netnode
    
    
    Get ids modnode.

Help on function get_imagebase in module ida_nalt:

get_imagebase(*args) -> 'ea_t'
    get_imagebase() -> ea_t
    
    
    Get image base address.

Help on function get_import_module_name in module ida_nalt:

get_import_module_name(*args) -> 'PyObject *'
    get_import_module_name(mod_index) -> PyObject *
    
    
    Returns the name of an imported module given its index
    @return: None or the module name

Help on function get_import_module_qty in module ida_nalt:

get_import_module_qty(*args) -> 'uint'
    get_import_module_qty() -> uint
    
    
    Get number of import modules.

Help on function get_ind_purged in module ida_nalt:

get_ind_purged(*args) -> 'ea_t'
    get_ind_purged(ea) -> ea_t

Help on function get_input_file_path in module ida_nalt:

get_input_file_path(*args) -> 'size_t'
    get_input_file_path() -> str
    
    
    Get full path of the input file.

Help on function get_item_color in module ida_nalt:

get_item_color(*args) -> 'bgcolor_t'
    get_item_color(ea) -> bgcolor_t

Help on function get_op_tinfo in module ida_nalt:

get_op_tinfo(*args) -> 'bool'
    get_op_tinfo(tif, ea, n) -> bool

Help on function get_outfile_encoding_idx in module ida_nalt:

get_outfile_encoding_idx(*args) -> 'int'
    get_outfile_encoding_idx() -> int
    
    
    Get the index of the encoding used when producing files 0 means no
    that the IDB's default 1 byte-per-unit encoding is used

Help on function get_refinfo in module ida_nalt:

get_refinfo(*args) -> 'bool'
    get_refinfo(ri, ea, n) -> bool

Help on function get_reftype_by_size in module ida_nalt:

get_reftype_by_size(*args) -> 'reftype_t'
    get_reftype_by_size(size) -> reftype_t
    
    
    Get REF_... constant from size Supported sizes: 1,2,4,8,16 For other
    sizes returns reftype_t(-1)
    
    @param size (C++: size_t)

Help on function get_root_filename in module ida_nalt:

get_root_filename(*args) -> 'size_t'
    get_root_filename() -> str
    
    
    Get file name only of the input file.

Help on function get_source_linnum in module ida_nalt:

get_source_linnum(*args) -> 'uval_t'
    get_source_linnum(ea) -> uval_t

Help on function get_str_encoding_idx in module ida_nalt:

get_str_encoding_idx(*args) -> 'uchar'
    get_str_encoding_idx(strtype) -> uchar
    
    
    Get index of the string encoding for this string.
    
    
    @param strtype (C++: int32)

Help on function get_str_term1 in module ida_nalt:

get_str_term1(*args) -> 'char'
    get_str_term1(strtype) -> char

Help on function get_str_term2 in module ida_nalt:

get_str_term2(*args) -> 'char'
    get_str_term2(strtype) -> char

Help on function get_str_type in module ida_nalt:

get_str_type(*args) -> 'uint32'
    get_str_type(ea) -> uint32

Help on function get_str_type_code in module ida_nalt:

get_str_type_code(*args) -> 'uchar'
    get_str_type_code(strtype) -> uchar

Help on function get_strtype_bpu in module ida_nalt:

get_strtype_bpu(*args) -> 'int'
    get_strtype_bpu(strtype) -> int

Help on function get_switch_info in module ida_nalt:

get_switch_info(*args)

Help on function get_switch_parent in module ida_nalt:

get_switch_parent(*args) -> 'ea_t'
    get_switch_parent(ea) -> ea_t

Help on function get_tinfo in module ida_nalt:

get_tinfo(*args) -> 'bool'
    get_tinfo(tif, ea) -> bool

Help on function getnode in module ida_nalt:

getnode(*args) -> 'netnode'
    getnode(ea) -> netnode

Help on function has_lname in module ida_nalt:

has_lname(*args) -> 'bool'
    has_lname(ea) -> bool

Help on function has_ti in module ida_nalt:

has_ti(*args) -> 'bool'
    has_ti(ea) -> bool

Help on function has_ti0 in module ida_nalt:

has_ti0(*args) -> 'bool'
    has_ti0(ea) -> bool

Help on function has_ti1 in module ida_nalt:

has_ti1(*args) -> 'bool'
    has_ti1(ea) -> bool

Help on function hide_border in module ida_nalt:

hide_border(*args) -> 'void'
    hide_border(ea)

Help on function hide_item in module ida_nalt:

hide_item(*args) -> 'void'
    hide_item(ea)

Help on function is__bnot0 in module ida_nalt:

is__bnot0(*args) -> 'bool'
    is__bnot0(ea) -> bool

Help on function is__bnot1 in module ida_nalt:

is__bnot1(*args) -> 'bool'
    is__bnot1(ea) -> bool

Help on function is__invsign0 in module ida_nalt:

is__invsign0(*args) -> 'bool'
    is__invsign0(ea) -> bool

Help on function is__invsign1 in module ida_nalt:

is__invsign1(*args) -> 'bool'
    is__invsign1(ea) -> bool

Help on function is_align_flow in module ida_nalt:

is_align_flow(*args) -> 'bool'
    is_align_flow(ea) -> bool

Help on function is_colored_item in module ida_nalt:

is_colored_item(*args) -> 'bool'
    is_colored_item(ea) -> bool

Help on function is_finally_visible_item in module ida_nalt:

is_finally_visible_item(*args) -> 'bool'
    is_finally_visible_item(ea) -> bool
    
    
    Is instruction visible?
    
    
    @param ea (C++: ea_t)

Help on function is_fixed_spd in module ida_nalt:

is_fixed_spd(*args) -> 'bool'
    is_fixed_spd(ea) -> bool

Help on function is_hidden_border in module ida_nalt:

is_hidden_border(*args) -> 'bool'
    is_hidden_border(ea) -> bool

Help on function is_hidden_item in module ida_nalt:

is_hidden_item(*args) -> 'bool'
    is_hidden_item(ea) -> bool

Help on function is_libitem in module ida_nalt:

is_libitem(*args) -> 'bool'
    is_libitem(ea) -> bool

Help on function is_lzero0 in module ida_nalt:

is_lzero0(*args) -> 'bool'
    is_lzero0(ea) -> bool

Help on function is_lzero1 in module ida_nalt:

is_lzero1(*args) -> 'bool'
    is_lzero1(ea) -> bool

Help on function is_noret in module ida_nalt:

is_noret(*args) -> 'bool'
    is_noret(ea) -> bool

Help on function is_notcode in module ida_nalt:

is_notcode(*args) -> 'bool'
    is_notcode(ea) -> bool
    
    
    Is the address marked as not-code?
    
    
    @param ea (C++: ea_t)

Help on function is_notproc in module ida_nalt:

is_notproc(*args) -> 'bool'
    is_notproc(ea) -> bool

Help on function is_pascal in module ida_nalt:

is_pascal(*args) -> 'bool'
    is_pascal(strtype) -> bool

Help on function is_reftype_target_optional in module ida_nalt:

is_reftype_target_optional(*args) -> 'bool'
    is_reftype_target_optional(type) -> bool
    
    
    Can the target be calculated using operand value?
    
    
    @param type (C++: reftype_t)

Help on function is_retfp in module ida_nalt:

is_retfp(*args) -> 'bool'
    is_retfp(ea) -> bool

Help on function is_terse_struc in module ida_nalt:

is_terse_struc(*args) -> 'bool'
    is_terse_struc(ea) -> bool

Help on function is_tilcmt in module ida_nalt:

is_tilcmt(*args) -> 'bool'
    is_tilcmt(ea) -> bool

Help on function is_usersp in module ida_nalt:

is_usersp(*args) -> 'bool'
    is_usersp(ea) -> bool

Help on function is_userti in module ida_nalt:

is_userti(*args) -> 'bool'
    is_userti(ea) -> bool

Help on function is_visible_item in module ida_nalt:

is_visible_item(*args) -> 'bool'
    is_visible_item(ea) -> bool
    
    
    Test visibility of item at given ea.
    
    
    @param ea (C++: ea_t)

Help on function is_zstroff in module ida_nalt:

is_zstroff(*args) -> 'bool'
    is_zstroff(ea) -> bool

Help on function node2ea in module ida_nalt:

node2ea(*args) -> 'ea_t'
    node2ea(ndx) -> ea_t

Help on class opinfo_t in module ida_nalt:

class opinfo_t(builtins.object)
 |  Proxy of C++ opinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> opinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_opinfo_t(...)
 |      delete_opinfo_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cd
 |      opinfo_t_cd_get(self) -> custom_data_type_ids_t
 |  
 |  ec
 |      opinfo_t_ec_get(self) -> enum_const_t
 |  
 |  path
 |      opinfo_t_path_get(self) -> strpath_t
 |  
 |  ri
 |      opinfo_t_ri_get(self) -> refinfo_t
 |  
 |  strtype
 |      opinfo_t_strtype_get(self) -> int32
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      opinfo_t_tid_get(self) -> tid_t

Help on class printop_t in module ida_nalt:

class printop_t(builtins.object)
 |  Proxy of C++ printop_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> printop_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_printop_t(...)
 |      delete_printop_t(self)
 |  
 |  get_ti(self, *args) -> 'opinfo_t const *'
 |      get_ti(self) -> opinfo_t
 |  
 |  is_aflags_initialized(self, *args) -> 'bool'
 |      is_aflags_initialized(self) -> bool
 |  
 |  is_ti_initialized(self, *args) -> 'bool'
 |      is_ti_initialized(self) -> bool
 |  
 |  set_aflags_initialized(self, *args) -> 'void'
 |      set_aflags_initialized(self, v=True)
 |  
 |  set_ti_initialized(self, *args) -> 'void'
 |      set_ti_initialized(self, v=True)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  aflags
 |      printop_t_aflags_get(self) -> flags_t
 |  
 |  features
 |      printop_t_features_get(self) -> uchar
 |  
 |  flags
 |      printop_t_flags_get(self) -> flags_t
 |  
 |  is_ti_valid
 |      is_ti_initialized(self) -> bool
 |  
 |  suspop
 |      printop_t_suspop_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ti
 |      printop_t_ti_get(self) -> opinfo_t

Help on class refinfo_t in module ida_nalt:

class refinfo_t(builtins.object)
 |  Proxy of C++ refinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> refinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_refinfo_t(...)
 |      delete_refinfo_t(self)
 |  
 |  init(self, *args) -> 'void'
 |      init(self, reft_and_flags, _base=0, _target=BADADDR, _tdelta=0)
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |  
 |  is_pastend(self, *args) -> 'bool'
 |      is_pastend(self) -> bool
 |  
 |  is_rvaoff(self, *args) -> 'bool'
 |      is_rvaoff(self) -> bool
 |  
 |  is_signed(self, *args) -> 'bool'
 |      is_signed(self) -> bool
 |  
 |  is_subtract(self, *args) -> 'bool'
 |      is_subtract(self) -> bool
 |  
 |  is_target_optional(self, *args) -> 'bool'
 |      is_target_optional(self) -> bool
 |  
 |  no_base_xref(self, *args) -> 'bool'
 |      no_base_xref(self) -> bool
 |  
 |  set_type(self, *args) -> 'void'
 |      set_type(self, t)
 |  
 |  type(self, *args) -> 'reftype_t'
 |      type(self) -> reftype_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  base
 |      refinfo_t_base_get(self) -> ea_t
 |  
 |  flags
 |      refinfo_t_flags_get(self) -> uint32
 |  
 |  target
 |      refinfo_t_target_get(self) -> ea_t
 |  
 |  tdelta
 |      refinfo_t_tdelta_get(self) -> adiff_t
 |  
 |  thisown
 |      The membership flag

Help on function rename_encoding in module ida_nalt:

rename_encoding(*args) -> 'bool'
    rename_encoding(idx, encoding) -> bool
    
    
    Change name for an encoding (1-based)
    
    
    @param idx (C++: int)
    @param encoding (C++: const char *)

Help on function retrieve_input_file_crc32 in module ida_nalt:

retrieve_input_file_crc32(*args) -> 'uint32'
    retrieve_input_file_crc32() -> uint32
    
    
    Get input file crc32 stored in the database. it can be used to check
    that the input file has not been changed.

Help on function retrieve_input_file_md5 in module ida_nalt:

retrieve_input_file_md5(*args) -> 'uchar [ANY]'
    retrieve_input_file_md5() -> str
    
    
    Get input file md5.

Help on function retrieve_input_file_sha256 in module ida_nalt:

retrieve_input_file_sha256(*args) -> 'uchar [ANY]'
    retrieve_input_file_sha256() -> str
    
    
    Get input file sha256.

Help on function retrieve_input_file_size in module ida_nalt:

retrieve_input_file_size(*args) -> 'uint32'
    retrieve_input_file_size() -> uint32
    
    
    Get size of input file in bytes.

Help on function set__bnot0 in module ida_nalt:

set__bnot0(*args) -> 'void'
    set__bnot0(ea)

Help on function set__bnot1 in module ida_nalt:

set__bnot1(*args) -> 'void'
    set__bnot1(ea)

Help on function set__invsign0 in module ida_nalt:

set__invsign0(*args) -> 'void'
    set__invsign0(ea)

Help on function set__invsign1 in module ida_nalt:

set__invsign1(*args) -> 'void'
    set__invsign1(ea)

Help on function set_abits in module ida_nalt:

set_abits(*args) -> 'void'
    set_abits(ea, bits)

Help on function set_absbase in module ida_nalt:

set_absbase(*args) -> 'void'
    set_absbase(ea, x)

Help on function set_aflags in module ida_nalt:

set_aflags(*args) -> 'void'
    set_aflags(ea, flags)

Help on function set_align_flow in module ida_nalt:

set_align_flow(*args) -> 'void'
    set_align_flow(ea)

Help on function set_alignment in module ida_nalt:

set_alignment(*args) -> 'void'
    set_alignment(ea, x)

Help on function set_archive_path in module ida_nalt:

set_archive_path(*args) -> 'bool'
    set_archive_path(file) -> bool
    
    
    Set archive file path from which input file was extracted.
    
    
    @param file (C++: const char *)

Help on function set_array_parameters in module ida_nalt:

set_array_parameters(*args) -> 'void'
    set_array_parameters(ea, _in)

Help on function set_asm_inc_file in module ida_nalt:

set_asm_inc_file(*args) -> 'bool'
    set_asm_inc_file(file) -> bool
    
    
    Set name of the include file.
    
    
    @param file (C++: const char *)

Help on function set_colored_item in module ida_nalt:

set_colored_item(*args) -> 'void'
    set_colored_item(ea)

Help on function set_custom_data_type_ids in module ida_nalt:

set_custom_data_type_ids(*args) -> 'void'
    set_custom_data_type_ids(ea, cdis)

Help on function set_default_encoding_idx in module ida_nalt:

set_default_encoding_idx(*args) -> 'bool'
    set_default_encoding_idx(bpu, idx) -> bool
    
    
    set default encoding for a string type
    
    @param bpu: the amount of bytes per unit (C++: int)
    @param idx: the encoding index idx can be 0 to disable encoding
                conversion (C++: int)

Help on function set_fixed_spd in module ida_nalt:

set_fixed_spd(*args) -> 'void'
    set_fixed_spd(ea)

Help on function set_gotea in module ida_nalt:

set_gotea(*args) -> 'void'
    set_gotea(gotea)

Help on function set_has_lname in module ida_nalt:

set_has_lname(*args) -> 'void'
    set_has_lname(ea)

Help on function set_has_ti in module ida_nalt:

set_has_ti(*args) -> 'void'
    set_has_ti(ea)

Help on function set_has_ti0 in module ida_nalt:

set_has_ti0(*args) -> 'void'
    set_has_ti0(ea)

Help on function set_has_ti1 in module ida_nalt:

set_has_ti1(*args) -> 'void'
    set_has_ti1(ea)

Help on function set_ids_modnode in module ida_nalt:

set_ids_modnode(*args) -> 'void'
    set_ids_modnode(id)
    
    
    Set ids modnode.
    
    
    @param id (C++: netnode)

Help on function set_imagebase in module ida_nalt:

set_imagebase(*args) -> 'void'
    set_imagebase(base)
    
    
    Set image base address.
    
    
    @param base (C++: ea_t)

Help on function set_item_color in module ida_nalt:

set_item_color(*args) -> 'void'
    set_item_color(ea, color)

Help on function set_libitem in module ida_nalt:

set_libitem(*args) -> 'void'
    set_libitem(ea)

Help on function set_lzero0 in module ida_nalt:

set_lzero0(*args) -> 'void'
    set_lzero0(ea)

Help on function set_lzero1 in module ida_nalt:

set_lzero1(*args) -> 'void'
    set_lzero1(ea)

Help on function set_noret in module ida_nalt:

set_noret(*args) -> 'void'
    set_noret(ea)

Help on function set_notcode in module ida_nalt:

set_notcode(*args) -> 'void'
    set_notcode(ea)
    
    
    Mark address so that it cannot be converted to instruction.
    
    
    @param ea (C++: ea_t)

Help on function set_notproc in module ida_nalt:

set_notproc(*args) -> 'void'
    set_notproc(ea)

Help on function set_op_tinfo in module ida_nalt:

set_op_tinfo(*args) -> 'bool'
    set_op_tinfo(ea, n, tif) -> bool

Help on function set_outfile_encoding_idx in module ida_nalt:

set_outfile_encoding_idx(*args) -> 'bool'
    set_outfile_encoding_idx(idx) -> bool
    
    
    set encoding to be used when producing files
    
    @param idx: the encoding index idx can be 0 to use the IDB's default
                1-byte-per-unit encoding (C++: int)

Help on function set_refinfo in module ida_nalt:

set_refinfo(*args) -> 'bool'
    set_refinfo(ea, n, type, target=BADADDR, base=0, tdelta=0) -> bool

Help on function set_refinfo_ex in module ida_nalt:

set_refinfo_ex(*args) -> 'bool'
    set_refinfo_ex(ea, n, ri) -> bool

Help on function set_retfp in module ida_nalt:

set_retfp(*args) -> 'void'
    set_retfp(ea)

Help on function set_root_filename in module ida_nalt:

set_root_filename(*args) -> 'void'
    set_root_filename(file)
    
    
    Set full path of the input file.
    
    
    @param file (C++: const char *)

Help on function set_source_linnum in module ida_nalt:

set_source_linnum(*args) -> 'void'
    set_source_linnum(ea, lnnum)

Help on function set_str_type in module ida_nalt:

set_str_type(*args) -> 'void'
    set_str_type(ea, x)

Help on function set_switch_info in module ida_nalt:

set_switch_info(*args) -> 'void'
    set_switch_info(ea, _in)

Help on function set_switch_parent in module ida_nalt:

set_switch_parent(*args) -> 'void'
    set_switch_parent(ea, x)

Help on function set_terse_struc in module ida_nalt:

set_terse_struc(*args) -> 'void'
    set_terse_struc(ea)

Help on function set_tilcmt in module ida_nalt:

set_tilcmt(*args) -> 'void'
    set_tilcmt(ea)

Help on function set_tinfo in module ida_nalt:

set_tinfo(*args) -> 'bool'
    set_tinfo(ea, tif) -> bool

Help on function set_usemodsp in module ida_nalt:

set_usemodsp(*args) -> 'void'
    set_usemodsp(ea)

Help on function set_usersp in module ida_nalt:

set_usersp(*args) -> 'void'
    set_usersp(ea)

Help on function set_userti in module ida_nalt:

set_userti(*args) -> 'void'
    set_userti(ea)

Help on function set_visible_item in module ida_nalt:

set_visible_item(*args) -> 'void'
    set_visible_item(ea, visible)
    
    
    Change visibility of item at given ea.
    
    
    @param ea (C++: ea_t)
    @param visible (C++: bool)

Help on function set_zstroff in module ida_nalt:

set_zstroff(*args) -> 'void'
    set_zstroff(ea)

Help on class strpath_ids_array in module ida_nalt:

class strpath_ids_array(builtins.object)
 |  Proxy of C++ wrapped_array_t< tid_t,32 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'unsigned-ea-like-numeric-type const &'↗
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &↗
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> strpath_ids_array
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_strpath_ids_array(...)
 |      delete_strpath_ids_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  data
 |      strpath_ids_array_data_get(self) -> unsigned-ea-like-numeric-type (&)[32]↗
 |  
 |  thisown
 |      The membership flag

Help on class strpath_t in module ida_nalt:

class strpath_t(builtins.object)
 |  Proxy of C++ strpath_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strpath_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_strpath_t(...)
 |      delete_strpath_t(self)
 |  
 |  _strpath_t__getIds = __getIds(self, *args) -> 'wrapped_array_t< tid_t,32 >'
 |      __getIds(self) -> strpath_ids_array
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  delta
 |      strpath_t_delta_get(self) -> adiff_t
 |  
 |  ids
 |      __getIds(self) -> strpath_ids_array
 |  
 |  len
 |      strpath_t_len_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on class switch_info_t in module ida_nalt:

class switch_info_t(builtins.object)
 |  Proxy of C++ switch_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> switch_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_switch_info_t(...)
 |      delete_switch_info_t(self)
 |  
 |  _get_values_lowcase(self, *args) -> 'ea_t'
 |      _get_values_lowcase(self) -> ea_t
 |  
 |  _set_values_lowcase(self, *args) -> 'void'
 |      _set_values_lowcase(self, values)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, other)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  get_jrange_vrange(self, *args) -> 'bool'
 |      get_jrange_vrange(self, jrange=None, vrange=None) -> bool
 |  
 |  get_jtable_element_size(self, *args) -> 'int'
 |      get_jtable_element_size(self) -> int
 |  
 |  get_jtable_size(self, *args) -> 'int'
 |      get_jtable_size(self) -> int
 |  
 |  get_lowcase(self, *args) -> 'sval_t'
 |      get_lowcase(self) -> sval_t
 |  
 |  get_shift(self, *args) -> 'int'
 |      get_shift(self) -> int
 |  
 |  get_version(self, *args) -> 'int'
 |      get_version(self) -> int
 |  
 |  get_vtable_element_size(self, *args) -> 'int'
 |      get_vtable_element_size(self) -> int
 |  
 |  has_default(self, *args) -> 'bool'
 |      has_default(self) -> bool
 |  
 |  has_elbase(self, *args) -> 'bool'
 |      has_elbase(self) -> bool
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |  
 |  is_indirect(self, *args) -> 'bool'
 |      is_indirect(self) -> bool
 |  
 |  is_nolowcase(self, *args) -> 'bool'
 |      is_nolowcase(self) -> bool
 |  
 |  is_sparse(self, *args) -> 'bool'
 |      is_sparse(self) -> bool
 |  
 |  is_subtract(self, *args) -> 'bool'
 |      is_subtract(self) -> bool
 |  
 |  set_elbase(self, *args) -> 'void'
 |      set_elbase(self, base)
 |  
 |  set_expr(self, *args) -> 'void'
 |      set_expr(self, r, dt)
 |  
 |  set_jtable_element_size(self, *args) -> 'void'
 |      set_jtable_element_size(self, size)
 |  
 |  set_jtable_size(self, *args) -> 'void'
 |      set_jtable_size(self, size)
 |  
 |  set_shift(self, *args) -> 'void'
 |      set_shift(self, shift)
 |  
 |  set_vtable_element_size(self, *args) -> 'void'
 |      set_vtable_element_size(self, size)
 |  
 |  use_std_table(self, *args) -> 'bool'
 |      use_std_table(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  custom
 |      switch_info_t_custom_get(self) -> uval_t
 |  
 |  defjump
 |      switch_info_t_defjump_get(self) -> ea_t
 |  
 |  elbase
 |      switch_info_t_elbase_get(self) -> ea_t
 |  
 |  expr_ea
 |      switch_info_t_expr_ea_get(self) -> ea_t
 |  
 |  flags
 |      switch_info_t_flags_get(self) -> uint32
 |  
 |  ind_lowcase
 |      switch_info_t_ind_lowcase_get(self) -> sval_t
 |  
 |  jcases
 |      switch_info_t_jcases_get(self) -> int
 |  
 |  jumps
 |      switch_info_t_jumps_get(self) -> ea_t
 |  
 |  lowcase
 |      _get_values_lowcase(self) -> ea_t
 |  
 |  marks
 |      switch_info_t_marks_get(self) -> eavec_t *
 |  
 |  ncases
 |      switch_info_t_ncases_get(self) -> ushort
 |  
 |  regdtype
 |      switch_info_t_regdtype_get(self) -> op_dtype_t
 |  
 |  regnum
 |      switch_info_t_regnum_get(self) -> int
 |  
 |  startea
 |      switch_info_t_startea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  values
 |      _get_values_lowcase(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  SWITCH_INFO_VERSION = 2

Help on function switch_info_t__from_ptrval__ in module ida_nalt:

switch_info_t__from_ptrval__(*args) -> 'switch_info_t *'
    switch_info_t__from_ptrval__(ptrval) -> switch_info_t

Help on function unhide_border in module ida_nalt:

unhide_border(*args) -> 'void'
    unhide_border(ea)

Help on function unhide_item in module ida_nalt:

unhide_item(*args) -> 'void'
    unhide_item(ea)

Help on function uses_modsp in module ida_nalt:

uses_modsp(*args) -> 'bool'
    uses_modsp(ea) -> bool

Help on function validate_idb_names in module ida_nalt:

validate_idb_names(*args) -> 'int'
    validate_idb_names(do_repair) -> int

=== ida_nalt EPYDOC INJECTIONS ===
ida_nalt.AFL_ALIGNFLOW
"""
the previous insn was created for alignment purposes only
"""

ida_nalt.AFL_BNOT0
"""
the 1st operand is bitwise negated
"""

ida_nalt.AFL_BNOT1
"""
the 2nd operand is bitwise negated
"""

ida_nalt.AFL_COLORED
"""
has user defined instruction color?
"""

ida_nalt.AFL_FIXEDSPD
"""
should not be modified by modules

sp delta value is fixed by analysis.
"""

ida_nalt.AFL_HIDDEN
"""
the item is hidden completely
"""

ida_nalt.AFL_LIB
"""
item from the standard library. low level flag, is used to set
'FUNC_LIB' of 'func_t'
"""

ida_nalt.AFL_LINNUM
"""
has line number info
"""

ida_nalt.AFL_LNAME
"""
has local name too ( 'FF_NAME' should be set)
"""

ida_nalt.AFL_LZERO0
"""
toggle leading zeroes for the 1st operand
"""

ida_nalt.AFL_LZERO1
"""
toggle leading zeroes for the 2nd operand
"""

ida_nalt.AFL_MANUAL
"""
the instruction/data is specified by the user
"""

ida_nalt.AFL_NOBRD
"""
the code/data border is hidden
"""

ida_nalt.AFL_NORET
"""
for imported function pointers: doesn't return. this flag can also be
used for any instruction which halts or finishes the program execution
"""

ida_nalt.AFL_NOTCODE
"""
autoanalysis should not create code here
"""

ida_nalt.AFL_NOTPROC
"""
autoanalysis should not create proc here
"""

ida_nalt.AFL_PUBNAM
"""
name is public (inter-file linkage)
"""

ida_nalt.AFL_RETFP
"""
function returns a floating point value
"""

ida_nalt.AFL_SIGN0
"""
code: toggle sign of the 1st operand
"""

ida_nalt.AFL_SIGN1
"""
code: toggle sign of the 2nd operand
"""

ida_nalt.AFL_TERSESTR
"""
terse structure variable display?
"""

ida_nalt.AFL_TI
"""
has typeinfo? ( 'NSUP_TYPEINFO' )
"""

ida_nalt.AFL_TI0
"""
has typeinfo for operand 0? ( 'NSUP_OPTYPES' )
"""

ida_nalt.AFL_TI1
"""
has typeinfo for operand 1? ( 'NSUP_OPTYPES' +1)
"""

ida_nalt.AFL_TILCMT
"""
has type comment? (such a comment may be changed by IDA)
"""

ida_nalt.AFL_USEMODSP
"""
example: pop [rsp+N]

insn modifes SP and uses the modified value
"""

ida_nalt.AFL_USERSP
"""
user-defined SP value
"""

ida_nalt.AFL_USERTI
"""
(comes from the user or type library)

the type information is definitive.
"""

ida_nalt.AFL_WEAKNAM
"""
name is weak
"""

ida_nalt.AFL_ZSTROFF
"""
display struct field name at 0 offset when displaying an offset.
example: \\v{offset somestruct.field_0} if this flag is clear, then
\\v{offset somestruct}
"""

ida_nalt.AP_ALLOWDUPS
"""
use 'dup' construct
"""

ida_nalt.AP_ARRAY
"""
create as array (this flag is not stored in database)
"""

ida_nalt.AP_IDXBASEMASK
"""
mask for number base of the indexes
"""

ida_nalt.AP_IDXBIN
"""
display indexes in binary
"""

ida_nalt.AP_IDXDEC
"""
display indexes in decimal
"""

ida_nalt.AP_IDXHEX
"""
display indexes in hex
"""

ida_nalt.AP_IDXOCT
"""
display indexes in octal
"""

ida_nalt.AP_INDEX
"""
display array element indexes as comments
"""

ida_nalt.AP_SIGNED
"""
treats numbers as signed
"""

ida_nalt.MAXSTRUCPATH
"""
maximal inclusion depth of unions
"""

ida_nalt.NALT_ABSBASE
"""
absolute segment location
"""

ida_nalt.NALT_AFLAGS
"""
additional flags for an item
"""

ida_nalt.NALT_ALIGN
"""
(should by equal to power of 2)

alignment value if the item is 'FF_ALIGN'
"""

ida_nalt.NALT_COLOR
"""
instruction/data background color
"""

ida_nalt.NALT_CREF_FROM
"""
code xref from, idx: source address
"""

ida_nalt.NALT_CREF_TO
"""
code xref to, idx: target address
"""

ida_nalt.NALT_DREF_FROM
"""
data xref from, idx: source address
"""

ida_nalt.NALT_DREF_TO
"""
data xref to, idx: target address
"""

ida_nalt.NALT_ENUM0
"""
enum id for the first operand
"""

ida_nalt.NALT_ENUM1
"""
enum id for the second operand
"""

ida_nalt.NALT_GR_LAYX
"""
group layout ptrs, hash: md5 of 'belongs'
"""

ida_nalt.NALT_LINNUM
"""
source line number
"""

ida_nalt.NALT_PURGE
"""
number of bytes purged from the stack when a function is called
indirectly
"""

ida_nalt.NALT_STRTYPE
"""
type of string item
"""

ida_nalt.NALT_STRUCT
"""
struct id
"""

ida_nalt.NALT_SWITCH
"""
switch idiom address (used at jump targets)
"""

ida_nalt.NSUP_ARGEAS
"""
instructions that initialize call arguments
"""

ida_nalt.NSUP_ARRAY
"""
array parameters
"""

ida_nalt.NSUP_CMT
"""
regular comment
"""

ida_nalt.NSUP_CUSTDT
"""
custom data type id
"""

ida_nalt.NSUP_FOP1
"""
forced operand 1
"""

ida_nalt.NSUP_FOP2
"""
forced operand 2
"""

ida_nalt.NSUP_FOP3
"""
forced operand 3
"""

ida_nalt.NSUP_FOP4
"""
forced operand 4
"""

ida_nalt.NSUP_FOP5
"""
forced operand 5
"""

ida_nalt.NSUP_FOP6
"""
forced operand 6
"""

ida_nalt.NSUP_FOP7
"""
forced operand 7
"""

ida_nalt.NSUP_FOP8
"""
forced operand 8
"""

ida_nalt.NSUP_FTAILS
"""
function tails or tail referers values NSUP_FTAILS..NSUP_FTAILS+0x1000
are reserved
"""

ida_nalt.NSUP_GROUP
"""
graph group information values NSUP_GROUP..NSUP_GROUP+0x1000 are
reserved
"""

ida_nalt.NSUP_GROUPS
"""
SEG_GRP: pack_dd encoded list of selectors.
"""

ida_nalt.NSUP_GR_INFO
"""
group node info: color, ea, text
"""

ida_nalt.NSUP_GR_LAYT
"""
group layouts, idx: layout pointer
"""

ida_nalt.NSUP_JINFO
"""
jump table info
"""

ida_nalt.NSUP_LLABEL
"""
local labels. values NSUP_LLABEL..NSUP_LLABEL+0x1000 are reserved
"""

ida_nalt.NSUP_MANUAL
"""
manual instruction. values NSUP_MANUAL..NSUP_MANUAL+0x1000 are
reserved
"""

ida_nalt.NSUP_OMFGRP
"""
OMF: group of segments (not used anymore)
"""

ida_nalt.NSUP_OPTYPES
"""
operand type information. values NSUP_OPTYPES..NSUP_OPTYPES+0x100000
are reserved
"""

ida_nalt.NSUP_OREF0
"""
outer complex reference information for operand 1
"""

ida_nalt.NSUP_OREF1
"""
outer complex reference information for operand 2
"""

ida_nalt.NSUP_OREF2
"""
outer complex reference information for operand 3
"""

ida_nalt.NSUP_OREF3
"""
outer complex reference information for operand 4
"""

ida_nalt.NSUP_OREF4
"""
outer complex reference information for operand 5
"""

ida_nalt.NSUP_OREF5
"""
outer complex reference information for operand 6
"""

ida_nalt.NSUP_OREF6
"""
outer complex reference information for operand 7
"""

ida_nalt.NSUP_OREF7
"""
outer complex reference information for operand 8
"""

ida_nalt.NSUP_ORIGFMD
"""
function metadata before lumina information was applied values
NSUP_ORIGFMD..NSUP_ORIGFMD+0x1000 are reserved
"""

ida_nalt.NSUP_POINTS
"""
SP change points blob (see funcs.cpp). values
NSUP_POINTS..NSUP_POINTS+0x1000 are reserved
"""

ida_nalt.NSUP_REF0
"""
complex reference information for operand 1
"""

ida_nalt.NSUP_REF1
"""
complex reference information for operand 2
"""

ida_nalt.NSUP_REF2
"""
complex reference information for operand 3
"""

ida_nalt.NSUP_REF3
"""
complex reference information for operand 4
"""

ida_nalt.NSUP_REF4
"""
complex reference information for operand 5
"""

ida_nalt.NSUP_REF5
"""
complex reference information for operand 6
"""

ida_nalt.NSUP_REF6
"""
complex reference information for operand 7
"""

ida_nalt.NSUP_REF7
"""
complex reference information for operand 8
"""

ida_nalt.NSUP_REGARG
"""
register argument type/name descriptions values
NSUP_REGARG..NSUP_REGARG+0x1000 are reserved
"""

ida_nalt.NSUP_REGVAR
"""
register variables. values NSUP_REGVAR..NSUP_REGVAR+0x1000 are
reserved
"""

ida_nalt.NSUP_REPCMT
"""
repeatable comment
"""

ida_nalt.NSUP_SEGTRANS
"""
segment translations
"""

ida_nalt.NSUP_STROFF0
"""
stroff: struct path for the first operand
"""

ida_nalt.NSUP_STROFF1
"""
stroff: struct path for the second operand
"""

ida_nalt.NSUP_SWITCH
"""
switch information
"""

ida_nalt.NSUP_TYPEINFO
"""
type information. values NSUP_TYPEINFO..NSUP_TYPEINFO+0x1000 are
reserved
"""

ida_nalt.NSUP_XREFPOS
"""
saved xref address and type in the xrefs window
"""

ida_nalt.PATCH_TAG
"""
Patch netnode tag.
"""

ida_nalt.REFINFO_CUSTOM
"""
a custom reference the kernel will call \\ph{notify}(ph.custom_offset,
.... that can change all arguments used for calculations. This flag is
useful for custom fixups
"""

ida_nalt.REFINFO_NOBASE
"""
don't create the base xref implies that the base can be any value nb:
base xrefs are created only if the offset base points to the middle of
a segment
"""

ida_nalt.REFINFO_PASTEND
"""
reference past an item it may point to an nonexistent address do not
destroy alignment dirs
"""

ida_nalt.REFINFO_RVAOFF
"""
based reference (rva) 'refinfo_t::base' will be forced to
'get_imagebase()' such a reference is displayed with the \\ash{a_rva}
keyword
"""

ida_nalt.REFINFO_SIGNEDOP
"""
the operand value is sign-extended (only supported for
REF_OFF8/16/32/64)
"""

ida_nalt.REFINFO_SUBTRACT
"""
the reference value is subtracted from the base value instead of (as
usual) being added to it
"""

ida_nalt.REFINFO_TYPE
"""
reference type
"""

ida_nalt.RIDX_ABINAME
"""
ABI name (processor specific)
"""

ida_nalt.RIDX_ARCHIVE_PATH
"""
archive file path
"""

ida_nalt.RIDX_C_MACROS
"""
C predefined macros.
"""

ida_nalt.RIDX_DBG_BINPATHS
"""
unused (20 indexes)
"""

ida_nalt.RIDX_DUALOP_GRAPH
"""
Graph text representation options.
"""

ida_nalt.RIDX_DUALOP_TEXT
"""
Text text representation options.
"""

ida_nalt.RIDX_FILE_FORMAT_NAME
"""
file format name for loader modules
"""

ida_nalt.RIDX_GROUPS
"""
segment group information (see init_groups())
"""

ida_nalt.RIDX_H_PATH
"""
C header path.
"""

ida_nalt.RIDX_IDA_VERSION
"""
version of ida which created the database
"""

ida_nalt.RIDX_INCLUDE
"""
assembler include file name
"""

ida_nalt.RIDX_MD5
"""
MD5 of the input file.
"""

ida_nalt.RIDX_NOTEPAD
"""
notepad blob, occupies 1000 indexes (1MB of text)
"""

ida_nalt.RIDX_PROBLEMS
"""
problem lists
"""

ida_nalt.RIDX_SELECTED_EXTLANG
"""
last selected extlang name (from the execute script box)
"""

ida_nalt.RIDX_SELECTORS
"""
2..63 are for selector_t blob (see init_selectors())
"""

ida_nalt.RIDX_SHA256
"""
SHA256 of the input file.
"""

ida_nalt.RIDX_SMALL_IDC
"""
Instant IDC statements, blob.
"""

ida_nalt.RIDX_SMALL_IDC_OLD
"""
Instant IDC statements (obsolete)
"""

ida_nalt.RIDX_SRCDBG_PATHS
"""
source debug paths, occupies 20 indexes
"""

ida_nalt.RIDX_SRCDBG_UNDESIRED
"""
user-closed source files, occupies 20 indexes
"""

ida_nalt.RIDX_STR_ENCODINGS
"""
a list of encodings for the program strings
"""

ida_nalt.STRENC_DEFAULT
"""
use default encoding for this type (see 'get_default_encoding_idx()' )
"""

ida_nalt.STRENC_NONE
"""
force no-conversion encoding
"""

ida_nalt.STRTYPE_C
"""
Zero-terminated 16bit chars.
"""

ida_nalt.STRTYPE_C_16
"""
Zero-terminated 32bit chars.
"""

ida_nalt.STRTYPE_C_32
"""
Pascal-style, one-byte length prefix.
"""

ida_nalt.STRTYPE_LEN2
"""
Pascal-style, 16bit chars, two-byte length prefix.
"""

ida_nalt.STRTYPE_LEN2_16
"""
Pascal-style, four-byte length prefix.
"""

ida_nalt.STRTYPE_LEN4
"""
Pascal-style, 16bit chars, four-byte length prefix.
"""

ida_nalt.STRTYPE_PASCAL
"""
Pascal-style, 16bit chars, one-byte length prefix.
"""

ida_nalt.STRTYPE_PASCAL_16
"""
Pascal-style, two-byte length prefix.
"""

ida_nalt.STRTYPE_TERMCHR
"""
C-style string.

< Character-terminated string. The termination characters are kept in
the next bytes of string type.
"""

ida_nalt.SWI_CUSTOM
"""
custom jump table. \\ph{create_switch_xrefs} will be called to create
code xrefs for the table. Custom jump table must be created by the
module (see also 'SWI_STDTBL' )
"""

ida_nalt.SWI_DEFRET
"""
return in the default case (defjump==BADADDR)
"""

ida_nalt.SWI_DEF_IN_TBL
"""
default case is an entry in the jump table. This flag is applicable in
2 cases:The sparse indirect switch (i.e. a switch with a values table)
<jump table="" size>=""> ==+ 1. The default case entry is the last one
in the table (or the first one in the case of an inversed jump
table).The switch with insns in the jump table. The default case entry
is before the first entry of the table. See also the
find_defjump_from_table() helper function.
"""

ida_nalt.SWI_ELBASE
"""
segment will be used)

elbase is present (otherwise the base of the switch
"""

ida_nalt.SWI_HXNOLOWCASE
"""
lowcase value should not be used by the decompiler (internal flag)
"""

ida_nalt.SWI_INDIRECT
"""
(for sparse switches)

value table elements are used as indexes into the jump table
"""

ida_nalt.SWI_J32
"""
32-bit jump offsets
"""

ida_nalt.SWI_JMPINSN
"""
jump table entries are insns. For such entries SHIFT has a different
meaning. It denotes the number of insns in the entry. For example, 0 -
the entry contains the jump to the case, 1 - the entry contains one
insn like a 'mov' and jump to the end of case, and so on.
"""

ida_nalt.SWI_JMP_INV
"""
for first entry in values table)

jumptable is inversed. (last entry is
"""

ida_nalt.SWI_JSIZE
"""
jump offset expansion bit
"""

ida_nalt.SWI_RESERVED
"""
was: SWI_DEFAULT
"""

ida_nalt.SWI_SELFREL
"""
jump address is relative to the element not to ELBASE
"""

ida_nalt.SWI_SEPARATE
"""
create an array of individual elements (otherwise separate items)
"""

ida_nalt.SWI_SHIFT_MASK
"""
use formula (element<<shift) + elbase to find jump targets
"""

ida_nalt.SWI_SIGNED
"""
jump table entries are signed
"""

ida_nalt.SWI_SPARSE
"""
otherwise lowcase present

sparse switch (value table present)
"""

ida_nalt.SWI_STDTBL
"""
custom jump table with standard table formatting. ATM IDA doesn't use
SWI_CUSTOM for switches with standard table formatting. So this flag
can be considered as obsolete.
"""

ida_nalt.SWI_SUBTRACT
"""
table values are subtracted from the elbase instead of being added
"""

ida_nalt.SWI_V32
"""
32-bit values in table
"""

ida_nalt.SWI_VERSION
"""
the structure contains the VERSION member
"""

ida_nalt.SWI_VSIZE
"""
value table element size expansion bit
"""

ida_nalt.SWI_VSPLIT
"""
value table is split (only for 32-bit values)
"""
=== ida_nalt EPYDOC INJECTIONS END ===
Help on class NearestName in module ida_name:

class NearestName(builtins.object)
 |  Utility class to help find the nearest name in a given ea/name dictionary
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, index)
 |      Returns the tupple (ea, name, index)
 |  
 |  __init__(self, ea_names)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __iter__(self)
 |  
 |  _get_item(self, index)
 |  
 |  find(self, ea)
 |      Returns a tupple (ea, name, pos) that is the nearest to the passed ea
 |      If no name is matched then None is returned
 |  
 |  update(self, ea_names)
 |      Updates the ea/names map
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function append_struct_fields in module ida_name:

append_struct_fields(*args) -> 'qstring *, adiff_t *'
    append_struct_fields(disp, n, path, flags, delta, appzero) -> str
    
    
    Append names of struct fields to a name if the name is a struct name.
    
    @param disp: displacement from the name (C++: adiff_t *)
    @param n: number of operand n which the name appears (C++: int)
    @param path: path in the struct. path is an array of id's. maximal
                 length of array is  MAXSTRUCPATH . the first element of
                 the array is the structure id. consecutive elements are
                 id's of used union members (if any). (C++: const  tid_t
                 *)
    @param flags: the input flags. they will be returned if the struct
                  cannot be found. (C++: flags_t)
    @param delta: delta to add to displacement (C++: adiff_t)
    @param appzero: should append a struct field name if the displacement
                    is zero? (C++: bool)
    @return: flags of the innermost struct member or the input flags

Help on function calc_gtn_flags in module ida_name:

calc_gtn_flags(fromaddr, ea)
    Calculate flags for get_ea_name() function
    
    @param fromaddr: the referring address. May be BADADDR.
    @param ea: linear address
    
    @return: flags

Help on function cleanup_name in module ida_name:

cleanup_name(*args) -> 'qstring *'
    cleanup_name(ea, name, flags=0) -> str

Help on function del_debug_names in module ida_name:

del_debug_names(*args) -> 'void'
    del_debug_names(ea1, ea2)

Help on function del_global_name in module ida_name:

del_global_name(*args) -> 'bool'
    del_global_name(ea) -> bool

Help on function del_local_name in module ida_name:

del_local_name(*args) -> 'bool'
    del_local_name(ea) -> bool

Help on function demangle_name in module ida_name:

demangle_name(*args) -> 'qstring *'
    demangle_name(name, disable_mask, demreq=DQT_FULL) -> str
    
    
    Demangle a name.
    
    @param name: name to demangle (C++: const char *)
    @param disable_mask: bits to inhibit parts of demangled name (see
                         MNG_). by the M_COMPILER bits a specific compiler
                         can be selected (see MT_). (C++: uint32)
    @param demreq (C++: demreq_type_t)
    @return: ME_... or MT__ bitmasks from  demangle.hpp

Help on class ea_name_t in module ida_name:

class ea_name_t(builtins.object)
 |  Proxy of C++ ea_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ea_name_t
 |      __init__(self, _ea, _name) -> ea_name_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ea_name_t(...)
 |      delete_ea_name_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea_name_t_ea_get(self) -> ea_t
 |  
 |  name
 |      ea_name_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on class ea_name_vec_t in module ida_name:

class ea_name_vec_t(builtins.object)
 |  Proxy of C++ qvector< ea_name_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'ea_name_t const &'
 |      __getitem__(self, i) -> ea_name_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ea_name_vec_t
 |      __init__(self, x) -> ea_name_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_ea_name_vec_t(...)
 |      delete_ea_name_vec_t(self)
 |  
 |  at(self, *args) -> 'ea_name_t const &'
 |      at(self, _idx) -> ea_name_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< ea_name_t >::const_iterator'
 |      begin(self) -> ea_name_t
 |      begin(self) -> ea_name_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< ea_name_t >::const_iterator'
 |      end(self) -> ea_name_t
 |      end(self) -> ea_name_t
 |  
 |  erase(self, *args) -> 'qvector< ea_name_t >::iterator'
 |      erase(self, it) -> ea_name_t
 |      erase(self, first, last) -> ea_name_t
 |  
 |  extract(self, *args) -> 'ea_name_t *'
 |      extract(self) -> ea_name_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=ea_name_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< ea_name_t >::iterator'
 |      insert(self, it, x) -> ea_name_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'ea_name_t &'
 |      push_back(self, x)
 |      push_back(self) -> ea_name_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function extract_name in module ida_name:

extract_name(*args) -> 'qstring *'
    extract_name(line, x) -> str
    
    
    Extract a name or address from the specified string.
    
    @param line: input string (C++: const char *)
    @param x: x coordinate of cursor (C++: int)
    @return: -1 if cannot extract. otherwise length of the name

Help on function force_name in module ida_name:

force_name(*args) -> 'bool'
    force_name(ea, name, flags=0) -> bool

Help on function get_colored_demangled_name in module ida_name:

get_colored_demangled_name(*args) -> 'qstring'
    get_colored_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring

Help on function get_colored_long_name in module ida_name:

get_colored_long_name(*args) -> 'qstring'
    get_colored_long_name(ea, gtn_flags=0) -> qstring

Help on function get_colored_name in module ida_name:

get_colored_name(*args) -> 'qstring'
    get_colored_name(ea) -> qstring

Help on function get_colored_short_name in module ida_name:

get_colored_short_name(*args) -> 'qstring'
    get_colored_short_name(ea, gtn_flags=0) -> qstring

Help on function get_cp_validity in module ida_name:

get_cp_validity(*args) -> 'bool'
    get_cp_validity(kind, cp, endcp=wchar32_t(-1)) -> bool
    
    
    Is the given codepoint (or range) acceptable in the given context? If
    'endcp' is not BADCP, it is considered to be the end of the range:
    [cp, endcp), and is not included in the range
    
    @param kind (C++: ucdr_kind_t)
    @param cp (C++: wchar32_t)
    @param endcp (C++: wchar32_t)

Help on function get_debug_name in module ida_name:

get_debug_name(*args) -> 'qstring *'
    get_debug_name(ea_ptr, how) -> str

Help on function get_debug_name_ea in module ida_name:

get_debug_name_ea(*args) -> 'ea_t'
    get_debug_name_ea(name) -> ea_t

Help on function get_debug_names in module ida_name:

get_debug_names(*args) -> 'PyObject *'
    get_debug_names(names, ea1, ea2)
    get_debug_names(ea1, ea2, return_list=False) -> PyObject *

Help on function get_demangled_name in module ida_name:

get_demangled_name(*args) -> 'qstring'
    get_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring

Help on function get_ea_name in module ida_name:

get_ea_name(*args) -> 'qstring'
    get_ea_name(ea, gtn_flags=0) -> qstring
    
    
    Get name at the specified address.
    
    @param ea: linear address (C++: ea_t)
    @param gtn_flags: how exactly the name should be retrieved.
                      combination of  bits for get_ea_name() function.
                      There is a convenience  bits (C++: int)
    @return: success

Help on function get_long_name in module ida_name:

get_long_name(*args) -> 'qstring'
    get_long_name(ea, gtn_flags=0) -> qstring

Help on function get_name in module ida_name:

get_name(*args) -> 'qstring'
    get_name(ea) -> qstring

Help on function get_name_base_ea in module ida_name:

get_name_base_ea(*args) -> 'ea_t'
    get_name_base_ea(_from, to) -> ea_t
    
    
    Get address of the name used in the expression for the address
    
    @param _from: address of the operand which references to the address
                  (C++: ea_t)
    @param to: the referenced address (C++: ea_t)
    @return: address of the name used to represent the operand

Help on function get_name_color in module ida_name:

get_name_color(*args) -> 'color_t'
    get_name_color(_from, ea) -> color_t
    
    
    Calculate flags for 'get_ea_name()' function.
    
    Get name color.
    
    @param _from: linear address where the name is used. if not
                  applicable, then should be  BADADDR . The kernel returns
                  a local name color if the reference is within a
                  function, i.e. 'from' and 'ea' belong to the same
                  function. (C++: ea_t)
    @param ea: linear address (C++: ea_t)

Help on function get_name_ea in module ida_name:

get_name_ea(*args) -> 'ea_t'
    get_name_ea(_from, name) -> ea_t
    
    
    Get address of the name. Dummy names (like byte_xxxx where xxxx are
    hex digits) are parsed by this function to obtain the address. The
    database is not consulted for them. This function works only with
    regular names.
    
    @param _from: linear address where the name is used. if not
                  applicable, then should be  BADADDR . (C++: ea_t)
    @param name: any name in the program or NULL (C++: const char *)
    @return: address of the name or  BADADDR

Help on function get_name_expr in module ida_name:

get_name_expr(*args) -> 'qstring *'
    get_name_expr(_from, n, ea, off, flags=0x0001) -> str
    
    
    Convert address to name expression (name with a displacement). This
    function takes into account fixup information and returns a colored
    name expression (in the form <name> +/- <offset>). It also knows about
    structure members and arrays. If the specified address doesn't have a
    name, a dummy name is generated.
    
    @param _from: linear address of instruction operand or data referring
                  to the name. This address will be used to get fixup
                  information, so it should point to exact position of the
                  operand in the instruction. (C++: ea_t)
    @param n: number of referencing operand. for data items specify 0
              (C++: int)
    @param ea: address to convert to name expression (C++: ea_t)
    @param off: the value of name expression. this parameter is used only
                to check that the name expression will have the wanted
                value. 'off' may be equal to BADADDR but this is
                discouraged because it prohibits checks. (C++: uval_t)
    @param flags: Name expression flags (C++: int)
    @return: < 0 if address is not valid, no segment or other failure.
             otherwise the length of the name expression in characters.

Help on function get_name_value in module ida_name:

get_name_value(*args) -> 'uval_t *'
    get_name_value(_from, name) -> int
    
    
    Get value of the name. This function knows about: regular names,
    enums, special segments, etc.
    
    @param _from: linear address where the name is used if not applicable,
                  then should be BADADDR (C++: ea_t)
    @param name: any name in the program or NULL (C++: const char *)
    @return: Name value result codes

Help on function get_nice_colored_name in module ida_name:

get_nice_colored_name(*args) -> 'qstring *'
    get_nice_colored_name(ea, flags=0) -> str
    
    
    Get a nice colored name at the specified address. Ex:segment:sub+offse
    tsegment:sub:local_labelsegment:labelsegment:addresssegment:address+of
    fset
    
    @param ea (C++: ea_t)
    @param flags (C++: int)
    @return: the length of the generated name in bytes.

Help on function get_nlist_ea in module ida_name:

get_nlist_ea(*args) -> 'ea_t'
    get_nlist_ea(idx) -> ea_t
    
    
    Get address from the list at 'idx'.
    
    
    @param idx (C++: size_t)

Help on function get_nlist_idx in module ida_name:

get_nlist_idx(*args) -> 'size_t'
    get_nlist_idx(ea) -> size_t
    
    
    Get index of the name in the listreturns the closest match. may return
    idx >= size.
    
    @param ea (C++: ea_t)

Help on function get_nlist_name in module ida_name:

get_nlist_name(*args) -> 'char const *'
    get_nlist_name(idx) -> char const *
    
    
    Get name using idx.
    
    
    @param idx (C++: size_t)

Help on function get_nlist_size in module ida_name:

get_nlist_size(*args) -> 'size_t'
    get_nlist_size() -> size_t
    
    
    Get number of names in the list.

Help on function get_short_name in module ida_name:

get_short_name(*args) -> 'qstring'
    get_short_name(ea, gtn_flags=0) -> qstring

Help on function get_visible_name in module ida_name:

get_visible_name(*args) -> 'qstring'
    get_visible_name(ea, gtn_flags=0) -> qstring

Help on function hide_name in module ida_name:

hide_name(*args) -> 'void'
    hide_name(ea)
    
    
    Remove name from the list of names
    
    @param ea: address of the name (C++: ea_t)

Help on function is_ident in module ida_name:

is_ident(*args) -> 'bool'
    is_ident(name) -> bool
    
    
    Is a valid name? (including ::MangleChars)
    
    
    @param name (C++: const char *)

Help on function is_ident_cp in module ida_name:

is_ident_cp(*args) -> 'bool'
    is_ident_cp(cp) -> bool
    
    
    Can a character appear in a name? (present in ::NameChars or
    ::MangleChars)
    
    
    @param cp (C++: wchar32_t)

Help on function is_in_nlist in module ida_name:

is_in_nlist(*args) -> 'bool'
    is_in_nlist(ea) -> bool
    
    
    Is name included into names list?
    
    
    @param ea (C++: ea_t)

Help on function is_name_defined_locally in module ida_name:

is_name_defined_locally(*args) -> 'bool'
    is_name_defined_locally(pfn, name, ignore_name_def, ea1=BADADDR, ea2=BADADDR) -> bool
    
    
    Is the name defined locally in the specified function?
    
    @param pfn: pointer to function (C++: func_t  *)
    @param name: name to check (C++: const char *)
    @param ignore_name_def: which names to ignore when checking (C++:
                            ignore_name_def_t)
    @param ea1: the starting address of the range inside the function
                (optional) (C++: ea_t)
    @param ea2: the ending address of the range inside the function
                (optional) (C++: ea_t)
    @return: true if the name has been defined

Help on function is_public_name in module ida_name:

is_public_name(*args) -> 'bool'
    is_public_name(ea) -> bool

Help on function is_strlit_cp in module ida_name:

is_strlit_cp(*args) -> 'bool'
    is_strlit_cp(cp, specific_ranges=None) -> bool
    
    
    Can a character appear in a string literal (present in ::StrlitChars)
    If 'specific_ranges' are specified, those will be used instead of the
    ones corresponding to the current culture (only if ::StrlitChars is
    configured to use the current culture)
    
    @param cp (C++: wchar32_t)
    @param specific_ranges (C++: const  rangeset_crefvec_t  *)

Help on function is_uname in module ida_name:

is_uname(*args) -> 'bool'
    is_uname(name) -> bool
    
    
    Is valid user-specified name? (valid name & !dummy prefix).
    
    @param name: name to test. may be NULL. (C++: const char *)

Help on function is_valid_cp in module ida_name:

is_valid_cp(*args) -> 'bool'
    is_valid_cp(cp, kind, data=None) -> bool
    
    
    Is the given codepoint acceptable in the given context?
    
    
    @param cp (C++: wchar32_t)
    @param kind (C++: nametype_t)
    @param data (C++: void *)

Help on function is_valid_typename in module ida_name:

is_valid_typename(*args) -> 'bool'
    is_valid_typename(name) -> bool
    
    
    Is valid type name?
    
    @param name: name to test. may be NULL. (C++: const char *)

Help on function is_visible_cp in module ida_name:

is_visible_cp(*args) -> 'bool'
    is_visible_cp(cp) -> bool
    
    
    Can a character be displayed in a name? (present in ::NameChars)
    
    
    @param cp (C++: wchar32_t)

Help on function is_weak_name in module ida_name:

is_weak_name(*args) -> 'bool'
    is_weak_name(ea) -> bool

Help on function make_name_auto in module ida_name:

make_name_auto(*args) -> 'bool'
    make_name_auto(ea) -> bool

Help on function make_name_non_public in module ida_name:

make_name_non_public(*args) -> 'void'
    make_name_non_public(ea)

Help on function make_name_non_weak in module ida_name:

make_name_non_weak(*args) -> 'void'
    make_name_non_weak(ea)

Help on function make_name_public in module ida_name:

make_name_public(*args) -> 'void'
    make_name_public(ea)

Help on function make_name_user in module ida_name:

make_name_user(*args) -> 'bool'
    make_name_user(ea) -> bool

Help on function make_name_weak in module ida_name:

make_name_weak(*args) -> 'void'
    make_name_weak(ea)

Help on function rebuild_nlist in module ida_name:

rebuild_nlist(*args) -> 'void'
    rebuild_nlist()
    
    
    Rebuild names list.

Help on function reorder_dummy_names in module ida_name:

reorder_dummy_names(*args) -> 'void'
    reorder_dummy_names()
    
    
    Renumber dummy names.

Help on function set_cp_validity in module ida_name:

set_cp_validity(*args) -> 'void'
    set_cp_validity(kind, cp, endcp=wchar32_t(-1), valid=True)
    
    
    Mark the given codepoint (or range) as acceptable or unacceptable in
    the given context If 'endcp' is not BADCP, it is considered to be the
    end of the range: [cp, endcp), and is not included in the range
    
    @param kind (C++: ucdr_kind_t)
    @param cp (C++: wchar32_t)
    @param endcp (C++: wchar32_t)
    @param valid (C++: bool)

Help on function set_debug_name in module ida_name:

set_debug_name(*args) -> 'bool'
    set_debug_name(ea, name) -> bool

Help on function set_dummy_name in module ida_name:

set_dummy_name(*args) -> 'bool'
    set_dummy_name(_from, ea) -> bool
    
    
    Give an autogenerated (dummy) name. Autogenerated names have special
    prefixes (loc_...).
    
    @param _from: linear address of the operand which references to the
                  address (C++: ea_t)
    @param ea: linear address (C++: ea_t)

Help on function set_name in module ida_name:

set_name(*args) -> 'bool'
    set_name(ea, name, flags=0) -> bool
    
    
    Set or delete name of an item at the specified address. An item can be
    anything: instruction, function, data byte, word, string, structure,
    etc... Include name into the list of names.
    
    @param ea: linear address. do nothing if ea is not valid (return 0).
               tail bytes can't have names. (C++: ea_t)
    @param name: new name.   NULL: do nothing (return 0).   "" : delete
                 name.   otherwise this is a new name. (C++: const char *)
    @param flags: Set name flags . If a bit is not specified, then the
                  corresponding action is not performed and the name will
                  retain the same bits as before calling this function.
                  For new names, default is: non-public, non-weak, non-
                  auto. (C++: int)

Help on function show_name in module ida_name:

show_name(*args) -> 'void'
    show_name(ea)
    
    
    Insert name to the list of names.
    
    
    @param ea (C++: ea_t)

Help on function validate_name in module ida_name:

validate_name(*args) -> 'PyObject *'
    validate_name(name, type, flags=0) -> PyObject *
    
    
    Validate a name. This function replaces all invalid characters in the
    name with SUBSTCHAR. However, it will return false if name is valid
    but not allowed to be an identifier (is a register name).
    
    @param name: ptr to name. the name will be modified (C++: qstring  *)
    @param type: the type of name we want to validate (C++: nametype_t)
    @param flags: see SN_* . Only SN_IDBENC is currently considered (C++:
                  int)
    @return: success

=== ida_name EPYDOC INJECTIONS ===
ida_name.FUNC_IMPORT_PREFIX
"""
Name prefix used by IDA for the imported functions.
"""

ida_name.GETN_APPZERO
"""
append a struct field name if the field offset is zero?

meaningful only if the name refers to a structure.
"""

ida_name.GETN_NODUMMY
"""
do not create a new dummy name but pretend it exists
"""

ida_name.GETN_NOFIXUP
"""
ignore the fixup information when producing the name
"""

ida_name.GNCN_NOCOLOR
"""
generate an uncolored name
"""

ida_name.GNCN_NODBGNM
"""
don't use debug names
"""

ida_name.GNCN_NOFUNC
"""
don't generate funcname+... expressions
"""

ida_name.GNCN_NOLABEL
"""
don't generate labels
"""

ida_name.GNCN_NOSEG
"""
ignore the segment prefix when producing the name
"""

ida_name.GNCN_PREFDBG
"""
if using debug names, prefer debug names over function names
"""

ida_name.GNCN_REQFUNC
"""
return 0 if the address does not belong to a function
"""

ida_name.GNCN_REQNAME
"""
return 0 if the address can only be represented as a hex number
"""

ida_name.GNCN_SEGNUM
"""
segment part is displayed as a hex number
"""

ida_name.GNCN_SEG_FUNC
"""
generate both segment and function names (default is to omit segment
name if a function name is present)
"""

ida_name.GN_COLORED
"""
return colored name
"""

ida_name.GN_DEMANGLED
"""
return demangled name
"""

ida_name.GN_ISRET
"""
for dummy names: use retloc
"""

ida_name.GN_LOCAL
"""
try to get local name first; if failed, get global
"""

ida_name.GN_LONG
"""
use long form of demangled name
"""

ida_name.GN_NOT_DUMMY
"""
do not return a dummy name
"""

ida_name.GN_NOT_ISRET
"""
for dummy names: do not use retloc
"""

ida_name.GN_SHORT
"""
use short form of demangled name
"""

ida_name.GN_STRICT
"""
fail if cannot demangle
"""

ida_name.GN_VISIBLE
"""
replace forbidden characters by SUBSTCHAR
"""

ida_name.MAXNAMELEN
"""
Maximum length of a name in IDA (with the trailing zero)
"""

ida_name.NT_ABS
"""
name is absolute symbol ( 'SEG_ABSSYM' )
"""

ida_name.NT_BMASK
"""
name is a bit group mask name
"""

ida_name.NT_BYTE
"""
name is byte name (regular name)
"""

ida_name.NT_ENUM
"""
name is symbolic constant
"""

ida_name.NT_LOCAL
"""
name is local label
"""

ida_name.NT_NONE
"""
name doesn't exist or has no value
"""

ida_name.NT_REGVAR
"""
name is a renamed register (*value is idx into pfn->regvars)
"""

ida_name.NT_SEG
"""
name is segment or segment register name
"""

ida_name.NT_STKVAR
"""
name is stack variable name
"""

ida_name.NT_STROFF
"""
name is structure member
"""

ida_name.SN_AUTO
"""
if set, make name autogenerated
"""

ida_name.SN_DELTAIL
"""
delete the hindering item

if name cannot be set because of a tail byte,
"""

ida_name.SN_FORCE
"""
if the specified name is already present in the database, try
variations with a numerical suffix like "_123"
"""

ida_name.SN_IDBENC
"""
the name is given in the IDB encoding; non-ASCII bytes will be decoded
accordingly. Specifying SN_IDBENC also implies SN_NODUMMY
"""

ida_name.SN_LOCAL
"""
create local name. a function should exist. local names can't be
public or weak. also they are not included into the list of names they
can't have dummy prefixes.
"""

ida_name.SN_NOCHECK
"""
Don't fail if the name contains invalid characters. If this bit is
clear, all invalid chars (those !is_ident_cp()) will be replaced by
SUBSTCHAR List of valid characters is defined in ida.cfg
"""

ida_name.SN_NODUMMY
"""
automatically prepend the name with '_' if it begins with a dummy
suffix such as 'sub_'. See also SN_IDBENC
"""

ida_name.SN_NOLIST
"""
if set, exclude name from the list. if not set, then include the name
into the list (however, if other bits are set, the name might be
immediately excluded from the list).
"""

ida_name.SN_NON_AUTO
"""
if set, make name non-autogenerated
"""

ida_name.SN_NON_PUBLIC
"""
if set, make name non-public
"""

ida_name.SN_NON_WEAK
"""
if set, make name non-weak
"""

ida_name.SN_NOWARN
"""
don't display a warning if failed
"""

ida_name.SN_PUBLIC
"""
if set, make name public
"""

ida_name.SN_WEAK
"""
if set, make name weak
"""
=== ida_name EPYDOC INJECTIONS END ===
Help on function exist in module ida_netnode:

exist(*args) -> 'bool'
    exist(n) -> bool

Help on class netnode in module ida_netnode:

class netnode(builtins.object)
 |  Proxy of C++ netnode class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, n) -> bool
 |      __eq__(self, x) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> netnode
 |      __init__(self, num) -> netnode
 |      __init__(self, _name, namlen=0, do_create=False) -> netnode
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, n) -> bool
 |      __ne__(self, x) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_netnode(...)
 |      delete_netnode(self)
 |  
 |  altdel(self, *args) -> 'bool'
 |      altdel(self, alt, tag=atag) -> bool
 |      altdel(self) -> bool
 |  
 |  altdel_all(self, *args) -> 'bool'
 |      altdel_all(self, tag) -> bool
 |  
 |  altdel_ea(self, *args) -> 'bool'
 |      altdel_ea(self, ea, tag=atag) -> bool
 |  
 |  altdel_idx8(self, *args) -> 'bool'
 |      altdel_idx8(self, alt, tag) -> bool
 |  
 |  altfirst(self, *args) -> 'nodeidx_t'
 |      altfirst(self, tag=atag) -> nodeidx_t
 |  
 |  altfirst_idx8(self, *args) -> 'nodeidx_t'
 |      altfirst_idx8(self, tag) -> nodeidx_t
 |  
 |  altlast(self, *args) -> 'nodeidx_t'
 |      altlast(self, tag=atag) -> nodeidx_t
 |  
 |  altlast_idx8(self, *args) -> 'nodeidx_t'
 |      altlast_idx8(self, tag) -> nodeidx_t
 |  
 |  altnext(self, *args) -> 'nodeidx_t'
 |      altnext(self, cur, tag=atag) -> nodeidx_t
 |  
 |  altnext_idx8(self, *args) -> 'nodeidx_t'
 |      altnext_idx8(self, cur, tag) -> nodeidx_t
 |  
 |  altprev(self, *args) -> 'nodeidx_t'
 |      altprev(self, cur, tag=atag) -> nodeidx_t
 |  
 |  altprev_idx8(self, *args) -> 'nodeidx_t'
 |      altprev_idx8(self, cur, tag) -> nodeidx_t
 |  
 |  altset(self, *args) -> 'bool'
 |      altset(self, alt, value, tag=atag) -> bool
 |  
 |  altset_ea(self, *args) -> 'bool'
 |      altset_ea(self, ea, value, tag=atag) -> bool
 |  
 |  altset_idx8(self, *args) -> 'bool'
 |      altset_idx8(self, alt, val, tag) -> bool
 |  
 |  altshift(self, *args) -> 'size_t'
 |      altshift(self, _from, to, size, tag=atag) -> size_t
 |  
 |  altval(self, *args) -> 'nodeidx_t'
 |      altval(self, alt, tag=atag) -> nodeidx_t
 |  
 |  altval_ea(self, *args) -> 'nodeidx_t'
 |      altval_ea(self, ea, tag=atag) -> nodeidx_t
 |  
 |  altval_idx8(self, *args) -> 'nodeidx_t'
 |      altval_idx8(self, alt, tag) -> nodeidx_t
 |  
 |  blobsize(self, *args) -> 'size_t'
 |      blobsize(self, _start, tag) -> size_t
 |  
 |  blobsize_ea(self, *args) -> 'size_t'
 |      blobsize_ea(self, ea, tag) -> size_t
 |  
 |  chardel(self, *args) -> 'bool'
 |      chardel(self, alt, tag) -> bool
 |  
 |  chardel_ea(self, *args) -> 'bool'
 |      chardel_ea(self, ea, tag) -> bool
 |  
 |  chardel_idx8(self, *args) -> 'bool'
 |      chardel_idx8(self, alt, tag) -> bool
 |  
 |  charfirst(self, *args) -> 'nodeidx_t'
 |      charfirst(self, tag) -> nodeidx_t
 |  
 |  charfirst_idx8(self, *args) -> 'nodeidx_t'
 |      charfirst_idx8(self, tag) -> nodeidx_t
 |  
 |  charlast(self, *args) -> 'nodeidx_t'
 |      charlast(self, tag) -> nodeidx_t
 |  
 |  charlast_idx8(self, *args) -> 'nodeidx_t'
 |      charlast_idx8(self, tag) -> nodeidx_t
 |  
 |  charnext(self, *args) -> 'nodeidx_t'
 |      charnext(self, cur, tag) -> nodeidx_t
 |  
 |  charnext_idx8(self, *args) -> 'nodeidx_t'
 |      charnext_idx8(self, cur, tag) -> nodeidx_t
 |  
 |  charprev(self, *args) -> 'nodeidx_t'
 |      charprev(self, cur, tag) -> nodeidx_t
 |  
 |  charprev_idx8(self, *args) -> 'nodeidx_t'
 |      charprev_idx8(self, cur, tag) -> nodeidx_t
 |  
 |  charset(self, *args) -> 'bool'
 |      charset(self, alt, val, tag) -> bool
 |  
 |  charset_ea(self, *args) -> 'bool'
 |      charset_ea(self, ea, val, tag) -> bool
 |  
 |  charset_idx8(self, *args) -> 'bool'
 |      charset_idx8(self, alt, val, tag) -> bool
 |  
 |  charshift(self, *args) -> 'size_t'
 |      charshift(self, _from, to, size, tag) -> size_t
 |  
 |  charval(self, *args) -> 'uchar'
 |      charval(self, alt, tag) -> uchar
 |  
 |  charval_ea(self, *args) -> 'uchar'
 |      charval_ea(self, ea, tag) -> uchar
 |  
 |  charval_idx8(self, *args) -> 'uchar'
 |      charval_idx8(self, alt, tag) -> uchar
 |  
 |  copyto(self, *args) -> 'size_t'
 |      copyto(self, target, count=1) -> size_t
 |  
 |  create(self, *args) -> 'bool'
 |      create(self, _name, namlen=0) -> bool
 |      create(self) -> bool
 |  
 |  delblob(self, *args) -> 'int'
 |      delblob(self, _start, tag) -> int
 |  
 |  delblob_ea(self, *args) -> 'int'
 |      delblob_ea(self, ea, tag) -> int
 |  
 |  delvalue(self, *args) -> 'bool'
 |      delvalue(self) -> bool
 |  
 |  eadel(self, *args) -> 'bool'
 |      eadel(self, ea, tag) -> bool
 |  
 |  eadel_idx8(self, *args) -> 'bool'
 |      eadel_idx8(self, idx, tag) -> bool
 |  
 |  eaget(self, *args) -> 'ea_t'
 |      eaget(self, ea, tag) -> ea_t
 |  
 |  eaget_idx(self, *args) -> 'ea_t'
 |      eaget_idx(self, idx, tag) -> ea_t
 |  
 |  eaget_idx8(self, *args) -> 'ea_t'
 |      eaget_idx8(self, idx, tag) -> ea_t
 |  
 |  easet(self, *args) -> 'bool'
 |      easet(self, ea, addr, tag) -> bool
 |  
 |  easet_idx(self, *args) -> 'bool'
 |      easet_idx(self, idx, addr, tag) -> bool
 |  
 |  easet_idx8(self, *args) -> 'bool'
 |      easet_idx8(self, idx, addr, tag) -> bool
 |  
 |  end(self, *args) -> 'bool'
 |      end(self) -> bool
 |  
 |  get_name(self, *args) -> 'ssize_t'
 |      get_name(self) -> ssize_t
 |  
 |  getblob(self, *args) -> 'PyObject *'
 |      getblob(self, start, tag) -> PyObject *
 |  
 |  getblob_ea(self, *args) -> 'PyObject *'
 |      getblob_ea(self, ea, tag) -> PyObject *
 |  
 |  getclob(self, *args) -> 'PyObject *'
 |      getclob(self, start, tag) -> PyObject *
 |  
 |  hashdel(self, *args) -> 'bool'
 |      hashdel(self, idx, tag=htag) -> bool
 |  
 |  hashdel_all(self, *args) -> 'bool'
 |      hashdel_all(self, tag=htag) -> bool
 |  
 |  hashfirst(self, *args) -> 'ssize_t'
 |      hashfirst(self, tag=htag) -> ssize_t
 |  
 |  hashlast(self, *args) -> 'ssize_t'
 |      hashlast(self, tag=htag) -> ssize_t
 |  
 |  hashnext(self, *args) -> 'ssize_t'
 |      hashnext(self, idx, tag=htag) -> ssize_t
 |  
 |  hashprev(self, *args) -> 'ssize_t'
 |      hashprev(self, idx, tag=htag) -> ssize_t
 |  
 |  hashset(self, *args) -> 'bool'
 |      hashset(self, idx, value, tag=htag) -> bool
 |  
 |  hashset_buf(self, *args) -> 'bool'
 |      hashset_buf(self, idx, py_str, tag=htag) -> bool
 |  
 |  hashset_idx(self, *args) -> 'bool'
 |      hashset_idx(self, idx, value, tag=htag) -> bool
 |  
 |  hashstr(self, *args) -> 'ssize_t'
 |      hashstr(self, idx, tag=htag) -> ssize_t
 |  
 |  hashstr_buf(self, *args) -> 'PyObject *'
 |      hashstr_buf(self, idx, tag=htag) -> PyObject *
 |  
 |  hashval(self, *args) -> 'ssize_t'
 |      hashval(self, idx, tag=htag) -> ssize_t
 |  
 |  hashval_long(self, *args) -> 'nodeidx_t'
 |      hashval_long(self, idx, tag=htag) -> nodeidx_t
 |  
 |  index(self, *args) -> 'nodeidx_t'
 |      index(self) -> nodeidx_t
 |  
 |  kill(self, *args) -> 'void'
 |      kill(self)
 |  
 |  long_value(self, *args) -> 'nodeidx_t'
 |      long_value(self) -> nodeidx_t
 |  
 |  lower_bound(self, *args) -> 'nodeidx_t'
 |      lower_bound(self, cur, tag=stag) -> nodeidx_t
 |  
 |  lower_bound_ea(self, *args) -> 'nodeidx_t'
 |      lower_bound_ea(self, ea, tag=stag) -> nodeidx_t
 |  
 |  lower_bound_idx8(self, *args) -> 'nodeidx_t'
 |      lower_bound_idx8(self, alt, tag) -> nodeidx_t
 |  
 |  moveto(self, *args) -> 'size_t'
 |      moveto(self, target, count=1) -> size_t
 |  
 |  next(self, *args) -> 'bool'
 |      next(self) -> bool
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self) -> bool
 |  
 |  rename(self, *args) -> 'bool'
 |      rename(self, newname, namlen=0) -> bool
 |  
 |  set(self, *args) -> 'bool'
 |      set(self, value) -> bool
 |  
 |  set_long(self, *args) -> 'bool'
 |      set_long(self, x) -> bool
 |  
 |  setblob(self, *args) -> 'bool'
 |      setblob(self, buf, _start, tag) -> bool
 |  
 |  setblob_ea(self, *args) -> 'bool'
 |      setblob_ea(self, buf, ea, tag) -> bool
 |  
 |  start(self, *args) -> 'bool'
 |      start(self) -> bool
 |  
 |  supdel(self, *args) -> 'bool'
 |      supdel(self, alt, tag=stag) -> bool
 |      supdel(self) -> bool
 |  
 |  supdel_all(self, *args) -> 'bool'
 |      supdel_all(self, tag) -> bool
 |  
 |  supdel_ea(self, *args) -> 'bool'
 |      supdel_ea(self, ea, tag=stag) -> bool
 |  
 |  supdel_idx8(self, *args) -> 'bool'
 |      supdel_idx8(self, alt, tag) -> bool
 |  
 |  supdel_range(self, *args) -> 'int'
 |      supdel_range(self, idx1, idx2, tag) -> int
 |  
 |  supdel_range_idx8(self, *args) -> 'int'
 |      supdel_range_idx8(self, idx1, idx2, tag) -> int
 |  
 |  supfirst(self, *args) -> 'nodeidx_t'
 |      supfirst(self, tag=stag) -> nodeidx_t
 |  
 |  supfirst_idx8(self, *args) -> 'nodeidx_t'
 |      supfirst_idx8(self, tag) -> nodeidx_t
 |  
 |  suplast(self, *args) -> 'nodeidx_t'
 |      suplast(self, tag=stag) -> nodeidx_t
 |  
 |  suplast_idx8(self, *args) -> 'nodeidx_t'
 |      suplast_idx8(self, tag) -> nodeidx_t
 |  
 |  supnext(self, *args) -> 'nodeidx_t'
 |      supnext(self, cur, tag=stag) -> nodeidx_t
 |  
 |  supnext_idx8(self, *args) -> 'nodeidx_t'
 |      supnext_idx8(self, alt, tag) -> nodeidx_t
 |  
 |  supprev(self, *args) -> 'nodeidx_t'
 |      supprev(self, cur, tag=stag) -> nodeidx_t
 |  
 |  supprev_idx8(self, *args) -> 'nodeidx_t'
 |      supprev_idx8(self, alt, tag) -> nodeidx_t
 |  
 |  supset(self, *args) -> 'bool'
 |      supset(self, alt, value, tag=stag) -> bool
 |      supset(self, alt, value, tag=stag) -> bool
 |  
 |  supset_ea(self, *args) -> 'bool'
 |      supset_ea(self, ea, value, tag=stag) -> bool
 |      supset_ea(self, ea, value, tag=stag) -> bool
 |  
 |  supset_idx8(self, *args) -> 'bool'
 |      supset_idx8(self, alt, value, tag) -> bool
 |  
 |  supshift(self, *args) -> 'size_t'
 |      supshift(self, _from, to, size, tag=stag) -> size_t
 |  
 |  supstr(self, *args) -> 'ssize_t'
 |      supstr(self, alt, tag=stag) -> ssize_t
 |  
 |  supstr_ea(self, *args) -> 'ssize_t'
 |      supstr_ea(self, ea, tag=stag) -> ssize_t
 |  
 |  supstr_idx8(self, *args) -> 'ssize_t'
 |      supstr_idx8(self, alt, tag) -> ssize_t
 |  
 |  supval(self, *args) -> 'ssize_t'
 |      supval(self, alt, tag=stag) -> ssize_t
 |  
 |  supval_ea(self, *args) -> 'ssize_t'
 |      supval_ea(self, ea, tag=stag) -> ssize_t
 |  
 |  supval_idx8(self, *args) -> 'ssize_t'
 |      supval_idx8(self, alt, tag) -> ssize_t
 |  
 |  valobj(self, *args) -> 'ssize_t'
 |      valobj(self) -> ssize_t
 |  
 |  valstr(self, *args) -> 'ssize_t'
 |      valstr(self) -> ssize_t
 |  
 |  value_exists(self, *args) -> 'bool'
 |      value_exists(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

=== ida_netnode EPYDOC INJECTIONS ===
ida_netnode.BADNODE
"""
A number to represent a bad netnode reference.
"""
=== ida_netnode EPYDOC INJECTIONS END ===
Help on function add_refinfo_dref in module ida_offset:

add_refinfo_dref(*args) -> 'ea_t'
    add_refinfo_dref(insn, _from, ri, opval, type, opoff) -> ea_t
    
    
    Add xrefs for a reference from the given instruction (\insn_t{ea}).
    This function creates a cross references to the target and the base.
    'insn_t::add_off_drefs()' calls this function to create xrefs for
    'offset' operand.
    
    @param insn: the referencing instruction (C++: const  insn_t  &)
    @param _from: the referencing instruction/data address (C++: ea_t)
    @param ri: reference info block from the database (C++: const
               refinfo_t  &)
    @param opval: operand value (usually  op_t::value  or  op_t::addr )
                  (C++: adiff_t)
    @param type: type of xref (C++: dref_t)
    @param opoff: offset of the operand from the start of instruction
                  (C++: int)
    @return: the target address of the reference

Help on function calc_basevalue in module ida_offset:

calc_basevalue(*args) -> 'ea_t'
    calc_basevalue(target, base) -> ea_t
    
    
    Calculate the value of the reference base.
    
    
    @param target (C++: ea_t)
    @param base (C++: ea_t)

Help on function calc_offset_base in module ida_offset:

calc_offset_base(*args) -> 'ea_t'
    calc_offset_base(ea, n) -> ea_t
    
    
    Try to calculate the offset base This function takes into account the
    fixup information, current ds and cs values.
    
    @param ea: the referencing instruction/data address (C++: ea_t)
    @param n: operand number   0: first operand   1: other operand (C++:
              int)
    @return: output base address or  BADADDR

Help on function calc_probable_base_by_value in module ida_offset:

calc_probable_base_by_value(*args) -> 'ea_t'
    calc_probable_base_by_value(ea, off) -> ea_t
    
    
    Try to calculate the offset base. 2 bases are checked: current ds and
    cs. If fails, return 'BADADDR'
    
    @param ea (C++: ea_t)
    @param off (C++: uval_t)

Help on function calc_reference_data in module ida_offset:

calc_reference_data(*args) -> 'bool'
    calc_reference_data(target, base, _from, ri, opval) -> bool
    
    
    Calculate the target and base addresses of an offset expression. The
    calculated target and base addresses are returned in the locations
    pointed by 'base' and 'target'. In case 'ri.base' is 'BADADDR' , the
    function calculates the offset base address from the referencing
    instruction/data address. The target address is copied from ri.target.
    If ri.target is 'BADADDR' then the target is calculated using the base
    address and 'opval'. This function also checks if 'opval' matches the
    full value of the reference and takes in account the memory-mapping.
    
    @param target: output target address (C++: ea_t *)
    @param base: output base address (C++: ea_t *)
    @param _from: the referencing instruction/data address (C++: ea_t)
    @param ri: reference info block from the database (C++: const
               refinfo_t  &)
    @param opval: operand value (usually  op_t::value  or  op_t::addr )
                  (C++: adiff_t)
    @return: success

Help on function calc_target in module ida_offset:

calc_target(*args) -> 'ea_t'
    calc_target(_from, opval, ri) -> ea_t
    calc_target(_from, ea, n, opval) -> ea_t
    
    
    Calculates the target, using the provided 'refinfo_t' .
    
    
    @param _from (C++: ea_t)
    @param opval (C++: adiff_t)
    @param ri (C++: const  refinfo_t  &)

Help on function can_be_off32 in module ida_offset:

can_be_off32(*args) -> 'ea_t'
    can_be_off32(ea) -> ea_t
    
    
    Does the specified address contain a valid OFF32 value?. For symbols
    in special segments the displacement is not taken into account. If
    yes, then the target address of OFF32 will be returned. If not, then
    'BADADDR' is returned.
    
    @param ea (C++: ea_t)

Help on function get_default_reftype in module ida_offset:

get_default_reftype(*args) -> 'reftype_t'
    get_default_reftype(ea) -> reftype_t
    
    
    Get default reference type depending on the segment.
    
    @param ea (C++: ea_t)
    @return: one of  REF_OFF8 , REF_OFF16 , REF_OFF32

Help on function get_offbase in module ida_offset:

get_offbase(*args) -> 'ea_t'
    get_offbase(ea, n) -> ea_t
    
    
    Get offset base value
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (C++: int)
    @return: offset base or  BADADDR

Help on function get_offset_expr in module ida_offset:

get_offset_expr(*args) -> 'qstring *'
    get_offset_expr(ea, n, ri, _from, offset, getn_flags=0) -> str
    
    
    See 'get_offset_expression()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)
    @param ri (C++: const  refinfo_t  &)
    @param _from (C++: ea_t)
    @param offset (C++: adiff_t)
    @param getn_flags (C++: int)

Help on function get_offset_expression in module ida_offset:

get_offset_expression(*args) -> 'qstring *'
    get_offset_expression(ea, n, _from, offset, getn_flags=0) -> str
    
    
    Get offset expression (in the form "offset name+displ"). This function
    uses offset translation function (\ph{translate}) if your IDP module
    has such a function. Translation function is used to map linear
    addresses in the program (only for offsets).Example: suppose we have
    instruction at linear address 0x00011000: \v{mov ax, [bx+7422h]} and
    at ds:7422h: \v{array dw ...} We want to represent the second operand
    with an offset expression, so then we call: \v{
    get_offset_expresion(0x001100, 1, 0x001102, 0x7422, buf); | | | | | |
    | | | +output buffer | | | +value of offset expression | | +address
    offset value in the instruction | +the second operand +address of
    instruction } and the function will return a colored string: \v{offset
    array}
    
    @param ea: start of instruction or data with the offset expression
               (C++: ea_t)
    @param n: number of operand (may be ORed with  OPND_OUTER )   0: first
              operand   1: second operand (C++: int)
    @param _from: linear address of instruction operand or data referring
                  to the name. This address will be used to get fixup
                  information, so it should point to exact position of
                  operand in the instruction. (C++: ea_t)
    @param offset: value of operand or its part. The function will return
                   text representation of this value as offset expression.
                   (C++: adiff_t)
    @param getn_flags: combination of:   GETN_APPZERO : meaningful only if
                       the name refers to a structure. appends the struct
                       field name if the field offset is zero
                       GETN_NODUMMY : do not generate dummy names for the
                       expression but pretend they already exist (useful
                       to verify that the offset expression can be
                       represented) (C++: int)

Help on function op_offset in module ida_offset:

op_offset(*args) -> 'int'
    op_offset(ea, n, type, target=BADADDR, base=0, tdelta=0) -> int
    
    
    See 'op_offset_ex()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)
    @param type (C++: reftype_t)
    @param target (C++: ea_t)
    @param base (C++: ea_t)
    @param tdelta (C++: adiff_t)

Help on function op_offset_ex in module ida_offset:

op_offset_ex(*args) -> 'int'
    op_offset_ex(ea, n, ri) -> int
    
    
    Convert operand to a reference. To delete an offset, use
    'clr_op_type()' function.
    
    @param ea: linear address. if 'ea' has unexplored bytes, try to
               convert them to   no segment: fail   16bit segment: to
               16bit word data   32bit segment: to dword (C++: ea_t)
    @param n: number of operand (may be ORed with  OPND_OUTER )   0: first
              1: second   2: third   OPND_MASK : all operands (C++: int)
    @param ri: reference information (C++: const  refinfo_t  *)
    @return: success

Help on function op_plain_offset in module ida_offset:

op_plain_offset(*args) -> 'bool'
    op_plain_offset(ea, n, base) -> bool
    
    
    Convert operand to a reference with the default reference type.
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)
    @param base (C++: ea_t)

Help on class __qmutex_t in module ida_pro:

class __qmutex_t(builtins.object)
 |  Proxy of C++ __qmutex_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qmutex_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete___qmutex_t(...)
 |      delete___qmutex_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class __qsemaphore_t in module ida_pro:

class __qsemaphore_t(builtins.object)
 |  Proxy of C++ __qsemaphore_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qsemaphore_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete___qsemaphore_t(...)
 |      delete___qsemaphore_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class __qthread_t in module ida_pro:

class __qthread_t(builtins.object)
 |  Proxy of C++ __qthread_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qthread_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete___qthread_t(...)
 |      delete___qthread_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class _qstrvec_t in module ida_pro:

class _qstrvec_t(ida_idaapi.py_clinked_object_t)
 |  WARNING: It is very unlikely an IDAPython user should ever, ever
 |  have to use this type. It should only be used for IDAPython internals.
 |  
 |  For example, in py_askusingform.py, we ctypes-expose to the IDA
 |  kernel & UI a qstrvec instance, in case a DropdownListControl is
 |  constructed.
 |  That's because that's what ask_form expects, and we have no
 |  choice but to make a DropdownListControl hold a qstrvec_t.
 |  This is, afaict, the only situation where a Python
 |  _qstrvec_t is required.
 |  
 |  Method resolution order:
 |      _qstrvec_t
 |      ida_idaapi.py_clinked_object_t
 |      ida_idaapi.pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, idx)
 |      Gets the string at the given index
 |  
 |  __init__(self, items=None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __setitem__(self, idx, s)
 |      Sets string at the given index
 |  
 |  _create_clink(self)
 |      Overwrite me.
 |      Creates a new clink
 |      @return: PyCapsule representing the C link
 |  
 |  _del_clink(self, lnk)
 |      Overwrite me.
 |      This method deletes the link
 |  
 |  _get_clink_ptr(self)
 |      Overwrite me.
 |      Returns the C link pointer as a 64bit number
 |  
 |  _qstrvec_t__get_size = __get_size(self)
 |  
 |  add(self, s)
 |      Add a string to the vector
 |  
 |  addressof(self, idx)
 |      Returns the address (as number) of the qstring at the given index
 |  
 |  assign(self, other)
 |      Copies the contents of 'other' to 'self'
 |  
 |  clear(self, qclear=False)
 |      Clears all strings from the vector.
 |      @param qclear: Just reset the size but do not actually free the memory
 |  
 |  from_list(self, lst)
 |      Populates the vector from a Python string list
 |  
 |  insert(self, idx, s)
 |      Insert a string into the vector
 |  
 |  remove(self, idx)
 |      Removes a string from the vector
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  size
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  __del__(self)
 |      Delete the link upon object destruction (only if not static)
 |  
 |  _free(self)
 |      Explicitly delete the link (only if not static)
 |  
 |  copy(self)
 |      Returns a new copy of this class
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  clink
 |  
 |  clink_ptr
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on class boolvec_t in module ida_pro:

class boolvec_t(builtins.object)
 |  Proxy of C++ qvector< bool > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'bool const &'
 |      __getitem__(self, i) -> bool const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> boolvec_t
 |      __init__(self, x) -> boolvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_boolvec_t(...)
 |      delete_boolvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'bool &'
 |  
 |  at = __getitem__(self, *args) -> 'bool const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< bool >::const_iterator'
 |      begin(self) -> qvector< bool >::iterator
 |      begin(self) -> qvector< bool >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< bool >::const_iterator'
 |      end(self) -> qvector< bool >::iterator
 |      end(self) -> qvector< bool >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< bool >::iterator'
 |      erase(self, it) -> qvector< bool >::iterator
 |      erase(self, first, last) -> qvector< bool >::iterator
 |  
 |  extract(self, *args) -> 'bool *'
 |      extract(self) -> bool *
 |  
 |  find(self, *args) -> 'qvector< bool >::const_iterator'
 |      find(self, x) -> qvector< bool >::iterator
 |      find(self, x) -> qvector< bool >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=bool())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< bool >::iterator'
 |      insert(self, it, x) -> qvector< bool >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'bool &'
 |      push_back(self, x)
 |      push_back(self) -> bool &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class channel_redir_t in module ida_pro:

class channel_redir_t(builtins.object)
 |  Proxy of C++ channel_redir_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> channel_redir_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_channel_redir_t(...)
 |      delete_channel_redir_t(self)
 |  
 |  is_append(self, *args) -> 'bool'
 |      is_append(self) -> bool
 |  
 |  is_input(self, *args) -> 'bool'
 |      is_input(self) -> bool
 |  
 |  is_output(self, *args) -> 'bool'
 |      is_output(self) -> bool
 |  
 |  is_quoted(self, *args) -> 'bool'
 |      is_quoted(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fd
 |      channel_redir_t_fd_get(self) -> int
 |  
 |  file
 |      channel_redir_t_file_get(self) -> qstring *
 |  
 |  flags
 |      channel_redir_t_flags_get(self) -> int
 |  
 |  length
 |      channel_redir_t_length_get(self) -> int
 |  
 |  start
 |      channel_redir_t_start_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on function check_process_exit in module ida_pro:

check_process_exit(*args) -> 'int'
    check_process_exit(handle, exit_code, msecs=-1) -> int
    
    
    Check whether process has terminated or not.
    
    @param handle: process handle to wait for (C++: void *)
    @param exit_code: pointer to the buffer for the exit code (C++: int *)

Help on function clear_bits in module ida_pro:

clear_bits(*args) -> 'void'
    clear_bits(bitmap, low, high)
    
    
    Clear bits between [low, high) in 'bitmap'.
    
    
    @param bitmap (C++: uchar  *)
    @param low (C++: size_t)
    @param high (C++: size_t)

Help on class ea_array in module ida_pro:

class ea_array(builtins.object)
 |  Proxy of C++ ea_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'ea_t'
 |      __getitem__(self, index) -> ea_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> ea_array
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, index, value)
 |  
 |  __swig_destroy__ = delete_ea_array(...)
 |      delete_ea_array(self)
 |  
 |  cast(self, *args) -> 'ea_t *'
 |      cast(self) -> ea_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'ea_array *'
 |      frompointer(t) -> ea_array
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function ea_array_frompointer in module ida_pro:

ea_array_frompointer(*args) -> 'ea_array *'
    ea_array_frompointer(t) -> ea_array

Help on class ea_pointer in module ida_pro:

class ea_pointer(builtins.object)
 |  Proxy of C++ ea_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ea_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ea_pointer(...)
 |      delete_ea_pointer(self)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, value)
 |  
 |  cast(self, *args) -> 'ea_t *'
 |      cast(self) -> ea_t *
 |  
 |  value(self, *args) -> 'ea_t'
 |      value(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'ea_pointer *'
 |      frompointer(t) -> ea_pointer
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function ea_pointer_frompointer in module ida_pro:

ea_pointer_frompointer(*args) -> 'ea_pointer *'
    ea_pointer_frompointer(t) -> ea_pointer

Help on function extend_sign in module ida_pro:

extend_sign(*args) -> 'uint64'
    extend_sign(v, nbytes, sign_extend) -> uint64
    
    
    Sign-, or zero-extend the value 'v' to occupy 64 bits. The value 'v'
    is considered to be of size 'nbytes'.
    
    @param v (C++: uint64)
    @param nbytes (C++: int)
    @param sign_extend (C++: bool)

Help on class instant_dbgopts_t in module ida_pro:

class instant_dbgopts_t(builtins.object)
 |  Proxy of C++ instant_dbgopts_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> instant_dbgopts_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_instant_dbgopts_t(...)
 |      delete_instant_dbgopts_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  _pass
 |      instant_dbgopts_t__pass_get(self) -> qstring *
 |  
 |  attach
 |      instant_dbgopts_t_attach_get(self) -> bool
 |  
 |  debmod
 |      instant_dbgopts_t_debmod_get(self) -> qstring *
 |  
 |  env
 |      instant_dbgopts_t_env_get(self) -> qstring *
 |  
 |  event_id
 |      instant_dbgopts_t_event_id_get(self) -> int
 |  
 |  host
 |      instant_dbgopts_t_host_get(self) -> qstring *
 |  
 |  pid
 |      instant_dbgopts_t_pid_get(self) -> int
 |  
 |  port
 |      instant_dbgopts_t_port_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on class longlongvec_t in module ida_pro:

class longlongvec_t(builtins.object)
 |  Proxy of C++ qvector< long long > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'long long const &'
 |      __getitem__(self, i) -> long long const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> longlongvec_t
 |      __init__(self, x) -> longlongvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_longlongvec_t(...)
 |      delete_longlongvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'long long &'
 |  
 |  at = __getitem__(self, *args) -> 'long long const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< long long >::const_iterator'
 |      begin(self) -> qvector< long long >::iterator
 |      begin(self) -> qvector< long long >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< long long >::const_iterator'
 |      end(self) -> qvector< long long >::iterator
 |      end(self) -> qvector< long long >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< long long >::iterator'
 |      erase(self, it) -> qvector< long long >::iterator
 |      erase(self, first, last) -> qvector< long long >::iterator
 |  
 |  extract(self, *args) -> 'long long *'
 |      extract(self) -> long long *
 |  
 |  find(self, *args) -> 'qvector< long long >::const_iterator'
 |      find(self, x) -> qvector< long long >::iterator
 |      find(self, x) -> qvector< long long >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< long long >::iterator'
 |      insert(self, it, x) -> qvector< long long >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'long long &'
 |      push_back(self, x)
 |      push_back(self) -> long long &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class int_pointer in module ida_pro:

class int_pointer(builtins.object)
 |  Proxy of C++ int_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> int_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_int_pointer(...)
 |      delete_int_pointer(self)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, value)
 |  
 |  cast(self, *args) -> 'int *'
 |      cast(self) -> int *
 |  
 |  value(self, *args) -> 'int'
 |      value(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'int_pointer *'
 |      frompointer(t) -> int_pointer
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function int_pointer_frompointer in module ida_pro:

int_pointer_frompointer(*args) -> 'int_pointer *'
    int_pointer_frompointer(t) -> int_pointer

Help on class intvec_t in module ida_pro:

class intvec_t(builtins.object)
 |  Proxy of C++ qvector< int > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'int const &'
 |      __getitem__(self, i) -> int const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> intvec_t
 |      __init__(self, x) -> intvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_intvec_t(...)
 |      delete_intvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'int &'
 |  
 |  at = __getitem__(self, *args) -> 'int const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< int >::const_iterator'
 |      begin(self) -> qvector< int >::iterator
 |      begin(self) -> qvector< int >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< int >::const_iterator'
 |      end(self) -> qvector< int >::iterator
 |      end(self) -> qvector< int >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< int >::iterator'
 |      erase(self, it) -> qvector< int >::iterator
 |      erase(self, first, last) -> qvector< int >::iterator
 |  
 |  extract(self, *args) -> 'int *'
 |      extract(self) -> int *
 |  
 |  find(self, *args) -> 'qvector< int >::const_iterator'
 |      find(self, x) -> qvector< int >::iterator
 |      find(self, x) -> qvector< int >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< int >::iterator'
 |      insert(self, it, x) -> qvector< int >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'int &'
 |      push_back(self, x)
 |      push_back(self) -> int &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function is_control_tty in module ida_pro:

is_control_tty(*args) -> 'enum tty_control_t'
    is_control_tty(fd) -> enum tty_control_t
    
    
    Check if the current process is the owner of the TTY specified by 'fd'
    (typically an opened descriptor to /dev/tty).
    
    @param fd (C++: int)

Help on function is_main_thread in module ida_pro:

is_main_thread(*args) -> 'bool'
    is_main_thread() -> bool
    
    
    Are we running in the main thread?

Help on function log2ceil in module ida_pro:

log2ceil(*args) -> 'int'
    log2ceil(d64) -> int
    
    
    calculate ceil(log2(d64)) or floor(log2(d64)), it returns 0 if d64 ==
    0
    
    @param d64 (C++: uint64)

Help on function log2floor in module ida_pro:

log2floor(*args) -> 'int'
    log2floor(d64) -> int

Help on function parse_dbgopts in module ida_pro:

parse_dbgopts(*args) -> 'bool'
    parse_dbgopts(ido, r_switch) -> bool
    
    
    Parse the -r command line switch (for instant debugging). r_switch
    points to the value of the -r switch. Example: win32@localhost+
    
    @param ido (C++: struct  instant_dbgopts_t  *)
    @param r_switch (C++: const char *)
    @return: true-ok, false-parse error

Help on function qatoll in module ida_pro:

qatoll(*args) -> 'int64'
    qatoll(nptr) -> int64

Help on function qcontrol_tty in module ida_pro:

qcontrol_tty(*args) -> 'void'
    qcontrol_tty()
    
    
    Make the current terminal the controlling terminal of the calling
    process.The current terminal is supposed to be /dev/tty

Help on function qdetach_tty in module ida_pro:

qdetach_tty(*args) -> 'void'
    qdetach_tty()
    
    
    If the current terminal is the controlling terminal of the calling
    process, give up this controlling terminal.The current terminal is
    supposed to be /dev/tty

Help on function qexit in module ida_pro:

qexit(*args) -> 'void'
    qexit(code)
    
    
    Call qatexit functions, shut down UI and kernel, and exit.
    
    @param code: exit code (C++: int)

Help on class qmutex_locker_t in module ida_pro:

class qmutex_locker_t(builtins.object)
 |  Proxy of C++ qmutex_locker_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _lock) -> qmutex_locker_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qmutex_locker_t(...)
 |      delete_qmutex_locker_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class qrefcnt_obj_t in module ida_pro:

class qrefcnt_obj_t(builtins.object)
 |  Proxy of C++ qrefcnt_obj_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qrefcnt_obj_t(...)
 |      delete_qrefcnt_obj_t(self)
 |  
 |  release(self, *args) -> 'void'
 |      release(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  refcnt
 |      qrefcnt_obj_t_refcnt_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on function qstrvec_t_add in module ida_pro:

qstrvec_t_add(*args) -> 'bool'
    qstrvec_t_add(_self, s) -> bool

Help on function qstrvec_t_addressof in module ida_pro:

qstrvec_t_addressof(*args) -> 'PyObject *'
    qstrvec_t_addressof(_self, idx) -> PyObject *

Help on function qstrvec_t_assign in module ida_pro:

qstrvec_t_assign(*args) -> 'bool'
    qstrvec_t_assign(_self, other) -> bool

Help on function qstrvec_t_clear in module ida_pro:

qstrvec_t_clear(*args) -> 'bool'
    qstrvec_t_clear(_self, qclear) -> bool

Help on function qstrvec_t_create in module ida_pro:

qstrvec_t_create(*args) -> 'PyObject *'
    qstrvec_t_create() -> PyObject *

Help on function qstrvec_t_destroy in module ida_pro:

qstrvec_t_destroy(*args) -> 'bool'
    qstrvec_t_destroy(py_obj) -> bool

Help on function qstrvec_t_from_list in module ida_pro:

qstrvec_t_from_list(*args) -> 'bool'
    qstrvec_t_from_list(_self, py_list) -> bool

Help on function qstrvec_t_get in module ida_pro:

qstrvec_t_get(*args) -> 'PyObject *'
    qstrvec_t_get(_self, idx) -> PyObject *

Help on function qstrvec_t_get_clink in module ida_pro:

qstrvec_t_get_clink(*args) -> 'qstrvec_t *'
    qstrvec_t_get_clink(_self) -> qstrvec_t *

Help on function qstrvec_t_get_clink_ptr in module ida_pro:

qstrvec_t_get_clink_ptr(*args) -> 'PyObject *'
    qstrvec_t_get_clink_ptr(_self) -> PyObject *

Help on function qstrvec_t_insert in module ida_pro:

qstrvec_t_insert(*args) -> 'bool'
    qstrvec_t_insert(_self, idx, s) -> bool

Help on function qstrvec_t_remove in module ida_pro:

qstrvec_t_remove(*args) -> 'bool'
    qstrvec_t_remove(_self, idx) -> bool

Help on function qstrvec_t_set in module ida_pro:

qstrvec_t_set(*args) -> 'bool'
    qstrvec_t_set(_self, idx, s) -> bool

Help on function qstrvec_t_size in module ida_pro:

qstrvec_t_size(*args) -> 'size_t'
    qstrvec_t_size(_self) -> size_t

Help on function quote_cmdline_arg in module ida_pro:

quote_cmdline_arg(*args) -> 'bool'
    quote_cmdline_arg(arg) -> bool
    
    
    Quote a command line argument if it contains escape characters. For
    example, *.c will be converted into "*.c" because * may be
    inadvertently expanded by the shell
    
    @param arg (C++: qstring  *)
    @return: true: modified 'arg'

Help on function qvector_reserve in module ida_pro:

qvector_reserve(*args) -> 'void *'
    qvector_reserve(vec, old, cnt, elsize) -> void *
    
    
    Change capacity of given qvector.
    
    @param vec: a pointer to a qvector (C++: void *)
    @param old: a pointer to the qvector's array (C++: void *)
    @param cnt: number of elements to reserve (C++: size_t)
    @param elsize: size of each element (C++: size_t)
    @return: a pointer to the newly allocated array

Help on function readbytes in module ida_pro:

readbytes(*args) -> 'int'
    readbytes(h, res, size, mf) -> int
    
    
    Read at most 4 bytes from file.
    
    @param h: file handle (C++: int)
    @param res: value read from file (C++: uint32  *)
    @param size: size of value in bytes (1,2,4) (C++: int)
    @param mf: is MSB first? (C++: bool)
    @return: 0 on success, nonzero otherwise

Help on function reloc_value in module ida_pro:

reloc_value(*args) -> 'void'
    reloc_value(value, size, delta, mf)

Help on function relocate_relobj in module ida_pro:

relocate_relobj(*args) -> 'bool'
    relocate_relobj(_relobj, ea, mf) -> bool

Help on class sel_array in module ida_pro:

class sel_array(builtins.object)
 |  Proxy of C++ sel_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'sel_t'
 |      __getitem__(self, index) -> sel_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> sel_array
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, index, value)
 |  
 |  __swig_destroy__ = delete_sel_array(...)
 |      delete_sel_array(self)
 |  
 |  cast(self, *args) -> 'sel_t *'
 |      cast(self) -> sel_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'sel_array *'
 |      frompointer(t) -> sel_array
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function sel_array_frompointer in module ida_pro:

sel_array_frompointer(*args) -> 'sel_array *'
    sel_array_frompointer(t) -> sel_array

Help on class sel_pointer in module ida_pro:

class sel_pointer(builtins.object)
 |  Proxy of C++ sel_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sel_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_sel_pointer(...)
 |      delete_sel_pointer(self)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, value)
 |  
 |  cast(self, *args) -> 'sel_t *'
 |      cast(self) -> sel_t *
 |  
 |  value(self, *args) -> 'sel_t'
 |      value(self) -> sel_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'sel_pointer *'
 |      frompointer(t) -> sel_pointer
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function sel_pointer_frompointer in module ida_pro:

sel_pointer_frompointer(*args) -> 'sel_pointer *'
    sel_pointer_frompointer(t) -> sel_pointer

Help on function set_bits in module ida_pro:

set_bits(*args) -> 'void'
    set_bits(bitmap, low, high)
    
    
    Set bits between [low, high) in 'bitmap'.
    
    
    @param bitmap (C++: uchar  *)
    @param low (C++: size_t)
    @param high (C++: size_t)

Help on class sizevec_t in module ida_pro:

class sizevec_t(builtins.object)
 |  Proxy of C++ qvector< size_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'size_t const &'
 |      __getitem__(self, i) -> size_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sizevec_t
 |      __init__(self, x) -> sizevec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_sizevec_t(...)
 |      delete_sizevec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'size_t const &'
 |      at(self, _idx) -> size_t const &
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< size_t >::const_iterator'
 |      begin(self) -> qvector< size_t >::iterator
 |      begin(self) -> qvector< size_t >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< size_t >::const_iterator'
 |      end(self) -> qvector< size_t >::iterator
 |      end(self) -> qvector< size_t >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< size_t >::iterator'
 |      erase(self, it) -> qvector< size_t >::iterator
 |      erase(self, first, last) -> qvector< size_t >::iterator
 |  
 |  extract(self, *args) -> 'size_t *'
 |      extract(self) -> size_t *
 |  
 |  find(self, *args) -> 'qvector< size_t >::const_iterator'
 |      find(self, x) -> qvector< size_t >::iterator
 |      find(self, x) -> qvector< size_t >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=size_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< size_t >::iterator'
 |      insert(self, it, x) -> qvector< size_t >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'size_t &'
 |      push_back(self, x)
 |      push_back(self) -> size_t &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function str2user in module ida_pro:

str2user(*args) -> 'PyObject *'
    str2user(str) -> PyObject *
    
    
    Insert C-style escape characters to string
    
    @return: new string with escape characters inserted

Help on class strvec_t in module ida_pro:

class strvec_t(builtins.object)
 |  Proxy of C++ qvector< simpleline_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'simpleline_t const &'
 |      __getitem__(self, i) -> simpleline_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strvec_t
 |      __init__(self, x) -> strvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_strvec_t(...)
 |      delete_strvec_t(self)
 |  
 |  append = push_back(self, *args) -> 'simpleline_t &'
 |  
 |  at = __getitem__(self, *args) -> 'simpleline_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< simpleline_t >::const_iterator'
 |      begin(self) -> qvector< simpleline_t >::iterator
 |      begin(self) -> qvector< simpleline_t >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< simpleline_t >::const_iterator'
 |      end(self) -> qvector< simpleline_t >::iterator
 |      end(self) -> qvector< simpleline_t >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< simpleline_t >::iterator'
 |      erase(self, it) -> qvector< simpleline_t >::iterator
 |      erase(self, first, last) -> qvector< simpleline_t >::iterator
 |  
 |  extract(self, *args) -> 'simpleline_t *'
 |      extract(self) -> simpleline_t *
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=simpleline_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< simpleline_t >::iterator'
 |      insert(self, it, x) -> qvector< simpleline_t >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'simpleline_t &'
 |      push_back(self, x)
 |      push_back(self) -> simpleline_t &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class sval_pointer in module ida_pro:

class sval_pointer(builtins.object)
 |  Proxy of C++ sval_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sval_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_sval_pointer(...)
 |      delete_sval_pointer(self)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, value)
 |  
 |  cast(self, *args) -> 'sval_t *'
 |      cast(self) -> sval_t *
 |  
 |  value(self, *args) -> 'sval_t'
 |      value(self) -> sval_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'sval_pointer *'
 |      frompointer(t) -> sval_pointer
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function sval_pointer_frompointer in module ida_pro:

sval_pointer_frompointer(*args) -> 'sval_pointer *'
    sval_pointer_frompointer(t) -> sval_pointer

Help on class tid_array in module ida_pro:

class tid_array(builtins.object)
 |  Proxy of C++ tid_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'tid_t'
 |      __getitem__(self, index) -> tid_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> tid_array
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, index, value)
 |  
 |  __swig_destroy__ = delete_tid_array(...)
 |      delete_tid_array(self)
 |  
 |  cast(self, *args) -> 'tid_t *'
 |      cast(self) -> tid_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'tid_array *'
 |      frompointer(t) -> tid_array
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function tid_array_frompointer in module ida_pro:

tid_array_frompointer(*args) -> 'tid_array *'
    tid_array_frompointer(t) -> tid_array

Help on class uchar_array in module ida_pro:

class uchar_array(builtins.object)
 |  Proxy of C++ uchar_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'uchar'
 |      __getitem__(self, index) -> uchar
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> uchar_array
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, index, value)
 |  
 |  __swig_destroy__ = delete_uchar_array(...)
 |      delete_uchar_array(self)
 |  
 |  cast(self, *args) -> 'uchar *'
 |      cast(self) -> uchar *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'uchar_array *'
 |      frompointer(t) -> uchar_array
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function uchar_array_frompointer in module ida_pro:

uchar_array_frompointer(*args) -> 'uchar_array *'
    uchar_array_frompointer(t) -> uchar_array

Help on class ulonglongvec_t in module ida_pro:

class ulonglongvec_t(builtins.object)
 |  Proxy of C++ qvector< unsigned long long > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'unsigned long long const &'
 |      __getitem__(self, i) -> unsigned long long const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ulonglongvec_t
 |      __init__(self, x) -> ulonglongvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_ulonglongvec_t(...)
 |      delete_ulonglongvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'unsigned long long &'
 |  
 |  at = __getitem__(self, *args) -> 'unsigned long long const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< unsigned long long >::const_iterator'
 |      begin(self) -> qvector< unsigned long long >::iterator
 |      begin(self) -> qvector< unsigned long long >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< unsigned long long >::const_iterator'
 |      end(self) -> qvector< unsigned long long >::iterator
 |      end(self) -> qvector< unsigned long long >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< unsigned long long >::iterator'
 |      erase(self, it) -> qvector< unsigned long long >::iterator
 |      erase(self, first, last) -> qvector< unsigned long long >::iterator
 |  
 |  extract(self, *args) -> 'unsigned long long *'
 |      extract(self) -> unsigned long long *
 |  
 |  find(self, *args) -> 'qvector< unsigned long long >::const_iterator'
 |      find(self, x) -> qvector< unsigned long long >::iterator
 |      find(self, x) -> qvector< unsigned long long >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< unsigned long long >::iterator'
 |      insert(self, it, x) -> qvector< unsigned long long >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'unsigned long long &'
 |      push_back(self, x)
 |      push_back(self) -> unsigned long long &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class uintvec_t in module ida_pro:

class uintvec_t(builtins.object)
 |  Proxy of C++ qvector< unsigned int > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'unsigned int const &'
 |      __getitem__(self, i) -> unsigned int const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> uintvec_t
 |      __init__(self, x) -> uintvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_uintvec_t(...)
 |      delete_uintvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'unsigned int &'
 |  
 |  at = __getitem__(self, *args) -> 'unsigned int const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< unsigned int >::const_iterator'
 |      begin(self) -> qvector< unsigned int >::iterator
 |      begin(self) -> qvector< unsigned int >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< unsigned int >::const_iterator'
 |      end(self) -> qvector< unsigned int >::iterator
 |      end(self) -> qvector< unsigned int >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< unsigned int >::iterator'
 |      erase(self, it) -> qvector< unsigned int >::iterator
 |      erase(self, first, last) -> qvector< unsigned int >::iterator
 |  
 |  extract(self, *args) -> 'unsigned int *'
 |      extract(self) -> unsigned int *
 |  
 |  find(self, *args) -> 'qvector< unsigned int >::const_iterator'
 |      find(self, x) -> qvector< unsigned int >::iterator
 |      find(self, x) -> qvector< unsigned int >::const_iterator
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< unsigned int >::iterator'
 |      insert(self, it, x) -> qvector< unsigned int >::iterator
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'unsigned int &'
 |      push_back(self, x)
 |      push_back(self) -> unsigned int &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class uval_array in module ida_pro:

class uval_array(builtins.object)
 |  Proxy of C++ uval_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'uval_t'
 |      __getitem__(self, index) -> uval_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> uval_array
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, index, value)
 |  
 |  __swig_destroy__ = delete_uval_array(...)
 |      delete_uval_array(self)
 |  
 |  cast(self, *args) -> 'uval_t *'
 |      cast(self) -> uval_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'uval_array *'
 |      frompointer(t) -> uval_array
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function uval_array_frompointer in module ida_pro:

uval_array_frompointer(*args) -> 'uval_array *'
    uval_array_frompointer(t) -> uval_array

Help on function writebytes in module ida_pro:

writebytes(*args) -> 'int'
    writebytes(h, l, size, mf) -> int
    
    
    Write at most 4 bytes to file.
    
    @param h: file handle (C++: int)
    @param l: value to write (C++: uint32)
    @param size: size of value in bytes (1,2,4) (C++: int)
    @param mf: is MSB first? (C++: bool)
    @return: 0 on success, nonzero otherwise

=== ida_pro EPYDOC INJECTIONS ===
ida_pro.CP_UTF16
"""
UTF-16 codepage.
"""

ida_pro.IDA_SDK_VERSION
"""
IDA SDK v7.4.
"""

ida_pro.IDBDEC_ESCAPE
"""
convert non-printable characters to C escapes (, \\xNN, \\uNNNN)
"""

ida_pro.IOREDIR_APPEND
"""
append, do not overwrite the output file
"""

ida_pro.IOREDIR_INPUT
"""
input redirection
"""

ida_pro.IOREDIR_OUTPUT
"""
output redirection
"""

ida_pro.IOREDIR_QUOTED
"""
the file name was quoted
"""

ida_pro.MAXSTR
"""
maximum string size
"""

ida_pro.SUBSTCHAR
"""
default char, used if a char cannot be represented in a codepage
"""

ida_pro.__MF__
"""
byte sex of our platform (Most significant byte First). 0: little
endian (Intel 80x86). 1: big endian (PowerPC).
"""
=== ida_pro EPYDOC INJECTIONS END ===
Help on function forget_problem in module ida_problems:

forget_problem(*args) -> 'bool'
    forget_problem(type, ea) -> bool
    
    
    Remove an address from a problem list
    
    @param type: problem list type (C++: problist_id_t)
    @param ea: linear address (C++: ea_t)
    @return: success

Help on function get_problem in module ida_problems:

get_problem(*args) -> 'ea_t'
    get_problem(type, lowea) -> ea_t
    
    
    Get an address from the specified problem list. The address is not
    removed from the list.
    
    @param type: problem list type (C++: problist_id_t)
    @param lowea: the returned address will be higher or equal than the
                  specified address (C++: ea_t)
    @return: linear address or  BADADDR

Help on function get_problem_desc in module ida_problems:

get_problem_desc(*args) -> 'qstring *'
    get_problem_desc(t, ea) -> str
    
    
    Get the human-friendly description of the problem, if one was provided
    to remember_problem.
    
    @param t: problem list type. (C++: problist_id_t)
    @param ea: linear address. (C++: ea_t)
    @return: the message length or -1 if none

Help on function get_problem_name in module ida_problems:

get_problem_name(*args) -> 'char const *'
    get_problem_name(type, longname=True) -> char const *
    
    
    Get problem list description.
    
    
    @param type (C++: problist_id_t)
    @param longname (C++: bool)

Help on function is_problem_present in module ida_problems:

is_problem_present(*args) -> 'bool'
    is_problem_present(t, ea) -> bool
    
    
    Check if the specified address is present in the problem list.
    
    
    @param t (C++: problist_id_t)
    @param ea (C++: ea_t)

Help on function remember_problem in module ida_problems:

remember_problem(*args) -> 'void'
    remember_problem(type, ea, msg=None)
    
    
    Insert an address to a list of problems. Display a message saying
    about the problem (except of 'PR_ATTN' , 'PR_FINAL' ) 'PR_JUMP' is
    temporarily ignored.
    
    @param type: problem list type (C++: problist_id_t)
    @param ea: linear address (C++: ea_t)
    @param msg: a user-friendly message to be displayed instead of the
                default more generic one associated with the type of
                problem. Defaults to NULL. (C++: const char *)

Help on function was_ida_decision in module ida_problems:

was_ida_decision(*args) -> 'bool'
    was_ida_decision(ea) -> bool

Help on class array_of_rangesets in module ida_range:

class array_of_rangesets(builtins.object)
 |  Proxy of C++ qvector< rangeset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'rangeset_t const &'
 |      __getitem__(self, i) -> rangeset_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_of_rangesets
 |      __init__(self, x) -> array_of_rangesets
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_array_of_rangesets(...)
 |      delete_array_of_rangesets(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'rangeset_t const &'
 |      at(self, _idx) -> rangeset_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< rangeset_t >::const_iterator'
 |      begin(self) -> rangeset_t
 |      begin(self) -> rangeset_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< rangeset_t >::const_iterator'
 |      end(self) -> rangeset_t
 |      end(self) -> rangeset_t
 |  
 |  erase(self, *args) -> 'qvector< rangeset_t >::iterator'
 |      erase(self, it) -> rangeset_t
 |      erase(self, first, last) -> rangeset_t
 |  
 |  extract(self, *args) -> 'rangeset_t *'
 |      extract(self) -> rangeset_t
 |  
 |  find(self, *args) -> 'qvector< rangeset_t >::const_iterator'
 |      find(self, x) -> rangeset_t
 |      find(self, x) -> rangeset_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=rangeset_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< rangeset_t >::iterator'
 |      insert(self, it, x) -> rangeset_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'rangeset_t &'
 |      push_back(self, x)
 |      push_back(self) -> rangeset_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class range_t in module ida_range:

class range_t(builtins.object)
 |  Proxy of C++ range_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> range_t
 |      __init__(self, ea1, ea2) -> range_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_range_t(...)
 |      delete_range_t(self)
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      contains(self, r) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function range_t_print in module ida_range:

range_t_print(*args) -> 'size_t'
    range_t_print(cb) -> str
    
    
    Helper function. Should not be called directly!

Help on class rangeset_t in module ida_range:

class rangeset_t(builtins.object)
 |  Proxy of C++ rangeset_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, aset) -> bool
 |  
 |  __getitem__(self, idx)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rangeset_t
 |      __init__(self, range) -> rangeset_t
 |      __init__(self, ivs) -> rangeset_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = nranges(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, aset) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_rangeset_t(...)
 |      delete_rangeset_t(self)
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  add(self, *args) -> 'bool'
 |      add(self, range) -> bool
 |      add(self, start, _end) -> bool
 |      add(self, aset) -> bool
 |  
 |  begin(self, *args) -> 'rangeset_t::iterator'
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  cached_range(self, *args) -> 'range_t const *'
 |      cached_range(self) -> range_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      contains(self, aset) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'rangeset_t::iterator'
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  find_range(self, *args) -> 'range_t const *'
 |      find_range(self, ea) -> range_t
 |  
 |  getrange(self, *args) -> 'range_t const &'
 |      getrange(self, idx) -> range_t
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, range) -> bool
 |      has_common(self, aset) -> bool
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, range) -> bool
 |  
 |  intersect(self, *args) -> 'bool'
 |      intersect(self, aset) -> bool
 |  
 |  is_equal(self, *args) -> 'bool'
 |      is_equal(self, aset) -> bool
 |  
 |  is_subset_of(self, *args) -> 'bool'
 |      is_subset_of(self, aset) -> bool
 |  
 |  lastrange(self, *args) -> 'range_t const &'
 |      lastrange(self) -> range_t
 |  
 |  next_addr(self, *args) -> 'ea_t'
 |      next_addr(self, ea) -> ea_t
 |  
 |  next_range(self, *args) -> 'ea_t'
 |      next_range(self, ea) -> ea_t
 |  
 |  nranges(self, *args) -> 'size_t'
 |      nranges(self) -> size_t
 |  
 |  prev_addr(self, *args) -> 'ea_t'
 |      prev_addr(self, ea) -> ea_t
 |  
 |  prev_range(self, *args) -> 'ea_t'
 |      prev_range(self, ea) -> ea_t
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, range) -> bool
 |      sub(self, ea) -> bool
 |      sub(self, aset) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class rangevec_base_t in module ida_range:

class rangevec_base_t(builtins.object)
 |  Proxy of C++ qvector< range_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rangevec_base_t
 |      __init__(self, x) -> rangevec_base_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_rangevec_base_t(...)
 |      delete_rangevec_base_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      erase(self, first, last) -> range_t
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      find(self, x) -> range_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class rangevec_t in module ida_range:

class rangevec_t(rangevec_base_t)
 |  Proxy of C++ rangevec_t class.
 |  
 |  Method resolution order:
 |      rangevec_t
 |      rangevec_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rangevec_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_rangevec_t(...)
 |      delete_rangevec_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from rangevec_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      erase(self, first, last) -> range_t
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      find(self, x) -> range_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from rangevec_base_t:
 |  
 |  __hash__ = None

Help on function reg_data_type in module ida_registry:

reg_data_type(*args) -> 'regval_type_t'
    reg_data_type(name, subkey=None) -> regval_type_t
    
    
    Get data type of a given value.
    
    @param name: value name (C++: const char *)
    @param subkey: key name (C++: const char *)
    @return: false if the [key+]value doesn't exist

Help on function reg_delete in module ida_registry:

reg_delete(*args) -> 'bool'
    reg_delete(name, subkey=None) -> bool
    
    
    Delete a value from the registry.
    
    @param name: value name (C++: const char *)
    @param subkey: parent key (C++: const char *)
    @return: success

Help on function reg_delete_subkey in module ida_registry:

reg_delete_subkey(*args) -> 'bool'
    reg_delete_subkey(name) -> bool
    
    
    Delete a key from the registry.
    
    
    @param name (C++: const char *)

Help on function reg_delete_tree in module ida_registry:

reg_delete_tree(*args) -> 'bool'
    reg_delete_tree(name) -> bool
    
    
    Delete a subtree from the registry.
    
    
    @param name (C++: const char *)

Help on function reg_exists in module ida_registry:

reg_exists(*args) -> 'bool'
    reg_exists(name, subkey=None) -> bool
    
    
    Is there already a value with the given name?
    
    @param name: value name (C++: const char *)
    @param subkey: parent key (C++: const char *)

Help on function reg_flush in module ida_registry:

reg_flush(*args) -> 'void'
    reg_flush()

Help on function reg_load in module ida_registry:

reg_load(*args) -> 'void'
    reg_load()

Help on function reg_read_binary in module ida_registry:

reg_read_binary(*args) -> 'PyObject *'
    reg_read_binary(name, subkey=None) -> PyObject *
    
    
    Read binary data from the registry.
    
    @param name: value name (C++: const char *)
    @param subkey: key name (C++: const char *)
    @return: false if 'data' is not large enough to hold all data present.
             in this case 'data' is left untouched.

Help on function reg_read_bool in module ida_registry:

reg_read_bool(*args) -> 'bool'
    reg_read_bool(name, defval, subkey=None) -> bool
    
    
    Read boolean value from the registry.
    
    @param name: value name (C++: const char *)
    @param defval: default value (C++: bool)
    @param subkey: key name (C++: const char *)
    @return: boolean read from registry, or 'defval' if the read failed

Help on function reg_read_int in module ida_registry:

reg_read_int(*args) -> 'int'
    reg_read_int(name, defval, subkey=None) -> int
    
    
    Read integer value from the registry.
    
    @param name: value name (C++: const char *)
    @param defval: default value (C++: int)
    @param subkey: key name (C++: const char *)
    @return: the value read from the registry, or 'defval' if the read
             failed

Help on function reg_read_string in module ida_registry:

reg_read_string(*args) -> 'PyObject *'
    reg_read_string(name, subkey=None, _def=None) -> PyObject *
    
    
    Read a string from the registry.
    
    @param name: value name (C++: const char *)
    @param subkey: key name (C++: const char *)
    @return: success

Help on function reg_read_strlist in module ida_registry:

reg_read_strlist(*args) -> 'qstrvec_t *'
    reg_read_strlist(subkey)
    
    
    Retrieve all string values associated with the given key. Also see
    'reg_update_strlist()' .
    
    @param subkey (C++: const char *)

Help on function reg_subkey_exists in module ida_registry:

reg_subkey_exists(*args) -> 'bool'
    reg_subkey_exists(name) -> bool
    
    
    Is there already a key with the given name?
    
    
    @param name (C++: const char *)

Help on function reg_subkey_subkeys in module ida_registry:

reg_subkey_subkeys(*args) -> 'PyObject *'
    reg_subkey_subkeys(name) -> PyObject *
    
    
    Get all subkey names of given key.
    
    
    @param name (C++: const char *)

Help on function reg_subkey_values in module ida_registry:

reg_subkey_values(*args) -> 'PyObject *'
    reg_subkey_values(name) -> PyObject *
    
    
    Get all value names under given key.
    
    
    @param name (C++: const char *)

Help on function reg_update_filestrlist in module ida_registry:

reg_update_filestrlist(*args) -> 'void'
    reg_update_filestrlist(subkey, add, maxrecs, rem=None)
    
    
    Update registry with a file list. Case sensitivity will vary depending
    on the target OS.'add' and 'rem' must be UTF-8, just like for regular
    string operations.
    
    @param subkey (C++: const char *)
    @param add (C++: const char *)
    @param maxrecs (C++: size_t)
    @param rem (C++: const char *)

Help on function reg_update_strlist in module ida_registry:

reg_update_strlist(*args) -> 'void'
    reg_update_strlist(subkey, add, maxrecs, rem=None, ignorecase=False)
    
    
    Update list of strings associated with given key.
    
    @param subkey: key name (C++: const char *)
    @param add: string to be added to list, can be NULL (C++: const char
                *)
    @param maxrecs: limit list to this size (C++: size_t)
    @param rem: string to be removed from list, can be NULL (C++: const
                char *)
    @param ignorecase: ignore case for 'add' and 'rem' (C++: bool)

Help on function reg_write_binary in module ida_registry:

reg_write_binary(*args) -> 'PyObject *'
    reg_write_binary(name, py_bytes, subkey=None) -> PyObject *
    
    
    Write binary data to the registry.
    
    @param name: value name (C++: const char *)
    @param subkey: key name (C++: const char *)

Help on function reg_write_bool in module ida_registry:

reg_write_bool(*args) -> 'void'
    reg_write_bool(name, value, subkey=None)
    
    
    Write boolean value to the registry.
    
    @param name: value name (C++: const char *)
    @param value: boolean to write (nonzero = true) (C++: int)
    @param subkey: key name (C++: const char *)

Help on function reg_write_int in module ida_registry:

reg_write_int(*args) -> 'void'
    reg_write_int(name, value, subkey=None)
    
    
    Write integer value to the registry.
    
    @param name: value name (C++: const char *)
    @param value: value to write (C++: int)
    @param subkey: key name (C++: const char *)

Help on function reg_write_string in module ida_registry:

reg_write_string(*args) -> 'void'
    reg_write_string(name, utf8, subkey=None)
    
    
    Write a string to the registry.
    
    @param name: value name (C++: const char *)
    @param utf8: utf8-encoded string (C++: const char *)
    @param subkey: key name (C++: const char *)

=== ida_registry EPYDOC INJECTIONS ===
ida_registry.ROOT_KEY_NAME
"""
Key used to store IDA settings in registry (Windows version).this name
is automatically prepended to all key names passed to functions in
this file.
"""
=== ida_registry EPYDOC INJECTIONS END ===
Help on function find_binary in module ida_search:

find_binary(*args) -> 'ea_t'
    find_binary(arg1, arg2, arg3, arg4, arg5) -> ea_t

Help on function find_code in module ida_search:

find_code(*args) -> 'ea_t'
    find_code(ea, sflag) -> ea_t
    
    
    Find next code address.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_data in module ida_search:

find_data(*args) -> 'ea_t'
    find_data(ea, sflag) -> ea_t
    
    
    Find next data address.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_defined in module ida_search:

find_defined(*args) -> 'ea_t'
    find_defined(ea, sflag) -> ea_t
    
    
    Find next ea that is the start of an instruction or data.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_error in module ida_search:

find_error(*args) -> 'int *'
    find_error(ea, sflag) -> ea_t
    
    
    Find next error or problem.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_imm in module ida_search:

find_imm(*args) -> 'int *'
    find_imm(newEA, sflag, srchValue) -> ea_t
    
    
    Find next immediate operand with the given value.
    
    
    @param newEA (C++: ea_t)
    @param sflag (C++: int)
    @param srchValue (C++: uval_t)

Help on function find_not_func in module ida_search:

find_not_func(*args) -> 'ea_t'
    find_not_func(ea, sflag) -> ea_t
    
    
    Find next code address that does not belong to a function.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_notype in module ida_search:

find_notype(*args) -> 'int *'
    find_notype(ea, sflag) -> ea_t
    
    
    Find next operand without any type info.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_suspop in module ida_search:

find_suspop(*args) -> 'int *'
    find_suspop(ea, sflag) -> ea_t
    
    
    Find next suspicious operand.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_text in module ida_search:

find_text(*args) -> 'ea_t'
    find_text(start_ea, y, x, ustr, sflag) -> ea_t
    
    
    See 'search()'
    
    
    @param start_ea (C++: ea_t)
    @param y (C++: int)
    @param x (C++: int)
    @param ustr (C++: const char *)
    @param sflag (C++: int)

Help on function find_unknown in module ida_search:

find_unknown(*args) -> 'ea_t'
    find_unknown(ea, sflag) -> ea_t
    
    
    Find next unexplored address.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function search_down in module ida_search:

search_down(*args) -> 'bool'
    search_down(sflag) -> bool
    
    
    Is the 'SEARCH_DOWN' bit set?
    
    
    @param sflag (C++: int)

=== ida_search EPYDOC INJECTIONS ===
ida_search.SEARCH_BRK
"""
return 'BADADDR' if Ctrl-Break wass pressed during search
"""

ida_search.SEARCH_CASE
"""
case-sensitive search (case-insensitive otherwise)
"""

ida_search.SEARCH_DOWN
"""
search towards higher addresses
"""

ida_search.SEARCH_IDENT
"""
search for an identifier (text search). it means that the characters
before and after the match cannot be is_visible_char().
"""

ida_search.SEARCH_NEXT
"""
for other find_.. functions it is implicitly set

useful only for 'search()' and find_binary().
"""

ida_search.SEARCH_NOBRK
"""
don't test for ctrl-break to interrupt the search
"""

ida_search.SEARCH_NOSHOW
"""
don't display the search progress/refresh screen
"""

ida_search.SEARCH_REGEX
"""
regular expressions in search string (only supported for txt search)
"""

ida_search.SEARCH_UP
"""
search towards lower addresses
"""
=== ida_search EPYDOC INJECTIONS END ===
Help on function add_segm in module ida_segment:

add_segm(*args) -> 'bool'
    add_segm(para, start, end, name, sclass, flags=0) -> bool
    
    
    Add a new segment, second form. Segment alignment is set to
    'saRelByte' . Segment combination is "public" or "stack" (if segment
    class is "STACK"). Addressing mode of segment is taken as default
    (16bit or 32bit). Default segment registers are set to 'BADSEL' . If a
    segment already exists at the specified range of addresses, this
    segment will be truncated. Instructions and data in the old segment
    will be deleted if the new segment has another addressing mode or
    another segment base address.
    
    @param para: segment base paragraph. if paragraph can't fit in 16bit,
                 then a new selector is allocated and mapped to the
                 paragraph. (C++: ea_t)
    @param start: start address of the segment. if start== BADADDR  then
                  start <- to_ea(para,0). (C++: ea_t)
    @param end: end address of the segment. end address should be higher
                than start address. For emulate empty segments, use
                SEG_NULL  segment type. If the end address is lower than
                start address, then fail. If end== BADADDR , then a
                segment up to the next segment will be created (if the
                next segment doesn't exist, then 1 byte segment will be
                created). If 'end' is too high and the new segment would
                overlap the next segment, 'end' is adjusted properly.
                (C++: ea_t)
    @param name: name of new segment. may be NULL (C++: const char *)
    @param sclass: class of the segment. may be NULL. type of the new
                   segment is modified if class is one of predefined
                   names:   "CODE" ->  SEG_CODE   "DATA" ->  SEG_DATA
                   "CONST" ->  SEG_DATA   "STACK" ->  SEG_BSS   "BSS" ->
                   SEG_BSS   "XTRN" ->  SEG_XTRN   "COMM" ->  SEG_COMM
                   "ABS" ->  SEG_ABSSYM (C++: const char *)
    @param flags (C++: int)

Help on function add_segm_ex in module ida_segment:

add_segm_ex(*args) -> 'bool'
    add_segm_ex(s, name, sclass, flags) -> bool
    
    
    Add a new segment. If a segment already exists at the specified range
    of addresses, this segment will be truncated. Instructions and data in
    the old segment will be deleted if the new segment has another
    addressing mode or another segment base address.
    
    @param s: pointer to filled segment structure. segment selector should
              have proper mapping (see  set_selector() ).   if
              s.start_ea== BADADDR  then s.start_ea <- get_segm_base(&s)
              if s.end_ea== BADADDR , then a segment up to the next
              segment will be created (if the next segment doesn't exist,
              then 1 byte segment will be created).   if the s.end_ea <
              s.start_ea, then fail.   if s.end_ea is too high and the new
              segment would overlap the next segment, s.end_ea is adjusted
              properly. (C++: segment_t  *)
    @param name: name of new segment. may be NULL. if specified, the
                 segment is immediately renamed (C++: const char *)
    @param sclass: class of the segment. may be NULL. if specified, the
                   segment class is immediately changed (C++: const char
                   *)
    @param flags: Add segment flags (C++: int)

Help on function add_segment_translation in module ida_segment:

add_segment_translation(*args) -> 'bool'
    add_segment_translation(segstart, mappedseg) -> bool
    
    
    Add segment translation.
    
    @param segstart: start address of the segment to add translation to
                     (C++: ea_t)
    @param mappedseg: start address of the overlayed segment (C++: ea_t)

Help on function allocate_selector in module ida_segment:

allocate_selector(*args) -> 'sel_t'
    allocate_selector(segbase) -> sel_t
    
    
    Allocate a selector for a segment unconditionally. You must call this
    function before calling 'add_segm_ex()' . 'add_segm()' calls this
    function itself, so you don't need to allocate a selector. This
    function will allocate a new free selector and setup its mapping using
    'find_free_selector()' and 'set_selector()' functions.
    
    @param segbase: a new segment base paragraph (C++: ea_t)
    @return: the allocated selector number

Help on function change_segment_status in module ida_segment:

change_segment_status(*args) -> 'int'
    change_segment_status(s, is_deb_segm) -> int
    
    
    Convert a debugger segment to a regular segment and vice versa. When
    converting debug->regular, the memory contents will be copied to the
    database.
    
    @param s: segment to modify (C++: segment_t  *)
    @param is_deb_segm: new status of the segment (C++: bool)
    @return: Change segment status result codes

Help on function del_segm in module ida_segment:

del_segm(*args) -> 'bool'
    del_segm(ea, flags) -> bool
    
    
    Delete a segment.
    
    @param ea: any address belonging to the segment (C++: ea_t)
    @param flags: Segment modification flags (C++: int)

Help on function del_segment_translations in module ida_segment:

del_segment_translations(*args) -> 'void'
    del_segment_translations(segstart)
    
    
    Delete the translation list
    
    @param segstart: start address of the segment to delete translation
                     list (C++: ea_t)

Help on function del_selector in module ida_segment:

del_selector(*args) -> 'void'
    del_selector(selector)
    
    
    Delete mapping of a selector. Be wary of deleting selectors that are
    being used in the program, this can make a mess in the segments.
    
    @param selector: number of selector to remove from the translation
                     table (C++: sel_t)

Help on function find_free_selector in module ida_segment:

find_free_selector(*args) -> 'sel_t'
    find_free_selector() -> sel_t
    
    
    Find first unused selector.
    
    @return: a number >= 1

Help on function find_selector in module ida_segment:

find_selector(*args) -> 'sel_t'
    find_selector(base) -> sel_t
    
    
    Find a selector that has mapping to the specified paragraph.
    
    @param base: paragraph to search in the translation table (C++: ea_t)
    @return: selector value or base

Help on function get_defsr in module ida_segment:

get_defsr(*args) -> 'sel_t'
    get_defsr(s, reg) -> sel_t

Help on function get_first_seg in module ida_segment:

get_first_seg(*args) -> 'segment_t *'
    get_first_seg() -> segment_t
    
    
    Get pointer to the first segment.

Help on function get_group_selector in module ida_segment:

get_group_selector(*args) -> 'sel_t'
    get_group_selector(grpsel) -> sel_t
    
    
    Get common selector for a group of segments.
    
    @param grpsel: selector of group segment (C++: sel_t)
    @return: common selector of the group or 'grpsel' if no such group is
             found

Help on function get_last_seg in module ida_segment:

get_last_seg(*args) -> 'segment_t *'
    get_last_seg() -> segment_t
    
    
    Get pointer to the last segment.

Help on function get_next_seg in module ida_segment:

get_next_seg(*args) -> 'segment_t *'
    get_next_seg(ea) -> segment_t
    
    
    Get pointer to the next segment.
    
    
    @param ea (C++: ea_t)

Help on function get_prev_seg in module ida_segment:

get_prev_seg(*args) -> 'segment_t *'
    get_prev_seg(ea) -> segment_t
    
    
    Get pointer to the previous segment.
    
    
    @param ea (C++: ea_t)

Help on function get_segm_base in module ida_segment:

get_segm_base(*args) -> 'ea_t'
    get_segm_base(s) -> ea_t
    
    
    Get segment base linear address. Segment base linear address is used
    to calculate virtual addresses. The virtual address of the first byte
    of the segment will be (start address of segment - segment base linear
    address)
    
    @param s: pointer to segment (C++: const  segment_t  *)
    @return: 0 if s == NULL, otherwise segment base linear address

Help on function get_segm_by_name in module ida_segment:

get_segm_by_name(*args) -> 'segment_t *'
    get_segm_by_name(name) -> segment_t
    
    
    Get pointer to segment by its name. If there are several segments with
    the same name, returns the first of them.
    
    @param name: segment name. may be NULL. (C++: const char *)
    @return: NULL or pointer to segment structure

Help on function get_segm_by_sel in module ida_segment:

get_segm_by_sel(*args) -> 'segment_t *'
    get_segm_by_sel(selector) -> segment_t
    
    
    Get pointer to segment structure. This function finds a segment by its
    selector. If there are several segments with the same selectors, the
    last one will be returned.
    
    @param selector: a segment with the specified selector will be
                     returned (C++: sel_t)
    @return: pointer to segment or NULL

Help on function get_segm_class in module ida_segment:

get_segm_class(*args) -> 'qstring *'
    get_segm_class(s) -> str
    
    
    Get segment class. Segment class is arbitrary text (max 8 characters).
    
    @param s: pointer to segment (C++: const  segment_t  *)
    @return: size of segment class (-1 if s==NULL or bufsize<=0)

Help on function get_segm_name in module ida_segment:

get_segm_name(*args) -> 'qstring *'
    get_segm_name(s, flags=0) -> str
    
    
    Get true segment name by pointer to segment.
    
    @param s: pointer to segment (C++: const  segment_t  *)
    @param flags: 0-return name as is; 1-substitute bad symbols with _ 1
                  corresponds to GN_VISIBLE (C++: int)
    @return: size of segment name (-1 if s==NULL)

Help on function get_segm_num in module ida_segment:

get_segm_num(*args) -> 'int'
    get_segm_num(ea) -> int
    
    
    Get number of segment by address.
    
    @param ea: linear address belonging to the segment (C++: ea_t)
    @return: -1 if no segment occupies the specified address. otherwise
             returns number of the specified segment (0.. get_segm_qty()
             -1)

Help on function get_segm_para in module ida_segment:

get_segm_para(*args) -> 'ea_t'
    get_segm_para(s) -> ea_t
    
    
    Get segment base paragraph. Segment base paragraph may be converted to
    segment base linear address using 'to_ea()' function. In fact,
    to_ea(get_segm_para(s), 0) == get_segm_base(s).
    
    @param s: pointer to segment (C++: const  segment_t  *)
    @return: 0 if s == NULL, the segment base paragraph

Help on function get_segm_qty in module ida_segment:

get_segm_qty(*args) -> 'int'
    get_segm_qty() -> int
    
    
    Get number of segments.

Help on function get_segment_alignment in module ida_segment:

get_segment_alignment(*args) -> 'char const *'
    get_segment_alignment(align) -> char const *
    
    
    Get text representation of segment alignment code.
    
    @param align (C++: uchar)
    @return: text digestable by IBM PC assembler.

Help on function get_segment_cmt in module ida_segment:

get_segment_cmt(*args) -> 'qstring *'
    get_segment_cmt(s, repeatable) -> str
    
    
    Get segment comment.
    
    @param s: pointer to segment structure (C++: const  segment_t  *)
    @param repeatable: 0: get regular comment. 1: get repeatable comment.
                       (C++: bool)
    @return: size of comment or -1

Help on function get_segment_combination in module ida_segment:

get_segment_combination(*args) -> 'char const *'
    get_segment_combination(comb) -> char const *
    
    
    Get text representation of segment combination code.
    
    @param comb (C++: uchar)
    @return: text digestable by IBM PC assembler.

Help on function get_segment_translations in module ida_segment:

get_segment_translations(*args) -> 'ssize_t'
    get_segment_translations(transmap, segstart) -> ssize_t
    
    
    Get segment translation list.
    
    @param transmap: vector of segment start addresses for the translation
                     list (C++: eavec_t  *)
    @param segstart: start address of the segment to get information about
                     (C++: ea_t)
    @return: -1 if no translation list or bad segstart. otherwise returns
             size of translation list.

Help on function get_selector_qty in module ida_segment:

get_selector_qty(*args) -> 'int'
    get_selector_qty() -> int
    
    
    Get number of defined selectors.

Help on function get_visible_segm_name in module ida_segment:

get_visible_segm_name(*args) -> 'qstring *'
    get_visible_segm_name(s) -> str
    
    
    Get segment name by pointer to segment.
    
    @param s: pointer to segment (C++: const  segment_t  *)
    @return: size of segment name (-1 if s==NULL)

Help on function getn_selector in module ida_segment:

getn_selector(*args) -> 'sel_t *, ea_t *'
    getn_selector(n) -> bool
    
    
    Get description of selector (0.. 'get_selector_qty()' -1)
    
    
    @param n (C++: int)

Help on function getnseg in module ida_segment:

getnseg(*args) -> 'segment_t *'
    getnseg(n) -> segment_t
    
    
    Get pointer to segment by its number.Obsoleted because it can slow
    down the debugger (it has to refresh the whole memory segmentation to
    calculate the correct answer)
    
    @param n: segment number in the range (0.. get_segm_qty() -1) (C++:
              int)
    @return: NULL or pointer to segment structure

Help on function getseg in module ida_segment:

getseg(*args) -> 'segment_t *'
    getseg(ea) -> segment_t
    
    
    Get pointer to segment by linear address.
    
    @param ea: linear address belonging to the segment (C++: ea_t)
    @return: NULL or pointer to segment structure

Help on function is_finally_visible_segm in module ida_segment:

is_finally_visible_segm(*args) -> 'bool'
    is_finally_visible_segm(s) -> bool
    
    
    See 'SFL_HIDDEN' , 'SCF_SHHID_SEGM' .
    
    
    @param s (C++: segment_t  *)

Help on function is_miniidb in module ida_segment:

is_miniidb(*args) -> 'bool'
    is_miniidb() -> bool
    
    
    Is the database a miniidb created by the debugger?.
    
    @return: true if the database contains no segments or only debugger
             segments

Help on function is_segm_locked in module ida_segment:

is_segm_locked(*args) -> 'bool'
    is_segm_locked(segm) -> bool
    
    
    Is a segment pointer locked?
    
    
    @param segm (C++: const  segment_t  *)

Help on function is_spec_ea in module ida_segment:

is_spec_ea(*args) -> 'bool'
    is_spec_ea(ea) -> bool
    
    
    Does the address belong to a segment with a special type?. (
    'SEG_XTRN' , 'SEG_GRP' , 'SEG_ABSSYM' , 'SEG_COMM' )
    
    @param ea: linear address (C++: ea_t)

Help on function is_spec_segm in module ida_segment:

is_spec_segm(*args) -> 'bool'
    is_spec_segm(seg_type) -> bool
    
    
    Has segment a special type?. ( 'SEG_XTRN' , 'SEG_GRP' , 'SEG_ABSSYM' ,
    'SEG_COMM' )
    
    @param seg_type (C++: uchar)

Help on function is_visible_segm in module ida_segment:

is_visible_segm(*args) -> 'bool'
    is_visible_segm(s) -> bool
    
    
    See 'SFL_HIDDEN' .
    
    
    @param s (C++: segment_t  *)

Help on function lock_segm in module ida_segment:

lock_segm(*args) -> 'void'
    lock_segm(segm, lock)
    
    
    Lock segment pointer Locked pointers are guaranteed to remain valid
    until they are unlocked. Ranges with locked pointers cannot be deleted
    or moved.
    
    @param segm (C++: const  segment_t  *)
    @param lock (C++: bool)

Help on class lock_segment in module ida_segment:

class lock_segment(builtins.object)
 |  Proxy of C++ lock_segment class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _segm) -> lock_segment
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lock_segment(...)
 |      delete_lock_segment(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function move_segm in module ida_segment:

move_segm(*args) -> 'int'
    move_segm(s, to, flags=0) -> int
    
    
    Move a segment to a new address. This function moves all information
    to the new address. It fixes up address sensitive information in the
    kernel. The total effect is equal to reloading the segment to the
    target address. For the file format dependent address sensitive
    information, 'loader_t::move_segm' is called. Also IDB notification
    event 'idb_event::segm_moved' is called.
    
    @param s: segment to move (C++: segment_t  *)
    @param to: new segment start address (C++: ea_t)
    @param flags: Move segment flags (C++: int)
    @return: Move segment result codes

Help on function move_segm_start in module ida_segment:

move_segm_start(*args) -> 'bool'
    move_segm_start(ea, newstart, mode) -> bool
    
    
    Move segment start. The main difference between this function and
    'set_segm_start()' is that this function may expand the previous
    segment while 'set_segm_start()' never does it. So, this function
    allows to change bounds of two segments simultaneously. If the
    previous segment and the specified segment have the same addressing
    mode and segment base, then instructions and data are not destroyed -
    they simply move from one segment to another. Otherwise all
    instructions/data which migrate from one segment to another are
    destroyed.this function never disables addresses.
    
    @param ea: any address belonging to the segment (C++: ea_t)
    @param newstart: new start address of the segment note that segment
                     start address should be higher than segment base
                     linear address. (C++: ea_t)
    @param mode: policy for destroying defined items   0: if it is
                 necessary to destroy defined items, display a dialog box
                 and ask confirmation   1: if it is necessary to destroy
                 defined items, just destroy them without asking the user
                 -1: if it is necessary to destroy defined items, don't
                 destroy them (i.e. function will fail)   -2: don't
                 destroy defined items (function will succeed) (C++: int)

Help on function rebase_program in module ida_segment:

rebase_program(*args) -> 'int'
    rebase_program(delta, flags) -> int
    
    
    Rebase the whole program by 'delta' bytes.
    
    @param delta: number of bytes to move the program (C++: adiff_t)
    @param flags: Move segment flags  it is recommended to use
                  MSF_FIXONCE  so that the loader takes care of global
                  variables it stored in the database (C++: int)
    @return: Move segment result codes

Help on function segm_adjust_diff in module ida_segment:

segm_adjust_diff(*args) -> 'adiff_t'
    segm_adjust_diff(s, delta) -> adiff_t
    
    
    Truncate and sign extend a delta depending on the segment.
    
    
    @param s (C++: const  segment_t  *)
    @param delta (C++: adiff_t)

Help on function segm_adjust_ea in module ida_segment:

segm_adjust_ea(*args) -> 'ea_t'
    segm_adjust_ea(s, ea) -> ea_t
    
    
    Truncate an address depending on the segment.
    
    
    @param s (C++: const  segment_t  *)
    @param ea (C++: ea_t)

Help on class segment_t in module ida_segment:

class segment_t(ida_range.range_t)
 |  Proxy of C++ segment_t class.
 |  
 |  Method resolution order:
 |      segment_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> segment_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_segment_t(...)
 |      delete_segment_t(self)
 |  
 |  abits(self, *args) -> 'int'
 |      abits(self) -> int
 |  
 |  abytes(self, *args) -> 'int'
 |      abytes(self) -> int
 |  
 |  clr_comorg(self, *args) -> 'void'
 |      clr_comorg(self)
 |  
 |  clr_ob_ok(self, *args) -> 'void'
 |      clr_ob_ok(self)
 |  
 |  comorg(self, *args) -> 'bool'
 |      comorg(self) -> bool
 |  
 |  is_header_segm(self, *args) -> 'bool'
 |      is_header_segm(self) -> bool
 |  
 |  is_hidden_segtype(self, *args) -> 'bool'
 |      is_hidden_segtype(self) -> bool
 |  
 |  is_loader_segm(self, *args) -> 'bool'
 |      is_loader_segm(self) -> bool
 |  
 |  is_visible_segm(self, *args) -> 'bool'
 |      is_visible_segm(self) -> bool
 |  
 |  ob_ok(self, *args) -> 'bool'
 |      ob_ok(self) -> bool
 |  
 |  set_comorg(self, *args) -> 'void'
 |      set_comorg(self)
 |  
 |  set_debugger_segm(self, *args) -> 'void'
 |      set_debugger_segm(self, debseg)
 |  
 |  set_header_segm(self, *args) -> 'void'
 |      set_header_segm(self, on)
 |  
 |  set_hidden_segtype(self, *args) -> 'void'
 |      set_hidden_segtype(self, hide)
 |  
 |  set_loader_segm(self, *args) -> 'void'
 |      set_loader_segm(self, ldrseg)
 |  
 |  set_ob_ok(self, *args) -> 'void'
 |      set_ob_ok(self)
 |  
 |  set_visible_segm(self, *args) -> 'void'
 |      set_visible_segm(self, visible)
 |  
 |  update(self, *args) -> 'bool'
 |      update(self) -> bool
 |  
 |  use32(self, *args) -> 'bool'
 |      use32(self) -> bool
 |  
 |  use64(self, *args) -> 'bool'
 |      use64(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  align
 |      segment_t_align_get(self) -> uchar
 |  
 |  bitness
 |      segment_t_bitness_get(self) -> uchar
 |  
 |  color
 |      segment_t_color_get(self) -> bgcolor_t
 |  
 |  comb
 |      segment_t_comb_get(self) -> uchar
 |  
 |  defsr
 |      segment_t_defsr_get(self) -> sel_t [16]
 |  
 |  end_ea
 |      segment_t_end_ea_get(self) -> ea_t
 |  
 |  flags
 |      segment_t_flags_get(self) -> ushort
 |  
 |  name
 |      segment_t_name_get(self) -> uval_t
 |  
 |  orgbase
 |      segment_t_orgbase_get(self) -> uval_t
 |  
 |  perm
 |      segment_t_perm_get(self) -> uchar
 |  
 |  sclass
 |      segment_t_sclass_get(self) -> uval_t
 |  
 |  sel
 |      segment_t_sel_get(self) -> sel_t
 |  
 |  start_ea
 |      segment_t_start_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      segment_t_type_get(self) -> uchar
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      contains(self, r) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  startEA
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on function segtype in module ida_segment:

segtype(*args) -> 'uchar'
    segtype(ea) -> uchar
    
    
    Get segment type.
    
    @param ea: any linear address within the segment (C++: ea_t)
    @return: Segment types ,  SEG_UNDF  if no segment found at 'ea'

Help on function sel2ea in module ida_segment:

sel2ea(*args) -> 'ea_t'
    sel2ea(selector) -> ea_t
    
    
    Get mapping of a selector as a linear address.
    
    @param selector: number of selector to translate to linear address
                     (C++: sel_t)
    @return: linear address the specified selector is mapped to. if there
             is no mapping, returns to_ea(selector,0);

Help on function sel2para in module ida_segment:

sel2para(*args) -> 'ea_t'
    sel2para(selector) -> ea_t
    
    
    Get mapping of a selector.
    
    @param selector: number of selector to translate (C++: sel_t)
    @return: paragraph the specified selector is mapped to. if there is no
             mapping, returns 'selector'.

Help on function set_defsr in module ida_segment:

set_defsr(*args) -> 'void'
    set_defsr(s, reg, value)

Help on function set_group_selector in module ida_segment:

set_group_selector(*args) -> 'int'
    set_group_selector(grp, sel) -> int
    
    
    Initialize groups. The kernel calls this function at the start of
    work.Create a new group of segments (used OMF files).
    
    @param grp: selector of group segment (segment type is  SEG_GRP ) You
                should create an 'empty' (1 byte) group segment It won't
                contain anything and will be used to redirect references
                to the group of segments to the common selector. (C++:
                sel_t)
    @param sel: common selector of all segments belonging to the segment
                You should create all segments within the group with the
                same selector value. (C++: sel_t)
    @return: 1 ok

Help on function set_segm_addressing in module ida_segment:

set_segm_addressing(*args) -> 'bool'
    set_segm_addressing(s, bitness) -> bool
    
    
    Change segment addressing mode (16, 32, 64 bits). You must use this
    function to change segment addressing, never change the 'bitness'
    field directly. This function will delete all instructions, comments
    and names in the segment
    
    @param s: pointer to segment (C++: segment_t  *)
    @param bitness: new addressing mode of segment   2: 64bit segment   1:
                    32bit segment   0: 16bit segment (C++: size_t)
    @return: success

Help on function set_segm_base in module ida_segment:

set_segm_base(*args) -> 'bool'
    set_segm_base(s, newbase) -> bool
    
    
    Internal function.
    
    
    @param s (C++: segment_t  *)
    @param newbase (C++: ea_t)

Help on function set_segm_class in module ida_segment:

set_segm_class(*args) -> 'int'
    set_segm_class(s, sclass, flags=0) -> int
    
    
    Set segment class.
    
    @param s: pointer to segment (may be NULL) (C++: segment_t  *)
    @param sclass: segment class (may be NULL). If segment type is
                   SEG_NORM  and segment class is one of predefined names,
                   then segment type is changed to:   "CODE" ->  SEG_CODE
                   "DATA" ->  SEG_DATA   "STACK" ->  SEG_BSS   "BSS" ->
                   SEG_BSS   if "UNK" then segment type is reset to
                   SEG_NORM . (C++: const char *)
    @param flags (C++: int)

Help on function set_segm_end in module ida_segment:

set_segm_end(*args) -> 'bool'
    set_segm_end(ea, newend, flags) -> bool
    
    
    Set segment end address. The next segment is shrinked to allow
    expansion of the specified segment. The kernel might even delete the
    next segment if necessary. The kernel will ask the user for a
    permission to destroy instructions or data going out of segment scope
    if such instructions exist.
    
    @param ea: any address belonging to the segment (C++: ea_t)
    @param newend: new end address of the segment (C++: ea_t)
    @param flags: Segment modification flags (C++: int)

Help on function set_segm_name in module ida_segment:

set_segm_name(*args) -> 'int'
    set_segm_name(s, name, flags=0) -> int
    
    
    Rename segment. The new name is validated (see validate_name). A
    segment always has a name. If you hadn't specified a name, the kernel
    will assign it "seg###" name where ### is segment number.
    
    @param s: pointer to segment (may be NULL) (C++: segment_t  *)
    @param name: new segment name (C++: const char *)
    @param flags: ADDSEG_IDBENC or 0 (C++: int)

Help on function set_segm_start in module ida_segment:

set_segm_start(*args) -> 'bool'
    set_segm_start(ea, newstart, flags) -> bool
    
    
    Set segment start address. The previous segment is trimmed to allow
    expansion of the specified segment. The kernel might even delete the
    previous segment if necessary. The kernel will ask the user for a
    permission to destroy instructions or data going out of segment scope
    if such instructions exist.
    
    @param ea: any address belonging to the segment (C++: ea_t)
    @param newstart: new start address of the segment note that segment
                     start address should be higher than segment base
                     linear address. (C++: ea_t)
    @param flags: Segment modification flags (C++: int)

Help on function set_segment_cmt in module ida_segment:

set_segment_cmt(*args) -> 'void'
    set_segment_cmt(s, cmt, repeatable)
    
    
    Set segment comment.
    
    @param s: pointer to segment structure (C++: const  segment_t  *)
    @param cmt: comment string, may be multiline (with '  '). maximal size
                is 4096 bytes. Use empty str ("") to delete comment (C++:
                const char *)
    @param repeatable: 0: set regular comment. 1: set repeatable comment.
                       (C++: bool)

Help on function set_segment_translations in module ida_segment:

set_segment_translations(*args) -> 'bool'
    set_segment_translations(segstart, transmap) -> bool
    
    
    Set new translation list.
    
    @param segstart: start address of the segment to add translation to
                     (C++: ea_t)
    @param transmap: vector of segment start addresses for the translation
                     list. If transmap is empty, the translation list is
                     deleted. (C++: const  eavec_t  &)

Help on function set_selector in module ida_segment:

set_selector(*args) -> 'int'
    set_selector(selector, paragraph) -> int
    
    
    Set mapping of selector to a paragraph. You should call this
    functionbeforecreating a segment which uses the selector, otherwise
    the creation of the segment will fail.
    
    @param selector: number of selector to map   if selector ==  BADSEL ,
                     then return 0 (fail)   if the selector has had a
                     mapping, old mapping is destroyed   if the selector
                     number is equal to paragraph value, then the mapping
                     is destroyed because we don't need to keep trivial
                     mappings. (C++: sel_t)
    @param paragraph: paragraph to map selector (C++: ea_t)

Help on function set_visible_segm in module ida_segment:

set_visible_segm(*args) -> 'void'
    set_visible_segm(s, visible)
    
    
    See 'SFL_HIDDEN' .
    
    
    @param s (C++: segment_t  *)
    @param visible (C++: bool)

Help on function setup_selector in module ida_segment:

setup_selector(*args) -> 'sel_t'
    setup_selector(segbase) -> sel_t
    
    
    Allocate a selector for a segment if necessary. You must call this
    function before calling 'add_segm_ex()' . 'add_segm()' calls this
    function itself, so you don't need to allocate a selector. This
    function will allocate a selector if 'segbase' requires more than 16
    bits and the current processor is IBM PC. Otherwise it will return the
    segbase value.
    
    @param segbase: a new segment base paragraph (C++: ea_t)
    @return: the allocated selector number

Help on function std_out_segm_footer in module ida_segment:

std_out_segm_footer(*args) -> 'void'
    std_out_segm_footer(ctx, seg)
    
    
    Generate segment footer line as a comment line. This function may be
    used in IDP modules to generate segment footer if the target assembler
    doesn't have 'ends' directive.
    
    @param ctx (C++: struct  outctx_t  &)
    @param seg (C++: segment_t  *)

Help on function take_memory_snapshot in module ida_segment:

take_memory_snapshot(*args) -> 'bool'
    take_memory_snapshot(only_loader_segs) -> bool
    
    
    Take a memory snapshot of the running process.
    
    @param only_loader_segs: only is_loader_segm() segments will be
                             affected (C++: bool)
    @return: success

Help on function update_segm in module ida_segment:

update_segm(*args) -> 'bool'
    update_segm(s) -> bool

=== ida_segment EPYDOC INJECTIONS ===
ida_segment.ADDSEG_FILLGAP
"""
fill gap between new segment and previous one. i.e. if such a gap
exists, and this gap is less than 64K, then fill the gap by extending
the previous segment and adding .align directive to it. This way we
avoid gaps between segments. too many gaps lead to a virtual array
failure. it cannot hold more than ~1000 gaps.
"""

ida_segment.ADDSEG_IDBENC
"""
non-ASCII bytes will be decoded accordingly

'name' and 'sclass' are given in the IDB encoding;
"""

ida_segment.ADDSEG_NOAA
"""
do not mark new segment for auto-analysis
"""

ida_segment.ADDSEG_NOSREG
"""
(undefine all default segment registers)

set all default segment register values to 'BADSEL'
"""

ida_segment.ADDSEG_NOTRUNC
"""
destroy/truncate old segments instead.

don't truncate the new segment at the beginning of the next segment if
they overlap.
"""

ida_segment.ADDSEG_OR_DIE
"""
 'qexit()' if can't add a segment
"""

ida_segment.ADDSEG_QUIET
"""
silent mode, no "Adding segment..." in the messages window
"""

ida_segment.ADDSEG_SPARSE
"""
use sparse storage method for the new segment
"""

ida_segment.CSS_BREAK
"""
memory reading process stopped by user
"""

ida_segment.CSS_NODBG
"""
debugger is not running
"""

ida_segment.CSS_NOMEM
"""
is too big)

not enough memory (might be because the segment
"""

ida_segment.CSS_NORANGE
"""
could not find corresponding memory range
"""

ida_segment.CSS_OK
"""
ok
"""

ida_segment.MAX_GROUPS
"""
max number of segment groups
"""

ida_segment.MAX_SEGM_TRANSLATIONS
"""
max number of segment translations
"""

ida_segment.MOVE_SEGM_CHUNK
"""
Too many chunks are defined, can't move.
"""

ida_segment.MOVE_SEGM_DEBUG
"""
Debugger segments cannot be moved.
"""

ida_segment.MOVE_SEGM_IDP
"""
IDP module forbids moving the segment.
"""

ida_segment.MOVE_SEGM_LOADER
"""
The segment has been moved but the loader complained.
"""

ida_segment.MOVE_SEGM_ODD
"""
Cannot move segments by an odd number of bytes.
"""

ida_segment.MOVE_SEGM_OK
"""
all ok
"""

ida_segment.MOVE_SEGM_ORPHAN
"""
Orphan bytes hinder segment movement.
"""

ida_segment.MOVE_SEGM_PARAM
"""
The specified segment does not exist.
"""

ida_segment.MOVE_SEGM_ROOM
"""
Not enough free room at the target address.
"""

ida_segment.MSF_FIXONCE
"""
valid for 'rebase_program()' . see 'loader_t::move_segm' .

call loader only once with the special calling method.
"""

ida_segment.MSF_LDKEEP
"""
keep the loader in the memory (optimization)
"""

ida_segment.MSF_NETNODES
"""
valid for 'rebase_program()'

move netnodes instead of changing inf.netdelta (this is slower)
"""

ida_segment.MSF_NOFIX
"""
don't call the loader to fix relocations
"""

ida_segment.MSF_PRIORITY
"""
valid for 'move_segm()'

loader segments will overwrite any existing debugger segments when
moved.
"""

ida_segment.MSF_SILENT
"""
don't display a "please wait" box on the screen
"""

ida_segment.SEGMOD_KEEP
"""
keep information (code & data, etc)
"""

ida_segment.SEGMOD_KEEP0
"""
flag for internal use, don't set
"""

ida_segment.SEGMOD_KEEPSEL
"""
do not try to delete unused selector
"""

ida_segment.SEGMOD_KILL
"""
disable addresses if segment gets shrinked or deleted
"""

ida_segment.SEGMOD_NOMOVE
"""
(for 'set_segm_start()' )

don't move info from the start of segment to the new start address
"""

ida_segment.SEGMOD_SILENT
"""
be silent
"""

ida_segment.SEGMOD_SPARSE
"""
(for 'set_segm_start()' , 'set_segm_end()' )

use sparse storage if extending the segment
"""

ida_segment.SEGPERM_EXEC
"""
Execute.
"""

ida_segment.SEGPERM_READ
"""
Read.
"""

ida_segment.SEGPERM_WRITE
"""
Write.
"""

ida_segment.SEG_ABSSYM
"""
segment with definitions of absolute symbols
"""

ida_segment.SEG_BSS
"""
uninitialized segment
"""

ida_segment.SEG_CODE
"""
code segment
"""

ida_segment.SEG_COMM
"""
segment with communal definitions
"""

ida_segment.SEG_DATA
"""
data segment
"""

ida_segment.SEG_GRP
"""
group of segments
"""

ida_segment.SEG_IMEM
"""
internal processor memory & sfr (8051)
"""

ida_segment.SEG_IMP
"""
java: implementation segment
"""

ida_segment.SEG_NORM
"""
unknown type, no assumptions
"""

ida_segment.SEG_NULL
"""
zero-length segment
"""

ida_segment.SEG_UNDF
"""
undefined segment type (not used)
"""

ida_segment.SEG_XTRN
"""
no instructions are allowed

segment with 'extern' definitions.
"""

ida_segment.SFL_COMORG
"""
IDP dependent field (IBM PC: if set, ORG directive is not commented
out)
"""

ida_segment.SFL_DEBUG
"""
Is the segment created for the debugger?. Such segments are temporary
and do not have permanent flags.
"""

ida_segment.SFL_HEADER
"""
Header segment (do not create offsets to it in the disassembly)
"""

ida_segment.SFL_HIDDEN
"""
Is the segment hidden?
"""

ida_segment.SFL_HIDETYPE
"""
Hide segment type (do not print it in the listing)
"""

ida_segment.SFL_LOADER
"""
Is the segment created by the loader?
"""

ida_segment.SFL_OBOK
"""
Orgbase is present? (IDP dependent field)
"""

ida_segment.SREG_NUM
"""
Maximum number of segment registers is 16 (see 'segregs.hpp' )
"""

ida_segment.saAbs
"""
Absolute segment.
"""

ida_segment.saGroup
"""
Segment group.
"""

ida_segment.saRel1024Bytes
"""
1024 bytes
"""

ida_segment.saRel128Bytes
"""
128 bytes
"""

ida_segment.saRel2048Bytes
"""
2048 bytes
"""

ida_segment.saRel32Bytes
"""
32 bytes
"""

ida_segment.saRel4K
"""
alignment. It is not supported by LINK.

This value is used by the PharLap OMF for page (4K)
"""

ida_segment.saRel512Bytes
"""
512 bytes
"""

ida_segment.saRel64Bytes
"""
64 bytes
"""

ida_segment.saRelByte
"""
Relocatable, byte aligned.
"""

ida_segment.saRelDble
"""
boundary.

Relocatable, aligned on a double word (4-byte)
"""

ida_segment.saRelPage
"""
Relocatable, aligned on 256-byte boundary.
"""

ida_segment.saRelPara
"""
Relocatable, paragraph (16-byte) aligned.
"""

ida_segment.saRelQword
"""
8 bytes
"""

ida_segment.saRelWord
"""
Relocatable, word (2-byte) aligned.
"""

ida_segment.scCommon
"""
Common. Combine by overlay using maximum size.
"""

ida_segment.scGroup
"""
Segment group.
"""

ida_segment.scPriv
"""
segment.

Private. Do not combine with any other program
"""

ida_segment.scPub
"""
the alignment requirement.

Public. Combine by appending at an offset that meets
"""

ida_segment.scPub2
"""
As defined by Microsoft, same as C=2 (public).
"""

ida_segment.scPub3
"""
As defined by Microsoft, same as C=2 (public).
"""

ida_segment.scStack
"""
byte alignment.

Stack. Combine as for C=2. This combine type forces
"""
=== ida_segment EPYDOC INJECTIONS END ===
Help on function copy_sreg_ranges in module ida_segregs:

copy_sreg_ranges(*args) -> 'void'
    copy_sreg_ranges(dst_rg, src_rg, map_selector=False)
    
    
    Duplicate segment register ranges.
    
    @param dst_rg: number of destination segment register (C++: int)
    @param src_rg: copy ranges from (C++: int)
    @param map_selector: map selectors to linear addresses using  sel2ea()
                         (C++: bool)

Help on function del_sreg_range in module ida_segregs:

del_sreg_range(*args) -> 'bool'
    del_sreg_range(ea, rg) -> bool
    
    
    Delete segment register range started at ea. When a segment register
    range is deleted, the previous range is extended to cover the empty
    space. The segment register range at the beginning of a segment cannot
    be deleted.
    
    @param ea: start_ea of the deleted range (C++: ea_t)
    @param rg: the segment register number (C++: int)
    @return: success

Help on function get_prev_sreg_range in module ida_segregs:

get_prev_sreg_range(*args) -> 'bool'
    get_prev_sreg_range(out, ea, rg) -> bool
    
    
    Get segment register range previous to one with address.more efficient
    then get_sreg_range(reg, ea-1)
    
    @param out: segment register range (C++: sreg_range_t  *)
    @param ea: any linear address in the program (C++: ea_t)
    @param rg: the segment register number (C++: int)
    @return: success

Help on function get_sreg in module ida_segregs:

get_sreg(*args) -> 'sel_t'
    get_sreg(ea, rg) -> sel_t
    
    
    Get value of a segment register. This function uses segment register
    range and default segment register values stored in the segment
    structure.
    
    @param ea: linear address in the program (C++: ea_t)
    @param rg: number of the segment register (C++: int)
    @return: value of the segment register,  BADSEL  if value is unknown.

Help on function get_sreg_range in module ida_segregs:

get_sreg_range(*args) -> 'bool'
    get_sreg_range(out, ea, rg) -> bool
    
    
    Get segment register range by linear address.
    
    @param out: segment register range (C++: sreg_range_t  *)
    @param ea: any linear address in the program (C++: ea_t)
    @param rg: the segment register number (C++: int)
    @return: success

Help on function get_sreg_range_num in module ida_segregs:

get_sreg_range_num(*args) -> 'int'
    get_sreg_range_num(ea, rg) -> int
    
    
    Get number of segment register range by address.
    
    @param ea: any address in the range (C++: ea_t)
    @param rg: the segment register number (C++: int)
    @return: -1 if no range occupies the specified address. otherwise
             returns number of the specified range
             (0..get_srranges_qty()-1)

Help on function get_sreg_ranges_qty in module ida_segregs:

get_sreg_ranges_qty(*args) -> 'size_t'
    get_sreg_ranges_qty(rg) -> size_t
    
    
    Get number of segment register ranges.
    
    @param rg: the segment register number (C++: int)

Help on function getn_sreg_range in module ida_segregs:

getn_sreg_range(*args) -> 'bool'
    getn_sreg_range(out, rg, n) -> bool
    
    
    Get segment register range by its number.
    
    @param out: segment register range (C++: sreg_range_t  *)
    @param rg: the segment register number (C++: int)
    @param n: number of range (0..qty()-1) (C++: int)
    @return: success

Help on function set_default_dataseg in module ida_segregs:

set_default_dataseg(*args) -> 'void'
    set_default_dataseg(ds_sel)
    
    
    Set default value of DS register for all segments.
    
    
    @param ds_sel (C++: sel_t)

Help on function set_default_sreg_value in module ida_segregs:

set_default_sreg_value(*args) -> 'bool'
    set_default_sreg_value(sg, rg, value) -> bool
    
    
    Set default value of a segment register for a segment.
    
    @param sg: pointer to segment structure if NULL, then set the register
               for all segments (C++: segment_t  *)
    @param rg: number of segment register (C++: int)
    @param value: its default value. this value will be used by
                  get_sreg()  if value of the register is unknown at the
                  specified address. (C++: sel_t)
    @return: success

Help on function set_sreg_at_next_code in module ida_segregs:

set_sreg_at_next_code(*args) -> 'void'
    set_sreg_at_next_code(ea1, ea2, rg, value)
    
    
    Set the segment register value at the next instruction. This function
    is designed to be called from 'idb_event::sgr_changed' handler in
    order to contain the effect of changing a segment register value only
    until the next instruction.It is useful, for example, in the ARM
    module: the modification of the T register does not affect existing
    instructions later in the code.
    
    @param ea1: address to start to search for an instruction (C++: ea_t)
    @param ea2: the maximal address (C++: ea_t)
    @param rg: the segment register number (C++: int)
    @param value: the segment register value (C++: sel_t)

Help on function split_sreg_range in module ida_segregs:

split_sreg_range(*args) -> 'bool'
    split_sreg_range(ea, rg, v, tag, silent=False) -> bool
    
    
    Create a new segment register range. This function is used when the
    IDP emulator detects that a segment register changes its value.
    
    @param ea: linear address where the segment register will have a new
               value. if ea== BADADDR , nothing to do. (C++: ea_t)
    @param rg: the number of the segment register (C++: int)
    @param v: the new value of the segment register. If the value is
              unknown, you should specify  BADSEL . (C++: sel_t)
    @param tag: the register info tag. see  Segment register range tags
                (C++: uchar)
    @param silent: if false, display a warning() in the case of failure
                   (C++: bool)
    @return: success

Help on class sreg_range_t in module ida_segregs:

class sreg_range_t(ida_range.range_t)
 |  Proxy of C++ sreg_range_t class.
 |  
 |  Method resolution order:
 |      sreg_range_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sreg_range_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_sreg_range_t(...)
 |      delete_sreg_range_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  tag
 |      sreg_range_t_tag_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  val
 |      sreg_range_t_val_get(self) -> sel_t
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      contains(self, r) -> bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

=== ida_segregs EPYDOC INJECTIONS ===
ida_segregs.SR_auto
"""
the value is determined by IDA
"""

ida_segregs.SR_autostart
"""
used as 'SR_auto' for segment starting address
"""

ida_segregs.SR_inherit
"""
the value is inherited from the previous range
"""

ida_segregs.SR_user
"""
the value is specified by the user
"""
=== ida_segregs EPYDOC INJECTIONS END ===
Help on function build_strlist in module ida_strlist:

build_strlist(*args) -> 'void'
    build_strlist()
    
    
    Build the string list. You should initialize options before this call
    using the restore_config() or setup_strings_window() methods.

Help on function clear_strlist in module ida_strlist:

clear_strlist(*args) -> 'void'
    clear_strlist()
    
    
    Clear the string list.

Help on function get_strlist_item in module ida_strlist:

get_strlist_item(*args) -> 'bool'
    get_strlist_item(si, n) -> bool
    
    
    Get nth element of the string list (n=0.. 'get_strlist_qty()' -1)
    
    
    @param si (C++: string_info_t  *)
    @param n (C++: size_t)

Help on function get_strlist_options in module ida_strlist:

get_strlist_options(*args) -> 'strwinsetup_t *'
    get_strlist_options() -> strwinsetup_t
    
    
    Get access to the static string list options.

Help on function get_strlist_qty in module ida_strlist:

get_strlist_qty(*args) -> 'size_t'
    get_strlist_qty() -> size_t
    
    
    Get number of elements in the string list.

Help on class string_info_t in module ida_strlist:

class string_info_t(builtins.object)
 |  Proxy of C++ string_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> string_info_t
 |      __init__(self, _ea) -> string_info_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_string_info_t(...)
 |      delete_string_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      string_info_t_ea_get(self) -> ea_t
 |  
 |  length
 |      string_info_t_length_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      string_info_t_type_get(self) -> int

Help on class strwinsetup_t in module ida_strlist:

class strwinsetup_t(builtins.object)
 |  Proxy of C++ strwinsetup_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strwinsetup_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_strwinsetup_t(...)
 |      delete_strwinsetup_t(self)
 |  
 |  _get_strtypes(self, *args) -> 'PyObject *'
 |      _get_strtypes(self) -> PyObject *
 |  
 |  _set_strtypes(self, *args) -> 'PyObject *'
 |      _set_strtypes(self, py_t) -> PyObject *
 |  
 |  is_initialized(self, *args) -> 'bool'
 |      is_initialized(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  display_only_existing_strings
 |      strwinsetup_t_display_only_existing_strings_get(self) -> uchar
 |  
 |  ignore_heads
 |      strwinsetup_t_ignore_heads_get(self) -> uchar
 |  
 |  minlen
 |      strwinsetup_t_minlen_get(self) -> sval_t
 |  
 |  only_7bit
 |      strwinsetup_t_only_7bit_get(self) -> uchar
 |  
 |  strtypes
 |      _get_strtypes(self) -> PyObject *
 |  
 |  thisown
 |      The membership flag

Help on function add_struc in module ida_struct:

add_struc(*args) -> 'tid_t'
    add_struc(idx, name, is_union=False) -> tid_t
    
    
    Create a structure type. if idx== 'BADADDR' then add as the last idx.
    if name==NULL then a name will be generated "struct_%d".
    
    @param idx (C++: uval_t)
    @param name (C++: const char *)
    @param is_union (C++: bool)

Help on function add_struc_member in module ida_struct:

add_struc_member(*args) -> 'struc_error_t'
    add_struc_member(sptr, fieldname, offset, flag, mt, nbytes) -> struc_error_t
    
    
    Add member to existing structure.
    
    @param sptr: structure to modify (C++: struc_t  *)
    @param fieldname: if NULL, then "anonymous_#" name will be generated
                      (C++: const char *)
    @param offset: BADADDR  means add to the end of structure (C++: ea_t)
    @param flag: type + representation bits (C++: flags_t)
    @param mt: additional info about member type. must be present for
               structs, offsets, enums, strings, struct offsets. (C++:
               const  opinfo_t  *)
    @param nbytes: if == 0 then the structure will be a varstruct. in this
                   case the member should be the last member in the
                   structure (C++: asize_t)

Help on function del_member_tinfo in module ida_struct:

del_member_tinfo(*args) -> 'bool'
    del_member_tinfo(sptr, mptr) -> bool
    
    
    Delete tinfo for given member.
    
    
    @param sptr (C++: struc_t  *)
    @param mptr (C++: member_t  *)

Help on function del_struc in module ida_struct:

del_struc(*args) -> 'bool'
    del_struc(sptr) -> bool
    
    
    Delete a structure type.
    
    
    @param sptr (C++: struc_t  *)

Help on function del_struc_member in module ida_struct:

del_struc_member(*args) -> 'bool'
    del_struc_member(sptr, offset) -> bool
    
    
    Delete member at given offset.
    
    
    @param sptr (C++: struc_t  *)
    @param offset (C++: ea_t)

Help on function del_struc_members in module ida_struct:

del_struc_members(*args) -> 'int'
    del_struc_members(sptr, off1, off2) -> int
    
    
    Delete members which occupy range of offsets (off1..off2).
    
    @param sptr (C++: struc_t  *)
    @param off1 (C++: ea_t)
    @param off2 (C++: ea_t)
    @return: number of deleted members or -1 on error

Help on function expand_struc in module ida_struct:

expand_struc(*args) -> 'bool'
    expand_struc(sptr, offset, delta, recalc=True) -> bool
    
    
    Expand/Shrink structure type.
    
    
    @param sptr (C++: struc_t  *)
    @param offset (C++: ea_t)
    @param delta (C++: adiff_t)
    @param recalc (C++: bool)

Help on function get_best_fit_member in module ida_struct:

get_best_fit_member(*args) -> 'member_t *'
    get_best_fit_member(sptr, offset) -> member_t
    
    
    Get member that is most likely referenced by the specified offset.
    Useful for offsets > sizeof(struct).
    
    @param sptr (C++: const  struc_t  *)
    @param offset (C++: asize_t)

Help on function get_first_struc_idx in module ida_struct:

get_first_struc_idx(*args) -> 'uval_t'
    get_first_struc_idx() -> uval_t
    
    
    Get index of first structure.
    
    @return: BADADDR  if no known structures, 0 otherwise

Help on function get_last_struc_idx in module ida_struct:

get_last_struc_idx(*args) -> 'uval_t'
    get_last_struc_idx() -> uval_t
    
    
    Get index of last structure.
    
    @return: BADADDR  if no known structures,  get_struc_qty() -1
             otherwise

Help on function get_max_offset in module ida_struct:

get_max_offset(*args) -> 'ea_t'
    get_max_offset(sptr) -> ea_t
    
    
    For unions: returns number of members, for structs: returns size of
    structure.
    
    
    @param sptr (C++: struc_t  *)

Help on function get_member in module ida_struct:

get_member(*args) -> 'member_t *'
    get_member(sptr, offset) -> member_t
    
    
    Get member at given offset.
    
    
    @param sptr (C++: const  struc_t  *)
    @param offset (C++: asize_t)

Help on function get_member_by_fullname in module ida_struct:

get_member_by_fullname(*args) -> 'struc_t **'
    get_member_by_fullname(fullname) -> member_t
    
    
    Get a member by its fully qualified name, "struct.field".
    
    
    @param fullname (C++: const char *)

Help on function get_member_by_id in module ida_struct:

get_member_by_id(*args) -> 'qstring *, struc_t **'
    get_member_by_id(mid) -> member_t
    
    
    Check if the specified member id points to a struct member.
    
    
    @param mid (C++: tid_t)

Help on function get_member_by_name in module ida_struct:

get_member_by_name(*args) -> 'member_t *'
    get_member_by_name(sptr, membername) -> member_t
    
    
    Get a member by its name, like "field44".
    
    
    @param sptr (C++: const  struc_t  *)
    @param membername (C++: const char *)

Help on function get_member_cmt in module ida_struct:

get_member_cmt(*args) -> 'qstring *'
    get_member_cmt(mid, repeatable) -> str
    
    
    Get comment of structure member.
    
    
    @param mid (C++: tid_t)
    @param repeatable (C++: bool)

Help on function get_member_fullname in module ida_struct:

get_member_fullname(*args) -> 'qstring *'
    get_member_fullname(mid) -> str
    
    
    Get a member's fully qualified name, "struct.field".
    
    
    @param mid (C++: tid_t)

Help on function get_member_id in module ida_struct:

get_member_id(*args) -> 'tid_t'
    get_member_id(sptr, offset) -> tid_t
    
    
    Get member id at given offset.
    
    
    @param sptr (C++: const  struc_t  *)
    @param offset (C++: asize_t)

Help on function get_member_name in module ida_struct:

get_member_name(*args) -> 'qstring *'
    get_member_name(mid) -> str
    
    
    Get name of structure member.
    
    
    @param mid (C++: tid_t)

Help on function get_member_size in module ida_struct:

get_member_size(*args) -> 'asize_t'
    get_member_size(nonnul_mptr) -> asize_t
    
    
    Get size of structure member. May return 0 for the last member of
    varstruct. For union members, returns 'member_t::eoff' .

Help on function get_member_struc in module ida_struct:

get_member_struc(*args) -> 'struc_t *'
    get_member_struc(fullname) -> struc_t
    
    
    Get containing structure of member by its full name "struct.field".
    
    
    @param fullname (C++: const char *)

Help on function get_member_tinfo in module ida_struct:

get_member_tinfo(*args) -> 'bool'
    get_member_tinfo(tif, mptr) -> bool
    
    
    Get tinfo for given member.
    
    
    @param tif (C++: tinfo_t  *)
    @param mptr (C++: const  member_t  *)

Help on function get_next_member_idx in module ida_struct:

get_next_member_idx(*args) -> 'ssize_t'
    get_next_member_idx(sptr, off) -> ssize_t
    
    
    Get the next member idx, if it does not exist, return -1.
    
    
    @param sptr (C++: const  struc_t  *)
    @param off (C++: asize_t)

Help on function get_next_struc_idx in module ida_struct:

get_next_struc_idx(*args) -> 'uval_t'
    get_next_struc_idx(idx) -> uval_t
    
    
    Get next struct index.
    
    @param idx (C++: uval_t)
    @return: BADADDR  if resulting index is out of bounds, otherwise idx++

Help on function get_or_guess_member_tinfo in module ida_struct:

get_or_guess_member_tinfo(*args) -> 'bool'
    get_or_guess_member_tinfo(tif, mptr) -> bool
    
    
    Try to get tinfo for given member - if failed, generate a tinfo using
    information about the member id from the disassembly
    
    @param tif (C++: tinfo_t  *)
    @param mptr (C++: const  member_t  *)

Help on function get_prev_member_idx in module ida_struct:

get_prev_member_idx(*args) -> 'ssize_t'
    get_prev_member_idx(sptr, off) -> ssize_t
    
    
    Get the prev member idx, if it does not exist, return -1.
    
    
    @param sptr (C++: const  struc_t  *)
    @param off (C++: asize_t)

Help on function get_prev_struc_idx in module ida_struct:

get_prev_struc_idx(*args) -> 'uval_t'
    get_prev_struc_idx(idx) -> uval_t
    
    
    Get previous struct index.
    
    @param idx (C++: uval_t)
    @return: BADADDR  if resulting index is negative, otherwise idx - 1

Help on function get_sptr in module ida_struct:

get_sptr(*args) -> 'struc_t *'
    get_sptr(mptr) -> struc_t
    
    
    Get child struct if member is a struct.
    
    
    @param mptr (C++: const  member_t  *)

Help on function get_struc in module ida_struct:

get_struc(*args) -> 'struc_t *'
    get_struc(id) -> struc_t
    
    
    Get pointer to struct type info.
    
    
    @param id (C++: tid_t)

Help on function get_struc_by_idx in module ida_struct:

get_struc_by_idx(*args) -> 'tid_t'
    get_struc_by_idx(idx) -> tid_t
    
    
    Get struct id by struct number.
    
    
    @param idx (C++: uval_t)

Help on function get_struc_cmt in module ida_struct:

get_struc_cmt(*args) -> 'qstring *'
    get_struc_cmt(id, repeatable) -> str
    
    
    Get struct comment.
    
    
    @param id (C++: tid_t)
    @param repeatable (C++: bool)

Help on function get_struc_first_offset in module ida_struct:

get_struc_first_offset(*args) -> 'ea_t'
    get_struc_first_offset(sptr) -> ea_t
    
    
    Get offset of first member.
    
    @param sptr (C++: const  struc_t  *)
    @return: BADADDR  if memqty == 0

Help on function get_struc_id in module ida_struct:

get_struc_id(*args) -> 'tid_t'
    get_struc_id(name) -> tid_t
    
    
    Get struct id by name.
    
    
    @param name (C++: const char *)

Help on function get_struc_idx in module ida_struct:

get_struc_idx(*args) -> 'uval_t'
    get_struc_idx(id) -> uval_t
    
    
    Get internal number of the structure.
    
    
    @param id (C++: tid_t)

Help on function get_struc_last_offset in module ida_struct:

get_struc_last_offset(*args) -> 'ea_t'
    get_struc_last_offset(sptr) -> ea_t
    
    
    Get offset of last member.
    
    @param sptr (C++: const  struc_t  *)
    @return: BADADDR  if memqty == 0

Help on function get_struc_name in module ida_struct:

get_struc_name(*args) -> 'qstring *'
    get_struc_name(id, flags=0) -> str
    
    
    Get struct name by id
    
    @param id: struct id (C++: tid_t)
    @param flags: Struct name flags (C++: int)

Help on function get_struc_next_offset in module ida_struct:

get_struc_next_offset(*args) -> 'ea_t'
    get_struc_next_offset(sptr, offset) -> ea_t
    
    
    Get offset of member with smallest offset larger than 'offset'.
    
    @param sptr (C++: const  struc_t  *)
    @param offset (C++: ea_t)
    @return: BADADDR  if no next offset

Help on function get_struc_prev_offset in module ida_struct:

get_struc_prev_offset(*args) -> 'ea_t'
    get_struc_prev_offset(sptr, offset) -> ea_t
    
    
    Get offset of member with largest offset less than 'offset'.
    
    @param sptr (C++: const  struc_t  *)
    @param offset (C++: ea_t)
    @return: BADADDR  if no prev offset

Help on function get_struc_qty in module ida_struct:

get_struc_qty(*args) -> 'size_t'
    get_struc_qty() -> size_t
    
    
    Get number of known structures.

Help on function get_struc_size in module ida_struct:

get_struc_size(*args) -> 'asize_t'
    get_struc_size(sptr) -> asize_t
    get_struc_size(id) -> asize_t
    
    
    Get struct size (also see 'get_struc_size(tid_t)' )
    
    
    @param sptr (C++: const  struc_t  *)

Help on function is_anonymous_member_name in module ida_struct:

is_anonymous_member_name(*args) -> 'bool'
    is_anonymous_member_name(name) -> bool
    
    
    Is member name prefixed with "anonymous"?
    
    
    @param name (C++: const char *)

Help on function is_dummy_member_name in module ida_struct:

is_dummy_member_name(*args) -> 'bool'
    is_dummy_member_name(name) -> bool
    
    
    Is member name an auto-generated name?
    
    
    @param name (C++: const char *)

Help on function is_member_id in module ida_struct:

is_member_id(*args) -> 'bool'
    is_member_id(mid) -> bool
    
    
    Is a member id?
    
    
    @param mid (C++: tid_t)

Help on function is_special_member in module ida_struct:

is_special_member(*args) -> 'bool'
    is_special_member(id) -> bool
    
    
    Is a special member with the name beginning with ' '?
    
    
    @param id (C++: tid_t)

Help on function is_union in module ida_struct:

is_union(*args) -> 'bool'
    is_union(id) -> bool
    
    
    Is a union?
    
    
    @param id (C++: tid_t)

Help on function is_varmember in module ida_struct:

is_varmember(*args) -> 'bool'
    is_varmember(mptr) -> bool
    
    
    Is variable size member?
    
    
    @param mptr (C++: const  member_t  *)

Help on function is_varstr in module ida_struct:

is_varstr(*args) -> 'bool'
    is_varstr(id) -> bool
    
    
    Is variable size structure?
    
    
    @param id (C++: tid_t)

Help on class member_t in module ida_struct:

class member_t(builtins.object)
 |  Proxy of C++ member_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> member_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_member_t(...)
 |      delete_member_t(self)
 |  
 |  by_til(self, *args) -> 'bool'
 |      by_til(self) -> bool
 |  
 |  get_soff(self, *args) -> 'ea_t'
 |      get_soff(self) -> ea_t
 |  
 |  has_ti(self, *args) -> 'bool'
 |      has_ti(self) -> bool
 |  
 |  has_union(self, *args) -> 'bool'
 |      has_union(self) -> bool
 |  
 |  is_baseclass(self, *args) -> 'bool'
 |      is_baseclass(self) -> bool
 |  
 |  is_destructor(self, *args) -> 'bool'
 |      is_destructor(self) -> bool
 |  
 |  is_dupname(self, *args) -> 'bool'
 |      is_dupname(self) -> bool
 |  
 |  unimem(self, *args) -> 'bool'
 |      unimem(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  eoff
 |      member_t_eoff_get(self) -> ea_t
 |  
 |  flag
 |      member_t_flag_get(self) -> flags_t
 |  
 |  id
 |      member_t_id_get(self) -> tid_t
 |  
 |  props
 |      member_t_props_get(self) -> uint32
 |  
 |  soff
 |      member_t_soff_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag

Help on function retrieve_member_info in module ida_struct:

retrieve_member_info(*args) -> 'opinfo_t *'
    retrieve_member_info(buf, mptr) -> opinfo_t
    
    
    Get operand type info for member.
    
    
    @param buf (C++: opinfo_t  *)
    @param mptr (C++: const  member_t  *)

Help on function save_struc in module ida_struct:

save_struc(*args) -> 'void'
    save_struc(sptr, may_update_ltypes=True)
    
    
    Update struct information in the database (internal function)
    
    
    @param sptr (C++: struc_t  *)
    @param may_update_ltypes (C++: bool)

Help on function set_member_cmt in module ida_struct:

set_member_cmt(*args) -> 'bool'
    set_member_cmt(mptr, cmt, repeatable) -> bool
    
    
    Set member comment.
    
    
    @param mptr (C++: member_t  *)
    @param cmt (C++: const char *)
    @param repeatable (C++: bool)

Help on function set_member_name in module ida_struct:

set_member_name(*args) -> 'bool'
    set_member_name(sptr, offset, name) -> bool
    
    
    Set name of member at given offset.
    
    
    @param sptr (C++: struc_t  *)
    @param offset (C++: ea_t)
    @param name (C++: const char *)

Help on function set_member_tinfo in module ida_struct:

set_member_tinfo(*args) -> 'smt_code_t'
    set_member_tinfo(sptr, mptr, memoff, tif, flags) -> smt_code_t
    
    
    Set tinfo for given member.
    
    @param sptr: containing struct (C++: struc_t  *)
    @param mptr: target member (C++: member_t  *)
    @param memoff: offset within member (C++: uval_t)
    @param tif: type info (C++: const  tinfo_t  &)
    @param flags: Set member tinfo flags (C++: int)

Help on function set_member_type in module ida_struct:

set_member_type(*args) -> 'bool'
    set_member_type(sptr, offset, flag, mt, nbytes) -> bool
    
    
    Set type of member at given offset (also see 'add_struc_member()' )
    
    
    @param sptr (C++: struc_t  *)
    @param offset (C++: ea_t)
    @param flag (C++: flags_t)
    @param mt (C++: const  opinfo_t  *)
    @param nbytes (C++: asize_t)

Help on function set_struc_align in module ida_struct:

set_struc_align(*args) -> 'bool'
    set_struc_align(sptr, shift) -> bool
    
    
    Set structure alignment ( 'SF_ALIGN' )
    
    
    @param sptr (C++: struc_t  *)
    @param shift (C++: int)

Help on function set_struc_cmt in module ida_struct:

set_struc_cmt(*args) -> 'bool'
    set_struc_cmt(id, cmt, repeatable) -> bool
    
    
    Set structure comment.
    
    
    @param id (C++: tid_t)
    @param cmt (C++: const char *)
    @param repeatable (C++: bool)

Help on function set_struc_hidden in module ida_struct:

set_struc_hidden(*args) -> 'void'
    set_struc_hidden(sptr, is_hidden)
    
    
    Hide/unhide a struct type.
    
    
    @param sptr (C++: struc_t  *)
    @param is_hidden (C++: bool)

Help on function set_struc_idx in module ida_struct:

set_struc_idx(*args) -> 'bool'
    set_struc_idx(sptr, idx) -> bool
    
    
    Set internal number of struct. Also see 'get_struc_idx()' ,
    'get_struc_by_idx()' .
    
    @param sptr (C++: const  struc_t  *)
    @param idx (C++: uval_t)

Help on function set_struc_listed in module ida_struct:

set_struc_listed(*args) -> 'void'
    set_struc_listed(sptr, is_listed)
    
    
    Add/remove a struct type from the struct list.
    
    
    @param sptr (C++: struc_t  *)
    @param is_listed (C++: bool)

Help on function set_struc_name in module ida_struct:

set_struc_name(*args) -> 'bool'
    set_struc_name(id, name) -> bool
    
    
    Set structure name.
    
    
    @param id (C++: tid_t)
    @param name (C++: const char *)

Help on function stroff_as_size in module ida_struct:

stroff_as_size(*args) -> 'bool'
    stroff_as_size(plen, sptr, value) -> bool
    
    
    Should display a structure offset expression as the structure size?
    
    
    @param plen (C++: int)
    @param sptr (C++: const  struc_t  *)
    @param value (C++: asize_t)

Help on class struc_t in module ida_struct:

class struc_t(builtins.object)
 |  Proxy of C++ struc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_struc_t(...)
 |      delete_struc_t(self)
 |  
 |  from_til(self, *args) -> 'bool'
 |      from_til(self) -> bool
 |  
 |  get_alignment(self, *args) -> 'int'
 |      get_alignment(self) -> int
 |  
 |  get_member(self, *args) -> 'member_t *'
 |      get_member(self, index) -> member_t
 |  
 |  has_union(self, *args) -> 'bool'
 |      has_union(self) -> bool
 |  
 |  is_choosable(self, *args) -> 'bool'
 |      is_choosable(self) -> bool
 |  
 |  is_frame(self, *args) -> 'bool'
 |      is_frame(self) -> bool
 |  
 |  is_ghost(self, *args) -> 'bool'
 |      is_ghost(self) -> bool
 |  
 |  is_hidden(self, *args) -> 'bool'
 |      is_hidden(self) -> bool
 |  
 |  is_union(self, *args) -> 'bool'
 |      is_union(self) -> bool
 |  
 |  is_varstr(self, *args) -> 'bool'
 |      is_varstr(self) -> bool
 |  
 |  set_alignment(self, *args) -> 'void'
 |      set_alignment(self, shift)
 |  
 |  set_ghost(self, *args) -> 'void'
 |      set_ghost(self, _is_ghost)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  age
 |      struc_t_age_get(self) -> ushort
 |  
 |  id
 |      struc_t_id_get(self) -> tid_t
 |  
 |  members
 |      struc_t_members_get(self) -> member_t
 |  
 |  memqty
 |      struc_t_memqty_get(self) -> uint32
 |  
 |  ordinal
 |      struc_t_ordinal_get(self) -> int32
 |  
 |  props
 |      struc_t_props_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag

Help on class struct_field_visitor_t in module ida_struct:

class struct_field_visitor_t(builtins.object)
 |  Proxy of C++ struct_field_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> struct_field_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_struct_field_visitor_t(...)
 |      delete_struct_field_visitor_t(self)
 |  
 |  visit_field(self, *args) -> 'int'
 |      visit_field(self, sptr, mptr) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function visit_stroff_fields in module ida_struct:

visit_stroff_fields(*args) -> 'adiff_t *'
    visit_stroff_fields(sfv, path, disp, appzero) -> flags_t
    
    
    Visit structure fields in a stroff expression or in a reference to a
    struct data variable. This function can be used to enumerate all
    components of an expression like 'a.b.c'.
    
    @param sfv: visitor object (C++: struct_field_visitor_t  &)
    @param path: struct path (path[0] contains the initial struct id)
                 (C++: const  tid_t  *)
    @param disp: offset into structure (C++: adiff_t *)
    @param appzero: should visit field at offset zero? (C++: bool)

=== ida_struct EPYDOC INJECTIONS ===
ida_struct.MF_BASECLASS
"""
a special member representing base class
"""

ida_struct.MF_BYTIL
"""
the member was created due to the type system
"""

ida_struct.MF_DTOR
"""
a special member representing destructor
"""

ida_struct.MF_DUPNAME
"""
duplicate name resolved with _N suffix (N==soff)
"""

ida_struct.MF_HASTI
"""
has type information?
"""

ida_struct.MF_HASUNI
"""
has members of type "union"?
"""

ida_struct.MF_OK
"""
is the member ok? (always yes)
"""

ida_struct.MF_UNIMEM
"""
is a member of a union?
"""

ida_struct.SET_MEMTI_BYTIL
"""
new type was created by the type subsystem
"""

ida_struct.SET_MEMTI_COMPATIBLE
"""
new type must be compatible with the old
"""

ida_struct.SET_MEMTI_FUNCARG
"""
mptr is function argument (cannot create arrays)
"""

ida_struct.SET_MEMTI_MAY_DESTROY
"""
may destroy other members
"""

ida_struct.SET_MEMTI_USERTI
"""
user-specified type
"""

ida_struct.SF_ALIGN
"""
alignment (shift amount: 0..31)
"""

ida_struct.SF_FRAME
"""
the structure is a function frame
"""

ida_struct.SF_GHOST
"""
ghost copy of a local type
"""

ida_struct.SF_HASUNI
"""
has members of type "union"?
"""

ida_struct.SF_HIDDEN
"""
the structure is collapsed
"""

ida_struct.SF_NOLIST
"""
don't include in the chooser list
"""

ida_struct.SF_TYPLIB
"""
the structure comes from type library
"""

ida_struct.SF_UNION
"""
varunions are prohibited!

is a union?
"""

ida_struct.SF_VAR
"""
is variable size structure (varstruct)? a variable size structure is
one with the zero size last member. if the last member is a varstruct,
then the current structure is a varstruct too.
"""

ida_struct.STRNFL_REGEX
"""
apply regular expressions to beautify the name
"""

ida_struct.STRUC_SEPARATOR
"""
structname.fieldname
"""
=== ida_struct EPYDOC INJECTIONS END ===
Help on function add_tryblk in module ida_tryblks:

add_tryblk(*args) -> 'int'
    add_tryblk(tb) -> int
    
    
    Add one try block information.
    
    @param tb: try block to add. (C++: const  tryblk_t  &)
    @return: error code; 0 means good

Help on class catch_t in module ida_tryblks:

class catch_t(try_handler_t)
 |  Proxy of C++ catch_t class.
 |  
 |  Method resolution order:
 |      catch_t
 |      try_handler_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> catch_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_catch_t(...)
 |      delete_catch_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  obj
 |      catch_t_obj_get(self) -> sval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type_id
 |      catch_t_type_id_get(self) -> sval_t
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from try_handler_t:
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from try_handler_t:
 |  
 |  disp
 |      try_handler_t_disp_get(self) -> sval_t
 |  
 |  fpreg
 |      try_handler_t_fpreg_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      erase(self, first, last) -> range_t
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      find(self, x) -> range_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.rangevec_base_t:
 |  
 |  __hash__ = None

Help on class catchvec_t in module ida_tryblks:

class catchvec_t(builtins.object)
 |  Proxy of C++ qvector< catch_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'catch_t const &'
 |      __getitem__(self, i) -> catch_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> catchvec_t
 |      __init__(self, x) -> catchvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_catchvec_t(...)
 |      delete_catchvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'catch_t const &'
 |      at(self, _idx) -> catch_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< catch_t >::const_iterator'
 |      begin(self) -> catch_t
 |      begin(self) -> catch_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< catch_t >::const_iterator'
 |      end(self) -> catch_t
 |      end(self) -> catch_t
 |  
 |  erase(self, *args) -> 'qvector< catch_t >::iterator'
 |      erase(self, it) -> catch_t
 |      erase(self, first, last) -> catch_t
 |  
 |  extract(self, *args) -> 'catch_t *'
 |      extract(self) -> catch_t
 |  
 |  find(self, *args) -> 'qvector< catch_t >::const_iterator'
 |      find(self, x) -> catch_t
 |      find(self, x) -> catch_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=catch_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< catch_t >::iterator'
 |      insert(self, it, x) -> catch_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'catch_t &'
 |      push_back(self, x)
 |      push_back(self) -> catch_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function del_tryblks in module ida_tryblks:

del_tryblks(*args) -> 'void'
    del_tryblks(range)
    
    
    Delete try block information in the specified range.
    
    @param range: the range to be cleared (C++: const  range_t  &)

Help on function find_syseh in module ida_tryblks:

find_syseh(*args) -> 'ea_t'
    find_syseh(ea) -> ea_t
    
    
    Find the start address of the system eh region including the argument.
    
    @param ea: search address (C++: ea_t)
    @return: start address of surrounding tryblk, otherwise BADADDR

Help on function get_tryblks in module ida_tryblks:

get_tryblks(*args) -> 'size_t'
    get_tryblks(tbv, range) -> size_t
    
    
    Retrieve try block information from the specified address range. Try
    blocks are sorted by starting address and their nest levels
    calculated.
    
    @param tbv: output buffer; may be NULL (C++: tryblks_t  *)
    @param range: address range to change (C++: const  range_t  &)
    @return: number of found try blocks

Help on class seh_t in module ida_tryblks:

class seh_t(try_handler_t)
 |  Proxy of C++ seh_t class.
 |  
 |  Method resolution order:
 |      seh_t
 |      try_handler_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> seh_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_seh_t(...)
 |      delete_seh_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  filter
 |      seh_t_filter_get(self) -> rangevec_t
 |  
 |  seh_code
 |      seh_t_seh_code_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from try_handler_t:
 |  
 |  disp
 |      try_handler_t_disp_get(self) -> sval_t
 |  
 |  fpreg
 |      try_handler_t_fpreg_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      erase(self, first, last) -> range_t
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      find(self, x) -> range_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.rangevec_base_t:
 |  
 |  __hash__ = None

Help on class try_handler_t in module ida_tryblks:

class try_handler_t(ida_range.rangevec_t)
 |  Proxy of C++ try_handler_t class.
 |  
 |  Method resolution order:
 |      try_handler_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> try_handler_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_try_handler_t(...)
 |      delete_try_handler_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  disp
 |      try_handler_t_disp_get(self) -> sval_t
 |  
 |  fpreg
 |      try_handler_t_fpreg_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      erase(self, first, last) -> range_t
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      find(self, x) -> range_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.rangevec_base_t:
 |  
 |  __hash__ = None

Help on class tryblk_t in module ida_tryblks:

class tryblk_t(ida_range.rangevec_t)
 |  Proxy of C++ tryblk_t class.
 |  
 |  Method resolution order:
 |      tryblk_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tryblk_t
 |      __init__(self, r) -> tryblk_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_tryblk_t(...)
 |      delete_tryblk_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  cpp(self, *args) -> 'catchvec_t &'
 |      cpp(self) -> catchvec_t
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  get_kind(self, *args) -> 'uchar'
 |      get_kind(self) -> uchar
 |  
 |  is_cpp(self, *args) -> 'bool'
 |      is_cpp(self) -> bool
 |  
 |  is_seh(self, *args) -> 'bool'
 |      is_seh(self) -> bool
 |  
 |  seh(self, *args) -> 'seh_t &'
 |      seh(self) -> seh_t
 |  
 |  set_cpp(self, *args) -> 'catchvec_t &'
 |      set_cpp(self) -> catchvec_t
 |  
 |  set_seh(self, *args) -> 'seh_t &'
 |      set_seh(self) -> seh_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  level
 |      tryblk_t_level_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      erase(self, first, last) -> range_t
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      find(self, x) -> range_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.rangevec_base_t:
 |  
 |  __hash__ = None

Help on class tryblks_t in module ida_tryblks:

class tryblks_t(builtins.object)
 |  Proxy of C++ qvector< tryblk_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'tryblk_t const &'
 |      __getitem__(self, i) -> tryblk_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tryblks_t
 |      __init__(self, x) -> tryblks_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_tryblks_t(...)
 |      delete_tryblks_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'tryblk_t const &'
 |      at(self, _idx) -> tryblk_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< tryblk_t >::const_iterator'
 |      begin(self) -> tryblk_t
 |      begin(self) -> tryblk_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< tryblk_t >::const_iterator'
 |      end(self) -> tryblk_t
 |      end(self) -> tryblk_t
 |  
 |  erase(self, *args) -> 'qvector< tryblk_t >::iterator'
 |      erase(self, it) -> tryblk_t
 |      erase(self, first, last) -> tryblk_t
 |  
 |  extract(self, *args) -> 'tryblk_t *'
 |      extract(self) -> tryblk_t
 |  
 |  find(self, *args) -> 'qvector< tryblk_t >::const_iterator'
 |      find(self, x) -> tryblk_t
 |      find(self, x) -> tryblk_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=tryblk_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< tryblk_t >::iterator'
 |      insert(self, it, x) -> tryblk_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'tryblk_t &'
 |      push_back(self, x)
 |      push_back(self) -> tryblk_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

=== ida_tryblks EPYDOC INJECTIONS ===
ida_tryblks.TBERR_EMPTY
"""
empty try block
"""

ida_tryblks.TBERR_END
"""
bad end address
"""

ida_tryblks.TBERR_INTERSECT
"""
range would intersect inner tryblk
"""

ida_tryblks.TBERR_KIND
"""
illegal try block kind
"""

ida_tryblks.TBERR_NO_CATCHES
"""
no catch blocks at all
"""

ida_tryblks.TBERR_OK
"""
ok
"""

ida_tryblks.TBERR_ORDER
"""
bad address order
"""

ida_tryblks.TBERR_START
"""
bad start address
"""
=== ida_tryblks EPYDOC INJECTIONS END ===
Help on function add_til in module ida_typeinf:

add_til(*args) -> 'int'
    add_til(name, flags) -> int
    
    
    Load a til file.
    
    @param name: til name (C++: const char *)
    @param flags: combination of  Load TIL flags (C++: int)
    @return: one of  Load TIL result codes

Help on function alloc_type_ordinal in module ida_typeinf:

alloc_type_ordinal(*args) -> 'uint32'
    alloc_type_ordinal(ti) -> uint32
    
    
    \call2{alloc_type_ordinals,ti,1}
    
    
    @param ti (C++: til_t  *)

Help on function alloc_type_ordinals in module ida_typeinf:

alloc_type_ordinals(*args) -> 'uint32'
    alloc_type_ordinals(ti, qty) -> uint32
    
    
    Allocate a range of ordinal numbers for new types.
    
    @param ti: type library (C++: til_t  *)
    @param qty: number of ordinals to allocate (C++: int)
    @return: the first ordinal. 0 means failure.

Help on class aloc_visitor_t in module ida_typeinf:

class aloc_visitor_t(builtins.object)
 |  Proxy of C++ aloc_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> aloc_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_aloc_visitor_t(...)
 |      delete_aloc_visitor_t(self)
 |  
 |  visit_location(self, *args) -> 'int'
 |      visit_location(self, v, off, size) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function append_abi_opts in module ida_typeinf:

append_abi_opts(*args) -> 'bool'
    append_abi_opts(abi_opts, user_level=False) -> bool
    
    
    Add/remove/check ABI option General form of full abi name: abiname-
    opt1-opt2-... or -opt1-opt2-...
    
    @param abi_opts: - ABI options to add/remove in form opt1-opt2-...
                     (C++: const char *)
    @param user_level: - initiated by user if TRUE (==SETCOMP_BY_USER)
                       (C++: bool)
    @return: success

Help on function append_argloc in module ida_typeinf:

append_argloc(*args) -> 'bool'
    append_argloc(out, vloc) -> bool
    
    
    Serialize argument location.
    
    
    @param out (C++: qtype  *)
    @param vloc (C++: const  argloc_t  &)

Help on function append_tinfo_covered in module ida_typeinf:

append_tinfo_covered(*args) -> 'bool'
    append_tinfo_covered(out, typid, offset) -> bool

Help on function apply_callee_tinfo in module ida_typeinf:

apply_callee_tinfo(*args) -> 'bool'
    apply_callee_tinfo(caller, tif) -> bool
    
    
    Apply the type of the called function to the calling instruction. This
    function will append parameter comments and rename the local variables
    of the calling function. It also stores information about the
    instructions that initialize call arguments in the database. Use
    'get_arg_addrs()' to retrieve it if necessary. Alternatively it is
    possible to hook to processor_t::arg_addrs_ready event.
    
    @param caller: linear address of the calling instruction. must belong
                   to a function. (C++: ea_t)
    @param tif: type info (C++: const  tinfo_t  &)
    @return: success

Help on function apply_cdecl in module ida_typeinf:

apply_cdecl(*args) -> 'bool'
    apply_cdecl(til, ea, decl, flags=0) -> bool
    
    
    Apply the specified type to the address. This function parses the
    declaration and calls 'apply_tinfo()'
    
    @param til: type library (C++: til_t  *)
    @param ea: linear address (C++: ea_t)
    @param decl: type declaration in C form (C++: const char *)
    @param flags: flags to pass to apply_tinfo ( TINFO_DEFINITE  is always
                  passed) (C++: int)
    @return: success

Help on function apply_named_type in module ida_typeinf:

apply_named_type(*args) -> 'bool'
    apply_named_type(ea, name) -> bool
    
    
    Apply the specified named type to the address.
    
    @param ea: linear address (C++: ea_t)
    @param name: the type name, e.g. "FILE" (C++: const char *)
    @return: success

Help on function apply_once_tinfo_and_name in module ida_typeinf:

apply_once_tinfo_and_name(*args) -> 'bool'
    apply_once_tinfo_and_name(dea, tif, name) -> bool
    
    
    Apply the specified type and name to the address. This function checks
    if the address already has a type. If the old typedoes not exist or
    the new type is 'better' than the old type, then thenew type will be
    applied. A type is considered better if it has moreinformation (e.g.
    'BTMT_STRUCT' is better than 'BT_INT' ).The same logic is with the
    name: if the address already have a meaningfulname, it will be
    preserved. Only if the old name does not exist or itis a dummy name
    like byte_123, it will be replaced by the new name.
    
    @param dea: linear address (C++: ea_t)
    @param tif: type string in the internal format (C++: const  tinfo_t
                &)
    @param name: new name for the address (C++: const char *)
    @return: success

Help on function apply_tinfo in module ida_typeinf:

apply_tinfo(*args) -> 'bool'
    apply_tinfo(ea, tif, flags) -> bool
    
    
    Apply the specified type to the specified address. This function sets
    the type and tries to convert the item at the specified address to
    conform the type.
    
    @param ea: linear address (C++: ea_t)
    @param tif: type string in internal format (C++: const  tinfo_t  &)
    @param flags: combination of  Apply tinfo flags (C++: uint32)
    @return: success

Help on function apply_tinfo_to_stkarg in module ida_typeinf:

apply_tinfo_to_stkarg(*args) -> 'bool'
    apply_tinfo_to_stkarg(insn, x, v, tif, name) -> bool
    
    
    Helper function for the processor modules. to be called from
    \ph{use_stkarg_type}
    
    @param insn (C++: const  insn_t  &)
    @param x (C++: const  op_t  &)
    @param v (C++: uval_t)
    @param tif (C++: const  tinfo_t  &)
    @param name (C++: const char *)

Help on function apply_type in module ida_typeinf:

apply_type(*args) -> 'bool'
    apply_type(ti, _type, _fields, ea, flags) -> bool
    
    
    Apply the specified type to the address
    @param ti: Type info library. 'None' can be used.
    @param py_type: type string
    @param py_fields: fields string (may be empty or None)
    @param ea: the address of the object
    @param flags: combination of TINFO_... constants or 0
    @return: Boolean

Help on class argloc_t in module ida_typeinf:

class argloc_t(builtins.object)
 |  Proxy of C++ argloc_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> argloc_t
 |      __init__(self, r) -> argloc_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_argloc_t(...)
 |      delete_argloc_t(self)
 |  
 |  _consume_rrel(self, *args) -> 'bool'
 |      _consume_rrel(self, p) -> bool
 |  
 |  _consume_scattered(self, *args) -> 'bool'
 |      _consume_scattered(self, p) -> bool
 |  
 |  _set_badloc(self, *args) -> 'void'
 |      _set_badloc(self)
 |  
 |  _set_biggest(self, *args) -> 'void'
 |      _set_biggest(self, ct, data)
 |  
 |  _set_custom(self, *args) -> 'void'
 |      _set_custom(self, ct, pdata)
 |  
 |  _set_ea(self, *args) -> 'void'
 |      _set_ea(self, _ea)
 |  
 |  _set_reg1(self, *args) -> 'void'
 |      _set_reg1(self, reg, off=0)
 |  
 |  _set_reg2(self, *args) -> 'void'
 |      _set_reg2(self, _reg1, _reg2)
 |  
 |  _set_stkoff(self, *args) -> 'void'
 |      _set_stkoff(self, off)
 |  
 |  advance(self, *args) -> 'bool'
 |      advance(self, delta) -> bool
 |  
 |  atype(self, *args) -> 'argloc_type_t'
 |      atype(self) -> argloc_type_t
 |  
 |  calc_offset(self, *args) -> 'sval_t'
 |      calc_offset(self) -> sval_t
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  consume_rrel(self, *args) -> 'void'
 |      consume_rrel(self, p)
 |  
 |  consume_scattered(self, *args) -> 'void'
 |      consume_scattered(self, p)
 |  
 |  get_biggest(self, *args) -> 'argloc_t::biggest_t'
 |      get_biggest(self) -> argloc_t::biggest_t
 |  
 |  get_custom(self, *args) -> 'void *'
 |      get_custom(self) -> void *
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self) -> ea_t
 |  
 |  get_reginfo(self, *args) -> 'uint32'
 |      get_reginfo(self) -> uint32
 |  
 |  get_rrel(self, *args) -> 'rrel_t const &'
 |      get_rrel(self) -> rrel_t
 |      get_rrel(self) -> rrel_t
 |  
 |  has_reg(self, *args) -> 'bool'
 |      has_reg(self) -> bool
 |  
 |  has_stkoff(self, *args) -> 'bool'
 |      has_stkoff(self) -> bool
 |  
 |  is_badloc(self, *args) -> 'bool'
 |      is_badloc(self) -> bool
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |  
 |  is_ea(self, *args) -> 'bool'
 |      is_ea(self) -> bool
 |  
 |  is_fragmented(self, *args) -> 'bool'
 |      is_fragmented(self) -> bool
 |  
 |  is_mixed_scattered(self, *args) -> 'bool'
 |      is_mixed_scattered(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |  
 |  is_rrel(self, *args) -> 'bool'
 |      is_rrel(self) -> bool
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |  
 |  justify_reg_high(self, *args) -> 'void'
 |      justify_reg_high(self, size, _slotsize)
 |  
 |  justify_stkoff_right(self, *args) -> 'void'
 |      justify_stkoff_right(self, size, _slotsize)
 |  
 |  reg1(self, *args) -> 'int'
 |      reg1(self) -> int
 |  
 |  reg2(self, *args) -> 'int'
 |      reg2(self) -> int
 |  
 |  regoff(self, *args) -> 'int'
 |      regoff(self) -> int
 |  
 |  scattered(self, *args) -> 'scattered_aloc_t const &'
 |      scattered(self) -> scattered_aloc_t
 |      scattered(self) -> scattered_aloc_t
 |  
 |  set_badloc(self, *args) -> 'void'
 |      set_badloc(self)
 |  
 |  set_ea(self, *args) -> 'void'
 |      set_ea(self, _ea)
 |  
 |  set_reg1(self, *args) -> 'void'
 |      set_reg1(self, reg, off=0)
 |  
 |  set_reg2(self, *args) -> 'void'
 |      set_reg2(self, _reg1, _reg2)
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, off)
 |  
 |  stkoff(self, *args) -> 'sval_t'
 |      stkoff(self) -> sval_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class argpart_t in module ida_typeinf:

class argpart_t(argloc_t)
 |  Proxy of C++ argpart_t class.
 |  
 |  Method resolution order:
 |      argpart_t
 |      argloc_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, a) -> argpart_t
 |      __init__(self) -> argpart_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_argpart_t(...)
 |      delete_argpart_t(self)
 |  
 |  bad_offset(self, *args) -> 'bool'
 |      bad_offset(self) -> bool
 |  
 |  bad_size(self, *args) -> 'bool'
 |      bad_size(self) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  off
 |      argpart_t_off_get(self) -> ushort
 |  
 |  size
 |      argpart_t_size_get(self) -> ushort
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from argloc_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  _consume_rrel(self, *args) -> 'bool'
 |      _consume_rrel(self, p) -> bool
 |  
 |  _consume_scattered(self, *args) -> 'bool'
 |      _consume_scattered(self, p) -> bool
 |  
 |  _set_badloc(self, *args) -> 'void'
 |      _set_badloc(self)
 |  
 |  _set_biggest(self, *args) -> 'void'
 |      _set_biggest(self, ct, data)
 |  
 |  _set_custom(self, *args) -> 'void'
 |      _set_custom(self, ct, pdata)
 |  
 |  _set_ea(self, *args) -> 'void'
 |      _set_ea(self, _ea)
 |  
 |  _set_reg1(self, *args) -> 'void'
 |      _set_reg1(self, reg, off=0)
 |  
 |  _set_reg2(self, *args) -> 'void'
 |      _set_reg2(self, _reg1, _reg2)
 |  
 |  _set_stkoff(self, *args) -> 'void'
 |      _set_stkoff(self, off)
 |  
 |  advance(self, *args) -> 'bool'
 |      advance(self, delta) -> bool
 |  
 |  atype(self, *args) -> 'argloc_type_t'
 |      atype(self) -> argloc_type_t
 |  
 |  calc_offset(self, *args) -> 'sval_t'
 |      calc_offset(self) -> sval_t
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  consume_rrel(self, *args) -> 'void'
 |      consume_rrel(self, p)
 |  
 |  consume_scattered(self, *args) -> 'void'
 |      consume_scattered(self, p)
 |  
 |  get_biggest(self, *args) -> 'argloc_t::biggest_t'
 |      get_biggest(self) -> argloc_t::biggest_t
 |  
 |  get_custom(self, *args) -> 'void *'
 |      get_custom(self) -> void *
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self) -> ea_t
 |  
 |  get_reginfo(self, *args) -> 'uint32'
 |      get_reginfo(self) -> uint32
 |  
 |  get_rrel(self, *args) -> 'rrel_t const &'
 |      get_rrel(self) -> rrel_t
 |      get_rrel(self) -> rrel_t
 |  
 |  has_reg(self, *args) -> 'bool'
 |      has_reg(self) -> bool
 |  
 |  has_stkoff(self, *args) -> 'bool'
 |      has_stkoff(self) -> bool
 |  
 |  is_badloc(self, *args) -> 'bool'
 |      is_badloc(self) -> bool
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |  
 |  is_ea(self, *args) -> 'bool'
 |      is_ea(self) -> bool
 |  
 |  is_fragmented(self, *args) -> 'bool'
 |      is_fragmented(self) -> bool
 |  
 |  is_mixed_scattered(self, *args) -> 'bool'
 |      is_mixed_scattered(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |  
 |  is_rrel(self, *args) -> 'bool'
 |      is_rrel(self) -> bool
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |  
 |  justify_reg_high(self, *args) -> 'void'
 |      justify_reg_high(self, size, _slotsize)
 |  
 |  justify_stkoff_right(self, *args) -> 'void'
 |      justify_stkoff_right(self, size, _slotsize)
 |  
 |  reg1(self, *args) -> 'int'
 |      reg1(self) -> int
 |  
 |  reg2(self, *args) -> 'int'
 |      reg2(self) -> int
 |  
 |  regoff(self, *args) -> 'int'
 |      regoff(self) -> int
 |  
 |  scattered(self, *args) -> 'scattered_aloc_t const &'
 |      scattered(self) -> scattered_aloc_t
 |      scattered(self) -> scattered_aloc_t
 |  
 |  set_badloc(self, *args) -> 'void'
 |      set_badloc(self)
 |  
 |  set_ea(self, *args) -> 'void'
 |      set_ea(self, _ea)
 |  
 |  set_reg1(self, *args) -> 'void'
 |      set_reg1(self, reg, off=0)
 |  
 |  set_reg2(self, *args) -> 'void'
 |      set_reg2(self, _reg1, _reg2)
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, off)
 |  
 |  stkoff(self, *args) -> 'sval_t'
 |      stkoff(self) -> sval_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from argloc_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from argloc_t:
 |  
 |  __hash__ = None

Help on class argpartvec_t in module ida_typeinf:

class argpartvec_t(builtins.object)
 |  Proxy of C++ qvector< argpart_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'argpart_t const &'
 |      __getitem__(self, i) -> argpart_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> argpartvec_t
 |      __init__(self, x) -> argpartvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_argpartvec_t(...)
 |      delete_argpartvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'argpart_t const &'
 |      at(self, _idx) -> argpart_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      begin(self) -> argpart_t
 |      begin(self) -> argpart_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      end(self) -> argpart_t
 |      end(self) -> argpart_t
 |  
 |  erase(self, *args) -> 'qvector< argpart_t >::iterator'
 |      erase(self, it) -> argpart_t
 |      erase(self, first, last) -> argpart_t
 |  
 |  extract(self, *args) -> 'argpart_t *'
 |      extract(self) -> argpart_t
 |  
 |  find(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      find(self, x) -> argpart_t
 |      find(self, x) -> argpart_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=argpart_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< argpart_t >::iterator'
 |      insert(self, it, x) -> argpart_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'argpart_t &'
 |      push_back(self, x)
 |      push_back(self) -> argpart_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class array_type_data_t in module ida_typeinf:

class array_type_data_t(builtins.object)
 |  Proxy of C++ array_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, b=0, n=0) -> array_type_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_array_type_data_t(...)
 |      delete_array_type_data_t(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  base
 |      array_type_data_t_base_get(self) -> uint32
 |  
 |  elem_type
 |      array_type_data_t_elem_type_get(self) -> tinfo_t
 |  
 |  nelems
 |      array_type_data_t_nelems_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag

Help on function begin_type_updating in module ida_typeinf:

begin_type_updating(*args) -> 'void'
    begin_type_updating(utp)
    
    
    Mark the beginning of a large update operation on the types. Can be
    used with 'add_enum_member()' , add_struc_member, etc... Also see
    'end_type_updating()'
    
    @param utp (C++: update_type_t)

Help on class bitfield_type_data_t in module ida_typeinf:

class bitfield_type_data_t(builtins.object)
 |  Proxy of C++ bitfield_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, _nbytes=0, _width=0, _is_unsigned=False) -> bitfield_type_data_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bitfield_type_data_t(...)
 |      delete_bitfield_type_data_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  is_unsigned
 |      bitfield_type_data_t_is_unsigned_get(self) -> bool
 |  
 |  nbytes
 |      bitfield_type_data_t_nbytes_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  width
 |      bitfield_type_data_t_width_get(self) -> uchar
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function calc_c_cpp_name in module ida_typeinf:

calc_c_cpp_name(*args) -> 'qstring *'
    calc_c_cpp_name(name, type, ccn_flags) -> str
    
    
    Get C or C++ form of the name.
    
    @param name: original (mangled or decorated) name (C++: const char *)
    @param type: name type if known, otherwise NULL (C++: const  tinfo_t
                 *)
    @param ccn_flags: one of  C/C++ naming flags (C++: int)

Help on function calc_number_of_children in module ida_typeinf:

calc_number_of_children(*args) -> 'int'
    calc_number_of_children(loc, tif, dont_deref_ptr=False) -> int
    
    
    Calculate max number of lines of a formatted c data, when expanded (
    'PTV_EXPAND' ).
    
    @param loc: location of the data ( ALOC_STATIC  or  ALOC_CUSTOM )
                (C++: const  argloc_t  &)
    @param tif: type info (C++: const  tinfo_t  &)
    @param dont_deref_ptr: consider 'ea' as the ptr value (C++: bool)

Help on function calc_tinfo_gaps in module ida_typeinf:

calc_tinfo_gaps(*args) -> 'bool'
    calc_tinfo_gaps(out, typid) -> bool

Help on function calc_type_size in module ida_typeinf:

calc_type_size(*args) -> 'PyObject *'
    calc_type_size(ti, tp) -> PyObject *
    
    
    Returns the size of a type
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @return:
        - None on failure
        - The size of the type

Help on class callregs_t in module ida_typeinf:

class callregs_t(builtins.object)
 |  Proxy of C++ callregs_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> callregs_t
 |      __init__(self, cc) -> callregs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_callregs_t(...)
 |      delete_callregs_t(self)
 |  
 |  init_regs(self, *args) -> 'void'
 |      init_regs(self, cc)
 |  
 |  reginds(self, *args) -> 'bool'
 |      reginds(self, gp_ind, fp_ind, r) -> bool
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |  
 |  set(self, *args) -> 'void'
 |      set(self, _policy, gprs, fprs)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  regcount(*args) -> 'int'
 |      regcount(cc) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fpregs
 |      callregs_t_fpregs_get(self) -> intvec_t *
 |  
 |  gpregs
 |      callregs_t_gpregs_get(self) -> intvec_t *
 |  
 |  nregs
 |      callregs_t_nregs_get(self) -> int
 |  
 |  policy
 |      callregs_t_policy_get(self) -> argreg_policy_t
 |  
 |  thisown
 |      The membership flag

Help on function callregs_t_regcount in module ida_typeinf:

callregs_t_regcount(*args) -> 'int'
    callregs_t_regcount(cc) -> int

Help on function choose_local_tinfo in module ida_typeinf:

choose_local_tinfo(*args) -> 'uint32'
    choose_local_tinfo(ti, title, func=None, def_ord=0, ud=None) -> uint32
    
    
    Choose a type from the local type library.
    
    @param ti: pointer to til (C++: const  til_t  *)
    @param title: title of listbox to display (C++: const char *)
    @param func: predicate to select types to display (maybe NULL) (C++:
                 local_tinfo_predicate_t  *)
    @param def_ord: ordinal to position cursor before choose (C++: uint32)
    @param ud: user data (C++: void *)
    @return: == 0 means nothing is chosen, otherwise an ordinal number

Help on function choose_local_tinfo_and_delta in module ida_typeinf:

choose_local_tinfo_and_delta(*args) -> 'uint32'
    choose_local_tinfo_and_delta(delta, ti, title, func=None, def_ord=0, ud=None) -> uint32
    
    
    Choose a type from the local type library and specify the pointer
    shift value.
    
    @param delta: pointer shift value (C++: int32  *)
    @param ti: pointer to til (C++: const  til_t  *)
    @param title: title of listbox to display (C++: const char *)
    @param func: predicate to select types to display (maybe NULL) (C++:
                 local_tinfo_predicate_t  *)
    @param def_ord: ordinal to position cursor before choose (C++: uint32)
    @param ud: user data (C++: void *)
    @return: == 0 means nothing is chosen, otherwise an ordinal number

Help on function choose_named_type in module ida_typeinf:

choose_named_type(*args) -> 'bool'
    choose_named_type(out_sym, root_til, title, ntf_flags, predicate=None) -> bool
    
    
    Choose a type from a type library.
    
    @param out_sym: pointer to be filled with the chosen type (C++:
                    til_symbol_t  *)
    @param root_til: pointer to starting til (the function will inspect
                     the base tils if allowed by flags) (C++: const  til_t
                     *)
    @param title: title of listbox to display (C++: const char *)
    @param ntf_flags: combination of  Flags for named types (C++: int)
    @param predicate: predicate to select types to display (maybe NULL)
                      (C++: predicate_t  *)
    @return: false if nothing is chosen, otherwise true

Help on function clear_tinfo_t in module ida_typeinf:

clear_tinfo_t(*args) -> 'void'
    clear_tinfo_t(_this)

Help on function compact_til in module ida_typeinf:

compact_til(*args) -> 'bool'
    compact_til(ti) -> bool
    
    
    Collect garbage in til. Must be called before storing the til.
    
    @param ti (C++: til_t  *)
    @return: true if any memory was freed

Help on function compare_tinfo in module ida_typeinf:

compare_tinfo(*args) -> 'bool'
    compare_tinfo(t1, t2, tcflags) -> bool

Help on class const_aloc_visitor_t in module ida_typeinf:

class const_aloc_visitor_t(builtins.object)
 |  Proxy of C++ const_aloc_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> const_aloc_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_const_aloc_visitor_t(...)
 |      delete_const_aloc_visitor_t(self)
 |  
 |  visit_location(self, *args) -> 'int'
 |      visit_location(self, v, off, size) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function convert_pt_flags_to_hti in module ida_typeinf:

convert_pt_flags_to_hti(*args) -> 'int'
    convert_pt_flags_to_hti(pt_flags) -> int
    
    
    Convert 'Type parsing flags' to 'Type formatting flags' . Type parsing
    flags lesser than 0x10 don't have stable meaning and will be ignored
    (more on these flags can be seen in idc.idc)
    
    @param pt_flags (C++: int)

Help on function copy_named_type in module ida_typeinf:

copy_named_type(*args) -> 'uint32'
    copy_named_type(dsttil, srctil, name) -> uint32
    
    
    Copy a named type from one til to another. This function will copy the
    specified type and all dependent types from the source type library to
    the destination library.
    
    @param dsttil: Destination til. It must have orginal types enabled
                   (C++: til_t  *)
    @param srctil: Source til. (C++: const  til_t  *)
    @param name: name of the type to copy (C++: const char *)
    @return: ordinal number of the copied type. 0 means error

Help on function copy_tinfo_t in module ida_typeinf:

copy_tinfo_t(*args) -> 'void'
    copy_tinfo_t(_this, r)

Help on function create_numbered_type_name in module ida_typeinf:

create_numbered_type_name(*args) -> 'qstring *'
    create_numbered_type_name(ord) -> str
    
    
    Create anonymous name for numbered type. This name can be used to
    reference a numbered type by its ordinal Ordinal names have the
    following format: '#' + set_de(ord) Returns: -1 if error, otherwise
    the name length
    
    @param ord (C++: int32)

Help on function create_tinfo in module ida_typeinf:

create_tinfo(*args) -> 'bool'
    create_tinfo(_this, bt, bt2, ptr) -> bool

Help on function default_compiler in module ida_typeinf:

default_compiler(*args) -> 'comp_t'
    default_compiler() -> comp_t
    
    
    Get compiler specified by \varmem{inf,idainfo,cc}.

Help on function del_named_type in module ida_typeinf:

del_named_type(*args) -> 'bool'
    del_named_type(ti, name, ntf_flags) -> bool
    
    
    Delete information about a symbol.
    
    @param ti: type library (C++: til_t  *)
    @param name: name of symbol (C++: const char *)
    @param ntf_flags: combination of  Flags for named types (C++: int)
    @return: success

Help on function del_numbered_type in module ida_typeinf:

del_numbered_type(*args) -> 'bool'
    del_numbered_type(ti, ordinal) -> bool
    
    
    Delete a numbered type.
    
    
    @param ti (C++: til_t  *)
    @param ordinal (C++: uint32)

Help on function del_til in module ida_typeinf:

del_til(*args) -> 'bool'
    del_til(name) -> bool
    
    
    Unload a til file.
    
    
    @param name (C++: const char *)

Help on function del_tinfo_attr in module ida_typeinf:

del_tinfo_attr(*args) -> 'bool'
    del_tinfo_attr(tif, key, make_copy) -> bool

Help on function deref_ptr in module ida_typeinf:

deref_ptr(*args) -> 'bool'
    deref_ptr(ptr_ea, tif, closure_obj=None) -> bool
    
    
    Dereference a pointer.
    
    @param ptr_ea: in/out parameter   in: address of the pointer   out:
                   the pointed address (C++: ea_t *)
    @param tif: type of the pointer (C++: const  tinfo_t  &)
    @param closure_obj: closure object (not used yet) (C++: ea_t *)
    @return: success

Help on function deserialize_tinfo in module ida_typeinf:

deserialize_tinfo(*args) -> 'bool'
    deserialize_tinfo(tif, til, ptype, pfields, pfldcmts) -> bool

Help on function dstr_tinfo in module ida_typeinf:

dstr_tinfo(*args) -> 'char const *'
    dstr_tinfo(tif) -> char const *

Help on function dump_func_type_data in module ida_typeinf:

dump_func_type_data(*args) -> 'qstring *'
    dump_func_type_data(fti, praloc_bits) -> str
    
    
    Use 'func_type_data_t::dump()'
    
    
    @param fti (C++: const  func_type_data_t  &)
    @param praloc_bits (C++: int)

Help on function end_type_updating in module ida_typeinf:

end_type_updating(*args) -> 'void'
    end_type_updating(utp)
    
    
    Mark the end of a large update operation on the types (see
    'begin_type_updating()' )
    
    
    @param utp (C++: update_type_t)

Help on class enum_member_t in module ida_typeinf:

class enum_member_t(builtins.object)
 |  Proxy of C++ enum_member_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_member_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_enum_member_t(...)
 |      delete_enum_member_t(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      enum_member_t_cmt_get(self) -> qstring *
 |  
 |  name
 |      enum_member_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      enum_member_t_value_get(self) -> uint64
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class enum_member_vec_t in module ida_typeinf:

class enum_member_vec_t(builtins.object)
 |  Proxy of C++ qvector< enum_member_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'enum_member_t const &'
 |      __getitem__(self, i) -> enum_member_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_member_vec_t
 |      __init__(self, x) -> enum_member_vec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_enum_member_vec_t(...)
 |      delete_enum_member_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'enum_member_t const &'
 |      at(self, _idx) -> enum_member_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      begin(self) -> enum_member_t
 |      begin(self) -> enum_member_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      end(self) -> enum_member_t
 |      end(self) -> enum_member_t
 |  
 |  erase(self, *args) -> 'qvector< enum_member_t >::iterator'
 |      erase(self, it) -> enum_member_t
 |      erase(self, first, last) -> enum_member_t
 |  
 |  extract(self, *args) -> 'enum_member_t *'
 |      extract(self) -> enum_member_t
 |  
 |  find(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      find(self, x) -> enum_member_t
 |      find(self, x) -> enum_member_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=enum_member_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< enum_member_t >::iterator'
 |      insert(self, it, x) -> enum_member_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'enum_member_t &'
 |      push_back(self, x)
 |      push_back(self) -> enum_member_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class enum_type_data_t in module ida_typeinf:

class enum_type_data_t(enum_member_vec_t)
 |  Proxy of C++ enum_type_data_t class.
 |  
 |  Method resolution order:
 |      enum_type_data_t
 |      enum_member_vec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _bte=BTE_ALWAYS|BTE_HEX) -> enum_type_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_enum_type_data_t(...)
 |      delete_enum_type_data_t(self)
 |  
 |  calc_mask(self, *args) -> 'uint64'
 |      calc_mask(self) -> uint64
 |  
 |  calc_nbytes(self, *args) -> 'int'
 |      calc_nbytes(self) -> int
 |  
 |  is_64bit(self, *args) -> 'bool'
 |      is_64bit(self) -> bool
 |  
 |  is_char(self, *args) -> 'bool'
 |      is_char(self) -> bool
 |  
 |  is_hex(self, *args) -> 'bool'
 |      is_hex(self) -> bool
 |  
 |  is_sdec(self, *args) -> 'bool'
 |      is_sdec(self) -> bool
 |  
 |  is_udec(self, *args) -> 'bool'
 |      is_udec(self) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bte
 |      enum_type_data_t_bte_get(self) -> bte_t
 |  
 |  group_sizes
 |      enum_type_data_t_group_sizes_get(self) -> intvec_t *
 |  
 |  taenum_bits
 |      enum_type_data_t_taenum_bits_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from enum_member_vec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'enum_member_t const &'
 |      __getitem__(self, i) -> enum_member_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'enum_member_t const &'
 |      at(self, _idx) -> enum_member_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      begin(self) -> enum_member_t
 |      begin(self) -> enum_member_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      end(self) -> enum_member_t
 |      end(self) -> enum_member_t
 |  
 |  erase(self, *args) -> 'qvector< enum_member_t >::iterator'
 |      erase(self, it) -> enum_member_t
 |      erase(self, first, last) -> enum_member_t
 |  
 |  extract(self, *args) -> 'enum_member_t *'
 |      extract(self) -> enum_member_t
 |  
 |  find(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      find(self, x) -> enum_member_t
 |      find(self, x) -> enum_member_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=enum_member_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< enum_member_t >::iterator'
 |      insert(self, it, x) -> enum_member_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'enum_member_t &'
 |      push_back(self, x)
 |      push_back(self) -> enum_member_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from enum_member_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from enum_member_vec_t:
 |  
 |  __hash__ = None

Help on function extract_argloc in module ida_typeinf:

extract_argloc(*args) -> 'bool'
    extract_argloc(vloc, ptype, is_retval) -> bool
    
    
    Deserialize argument location.
    
    
    @param vloc (C++: argloc_t  *)
    @param ptype (C++: const  type_t  **)
    @param is_retval (C++: bool)

Help on function find_tinfo_udt_member in module ida_typeinf:

find_tinfo_udt_member(*args) -> 'int'
    find_tinfo_udt_member(udm, typid, strmem_flags) -> int

Help on function first_named_type in module ida_typeinf:

first_named_type(*args) -> 'char const *'
    first_named_type(ti, ntf_flags) -> char const *
    
    
    Enumerate types. Returns mangled names. Never returns anonymous types.
    To include it, enumerate types by ordinals.
    
    @param ti (C++: const  til_t  *)
    @param ntf_flags (C++: int)

Help on function for_all_arglocs in module ida_typeinf:

for_all_arglocs(*args) -> 'int'
    for_all_arglocs(vv, vloc, size, off=0) -> int
    
    
    Compress larger argloc types and initiate the aloc visitor.
    
    
    @param vv (C++: aloc_visitor_t  &)
    @param vloc (C++: argloc_t  &)
    @param size (C++: int)
    @param off (C++: int)

Help on function for_all_const_arglocs in module ida_typeinf:

for_all_const_arglocs(*args) -> 'int'
    for_all_const_arglocs(vv, vloc, size, off=0) -> int
    
    
    See 'for_all_arglocs()'
    
    
    @param vv (C++: const_aloc_visitor_t  &)
    @param vloc (C++: const  argloc_t  &)
    @param size (C++: int)
    @param off (C++: int)

Help on function free_til in module ida_typeinf:

free_til(*args) -> 'void'
    free_til(ti)
    
    
    Free memory allocated by til.
    
    
    @param ti (C++: til_t  *)

Help on function func_has_stkframe_hole in module ida_typeinf:

func_has_stkframe_hole(*args) -> 'bool'
    func_has_stkframe_hole(ea, fti) -> bool
    
    
    Looks for a hole at the beginning of the stack arguments. Will make
    use of the IDB's 'func_t' function at that place (if present) to help
    determine the presence of such a hole.
    
    @param ea (C++: ea_t)
    @param fti (C++: const  func_type_data_t  &)

Help on class func_type_data_t in module ida_typeinf:

class func_type_data_t(funcargvec_t)
 |  Proxy of C++ func_type_data_t class.
 |  
 |  Method resolution order:
 |      func_type_data_t
 |      funcargvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_type_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_type_data_t(...)
 |      delete_func_type_data_t(self)
 |  
 |  dump(self, *args) -> 'bool'
 |      dump(self, praloc_bits=0x02) -> bool
 |  
 |  get_call_method(self, *args) -> 'int'
 |      get_call_method(self) -> int
 |  
 |  guess_cc(self, *args) -> 'cm_t'
 |      guess_cc(self, purged, cc_flags) -> cm_t
 |  
 |  is_high(self, *args) -> 'bool'
 |      is_high(self) -> bool
 |  
 |  is_noret(self, *args) -> 'bool'
 |      is_noret(self) -> bool
 |  
 |  is_pure(self, *args) -> 'bool'
 |      is_pure(self) -> bool
 |  
 |  is_vararg_cc(self, *args) -> 'bool'
 |      is_vararg_cc(self) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cc
 |      func_type_data_t_cc_get(self) -> cm_t
 |  
 |  flags
 |      func_type_data_t_flags_get(self) -> int
 |  
 |  retloc
 |      func_type_data_t_retloc_get(self) -> argloc_t
 |  
 |  rettype
 |      func_type_data_t_rettype_get(self) -> tinfo_t
 |  
 |  spoiled
 |      func_type_data_t_spoiled_get(self) -> reginfovec_t
 |  
 |  stkargs
 |      func_type_data_t_stkargs_get(self) -> uval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from funcargvec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'funcarg_t const &'
 |      __getitem__(self, i) -> funcarg_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'funcarg_t const &'
 |      at(self, _idx) -> funcarg_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      begin(self) -> funcarg_t
 |      begin(self) -> funcarg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      end(self) -> funcarg_t
 |      end(self) -> funcarg_t
 |  
 |  erase(self, *args) -> 'qvector< funcarg_t >::iterator'
 |      erase(self, it) -> funcarg_t
 |      erase(self, first, last) -> funcarg_t
 |  
 |  extract(self, *args) -> 'funcarg_t *'
 |      extract(self) -> funcarg_t
 |  
 |  find(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      find(self, x) -> funcarg_t
 |      find(self, x) -> funcarg_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=funcarg_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< funcarg_t >::iterator'
 |      insert(self, it, x) -> funcarg_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'funcarg_t &'
 |      push_back(self, x)
 |      push_back(self) -> funcarg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from funcargvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from funcargvec_t:
 |  
 |  __hash__ = None

Help on class funcarg_t in module ida_typeinf:

class funcarg_t(builtins.object)
 |  Proxy of C++ funcarg_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> funcarg_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_funcarg_t(...)
 |      delete_funcarg_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  argloc
 |      funcarg_t_argloc_get(self) -> argloc_t
 |  
 |  cmt
 |      funcarg_t_cmt_get(self) -> qstring *
 |  
 |  flags
 |      funcarg_t_flags_get(self) -> uint32
 |  
 |  name
 |      funcarg_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      funcarg_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class funcargvec_t in module ida_typeinf:

class funcargvec_t(builtins.object)
 |  Proxy of C++ qvector< funcarg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'funcarg_t const &'
 |      __getitem__(self, i) -> funcarg_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> funcargvec_t
 |      __init__(self, x) -> funcargvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_funcargvec_t(...)
 |      delete_funcargvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'funcarg_t const &'
 |      at(self, _idx) -> funcarg_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      begin(self) -> funcarg_t
 |      begin(self) -> funcarg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      end(self) -> funcarg_t
 |      end(self) -> funcarg_t
 |  
 |  erase(self, *args) -> 'qvector< funcarg_t >::iterator'
 |      erase(self, it) -> funcarg_t
 |      erase(self, first, last) -> funcarg_t
 |  
 |  extract(self, *args) -> 'funcarg_t *'
 |      extract(self) -> funcarg_t
 |  
 |  find(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      find(self, x) -> funcarg_t
 |      find(self, x) -> funcarg_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=funcarg_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< funcarg_t >::iterator'
 |      insert(self, it, x) -> funcarg_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'funcarg_t &'
 |      push_back(self, x)
 |      push_back(self) -> funcarg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function gcc_layout in module ida_typeinf:

gcc_layout(*args) -> 'bool'
    gcc_layout() -> bool
    
    
    Should use the struct/union layout as done by gcc?

Help on function gen_decorate_name in module ida_typeinf:

gen_decorate_name(*args) -> 'qstring *'
    gen_decorate_name(name, mangle, cc, type) -> str
    
    
    Generic function for 'decorate_name()' (may be used in IDP modules)
    
    
    @param name (C++: const char *)
    @param mangle (C++: bool)
    @param cc (C++: cm_t)
    @param type (C++: const  tinfo_t  *)

Help on function gen_use_arg_tinfos in module ida_typeinf:

gen_use_arg_tinfos(*args) -> 'void'
    gen_use_arg_tinfos(caller, fti, rargs, set_optype, is_stkarg_load, has_delay_slot)
    
    
    The main function using these callbacks:
    
    
    @param caller (C++: ea_t)
    @param fti (C++: func_type_data_t  *)
    @param rargs (C++: funcargvec_t  *)
    @param set_optype (C++: set_op_tinfo_t  *)
    @param is_stkarg_load (C++: is_stkarg_load_t  *)
    @param has_delay_slot (C++: has_delay_slot_t  *)

Help on function get_abi_name in module ida_typeinf:

get_abi_name(*args) -> 'qstring *'
    get_abi_name() -> str
    
    
    Get ABI name.
    
    @return: length of the name (>=0)

Help on function get_alias_target in module ida_typeinf:

get_alias_target(*args) -> 'uint32'
    get_alias_target(ti, ordinal) -> uint32
    
    
    Find the final alias destination. If the ordinal has not been aliased,
    return the specified ordinal itself If failed, returns 0.
    
    @param ti (C++: const  til_t  *)
    @param ordinal (C++: uint32)

Help on function get_arg_addrs in module ida_typeinf:

get_arg_addrs(*args) -> 'PyObject *'
    get_arg_addrs(caller) -> PyObject *
    
    
    Retrieve addresses of argument initialization instructions
    
    @param caller: the address of the call instruction
    @return: list of instruction addresses

Help on function get_base_type in module ida_typeinf:

get_base_type(*args) -> 'type_t'
    get_base_type(t) -> type_t
    
    
    Get get basic type bits ( 'TYPE_BASE_MASK' )
    
    
    @param t (C++: type_t)

Help on function get_c_header_path in module ida_typeinf:

get_c_header_path(*args) -> 'qstring *'
    get_c_header_path() -> str
    
    
    Get the include directory path of the target compiler.

Help on function get_c_macros in module ida_typeinf:

get_c_macros(*args) -> 'qstring *'
    get_c_macros() -> str
    
    
    Get predefined macros for the target compiler.

Help on function get_comp in module ida_typeinf:

get_comp(*args) -> 'comp_t'
    get_comp(comp) -> comp_t
    
    
    Get compiler bits.
    
    
    @param comp (C++: comp_t)

Help on function get_compiler_abbr in module ida_typeinf:

get_compiler_abbr(*args) -> 'char const *'
    get_compiler_abbr(id) -> char const *
    
    
    Get abbreviated compiler name.
    
    
    @param id (C++: comp_t)

Help on function get_compiler_name in module ida_typeinf:

get_compiler_name(*args) -> 'char const *'
    get_compiler_name(id) -> char const *
    
    
    Get full compiler name.
    
    
    @param id (C++: comp_t)

Help on function get_compilers in module ida_typeinf:

get_compilers(*args) -> 'void'
    get_compilers(ids, names, abbrs)
    
    
    Get names of all built-in compilers.
    
    
    @param ids (C++: compvec_t  *)
    @param names (C++: qstrvec_t  *)
    @param abbrs (C++: qstrvec_t  *)

Help on function get_enum_member_expr in module ida_typeinf:

get_enum_member_expr(*args) -> 'qstring *'
    get_enum_member_expr(tif, serial, value) -> str
    
    
    Return a C expression that can be used to represent an enum member. If
    the value does not correspond to any single enum member, this function
    tries to find a bitwise combination of enum members that correspond to
    it. If more than half of value bits do not match any enum members, it
    fails.
    
    @param tif: enumeration type (C++: const  tinfo_t  &)
    @param serial: which enumeration member to use (0 means the first with
                   the given value) (C++: int)
    @param value: value to search in the enumeration type. only 32-bit
                  number can be handled yet (C++: uint64)
    @return: success

Help on function get_full_type in module ida_typeinf:

get_full_type(*args) -> 'type_t'
    get_full_type(t) -> type_t
    
    
    Get basic type bits + type flags ( 'TYPE_FULL_MASK' )
    
    
    @param t (C++: type_t)

Help on function get_idainfo_by_type in module ida_typeinf:

get_idainfo_by_type(*args) -> 'size_t *, flags_t *, opinfo_t *, size_t *'
    get_idainfo_by_type(tif) -> bool
    
    
    Extract information from a 'tinfo_t' .
    
    @param tif: the type to inspect (C++: const  tinfo_t  &)

Help on function get_idati in module ida_typeinf:

get_idati(*args) -> 'til_t const *'
    get_idati() -> til_t
    
    
    Pointer to the local type library - this til is private for each IDB
    file Function that accepts til_t* uses local type library instead of
    NULL.

Help on function get_named_type in module ida_typeinf:

get_named_type(*args) -> 'PyObject *'
    get_named_type(til, name, ntf_flags) -> PyObject *
    
    
    Get a type data by its name.
    @param til: the type library
    @param name: the type name
    @param ntf_flags: a combination of NTF_* constants
    @return:
        None on failure
        tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success

Help on function get_named_type64 in module ida_typeinf:

get_named_type64(*args) -> 'PyObject *'
    get_named_type64(til, name, ntf_flags) -> PyObject *
    
    
    See 'get_named_type()' above.If the value in the 'ti' library is
    32-bit, it will be sign-extended before being stored in the 'value'
    pointer.
    
    @param name (C++: const char *)
    @param ntf_flags (C++: int)

Help on function get_numbered_type in module ida_typeinf:

get_numbered_type(*args) -> 'PyObject *'
    get_numbered_type(til, ordinal) -> PyObject *
    
    
    Retrieve a type by its ordinal number.
    
    
    @param ordinal (C++: uint32)

Help on function get_numbered_type_name in module ida_typeinf:

get_numbered_type_name(*args) -> 'char const *'
    get_numbered_type_name(ti, ordinal) -> char const *
    
    
    Get type name (if exists) by its ordinal. If the type is anonymous,
    returns "". If failed, returns NULL
    
    @param ti (C++: const  til_t  *)
    @param ordinal (C++: uint32)

Help on function get_ordinal_from_idb_type in module ida_typeinf:

get_ordinal_from_idb_type(*args) -> 'int'
    get_ordinal_from_idb_type(name, type) -> int
    
    
    Get ordinal number of an idb type (struct/enum). The 'type' parameter
    is used only to determine the kind of the type (struct or enum) Use
    this function to find out the correspondence between idb types and til
    types
    
    @param name (C++: const char *)
    @param type (C++: const  type_t  *)

Help on function get_ordinal_qty in module ida_typeinf:

get_ordinal_qty(*args) -> 'uint32'
    get_ordinal_qty(ti) -> uint32
    
    
    Get number of allocated ordinals.
    
    @param ti (C++: const  til_t  *)
    @return: uint32(-1) if failed

Help on function get_scalar_bt in module ida_typeinf:

get_scalar_bt(*args) -> 'type_t'
    get_scalar_bt(size) -> type_t

Help on function get_stock_tinfo in module ida_typeinf:

get_stock_tinfo(*args) -> 'bool'
    get_stock_tinfo(tif, id) -> bool

Help on function get_tinfo_attr in module ida_typeinf:

get_tinfo_attr(*args) -> 'bool'
    get_tinfo_attr(typid, key, bv, all_attrs) -> bool

Help on function get_tinfo_attrs in module ida_typeinf:

get_tinfo_attrs(*args) -> 'bool'
    get_tinfo_attrs(typid, tav, include_ref_attrs) -> bool

Help on function get_tinfo_details in module ida_typeinf:

get_tinfo_details(*args) -> 'bool'
    get_tinfo_details(typid, bt2, buf) -> bool

Help on function get_tinfo_pdata in module ida_typeinf:

get_tinfo_pdata(*args) -> 'size_t'
    get_tinfo_pdata(outptr, typid, what) -> size_t

Help on function get_tinfo_property in module ida_typeinf:

get_tinfo_property(*args) -> 'size_t'
    get_tinfo_property(typid, gta_prop) -> size_t

Help on function get_tinfo_size in module ida_typeinf:

get_tinfo_size(*args) -> 'size_t'
    get_tinfo_size(p_effalign, typid, gts_code) -> size_t

Help on function get_type_flags in module ida_typeinf:

get_type_flags(*args) -> 'type_t'
    get_type_flags(t) -> type_t
    
    
    Get type flags ( 'TYPE_FLAGS_MASK' )
    
    
    @param t (C++: type_t)

Help on function get_type_ordinal in module ida_typeinf:

get_type_ordinal(*args) -> 'int32'
    get_type_ordinal(ti, name) -> int32
    
    
    Get type ordinal by its name.
    
    
    @param ti (C++: const  til_t  *)
    @param name (C++: const char *)

Help on function guess_func_cc in module ida_typeinf:

guess_func_cc(*args) -> 'cm_t'
    guess_func_cc(fti, npurged, cc_flags) -> cm_t
    
    
    Use 'func_type_data_t::guess_cc()'
    
    
    @param fti (C++: const  func_type_data_t  &)
    @param npurged (C++: int)
    @param cc_flags (C++: int)

Help on function guess_tinfo in module ida_typeinf:

guess_tinfo(*args) -> 'int'
    guess_tinfo(tif, id) -> int
    
    
    Generate a type information about the id from the disassembly. id can
    be a structure/union/enum id or an address.
    
    @param tif (C++: tinfo_t  *)
    @param id (C++: tid_t)
    @return: one of  Guess tinfo codes

Help on class ida_lowertype_helper_t in module ida_typeinf:

class ida_lowertype_helper_t(lowertype_helper_t)
 |  Proxy of C++ ida_lowertype_helper_t class.
 |  
 |  Method resolution order:
 |      ida_lowertype_helper_t
 |      lowertype_helper_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _tif, _ea, _pb) -> ida_lowertype_helper_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ida_lowertype_helper_t(...)
 |      delete_ida_lowertype_helper_t(self)
 |  
 |  func_has_stkframe_hole(self, *args) -> 'bool'
 |      func_has_stkframe_hole(self, candidate, candidate_data) -> bool
 |  
 |  get_func_purged_bytes(self, *args) -> 'int'
 |      get_func_purged_bytes(self, candidate, arg3) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from lowertype_helper_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function idc_get_local_type in module ida_typeinf:

idc_get_local_type(*args) -> 'int'
    idc_get_local_type(ordinal, flags, buf, maxsize) -> int

Help on function idc_get_local_type_name in module ida_typeinf:

idc_get_local_type_name(*args) -> 'size_t'
    idc_get_local_type_name(ordinal) -> str

Help on function idc_get_local_type_raw in module ida_typeinf:

idc_get_local_type_raw(*args) -> 'PyObject *'
    idc_get_local_type_raw(ordinal) -> PyObject *

Help on function idc_get_type in module ida_typeinf:

idc_get_type(*args) -> 'size_t'
    idc_get_type(ea) -> str

Help on function idc_get_type_raw in module ida_typeinf:

idc_get_type_raw(*args) -> 'PyObject *'
    idc_get_type_raw(ea) -> PyObject *

Help on function idc_guess_type in module ida_typeinf:

idc_guess_type(*args) -> 'size_t'
    idc_guess_type(ea) -> str

Help on function idc_parse_decl in module ida_typeinf:

idc_parse_decl(*args) -> 'PyObject *'
    idc_parse_decl(ti, decl, flags) -> PyObject *

Help on function idc_parse_types in module ida_typeinf:

idc_parse_types(*args) -> 'int'
    idc_parse_types(input, flags) -> int

Help on function idc_print_type in module ida_typeinf:

idc_print_type(*args) -> 'PyObject *'
    idc_print_type(_type, _fields, name, flags) -> PyObject *

Help on function idc_set_local_type in module ida_typeinf:

idc_set_local_type(*args) -> 'int'
    idc_set_local_type(ordinal, dcl, flags) -> int

Help on function import_type in module ida_typeinf:

import_type(*args) -> 'tid_t'
    import_type(til, idx, name, flags=0) -> tid_t
    
    
    Copy a named type from til to idb.
    
    @param til: type library (C++: const  til_t  *)
    @param idx: the position of the new type in the list of types
                (structures or enums). -1 means at the end of the list
                (C++: int)
    @param name: the type name (C++: const char *)
    @param flags: combination of  Import type flags (C++: int)
    @return: BADNODE  on error

Help on function is_autosync in module ida_typeinf:

is_autosync(*args) -> 'bool'
    is_autosync(name, type) -> bool
    is_autosync(name, tif) -> bool
    
    
    Is the specified idb type automatically synchronized?
    
    
    @param name (C++: const char *)
    @param type (C++: const  type_t  *)

Help on function is_code_far in module ida_typeinf:

is_code_far(*args) -> 'bool'
    is_code_far(cm) -> bool
    
    
    Does the given model specify far code?.
    
    
    @param cm (C++: cm_t)

Help on function is_comp_unsure in module ida_typeinf:

is_comp_unsure(*args) -> 'comp_t'
    is_comp_unsure(comp) -> comp_t
    
    
    See 'COMP_UNSURE' .
    
    
    @param comp (C++: comp_t)

Help on function is_data_far in module ida_typeinf:

is_data_far(*args) -> 'bool'
    is_data_far(cm) -> bool
    
    
    Does the given model specify far data?.
    
    
    @param cm (C++: cm_t)

Help on function is_gcc in module ida_typeinf:

is_gcc(*args) -> 'bool'
    is_gcc() -> bool
    
    
    Is the target compiler 'COMP_GNU' ?

Help on function is_gcc32 in module ida_typeinf:

is_gcc32(*args) -> 'bool'
    is_gcc32() -> bool
    
    
    Is the target compiler 32 bit gcc?

Help on function is_gcc64 in module ida_typeinf:

is_gcc64(*args) -> 'bool'
    is_gcc64() -> bool
    
    
    Is the target compiler 64 bit gcc?

Help on function is_ordinal_name in module ida_typeinf:

is_ordinal_name(*args) -> 'bool'
    is_ordinal_name(name, ord=None) -> bool
    
    
    Check if the name is an ordinal name. Ordinal names have the following
    format: '#' + set_de(ord)
    
    @param name (C++: const char *)
    @param ord (C++: uint32  *)

Help on function is_purging_cc in module ida_typeinf:

is_purging_cc(*args) -> 'bool'
    is_purging_cc(cm) -> bool
    
    
    Does the calling convention clean the stack arguments upon
    return?.this function is valid only for x86 code
    
    @param cm (C++: cm_t)

Help on function is_restype_enum in module ida_typeinf:

is_restype_enum(*args) -> 'bool'
    is_restype_enum(til, type) -> bool

Help on function is_restype_struct in module ida_typeinf:

is_restype_struct(*args) -> 'bool'
    is_restype_struct(til, type) -> bool

Help on function is_restype_struni in module ida_typeinf:

is_restype_struni(*args) -> 'bool'
    is_restype_struni(til, type) -> bool

Help on function is_restype_void in module ida_typeinf:

is_restype_void(*args) -> 'bool'
    is_restype_void(til, type) -> bool

Help on function is_sdacl_byte in module ida_typeinf:

is_sdacl_byte(*args) -> 'bool'
    is_sdacl_byte(t) -> bool
    
    
    Identify an sdacl byte. The first sdacl byte has the following format:
    11xx000x. The sdacl bytes are appended to udt fields. They indicate
    the start of type attributes (as the tah-bytes do). The sdacl bytes
    are used in the udt headers instead of the tah-byte. This is done for
    compatibility with old databases, they were already using sdacl bytes
    in udt headers and as udt field postfixes. (see "sdacl-typeattrs" in
    the type bit definitions)
    
    @param t (C++: type_t)

Help on function is_tah_byte in module ida_typeinf:

is_tah_byte(*args) -> 'bool'
    is_tah_byte(t) -> bool
    
    
    The TAH byte (type attribute header byte) denotes the start of type
    attributes. (see "tah-typeattrs" in the type bit definitions)
    
    @param t (C++: type_t)

Help on function is_type_arithmetic in module ida_typeinf:

is_type_arithmetic(*args) -> 'bool'
    is_type_arithmetic(t) -> bool
    
    
    Is the type an arithmetic type? (floating or integral)
    
    
    @param t (C++: type_t)

Help on function is_type_array in module ida_typeinf:

is_type_array(*args) -> 'bool'
    is_type_array(t) -> bool
    
    
    See 'BT_ARRAY' .
    
    
    @param t (C++: type_t)

Help on function is_type_bitfld in module ida_typeinf:

is_type_bitfld(*args) -> 'bool'
    is_type_bitfld(t) -> bool
    
    
    See 'BT_BITFIELD' .
    
    
    @param t (C++: type_t)

Help on function is_type_bool in module ida_typeinf:

is_type_bool(*args) -> 'bool'
    is_type_bool(t) -> bool
    
    
    See 'BTF_BOOL' .
    
    
    @param t (C++: type_t)

Help on function is_type_char in module ida_typeinf:

is_type_char(*args) -> 'bool'
    is_type_char(t) -> bool
    
    
    Does the type specify a char value? (signed or unsigned, see 'Basic
    type: integer' )
    
    
    @param t (C++: type_t)

Help on function is_type_complex in module ida_typeinf:

is_type_complex(*args) -> 'bool'
    is_type_complex(t) -> bool
    
    
    See 'BT_COMPLEX' .
    
    
    @param t (C++: type_t)

Help on function is_type_const in module ida_typeinf:

is_type_const(*args) -> 'bool'
    is_type_const(t) -> bool
    
    
    See 'BTM_CONST' .
    
    
    @param t (C++: type_t)

Help on function is_type_double in module ida_typeinf:

is_type_double(*args) -> 'bool'
    is_type_double(t) -> bool
    
    
    See 'BTF_DOUBLE' .
    
    
    @param t (C++: type_t)

Help on function is_type_enum in module ida_typeinf:

is_type_enum(*args) -> 'bool'
    is_type_enum(t) -> bool
    
    
    See 'BTF_ENUM' .
    
    
    @param t (C++: type_t)

Help on function is_type_ext_arithmetic in module ida_typeinf:

is_type_ext_arithmetic(*args) -> 'bool'
    is_type_ext_arithmetic(t) -> bool
    
    
    Is the type an extended arithmetic type? (arithmetic or enum)
    
    
    @param t (C++: type_t)

Help on function is_type_ext_integral in module ida_typeinf:

is_type_ext_integral(*args) -> 'bool'
    is_type_ext_integral(t) -> bool
    
    
    Is the type an extended integral type? (integral or enum)
    
    
    @param t (C++: type_t)

Help on function is_type_float in module ida_typeinf:

is_type_float(*args) -> 'bool'
    is_type_float(t) -> bool
    
    
    See 'BTF_FLOAT' .
    
    
    @param t (C++: type_t)

Help on function is_type_floating in module ida_typeinf:

is_type_floating(*args) -> 'bool'
    is_type_floating(t) -> bool
    
    
    Is the type a floating point type?
    
    
    @param t (C++: type_t)

Help on function is_type_func in module ida_typeinf:

is_type_func(*args) -> 'bool'
    is_type_func(t) -> bool
    
    
    See 'BT_FUNC' .
    
    
    @param t (C++: type_t)

Help on function is_type_int in module ida_typeinf:

is_type_int(*args) -> 'bool'
    is_type_int(bt) -> bool
    
    
    Does the type_t specify one of the basic types in 'Basic type:
    integer' ?
    
    
    @param bt (C++: type_t)

Help on function is_type_int128 in module ida_typeinf:

is_type_int128(*args) -> 'bool'
    is_type_int128(t) -> bool
    
    
    Does the type specify a 128-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    
    @param t (C++: type_t)

Help on function is_type_int16 in module ida_typeinf:

is_type_int16(*args) -> 'bool'
    is_type_int16(t) -> bool
    
    
    Does the type specify a 16-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    
    @param t (C++: type_t)

Help on function is_type_int32 in module ida_typeinf:

is_type_int32(*args) -> 'bool'
    is_type_int32(t) -> bool
    
    
    Does the type specify a 32-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    
    @param t (C++: type_t)

Help on function is_type_int64 in module ida_typeinf:

is_type_int64(*args) -> 'bool'
    is_type_int64(t) -> bool
    
    
    Does the type specify a 64-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    
    @param t (C++: type_t)

Help on function is_type_integral in module ida_typeinf:

is_type_integral(*args) -> 'bool'
    is_type_integral(t) -> bool
    
    
    Is the type an integral type (char/short/int/long/bool)?
    
    
    @param t (C++: type_t)

Help on function is_type_ldouble in module ida_typeinf:

is_type_ldouble(*args) -> 'bool'
    is_type_ldouble(t) -> bool
    
    
    See 'BTF_LDOUBLE' .
    
    
    @param t (C++: type_t)

Help on function is_type_paf in module ida_typeinf:

is_type_paf(*args) -> 'bool'
    is_type_paf(t) -> bool
    
    
    Is the type a pointer, array, or function type?
    
    
    @param t (C++: type_t)

Help on function is_type_partial in module ida_typeinf:

is_type_partial(*args) -> 'bool'
    is_type_partial(t) -> bool
    
    
    Identifies an unknown or void type with a known size (see 'Basic type:
    unknown & void' )
    
    
    @param t (C++: type_t)

Help on function is_type_ptr in module ida_typeinf:

is_type_ptr(*args) -> 'bool'
    is_type_ptr(t) -> bool
    
    
    See 'BT_PTR' .
    
    
    @param t (C++: type_t)

Help on function is_type_ptr_or_array in module ida_typeinf:

is_type_ptr_or_array(*args) -> 'bool'
    is_type_ptr_or_array(t) -> bool
    
    
    Is the type a pointer or array type?
    
    
    @param t (C++: type_t)

Help on function is_type_struct in module ida_typeinf:

is_type_struct(*args) -> 'bool'
    is_type_struct(t) -> bool
    
    
    See 'BTF_STRUCT' .
    
    
    @param t (C++: type_t)

Help on function is_type_struni in module ida_typeinf:

is_type_struni(*args) -> 'bool'
    is_type_struni(t) -> bool
    
    
    Is the type a struct or union?
    
    
    @param t (C++: type_t)

Help on function is_type_sue in module ida_typeinf:

is_type_sue(*args) -> 'bool'
    is_type_sue(t) -> bool
    
    
    Is the type a struct/union/enum?
    
    
    @param t (C++: type_t)

Help on function is_type_tbyte in module ida_typeinf:

is_type_tbyte(*args) -> 'bool'
    is_type_tbyte(t) -> bool
    
    
    See 'BTF_FLOAT' .
    
    
    @param t (C++: type_t)

Help on function is_type_typedef in module ida_typeinf:

is_type_typedef(*args) -> 'bool'
    is_type_typedef(t) -> bool
    
    
    See 'BTF_TYPEDEF' .
    
    
    @param t (C++: type_t)

Help on function is_type_uchar in module ida_typeinf:

is_type_uchar(*args) -> 'bool'
    is_type_uchar(t) -> bool
    
    
    See 'BTF_UCHAR' .
    
    
    @param t (C++: type_t)

Help on function is_type_uint in module ida_typeinf:

is_type_uint(*args) -> 'bool'
    is_type_uint(t) -> bool
    
    
    See 'BTF_UINT' .
    
    
    @param t (C++: type_t)

Help on function is_type_uint128 in module ida_typeinf:

is_type_uint128(*args) -> 'bool'
    is_type_uint128(t) -> bool
    
    
    See 'BTF_UINT128' .
    
    
    @param t (C++: type_t)

Help on function is_type_uint16 in module ida_typeinf:

is_type_uint16(*args) -> 'bool'
    is_type_uint16(t) -> bool
    
    
    See 'BTF_UINT16' .
    
    
    @param t (C++: type_t)

Help on function is_type_uint32 in module ida_typeinf:

is_type_uint32(*args) -> 'bool'
    is_type_uint32(t) -> bool
    
    
    See 'BTF_UINT32' .
    
    
    @param t (C++: type_t)

Help on function is_type_uint64 in module ida_typeinf:

is_type_uint64(*args) -> 'bool'
    is_type_uint64(t) -> bool
    
    
    See 'BTF_UINT64' .
    
    
    @param t (C++: type_t)

Help on function is_type_union in module ida_typeinf:

is_type_union(*args) -> 'bool'
    is_type_union(t) -> bool
    
    
    See 'BTF_UNION' .
    
    
    @param t (C++: type_t)

Help on function is_type_unknown in module ida_typeinf:

is_type_unknown(*args) -> 'bool'
    is_type_unknown(t) -> bool
    
    
    See 'BT_UNKNOWN' .
    
    
    @param t (C++: type_t)

Help on function is_type_void in module ida_typeinf:

is_type_void(*args) -> 'bool'
    is_type_void(t) -> bool
    
    
    See 'BTF_VOID' .
    
    
    @param t (C++: type_t)

Help on function is_type_volatile in module ida_typeinf:

is_type_volatile(*args) -> 'bool'
    is_type_volatile(t) -> bool
    
    
    See 'BTM_VOLATILE' .
    
    
    @param t (C++: type_t)

Help on function is_typeid_last in module ida_typeinf:

is_typeid_last(*args) -> 'bool'
    is_typeid_last(t) -> bool
    
    
    Is the type_t the last byte of type declaration? (there are no
    additional bytes after a basic type, see '_BT_LAST_BASIC' )
    
    @param t (C++: type_t)

Help on function is_user_cc in module ida_typeinf:

is_user_cc(*args) -> 'bool'
    is_user_cc(cm) -> bool
    
    
    Does the calling convention specify argument locations explicitly?
    
    
    @param cm (C++: cm_t)

Help on function is_vararg_cc in module ida_typeinf:

is_vararg_cc(*args) -> 'bool'
    is_vararg_cc(cm) -> bool
    
    
    Does the calling convention use ellipsis?
    
    
    @param cm (C++: cm_t)

Help on function lexcompare_tinfo in module ida_typeinf:

lexcompare_tinfo(*args) -> 'int'
    lexcompare_tinfo(t1, t2, arg3) -> int

Help on function load_til in module ida_typeinf:

load_til(*args) -> 'qstring *'
    load_til(name, tildir=None) -> til_t
    
    
    Load til from a file. Failure to load base tils are reported into
    'errbuf'. They do not prevent loading of the main til.
    
    @param name: filename of the til. If it's an absolute path, tildir is
                 ignored.   NB: the file extension is forced to .til (C++:
                 const char *)
    @param tildir: directory where to load the til from. NULL means
                   default til subdirectories. (C++: const char *)
    @return: pointer to resulting til, NULL if failed and error message is
             in errbuf

Help on function load_til_header in module ida_typeinf:

load_til_header(*args) -> 'qstring *'
    load_til_header(tildir, name) -> til_t
    
    
    Get human-readable til description.
    
    
    @param tildir (C++: const char *)
    @param name (C++: const char *)

Help on function lower_type in module ida_typeinf:

lower_type(*args) -> 'int'
    lower_type(til, tif, name=None, _helper=None) -> int
    
    
    Lower type. Inspect the type and lower all function subtypes using
    lower_func_type().We call the prototypes usually encountered in source
    files "high level"They may have implicit arguments, array arguments,
    big structure retvals, etcWe introduce explicit arguments (i.e. 'this'
    pointer) and call the result"low level prototype". See 'FTI_HIGH' .In
    order to improve heuristics for recognition of big structure
    retvals,it is recommended to pass a helper that will be used to make
    decisions.That helper will be used only for lowering 'tif', and not
    for the childrentypes walked through by recursion.
    
    @param til (C++: til_t  *)
    @param tif (C++: tinfo_t  *)
    @param name (C++: const char *)
    @param _helper (C++: lowertype_helper_t  *)

Help on class lowertype_helper_t in module ida_typeinf:

class lowertype_helper_t(builtins.object)
 |  Proxy of C++ lowertype_helper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lowertype_helper_t(...)
 |      delete_lowertype_helper_t(self)
 |  
 |  func_has_stkframe_hole(self, *args) -> 'bool'
 |      func_has_stkframe_hole(self, candidate, candidate_data) -> bool
 |  
 |  get_func_purged_bytes(self, *args) -> 'int'
 |      get_func_purged_bytes(self, candidate, candidate_data) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function new_til in module ida_typeinf:

new_til(*args) -> 'til_t *'
    new_til(name, desc) -> til_t
    
    
    Initialize a til.
    
    
    @param name (C++: const char *)
    @param desc (C++: const char *)

Help on function next_named_type in module ida_typeinf:

next_named_type(*args) -> 'char const *'
    next_named_type(ti, name, ntf_flags) -> char const *
    
    
    Enumerate types. Returns mangled names. Never returns anonymous types.
    To include it, enumerate types by ordinals.
    
    @param ti (C++: const  til_t  *)
    @param name (C++: const char *)
    @param ntf_flags (C++: int)

Help on function optimize_argloc in module ida_typeinf:

optimize_argloc(*args) -> 'bool'
    optimize_argloc(vloc, size, gaps) -> bool
    
    
    Verify and optimize scattered argloc into simple form. All new arglocs
    must be processed by this function.
    
    @param vloc (C++: argloc_t  *)
    @param size (C++: int)
    @param gaps (C++: const  rangeset_t  *)

Help on function pack_idcobj_to_bv in module ida_typeinf:

pack_idcobj_to_bv(*args) -> 'error_t'
    pack_idcobj_to_bv(obj, tif, bytes, objoff, pio_flags=0) -> error_t
    
    
    Write a typed idc object to the byte vector. Byte vector may be non-
    empty, this function will append data to it
    
    @param obj (C++: const  idc_value_t  *)
    @param tif (C++: const  tinfo_t  &)
    @param bytes (C++: relobj_t  *)
    @param objoff (C++: void *)
    @param pio_flags (C++: int)

Help on function pack_idcobj_to_idb in module ida_typeinf:

pack_idcobj_to_idb(*args) -> 'error_t'
    pack_idcobj_to_idb(obj, tif, ea, pio_flags=0) -> error_t
    
    
    Write a typed idc object to the database.
    
    
    @param obj (C++: const  idc_value_t  *)
    @param tif (C++: const  tinfo_t  &)
    @param ea (C++: ea_t)
    @param pio_flags (C++: int)

Help on function pack_object_to_bv in module ida_typeinf:

pack_object_to_bv(*args) -> 'PyObject *'
    pack_object_to_bv(py_obj, ti, _type, _fields, base_ea, pio_flags=0) -> PyObject *
    
    
    Packs a typed object to a string
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @param fields: fields string (may be empty or None)
    @param base_ea: base ea used to relocate the pointers in the packed object
    @param pio_flags: flags used while unpacking
    @return:
        tuple(0, err_code) on failure
        tuple(1, packed_buf) on success

Help on function pack_object_to_idb in module ida_typeinf:

pack_object_to_idb(*args) -> 'PyObject *'
    pack_object_to_idb(py_obj, ti, _type, _fields, ea, pio_flags=0) -> PyObject *
    
    
    Write a typed object to the database.
    Raises an exception if wrong parameters were passed or conversion fails
    Returns the error_t returned by idaapi.pack_object_to_idb
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @param fields: fields string (may be empty or None)
    @param ea: ea to be used while packing
    @param pio_flags: flags used while unpacking

Help on function parse_decl in module ida_typeinf:

parse_decl(*args) -> 'qstring *'
    parse_decl(tif, til, decl, flags) -> str
    
    
    Parse ONE declaration. If the input string contains more than one
    declaration, the first complete type declaration ( 'PT_TYP' ) or the
    last variable declaration ( 'PT_VAR' ) will be used.name & tif may be
    empty after the call!
    
    @param tif: type info (C++: tinfo_t  *)
    @param til: type library to use. may be NULL (C++: til_t  *)
    @param decl: C declaration to parse (C++: const char *)
    @param flags: combination of  Type parsing flags  bits (C++: int)

Help on function parse_decls in module ida_typeinf:

parse_decls(*args) -> 'int'
    parse_decls(til, input, printer, hti_flags) -> int
    
    
    Parse many declarations and store them in a til. If there are any
    errors, they will be printed using 'printer'. This function uses
    default include path and predefined macros from the database settings.
    It always uses the 'HTI_DCL' bit.
    
    @param til: type library to store the result (C++: til_t  *)
    @param input: input string or file name (see hti_flags) (C++: const
                  char *)
    @param printer: function to output error messages (use msg or NULL or
                    your own callback) (C++: printer_t  *)
    @param hti_flags: combination of  Type formatting flags (C++: int)
    @return: number of errors, 0 means ok.

Help on class predicate_t in module ida_typeinf:

class predicate_t(builtins.object)
 |  Proxy of C++ predicate_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> predicate_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_predicate_t(...)
 |      delete_predicate_t(self)
 |  
 |  should_display(self, *args) -> 'bool'
 |      should_display(self, til, name, type, fields) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function print_argloc in module ida_typeinf:

print_argloc(*args) -> 'size_t'
    print_argloc(vloc, size=0, vflags=0) -> str
    
    
    Convert an argloc to human readable form.
    
    
    @param vloc (C++: const  argloc_t  &)
    @param size (C++: int)
    @param vflags (C++: int)

Help on function print_decls in module ida_typeinf:

print_decls(*args) -> 'PyObject *'
    print_decls(printer, til, py_ordinals, flags) -> PyObject *
    
    
    Print types (and possibly their dependencies) in a format suitable for
    use in a header file. This is the reverse 'parse_decls()' .
    
    @param printer: a handler for printing text (C++: text_sink_t  &)
    @param til: the type library holding the ordinals (C++: til_t  *)
    @param flags: flags for the algorithm. A combination of PDF_*
                  constants (C++: uint32)

Help on function print_tinfo in module ida_typeinf:

print_tinfo(*args) -> 'qstring *'
    print_tinfo(prefix, indent, cmtindent, flags, tif, name, cmt) -> str

Help on function print_type in module ida_typeinf:

print_type(*args) -> 'qstring *'
    print_type(ea, prtype_flags) -> str
    
    
    Get type declaration for the specified address.
    
    @param ea: address (C++: ea_t)
    @param prtype_flags: combination of  Type printing flags (C++: int)
    @return: success

Help on class ptr_type_data_t in module ida_typeinf:

class ptr_type_data_t(builtins.object)
 |  Proxy of C++ ptr_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self, c=tinfo_t(), bps=0, p=tinfo_t(), d=0) -> ptr_type_data_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ptr_type_data_t(...)
 |      delete_ptr_type_data_t(self)
 |  
 |  is_code_ptr(self, *args) -> 'bool'
 |      is_code_ptr(self) -> bool
 |  
 |  is_shifted(self, *args) -> 'bool'
 |      is_shifted(self) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  based_ptr_size
 |      ptr_type_data_t_based_ptr_size_get(self) -> uchar
 |  
 |  closure
 |      ptr_type_data_t_closure_get(self) -> tinfo_t
 |  
 |  delta
 |      ptr_type_data_t_delta_get(self) -> int32
 |  
 |  obj_type
 |      ptr_type_data_t_obj_type_get(self) -> tinfo_t
 |  
 |  parent
 |      ptr_type_data_t_parent_get(self) -> tinfo_t
 |  
 |  taptr_bits
 |      ptr_type_data_t_taptr_bits_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function read_tinfo_bitfield_value in module ida_typeinf:

read_tinfo_bitfield_value(*args) -> 'uint64'
    read_tinfo_bitfield_value(typid, v, bitoff) -> uint64

Help on class reginfovec_t in module ida_typeinf:

class reginfovec_t(builtins.object)
 |  Proxy of C++ qvector< reg_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'reg_info_t const &'
 |      __getitem__(self, i) -> reg_info_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reginfovec_t
 |      __init__(self, x) -> reginfovec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_reginfovec_t(...)
 |      delete_reginfovec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'reg_info_t &'
 |  
 |  at = __getitem__(self, *args) -> 'reg_info_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< reg_info_t >::const_iterator'
 |      begin(self) -> reg_info_t
 |      begin(self) -> reg_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< reg_info_t >::const_iterator'
 |      end(self) -> reg_info_t
 |      end(self) -> reg_info_t
 |  
 |  erase(self, *args) -> 'qvector< reg_info_t >::iterator'
 |      erase(self, it) -> reg_info_t
 |      erase(self, first, last) -> reg_info_t
 |  
 |  extract(self, *args) -> 'reg_info_t *'
 |      extract(self) -> reg_info_t
 |  
 |  find(self, *args) -> 'qvector< reg_info_t >::const_iterator'
 |      find(self, x) -> reg_info_t
 |      find(self, x) -> reg_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=reg_info_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< reg_info_t >::iterator'
 |      insert(self, it, x) -> reg_info_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'reg_info_t &'
 |      push_back(self, x)
 |      push_back(self) -> reg_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class regobj_t in module ida_typeinf:

class regobj_t(builtins.object)
 |  Proxy of C++ regobj_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regobj_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_regobj_t(...)
 |      delete_regobj_t(self)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  regidx
 |      regobj_t_regidx_get(self) -> int
 |  
 |  relocate
 |      regobj_t_relocate_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      regobj_t_value_get(self) -> bytevec_t *

Help on class regobjs_t in module ida_typeinf:

class regobjs_t(regobjvec_t)
 |  Proxy of C++ regobjs_t class.
 |  
 |  Method resolution order:
 |      regobjs_t
 |      regobjvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regobjs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_regobjs_t(...)
 |      delete_regobjs_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from regobjvec_t:
 |  
 |  __getitem__(self, *args) -> 'regobj_t const &'
 |      __getitem__(self, i) -> regobj_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  at(self, *args) -> 'regobj_t const &'
 |      at(self, _idx) -> regobj_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< regobj_t >::const_iterator'
 |      begin(self) -> regobj_t
 |      begin(self) -> regobj_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< regobj_t >::const_iterator'
 |      end(self) -> regobj_t
 |      end(self) -> regobj_t
 |  
 |  erase(self, *args) -> 'qvector< regobj_t >::iterator'
 |      erase(self, it) -> regobj_t
 |      erase(self, first, last) -> regobj_t
 |  
 |  extract(self, *args) -> 'regobj_t *'
 |      extract(self) -> regobj_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=regobj_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< regobj_t >::iterator'
 |      insert(self, it, x) -> regobj_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'regobj_t &'
 |      push_back(self, x)
 |      push_back(self) -> regobj_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from regobjvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class regobjvec_t in module ida_typeinf:

class regobjvec_t(builtins.object)
 |  Proxy of C++ qvector< regobj_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'regobj_t const &'
 |      __getitem__(self, i) -> regobj_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regobjvec_t
 |      __init__(self, x) -> regobjvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_regobjvec_t(...)
 |      delete_regobjvec_t(self)
 |  
 |  at(self, *args) -> 'regobj_t const &'
 |      at(self, _idx) -> regobj_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< regobj_t >::const_iterator'
 |      begin(self) -> regobj_t
 |      begin(self) -> regobj_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< regobj_t >::const_iterator'
 |      end(self) -> regobj_t
 |      end(self) -> regobj_t
 |  
 |  erase(self, *args) -> 'qvector< regobj_t >::iterator'
 |      erase(self, it) -> regobj_t
 |      erase(self, first, last) -> regobj_t
 |  
 |  extract(self, *args) -> 'regobj_t *'
 |      extract(self) -> regobj_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=regobj_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< regobj_t >::iterator'
 |      insert(self, it, x) -> regobj_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'regobj_t &'
 |      push_back(self, x)
 |      push_back(self) -> regobj_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function remove_abi_opts in module ida_typeinf:

remove_abi_opts(*args) -> 'bool'
    remove_abi_opts(abi_opts, user_level=False) -> bool

Help on function remove_pointer in module ida_typeinf:

remove_pointer(*args) -> 'tinfo_t'
    remove_pointer(tif) -> tinfo_t
    
    
     'BT_PTR' : If the current type is a pointer, return the pointed
    object. If the current type is not a pointer, return the current type.
    See also get_ptrarr_object() and get_pointed_object()
    
    @param tif (C++: const  tinfo_t  &)

Help on function remove_tinfo_pointer in module ida_typeinf:

remove_tinfo_pointer(*args) -> 'PyObject *'
    remove_tinfo_pointer(tif, name, til) -> PyObject *
    
    
    Remove pointer of a type. (i.e. convert "char *" into "char").
    Optionally remove the "lp" (or similar) prefix of the input name. If
    the input type is not a pointer, then fail.
    
    @param tif (C++: tinfo_t  *)
    @param til (C++: const  til_t  *)

Help on function replace_ordinal_typerefs in module ida_typeinf:

replace_ordinal_typerefs(*args) -> 'int'
    replace_ordinal_typerefs(til, tif) -> int
    
    
    Replace references to ordinal types by name references. This function
    'unties' the type from the current local type library and makes it
    easier to export it.
    
    @param til: type library to use. may be NULL. (C++: til_t  *)
    @param tif: type to modify (in/out) (C++: tinfo_t  *)

Help on function resolve_typedef in module ida_typeinf:

resolve_typedef(*args) -> 'type_t const *'
    resolve_typedef(til, type) -> type_t const *

Help on class rrel_t in module ida_typeinf:

class rrel_t(builtins.object)
 |  Proxy of C++ rrel_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rrel_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_rrel_t(...)
 |      delete_rrel_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      rrel_t_off_get(self) -> sval_t
 |  
 |  reg
 |      rrel_t_reg_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on function save_tinfo in module ida_typeinf:

save_tinfo(*args) -> 'tinfo_code_t'
    save_tinfo(tif, til, ord, name, ntf_flags) -> tinfo_code_t

Help on class scattered_aloc_t in module ida_typeinf:

class scattered_aloc_t(argpartvec_t)
 |  Proxy of C++ scattered_aloc_t class.
 |  
 |  Method resolution order:
 |      scattered_aloc_t
 |      argpartvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> scattered_aloc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_scattered_aloc_t(...)
 |      delete_scattered_aloc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from argpartvec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'argpart_t const &'
 |      __getitem__(self, i) -> argpart_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'argpart_t const &'
 |      at(self, _idx) -> argpart_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      begin(self) -> argpart_t
 |      begin(self) -> argpart_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      end(self) -> argpart_t
 |      end(self) -> argpart_t
 |  
 |  erase(self, *args) -> 'qvector< argpart_t >::iterator'
 |      erase(self, it) -> argpart_t
 |      erase(self, first, last) -> argpart_t
 |  
 |  extract(self, *args) -> 'argpart_t *'
 |      extract(self) -> argpart_t
 |  
 |  find(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      find(self, x) -> argpart_t
 |      find(self, x) -> argpart_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=argpart_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< argpart_t >::iterator'
 |      insert(self, it, x) -> argpart_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'argpart_t &'
 |      push_back(self, x)
 |      push_back(self) -> argpart_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from argpartvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from argpartvec_t:
 |  
 |  __hash__ = None

Help on function score_tinfo in module ida_typeinf:

score_tinfo(*args) -> 'uint32'
    score_tinfo(tif) -> uint32

Help on function serialize_tinfo in module ida_typeinf:

serialize_tinfo(*args) -> 'bool'
    serialize_tinfo(type, fields, fldcmts, tif, sudt_flags) -> bool

Help on function set_abi_name in module ida_typeinf:

set_abi_name(*args) -> 'bool'
    set_abi_name(abiname, user_level=False) -> bool
    
    
    Set abi name (see 'Compiler IDs' )
    
    
    @param abiname (C++: const char *)
    @param user_level (C++: bool)

Help on function set_c_header_path in module ida_typeinf:

set_c_header_path(*args) -> 'void'
    set_c_header_path(incdir)
    
    
    Set include directory path the target compiler.
    
    
    @param incdir (C++: const char *)

Help on function set_c_macros in module ida_typeinf:

set_c_macros(*args) -> 'void'
    set_c_macros(macros)
    
    
    Set predefined macros for the target compiler.
    
    
    @param macros (C++: const char *)

Help on function set_compiler in module ida_typeinf:

set_compiler(*args) -> 'bool'
    set_compiler(cc, flags, abiname=None) -> bool
    
    
    Change current compiler.
    
    @param cc: compiler to switch to (C++: const  compiler_info_t  &)
    @param flags: Set compiler flags (C++: int)
    @param abiname: ABI name (C++: const char *)
    @return: success

Help on function set_compiler_id in module ida_typeinf:

set_compiler_id(*args) -> 'bool'
    set_compiler_id(id, abiname=None) -> bool
    
    
    Set the compiler id (see 'Compiler IDs' )
    
    
    @param id (C++: comp_t)
    @param abiname (C++: const char *)

Help on function set_compiler_string in module ida_typeinf:

set_compiler_string(*args) -> 'bool'
    set_compiler_string(compstr, user_level) -> bool

Help on function set_numbered_type in module ida_typeinf:

set_numbered_type(*args) -> 'tinfo_code_t'
    set_numbered_type(ti, ordinal, ntf_flags, name, type, fields=None, cmt=None, fldcmts=None, sclass=None) -> tinfo_code_t
    
    
    Store a type in the til. 'name' may be NULL for anonymous types. The
    specified ordinal must be free (no other type is using it). For
    ntf_flags, only 'NTF_REPLACE' is consulted.
    
    @param ti (C++: til_t  *)
    @param ordinal (C++: uint32)
    @param ntf_flags (C++: int)
    @param name (C++: const char *)
    @param type (C++: const  type_t  *)
    @param fields (C++: const  p_list  *)
    @param cmt (C++: const char *)
    @param fldcmts (C++: const  p_list  *)
    @param sclass (C++: const  sclass_t  *)

Help on function set_tinfo_attr in module ida_typeinf:

set_tinfo_attr(*args) -> 'bool'
    set_tinfo_attr(tif, ta, may_overwrite) -> bool

Help on function set_tinfo_attrs in module ida_typeinf:

set_tinfo_attrs(*args) -> 'bool'
    set_tinfo_attrs(tif, ta) -> bool

Help on function set_tinfo_property in module ida_typeinf:

set_tinfo_property(*args) -> 'size_t'
    set_tinfo_property(tif, sta_prop, x) -> size_t

Help on function set_type_alias in module ida_typeinf:

set_type_alias(*args) -> 'bool'
    set_type_alias(ti, src_ordinal, dst_ordinal) -> bool
    
    
    Create a type alias. Redirects all references to source type to the
    destination type. This is equivalent to instantaneous replacement all
    reference to srctype by dsttype.
    
    @param ti (C++: til_t  *)
    @param src_ordinal (C++: uint32)
    @param dst_ordinal (C++: uint32)

Help on class simd_info_t in module ida_typeinf:

class simd_info_t(builtins.object)
 |  Proxy of C++ simd_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, nm=None, sz=0, memt=BTF_UNK) -> simd_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_simd_info_t(...)
 |      delete_simd_info_t(self)
 |  
 |  match_pattern(self, *args) -> 'bool'
 |      match_pattern(self, pattern) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  memtype
 |      simd_info_t_memtype_get(self) -> type_t
 |  
 |  name
 |      simd_info_t_name_get(self) -> char const *
 |  
 |  size
 |      simd_info_t_size_get(self) -> uint16
 |  
 |  thisown
 |      The membership flag
 |  
 |  tif
 |      simd_info_t_tif_get(self) -> tinfo_t

Help on function store_til in module ida_typeinf:

store_til(*args) -> 'bool'
    store_til(ti, tildir, name) -> bool
    
    
    Store til to a file. If the til contains garbage, it will be collected
    before storing the til. Your plugin should call 'compact_til()' before
    calling 'store_til()' .
    
    @param ti: type library to store (C++: til_t  *)
    @param tildir: directory where to store the til. NULL means current
                   directory. (C++: const char *)
    @param name: filename of the til. If it's an absolute path, tildir is
                 ignored.   NB: the file extension is forced to .til (C++:
                 const char *)
    @return: success

Help on class text_sink_t in module ida_typeinf:

class text_sink_t(builtins.object)
 |  Proxy of C++ text_sink_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> text_sink_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_text_sink_t(...)
 |      delete_text_sink_t(self)
 |  
 |  _print(self, *args) -> 'int'
 |      _print(self, str) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class til_symbol_t in module ida_typeinf:

class til_symbol_t(builtins.object)
 |  Proxy of C++ til_symbol_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, n=None, t=None) -> til_symbol_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_til_symbol_t(...)
 |      delete_til_symbol_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      til_symbol_t_name_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  til
 |      til_symbol_t_til_get(self) -> til_t

Help on class til_t in module ida_typeinf:

class til_t(builtins.object)
 |  Proxy of C++ til_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> til_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_til_t(...)
 |      delete_til_t(self)
 |  
 |  base(self, *args) -> 'til_t *'
 |      base(self, n) -> til_t
 |  
 |  is_dirty(self, *args) -> 'bool'
 |      is_dirty(self) -> bool
 |  
 |  set_dirty(self, *args) -> 'void'
 |      set_dirty(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cc
 |      til_t_cc_get(self) -> compiler_info_t
 |  
 |  desc
 |      til_t_desc_get(self) -> char *
 |  
 |  flags
 |      til_t_flags_get(self) -> uint32
 |  
 |  name
 |      til_t_name_get(self) -> char *
 |  
 |  nbases
 |      til_t_nbases_get(self) -> int
 |  
 |  nrefs
 |      til_t_nrefs_get(self) -> int
 |  
 |  nstreams
 |      til_t_nstreams_get(self) -> int
 |  
 |  streams
 |      til_t_streams_get(self) -> til_stream_t **
 |  
 |  thisown
 |      The membership flag

Help on class tinfo_t in module ida_typeinf:

class tinfo_t(builtins.object)
 |  Proxy of C++ tinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tinfo_t
 |      __init__(self, decl_type) -> tinfo_t
 |      __init__(self, r) -> tinfo_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args) -> 'qstring'
 |      __str__(self) -> qstring
 |  
 |  __swig_destroy__ = delete_tinfo_t(...)
 |      delete_tinfo_t(self)
 |  
 |  _print(self, *args) -> 'bool'
 |      _print(self, name=None, prtype_flags=0, indent=0, cmtindent=0, prefix=None, cmt=None) -> bool
 |  
 |  append_covered(self, *args) -> 'bool'
 |      append_covered(self, out, offset=0) -> bool
 |  
 |  calc_gaps(self, *args) -> 'bool'
 |      calc_gaps(self, out) -> bool
 |  
 |  calc_purged_bytes(self, *args) -> 'int'
 |      calc_purged_bytes(self) -> int
 |  
 |  calc_score(self, *args) -> 'uint32'
 |      calc_score(self) -> uint32
 |  
 |  calc_udt_aligns(self, *args) -> 'bool'
 |      calc_udt_aligns(self, sudt_flags=0x0004) -> bool
 |  
 |  change_sign(self, *args) -> 'bool'
 |      change_sign(self, sign) -> bool
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  clr_const(self, *args) -> 'void'
 |      clr_const(self)
 |  
 |  clr_const_volatile(self, *args) -> 'void'
 |      clr_const_volatile(self)
 |  
 |  clr_volatile(self, *args) -> 'void'
 |      clr_volatile(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |  
 |  compare_with(self, *args) -> 'bool'
 |      compare_with(self, r, tcflags=0) -> bool
 |  
 |  convert_array_to_ptr(self, *args) -> 'bool'
 |      convert_array_to_ptr(self) -> bool
 |  
 |  copy(self, *args) -> 'tinfo_t'
 |      copy(self) -> tinfo_t
 |  
 |  create_array(self, *args) -> 'bool'
 |      create_array(self, p, decl_type=BT_ARRAY) -> bool
 |      create_array(self, tif, nelems=0, base=0, decl_type=BT_ARRAY) -> bool
 |  
 |  create_bitfield(self, *args) -> 'bool'
 |      create_bitfield(self, p, decl_type=BT_BITFIELD) -> bool
 |      create_bitfield(self, nbytes, width, is_unsigned=False, decl_type=BT_BITFIELD) -> bool
 |  
 |  create_enum(self, *args) -> 'bool'
 |      create_enum(self, p, decl_type=BTF_ENUM) -> bool
 |  
 |  create_forward_decl(self, *args) -> 'tinfo_code_t'
 |      create_forward_decl(self, til, decl_type, name, ntf_flags=0) -> tinfo_code_t
 |  
 |  create_func(self, *args) -> 'bool'
 |      create_func(self, p, decl_type=BT_FUNC) -> bool
 |  
 |  create_ptr(self, *args) -> 'bool'
 |      create_ptr(self, p, decl_type=BT_PTR) -> bool
 |      create_ptr(self, tif, bps=0, decl_type=BT_PTR) -> bool
 |  
 |  create_simple_type(self, *args) -> 'bool'
 |      create_simple_type(self, decl_type) -> bool
 |  
 |  create_typedef(self, *args) -> 'void'
 |      create_typedef(self, p, decl_type=BTF_TYPEDEF, try_ordinal=True) -> bool
 |      create_typedef(self, til, name, decl_type=BTF_TYPEDEF, try_ordinal=True)
 |      create_typedef(self, til, ord, decl_type=BTF_TYPEDEF)
 |  
 |  create_udt(self, *args) -> 'bool'
 |      create_udt(self, p, decl_type) -> bool
 |  
 |  del_attr(self, *args) -> 'bool'
 |      del_attr(self, key, make_copy=True) -> bool
 |  
 |  del_attrs(self, *args) -> 'void'
 |      del_attrs(self)
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, til, ptype, pfields=None, pfldcmts=None) -> bool
 |      deserialize(self, til, type, fields, cmts=None) -> bool
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  equals_to(self, *args) -> 'bool'
 |      equals_to(self, r) -> bool
 |  
 |  find_udt_member(self, *args) -> 'int'
 |      find_udt_member(self, udm, strmem_flags) -> int
 |  
 |  get_array_details(self, *args) -> 'bool'
 |      get_array_details(self, ai) -> bool
 |  
 |  get_array_element(self, *args) -> 'tinfo_t'
 |      get_array_element(self) -> tinfo_t
 |  
 |  get_array_nelems(self, *args) -> 'int'
 |      get_array_nelems(self) -> int
 |  
 |  get_attr(self, *args) -> 'PyObject *'
 |      get_attr(self, key, all_attrs=True) -> PyObject *
 |  
 |  get_attrs(self, *args) -> 'bool'
 |      get_attrs(self, tav, all_attrs=False) -> bool
 |  
 |  get_bitfield_details(self, *args) -> 'bool'
 |      get_bitfield_details(self, bi) -> bool
 |  
 |  get_declalign(self, *args) -> 'uchar'
 |      get_declalign(self) -> uchar
 |  
 |  get_decltype(self, *args) -> 'type_t'
 |      get_decltype(self) -> type_t
 |  
 |  get_enum_base_type(self, *args) -> 'type_t'
 |      get_enum_base_type(self) -> type_t
 |  
 |  get_enum_details(self, *args) -> 'bool'
 |      get_enum_details(self, ei) -> bool
 |  
 |  get_final_ordinal(self, *args) -> 'uint32'
 |      get_final_ordinal(self) -> uint32
 |  
 |  get_final_type_name(self, *args) -> 'bool'
 |      get_final_type_name(self) -> bool
 |  
 |  get_func_details(self, *args) -> 'bool'
 |      get_func_details(self, fi, gtd=GTD_CALC_ARGLOCS) -> bool
 |  
 |  get_modifiers(self, *args) -> 'type_t'
 |      get_modifiers(self) -> type_t
 |  
 |  get_named_type(self, *args) -> 'bool'
 |      get_named_type(self, til, name, decl_type=BTF_TYPEDEF, resolve=True, try_ordinal=True) -> bool
 |  
 |  get_nargs(self, *args) -> 'int'
 |      get_nargs(self) -> int
 |  
 |  get_next_type_name(self, *args) -> 'bool'
 |      get_next_type_name(self) -> bool
 |  
 |  get_nth_arg(self, *args) -> 'tinfo_t'
 |      get_nth_arg(self, n) -> tinfo_t
 |  
 |  get_numbered_type(self, *args) -> 'bool'
 |      get_numbered_type(self, til, ordinal, decl_type=BTF_TYPEDEF, resolve=True) -> bool
 |  
 |  get_onemember_type(self, *args) -> 'tinfo_t'
 |      get_onemember_type(self) -> tinfo_t
 |  
 |  get_ordinal(self, *args) -> 'uint32'
 |      get_ordinal(self) -> uint32
 |  
 |  get_pointed_object(self, *args) -> 'tinfo_t'
 |      get_pointed_object(self) -> tinfo_t
 |  
 |  get_ptr_details(self, *args) -> 'bool'
 |      get_ptr_details(self, pi) -> bool
 |  
 |  get_ptrarr_object(self, *args) -> 'tinfo_t'
 |      get_ptrarr_object(self) -> tinfo_t
 |  
 |  get_ptrarr_objsize(self, *args) -> 'int'
 |      get_ptrarr_objsize(self) -> int
 |  
 |  get_realtype(self, *args) -> 'type_t'
 |      get_realtype(self, full=False) -> type_t
 |  
 |  get_rettype(self, *args) -> 'tinfo_t'
 |      get_rettype(self) -> tinfo_t
 |  
 |  get_sign(self, *args) -> 'type_sign_t'
 |      get_sign(self) -> type_sign_t
 |  
 |  get_size(self, *args) -> 'size_t'
 |      get_size(self, p_effalign=None, gts_code=0) -> size_t
 |  
 |  get_til(self, *args) -> 'til_t const *'
 |      get_til(self) -> til_t
 |  
 |  get_type_name(self, *args) -> 'bool'
 |      get_type_name(self) -> bool
 |  
 |  get_udt_details(self, *args) -> 'bool'
 |      get_udt_details(self, udt, gtd=GTD_CALC_LAYOUT) -> bool
 |  
 |  get_udt_nmembers(self, *args) -> 'int'
 |      get_udt_nmembers(self) -> int
 |  
 |  get_unpadded_size(self, *args) -> 'size_t'
 |      get_unpadded_size(self) -> size_t
 |  
 |  has_details(self, *args) -> 'bool'
 |      has_details(self) -> bool
 |  
 |  has_vftable(self, *args) -> 'bool'
 |      has_vftable(self) -> bool
 |  
 |  is_anonymous_udt(self, *args) -> 'bool'
 |      is_anonymous_udt(self) -> bool
 |  
 |  is_arithmetic(self, *args) -> 'bool'
 |      is_arithmetic(self) -> bool
 |  
 |  is_array(self, *args) -> 'bool'
 |      is_array(self) -> bool
 |  
 |  is_bitfield(self, *args) -> 'bool'
 |      is_bitfield(self) -> bool
 |  
 |  is_bool(self, *args) -> 'bool'
 |      is_bool(self) -> bool
 |  
 |  is_castable_to(self, *args) -> 'bool'
 |      is_castable_to(self, target) -> bool
 |  
 |  is_char(self, *args) -> 'bool'
 |      is_char(self) -> bool
 |  
 |  is_complex(self, *args) -> 'bool'
 |      is_complex(self) -> bool
 |  
 |  is_const(self, *args) -> 'bool'
 |      is_const(self) -> bool
 |  
 |  is_correct(self, *args) -> 'bool'
 |      is_correct(self) -> bool
 |  
 |  is_decl_array(self, *args) -> 'bool'
 |      is_decl_array(self) -> bool
 |  
 |  is_decl_bitfield(self, *args) -> 'bool'
 |      is_decl_bitfield(self) -> bool
 |  
 |  is_decl_bool(self, *args) -> 'bool'
 |      is_decl_bool(self) -> bool
 |  
 |  is_decl_char(self, *args) -> 'bool'
 |      is_decl_char(self) -> bool
 |  
 |  is_decl_complex(self, *args) -> 'bool'
 |      is_decl_complex(self) -> bool
 |  
 |  is_decl_const(self, *args) -> 'bool'
 |      is_decl_const(self) -> bool
 |  
 |  is_decl_double(self, *args) -> 'bool'
 |      is_decl_double(self) -> bool
 |  
 |  is_decl_enum(self, *args) -> 'bool'
 |      is_decl_enum(self) -> bool
 |  
 |  is_decl_float(self, *args) -> 'bool'
 |      is_decl_float(self) -> bool
 |  
 |  is_decl_floating(self, *args) -> 'bool'
 |      is_decl_floating(self) -> bool
 |  
 |  is_decl_func(self, *args) -> 'bool'
 |      is_decl_func(self) -> bool
 |  
 |  is_decl_int(self, *args) -> 'bool'
 |      is_decl_int(self) -> bool
 |  
 |  is_decl_int128(self, *args) -> 'bool'
 |      is_decl_int128(self) -> bool
 |  
 |  is_decl_int16(self, *args) -> 'bool'
 |      is_decl_int16(self) -> bool
 |  
 |  is_decl_int32(self, *args) -> 'bool'
 |      is_decl_int32(self) -> bool
 |  
 |  is_decl_int64(self, *args) -> 'bool'
 |      is_decl_int64(self) -> bool
 |  
 |  is_decl_last(self, *args) -> 'bool'
 |      is_decl_last(self) -> bool
 |  
 |  is_decl_ldouble(self, *args) -> 'bool'
 |      is_decl_ldouble(self) -> bool
 |  
 |  is_decl_paf(self, *args) -> 'bool'
 |      is_decl_paf(self) -> bool
 |  
 |  is_decl_partial(self, *args) -> 'bool'
 |      is_decl_partial(self) -> bool
 |  
 |  is_decl_ptr(self, *args) -> 'bool'
 |      is_decl_ptr(self) -> bool
 |  
 |  is_decl_struct(self, *args) -> 'bool'
 |      is_decl_struct(self) -> bool
 |  
 |  is_decl_sue(self, *args) -> 'bool'
 |      is_decl_sue(self) -> bool
 |  
 |  is_decl_tbyte(self, *args) -> 'bool'
 |      is_decl_tbyte(self) -> bool
 |  
 |  is_decl_typedef(self, *args) -> 'bool'
 |      is_decl_typedef(self) -> bool
 |  
 |  is_decl_uchar(self, *args) -> 'bool'
 |      is_decl_uchar(self) -> bool
 |  
 |  is_decl_udt(self, *args) -> 'bool'
 |      is_decl_udt(self) -> bool
 |  
 |  is_decl_uint(self, *args) -> 'bool'
 |      is_decl_uint(self) -> bool
 |  
 |  is_decl_uint128(self, *args) -> 'bool'
 |      is_decl_uint128(self) -> bool
 |  
 |  is_decl_uint16(self, *args) -> 'bool'
 |      is_decl_uint16(self) -> bool
 |  
 |  is_decl_uint32(self, *args) -> 'bool'
 |      is_decl_uint32(self) -> bool
 |  
 |  is_decl_uint64(self, *args) -> 'bool'
 |      is_decl_uint64(self) -> bool
 |  
 |  is_decl_union(self, *args) -> 'bool'
 |      is_decl_union(self) -> bool
 |  
 |  is_decl_unknown(self, *args) -> 'bool'
 |      is_decl_unknown(self) -> bool
 |  
 |  is_decl_void(self, *args) -> 'bool'
 |      is_decl_void(self) -> bool
 |  
 |  is_decl_volatile(self, *args) -> 'bool'
 |      is_decl_volatile(self) -> bool
 |  
 |  is_double(self, *args) -> 'bool'
 |      is_double(self) -> bool
 |  
 |  is_empty_udt(self, *args) -> 'bool'
 |      is_empty_udt(self) -> bool
 |  
 |  is_enum(self, *args) -> 'bool'
 |      is_enum(self) -> bool
 |  
 |  is_ext_arithmetic(self, *args) -> 'bool'
 |      is_ext_arithmetic(self) -> bool
 |  
 |  is_ext_integral(self, *args) -> 'bool'
 |      is_ext_integral(self) -> bool
 |  
 |  is_float(self, *args) -> 'bool'
 |      is_float(self) -> bool
 |  
 |  is_floating(self, *args) -> 'bool'
 |      is_floating(self) -> bool
 |  
 |  is_forward_decl(self, *args) -> 'bool'
 |      is_forward_decl(self) -> bool
 |  
 |  is_from_subtil(self, *args) -> 'bool'
 |      is_from_subtil(self) -> bool
 |  
 |  is_func(self, *args) -> 'bool'
 |      is_func(self) -> bool
 |  
 |  is_funcptr(self, *args) -> 'bool'
 |      is_funcptr(self) -> bool
 |  
 |  is_high_func(self, *args) -> 'bool'
 |      is_high_func(self) -> bool
 |  
 |  is_int(self, *args) -> 'bool'
 |      is_int(self) -> bool
 |  
 |  is_int128(self, *args) -> 'bool'
 |      is_int128(self) -> bool
 |  
 |  is_int16(self, *args) -> 'bool'
 |      is_int16(self) -> bool
 |  
 |  is_int32(self, *args) -> 'bool'
 |      is_int32(self) -> bool
 |  
 |  is_int64(self, *args) -> 'bool'
 |      is_int64(self) -> bool
 |  
 |  is_integral(self, *args) -> 'bool'
 |      is_integral(self) -> bool
 |  
 |  is_ldouble(self, *args) -> 'bool'
 |      is_ldouble(self) -> bool
 |  
 |  is_manually_castable_to(self, *args) -> 'bool'
 |      is_manually_castable_to(self, target) -> bool
 |  
 |  is_one_fpval(self, *args) -> 'bool'
 |      is_one_fpval(self) -> bool
 |  
 |  is_paf(self, *args) -> 'bool'
 |      is_paf(self) -> bool
 |  
 |  is_partial(self, *args) -> 'bool'
 |      is_partial(self) -> bool
 |  
 |  is_ptr(self, *args) -> 'bool'
 |      is_ptr(self) -> bool
 |  
 |  is_ptr_or_array(self, *args) -> 'bool'
 |      is_ptr_or_array(self) -> bool
 |  
 |  is_purging_cc(self, *args) -> 'bool'
 |      is_purging_cc(self) -> bool
 |  
 |  is_pvoid(self, *args) -> 'bool'
 |      is_pvoid(self) -> bool
 |  
 |  is_scalar(self, *args) -> 'bool'
 |      is_scalar(self) -> bool
 |  
 |  is_shifted_ptr(self, *args) -> 'bool'
 |      is_shifted_ptr(self) -> bool
 |  
 |  is_signed(self, *args) -> 'bool'
 |      is_signed(self) -> bool
 |  
 |  is_small_udt(self, *args) -> 'bool'
 |      is_small_udt(self) -> bool
 |  
 |  is_sse_type(self, *args) -> 'bool'
 |      is_sse_type(self) -> bool
 |  
 |  is_struct(self, *args) -> 'bool'
 |      is_struct(self) -> bool
 |  
 |  is_sue(self, *args) -> 'bool'
 |      is_sue(self) -> bool
 |  
 |  is_tbyte(self, *args) -> 'bool'
 |      is_tbyte(self) -> bool
 |  
 |  is_typeref(self, *args) -> 'bool'
 |      is_typeref(self) -> bool
 |  
 |  is_uchar(self, *args) -> 'bool'
 |      is_uchar(self) -> bool
 |  
 |  is_udt(self, *args) -> 'bool'
 |      is_udt(self) -> bool
 |  
 |  is_uint(self, *args) -> 'bool'
 |      is_uint(self) -> bool
 |  
 |  is_uint128(self, *args) -> 'bool'
 |      is_uint128(self) -> bool
 |  
 |  is_uint16(self, *args) -> 'bool'
 |      is_uint16(self) -> bool
 |  
 |  is_uint32(self, *args) -> 'bool'
 |      is_uint32(self) -> bool
 |  
 |  is_uint64(self, *args) -> 'bool'
 |      is_uint64(self) -> bool
 |  
 |  is_union(self, *args) -> 'bool'
 |      is_union(self) -> bool
 |  
 |  is_unknown(self, *args) -> 'bool'
 |      is_unknown(self) -> bool
 |  
 |  is_unsigned(self, *args) -> 'bool'
 |      is_unsigned(self) -> bool
 |  
 |  is_user_cc(self, *args) -> 'bool'
 |      is_user_cc(self) -> bool
 |  
 |  is_vararg_cc(self, *args) -> 'bool'
 |      is_vararg_cc(self) -> bool
 |  
 |  is_varstruct(self, *args) -> 'bool'
 |      is_varstruct(self) -> bool
 |  
 |  is_vftable(self, *args) -> 'bool'
 |      is_vftable(self) -> bool
 |  
 |  is_void(self, *args) -> 'bool'
 |      is_void(self) -> bool
 |  
 |  is_volatile(self, *args) -> 'bool'
 |      is_volatile(self) -> bool
 |  
 |  is_well_defined(self, *args) -> 'bool'
 |      is_well_defined(self) -> bool
 |  
 |  present(self, *args) -> 'bool'
 |      present(self) -> bool
 |  
 |  read_bitfield_value(self, *args) -> 'uint64'
 |      read_bitfield_value(self, v, bitoff) -> uint64
 |  
 |  remove_ptr_or_array(self, *args) -> 'bool'
 |      remove_ptr_or_array(self) -> bool
 |  
 |  requires_qualifier(self, *args) -> 'bool'
 |      requires_qualifier(self, name, offset) -> bool
 |  
 |  serialize(self, *args) -> 'PyObject *'
 |      serialize(self, sudt_flags=SUDT_FAST|SUDT_TRUNC) -> PyObject *
 |  
 |  set_attr(self, *args) -> 'bool'
 |      set_attr(self, ta, may_overwrite=True) -> bool
 |  
 |  set_attrs(self, *args) -> 'bool'
 |      set_attrs(self, tav) -> bool
 |  
 |  set_const(self, *args) -> 'void'
 |      set_const(self)
 |  
 |  set_declalign(self, *args) -> 'bool'
 |      set_declalign(self, declalign) -> bool
 |  
 |  set_modifiers(self, *args) -> 'void'
 |      set_modifiers(self, mod)
 |  
 |  set_named_type(self, *args) -> 'tinfo_code_t'
 |      set_named_type(self, til, name, ntf_flags=0) -> tinfo_code_t
 |  
 |  set_numbered_type(self, *args) -> 'tinfo_code_t'
 |      set_numbered_type(self, til, ord, ntf_flags=0, name=None) -> tinfo_code_t
 |  
 |  set_symbol_type(self, *args) -> 'tinfo_code_t'
 |      set_symbol_type(self, til, name, ntf_flags=0) -> tinfo_code_t
 |  
 |  set_volatile(self, *args) -> 'void'
 |      set_volatile(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  write_bitfield_value(self, *args) -> 'uint64'
 |      write_bitfield_value(self, dst, v, bitoff) -> uint64
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  get_stock(*args) -> 'tinfo_t'
 |      get_stock(id) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function tinfo_t_get_stock in module ida_typeinf:

tinfo_t_get_stock(*args) -> 'tinfo_t'
    tinfo_t_get_stock(id) -> tinfo_t

Help on class tinfo_visitor_t in module ida_typeinf:

class tinfo_visitor_t(builtins.object)
 |  Proxy of C++ tinfo_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, s=0) -> tinfo_visitor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_tinfo_visitor_t(...)
 |      delete_tinfo_visitor_t(self)
 |  
 |  apply_to(self, *args) -> 'int'
 |      apply_to(self, tif, out=None, name=None, cmt=None) -> int
 |  
 |  prune_now(self, *args) -> 'void'
 |      prune_now(self)
 |  
 |  visit_type(self, *args) -> 'int'
 |      visit_type(self, out, tif, name, cmt) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  state
 |      tinfo_visitor_t_state_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on class type_attr_t in module ida_typeinf:

class type_attr_t(builtins.object)
 |  Proxy of C++ type_attr_t class.
 |  
 |  Methods defined here:
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> type_attr_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_type_attr_t(...)
 |      delete_type_attr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  key
 |      type_attr_t_key_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      type_attr_t_value_get(self) -> bytevec_t *

Help on class type_attrs_t in module ida_typeinf:

class type_attrs_t(builtins.object)
 |  Proxy of C++ qvector< type_attr_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'type_attr_t const &'
 |      __getitem__(self, i) -> type_attr_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> type_attrs_t
 |      __init__(self, x) -> type_attrs_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_type_attrs_t(...)
 |      delete_type_attrs_t(self)
 |  
 |  at(self, *args) -> 'type_attr_t const &'
 |      at(self, _idx) -> type_attr_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< type_attr_t >::const_iterator'
 |      begin(self) -> type_attr_t
 |      begin(self) -> type_attr_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< type_attr_t >::const_iterator'
 |      end(self) -> type_attr_t
 |      end(self) -> type_attr_t
 |  
 |  erase(self, *args) -> 'qvector< type_attr_t >::iterator'
 |      erase(self, it) -> type_attr_t
 |      erase(self, first, last) -> type_attr_t
 |  
 |  extract(self, *args) -> 'type_attr_t *'
 |      extract(self) -> type_attr_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=type_attr_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< type_attr_t >::iterator'
 |      insert(self, it, x) -> type_attr_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'type_attr_t &'
 |      push_back(self, x)
 |      push_back(self) -> type_attr_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class type_mods_t in module ida_typeinf:

class type_mods_t(builtins.object)
 |  Proxy of C++ type_mods_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> type_mods_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_type_mods_t(...)
 |      delete_type_mods_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  has_cmt(self, *args) -> 'bool'
 |      has_cmt(self) -> bool
 |  
 |  has_info(self, *args) -> 'bool'
 |      has_info(self) -> bool
 |  
 |  has_name(self, *args) -> 'bool'
 |      has_name(self) -> bool
 |  
 |  has_type(self, *args) -> 'bool'
 |      has_type(self) -> bool
 |  
 |  set_new_cmt(self, *args) -> 'void'
 |      set_new_cmt(self, c)
 |  
 |  set_new_name(self, *args) -> 'void'
 |      set_new_name(self, n)
 |  
 |  set_new_type(self, *args) -> 'void'
 |      set_new_type(self, t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      type_mods_t_cmt_get(self) -> qstring *
 |  
 |  flags
 |      type_mods_t_flags_get(self) -> int
 |  
 |  name
 |      type_mods_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type_mods_t_type_get(self) -> tinfo_t

Help on class typedef_type_data_t in module ida_typeinf:

class typedef_type_data_t(builtins.object)
 |  Proxy of C++ typedef_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _til, _name, _resolve=False) -> typedef_type_data_t
 |      __init__(self, _til, ord, _resolve=False) -> typedef_type_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_typedef_type_data_t(...)
 |      delete_typedef_type_data_t(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  is_ordref
 |      typedef_type_data_t_is_ordref_get(self) -> bool
 |  
 |  resolve
 |      typedef_type_data_t_resolve_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  til
 |      typedef_type_data_t_til_get(self) -> til_t

Help on class udt_member_t in module ida_typeinf:

class udt_member_t(builtins.object)
 |  Proxy of C++ udt_member_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udt_member_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udt_member_t(...)
 |      delete_udt_member_t(self)
 |  
 |  begin(self, *args) -> 'uint64'
 |      begin(self) -> uint64
 |  
 |  clr_baseclass(self, *args) -> 'void'
 |      clr_baseclass(self)
 |  
 |  clr_unaligned(self, *args) -> 'void'
 |      clr_unaligned(self)
 |  
 |  clr_vftable(self, *args) -> 'void'
 |      clr_vftable(self)
 |  
 |  clr_virtbase(self, *args) -> 'void'
 |      clr_virtbase(self)
 |  
 |  end(self, *args) -> 'uint64'
 |      end(self) -> uint64
 |  
 |  is_anonymous_udm(self, *args) -> 'bool'
 |      is_anonymous_udm(self) -> bool
 |  
 |  is_baseclass(self, *args) -> 'bool'
 |      is_baseclass(self) -> bool
 |  
 |  is_bitfield(self, *args) -> 'bool'
 |      is_bitfield(self) -> bool
 |  
 |  is_unaligned(self, *args) -> 'bool'
 |      is_unaligned(self) -> bool
 |  
 |  is_vftable(self, *args) -> 'bool'
 |      is_vftable(self) -> bool
 |  
 |  is_virtbase(self, *args) -> 'bool'
 |      is_virtbase(self) -> bool
 |  
 |  is_zero_bitfield(self, *args) -> 'bool'
 |      is_zero_bitfield(self) -> bool
 |  
 |  set_baseclass(self, *args) -> 'void'
 |      set_baseclass(self)
 |  
 |  set_unaligned(self, *args) -> 'void'
 |      set_unaligned(self)
 |  
 |  set_vftable(self, *args) -> 'void'
 |      set_vftable(self)
 |  
 |  set_virtbase(self, *args) -> 'void'
 |      set_virtbase(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      udt_member_t_cmt_get(self) -> qstring *
 |  
 |  effalign
 |      udt_member_t_effalign_get(self) -> int
 |  
 |  fda
 |      udt_member_t_fda_get(self) -> uchar
 |  
 |  name
 |      udt_member_t_name_get(self) -> qstring *
 |  
 |  offset
 |      udt_member_t_offset_get(self) -> uint64
 |  
 |  size
 |      udt_member_t_size_get(self) -> uint64
 |  
 |  tafld_bits
 |      udt_member_t_tafld_bits_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      udt_member_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class udt_type_data_t in module ida_typeinf:

class udt_type_data_t(udtmembervec_t)
 |  Proxy of C++ udt_type_data_t class.
 |  
 |  Method resolution order:
 |      udt_type_data_t
 |      udtmembervec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udt_type_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udt_type_data_t(...)
 |      delete_udt_type_data_t(self)
 |  
 |  is_cppobj(self, *args) -> 'bool'
 |      is_cppobj(self) -> bool
 |  
 |  is_last_baseclass(self, *args) -> 'bool'
 |      is_last_baseclass(self, idx) -> bool
 |  
 |  is_msstruct(self, *args) -> 'bool'
 |      is_msstruct(self) -> bool
 |  
 |  is_unaligned(self, *args) -> 'bool'
 |      is_unaligned(self) -> bool
 |  
 |  is_vftable(self, *args) -> 'bool'
 |      is_vftable(self) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  effalign
 |      udt_type_data_t_effalign_get(self) -> uint32
 |  
 |  is_union
 |      udt_type_data_t_is_union_get(self) -> bool
 |  
 |  pack
 |      udt_type_data_t_pack_get(self) -> uchar
 |  
 |  sda
 |      udt_type_data_t_sda_get(self) -> uchar
 |  
 |  taudt_bits
 |      udt_type_data_t_taudt_bits_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  total_size
 |      udt_type_data_t_total_size_get(self) -> size_t
 |  
 |  unpadded_size
 |      udt_type_data_t_unpadded_size_get(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from udtmembervec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'udt_member_t const &'
 |      __getitem__(self, i) -> udt_member_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'udt_member_t const &'
 |      at(self, _idx) -> udt_member_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      begin(self) -> udt_member_t
 |      begin(self) -> udt_member_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      end(self) -> udt_member_t
 |      end(self) -> udt_member_t
 |  
 |  erase(self, *args) -> 'qvector< udt_member_t >::iterator'
 |      erase(self, it) -> udt_member_t
 |      erase(self, first, last) -> udt_member_t
 |  
 |  extract(self, *args) -> 'udt_member_t *'
 |      extract(self) -> udt_member_t
 |  
 |  find(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      find(self, x) -> udt_member_t
 |      find(self, x) -> udt_member_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=udt_member_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< udt_member_t >::iterator'
 |      insert(self, it, x) -> udt_member_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'udt_member_t &'
 |      push_back(self, x)
 |      push_back(self) -> udt_member_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from udtmembervec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from udtmembervec_t:
 |  
 |  __hash__ = None

Help on class udtmembervec_t in module ida_typeinf:

class udtmembervec_t(builtins.object)
 |  Proxy of C++ qvector< udt_member_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'udt_member_t const &'
 |      __getitem__(self, i) -> udt_member_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udtmembervec_t
 |      __init__(self, x) -> udtmembervec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_udtmembervec_t(...)
 |      delete_udtmembervec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  at(self, *args) -> 'udt_member_t const &'
 |      at(self, _idx) -> udt_member_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      begin(self) -> udt_member_t
 |      begin(self) -> udt_member_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      end(self) -> udt_member_t
 |      end(self) -> udt_member_t
 |  
 |  erase(self, *args) -> 'qvector< udt_member_t >::iterator'
 |      erase(self, it) -> udt_member_t
 |      erase(self, first, last) -> udt_member_t
 |  
 |  extract(self, *args) -> 'udt_member_t *'
 |      extract(self) -> udt_member_t
 |  
 |  find(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      find(self, x) -> udt_member_t
 |      find(self, x) -> udt_member_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=udt_member_t())
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< udt_member_t >::iterator'
 |      insert(self, it, x) -> udt_member_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'udt_member_t &'
 |      push_back(self, x)
 |      push_back(self) -> udt_member_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function unpack_idcobj_from_bv in module ida_typeinf:

unpack_idcobj_from_bv(*args) -> 'error_t'
    unpack_idcobj_from_bv(obj, tif, bytes, pio_flags=0) -> error_t
    
    
    Read a typed idc object from the byte vector.
    
    
    @param obj (C++: idc_value_t  *)
    @param tif (C++: const  tinfo_t  &)
    @param bytes (C++: const  bytevec_t  &)
    @param pio_flags (C++: int)

Help on function unpack_idcobj_from_idb in module ida_typeinf:

unpack_idcobj_from_idb(*args) -> 'error_t'
    unpack_idcobj_from_idb(obj, tif, ea, off0, pio_flags=0) -> error_t
    
    
    Collection of register objects.
    
    Read a typed idc object from the database
    
    @param obj (C++: idc_value_t  *)
    @param tif (C++: const  tinfo_t  &)
    @param ea (C++: ea_t)
    @param off0 (C++: const  bytevec_t  *)
    @param pio_flags (C++: int)

Help on function unpack_object_from_bv in module ida_typeinf:

unpack_object_from_bv(*args) -> 'PyObject *'
    unpack_object_from_bv(ti, _type, _fields, bytes, pio_flags=0) -> PyObject *
    
    
    Unpacks a buffer into an object.
    Returns the error_t returned by idaapi.pack_object_to_idb
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @param fields: fields string (may be empty or None)
    @param bytes: the bytes to unpack
    @param pio_flags: flags used while unpacking
    @return:
        - tuple(0, err) on failure
        - tuple(1, obj) on success

Help on function unpack_object_from_idb in module ida_typeinf:

unpack_object_from_idb(*args) -> 'PyObject *'
    unpack_object_from_idb(ti, _type, _fields, ea, pio_flags=0) -> PyObject *

Help on class valstr_t in module ida_typeinf:

class valstr_t(builtins.object)
 |  Proxy of C++ valstr_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> valstr_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_valstr_t(...)
 |      delete_valstr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  info
 |      valstr_t_info_get(self) -> valinfo_t *
 |  
 |  length
 |      valstr_t_length_get(self) -> size_t
 |  
 |  members
 |      valstr_t_members_get(self) -> valstrs_t
 |  
 |  oneline
 |      valstr_t_oneline_get(self) -> qstring *
 |  
 |  props
 |      valstr_t_props_get(self) -> int
 |  
 |  thisown
 |      The membership flag

Help on class valstrs_t in module ida_typeinf:

class valstrs_t(valstrvec_t)
 |  Proxy of C++ valstrs_t class.
 |  
 |  Method resolution order:
 |      valstrs_t
 |      valstrvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> valstrs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_valstrs_t(...)
 |      delete_valstrs_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from valstrvec_t:
 |  
 |  __getitem__(self, *args) -> 'valstr_t const &'
 |      __getitem__(self, i) -> valstr_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  at(self, *args) -> 'valstr_t const &'
 |      at(self, _idx) -> valstr_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< valstr_t >::const_iterator'
 |      begin(self) -> valstr_t
 |      begin(self) -> valstr_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< valstr_t >::const_iterator'
 |      end(self) -> valstr_t
 |      end(self) -> valstr_t
 |  
 |  erase(self, *args) -> 'qvector< valstr_t >::iterator'
 |      erase(self, it) -> valstr_t
 |      erase(self, first, last) -> valstr_t
 |  
 |  extract(self, *args) -> 'valstr_t *'
 |      extract(self) -> valstr_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=valstr_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< valstr_t >::iterator'
 |      insert(self, it, x) -> valstr_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'valstr_t &'
 |      push_back(self, x)
 |      push_back(self) -> valstr_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from valstrvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class valstrvec_t in module ida_typeinf:

class valstrvec_t(builtins.object)
 |  Proxy of C++ qvector< valstr_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'valstr_t const &'
 |      __getitem__(self, i) -> valstr_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> valstrvec_t
 |      __init__(self, x) -> valstrvec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_valstrvec_t(...)
 |      delete_valstrvec_t(self)
 |  
 |  at(self, *args) -> 'valstr_t const &'
 |      at(self, _idx) -> valstr_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< valstr_t >::const_iterator'
 |      begin(self) -> valstr_t
 |      begin(self) -> valstr_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< valstr_t >::const_iterator'
 |      end(self) -> valstr_t
 |      end(self) -> valstr_t
 |  
 |  erase(self, *args) -> 'qvector< valstr_t >::iterator'
 |      erase(self, it) -> valstr_t
 |      erase(self, first, last) -> valstr_t
 |  
 |  extract(self, *args) -> 'valstr_t *'
 |      extract(self) -> valstr_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=valstr_t())
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< valstr_t >::iterator'
 |      insert(self, it, x) -> valstr_t
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'valstr_t &'
 |      push_back(self, x)
 |      push_back(self) -> valstr_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function verify_argloc in module ida_typeinf:

verify_argloc(*args) -> 'int'
    verify_argloc(vloc, size, gaps) -> int
    
    
    Verify 'argloc_t' .
    
    @param vloc (C++: const  argloc_t  &)
    @param size: total size of the variable (C++: int)
    @param gaps: if not NULL, specifies gaps in structure definition.
                 these gaps should not map to any argloc, but everything
                 else must be covered (C++: const  rangeset_t  *)
    @return: 0 if ok, otherwise an interr code.

Help on function verify_tinfo in module ida_typeinf:

verify_tinfo(*args) -> 'int'
    verify_tinfo(typid) -> int

Help on function visit_subtypes in module ida_typeinf:

visit_subtypes(*args) -> 'int'
    visit_subtypes(visitor, out, tif, name, cmt) -> int

Help on function write_tinfo_bitfield_value in module ida_typeinf:

write_tinfo_bitfield_value(*args) -> 'uint64'
    write_tinfo_bitfield_value(typid, dst, v, bitoff) -> uint64

=== ida_typeinf EPYDOC INJECTIONS ===
ida_typeinf.ADDTIL_ABORTED
"""
til was not loaded (incompatible til rejected by user)
"""

ida_typeinf.ADDTIL_COMP
"""
ok, but til is not compatible with the current compiler
"""

ida_typeinf.ADDTIL_DEFAULT
"""
default behavior
"""

ida_typeinf.ADDTIL_FAILED
"""
something bad, the warning is displayed
"""

ida_typeinf.ADDTIL_INCOMP
"""
load incompatible tils
"""

ida_typeinf.ADDTIL_OK
"""
ok, til is loaded
"""

ida_typeinf.ADDTIL_SILENT
"""
do not ask any questions
"""

ida_typeinf.CC_ALLOW_ARGPERM
"""
disregard argument order?
"""

ida_typeinf.CC_ALLOW_REGHOLES
"""
allow holes in register argument list?
"""

ida_typeinf.CC_CDECL_OK
"""
can use __cdecl calling convention?
"""

ida_typeinf.CC_HAS_ELLIPSIS
"""
function has a variable list of arguments?
"""

ida_typeinf.FAH_BYTE
"""
function argument attribute header byte
"""

ida_typeinf.FAI_ARRAY
"""
was initially an array see "__org_typedef" or "__org_arrdim" type
attributes to determine the original type
"""

ida_typeinf.FAI_HIDDEN
"""
hidden argument
"""

ida_typeinf.FAI_RETPTR
"""
pointer to return value. implies hidden
"""

ida_typeinf.FAI_STRUCT
"""
was initially a structure
"""

ida_typeinf.FTI_ALL
"""
all defined bits
"""

ida_typeinf.FTI_ARGLOCS
"""
(stkargs and retloc too)

info about argument locations has been calculated
"""

ida_typeinf.FTI_CALLTYPE
"""
mask for FTI_*CALL
"""

ida_typeinf.FTI_DEFCALL
"""
default call
"""

ida_typeinf.FTI_FARCALL
"""
far call
"""

ida_typeinf.FTI_HIGH
"""
high level prototype (with possibly hidden args)
"""

ida_typeinf.FTI_INTCALL
"""
interrupt call
"""

ida_typeinf.FTI_NEARCALL
"""
near call
"""

ida_typeinf.FTI_NORET
"""
noreturn
"""

ida_typeinf.FTI_PURE
"""
__pure
"""

ida_typeinf.FTI_SPOILED
"""
information about spoiled registers is present
"""

ida_typeinf.FTI_STATIC
"""
static
"""

ida_typeinf.FTI_VIRTUAL
"""
virtual
"""

ida_typeinf.GUESS_FUNC_FAILED
"""
couldn't guess the function type
"""

ida_typeinf.GUESS_FUNC_OK
"""
ok, some non-trivial information is gathered
"""

ida_typeinf.GUESS_FUNC_TRIVIAL
"""
the function type doesn't have interesting info
"""

ida_typeinf.HTI_CPP
"""
C++ mode (not implemented)
"""

ida_typeinf.HTI_DCL
"""
don't complain about redeclarations
"""

ida_typeinf.HTI_EXT
"""
debug: print external representation of types
"""

ida_typeinf.HTI_FIL
"""
otherwise "input" contains a C declaration

"input" is file name,
"""

ida_typeinf.HTI_HIGH
"""
(with hidden args, etc)

assume high level prototypes
"""

ida_typeinf.HTI_INT
"""
debug: print internal representation of types
"""

ida_typeinf.HTI_LEX
"""
debug: print tokens
"""

ida_typeinf.HTI_LOWER
"""
lower the function prototypes
"""

ida_typeinf.HTI_MAC
"""
define macros from the base tils
"""

ida_typeinf.HTI_NDC
"""
don't decorate names
"""

ida_typeinf.HTI_NER
"""
ignore all errors but display them
"""

ida_typeinf.HTI_NWR
"""
no warning messages
"""

ida_typeinf.HTI_PAK
"""
explicit structure pack value (#pragma pack)
"""

ida_typeinf.HTI_PAK1
"""
#pragma pack(1)
"""

ida_typeinf.HTI_PAK16
"""
#pragma pack(16)
"""

ida_typeinf.HTI_PAK2
"""
#pragma pack(2)
"""

ida_typeinf.HTI_PAK4
"""
#pragma pack(4)
"""

ida_typeinf.HTI_PAK8
"""
#pragma pack(8)
"""

ida_typeinf.HTI_PAKDEF
"""
default pack value
"""

ida_typeinf.HTI_PAK_SHIFT
"""
shift for 'HTI_PAK' . This field should be used if you want to
remember an explicit pack value for each structure/union type. See
'HTI_PAK' ... definitions
"""

ida_typeinf.HTI_RAWARGS
"""
leave argument names unchanged (do not remove underscores)
"""

ida_typeinf.HTI_TST
"""
test mode: discard the result
"""

ida_typeinf.HTI_UNP
"""
debug: check the result by unpacking it
"""

ida_typeinf.IMPTYPE_LOCAL
"""
the type is local, the struct/enum won't be marked as til type. there
is no need to specify this bit if til==idati, the kernel will set it
automatically
"""

ida_typeinf.IMPTYPE_OVERRIDE
"""
override existing type
"""

ida_typeinf.IMPTYPE_VERBOSE
"""
more verbose output (dialog boxes may appear)
"""

ida_typeinf.MAX_FUNC_ARGS
"""
max number of function arguments
"""

ida_typeinf.NTF_64BIT
"""
value is 64bit
"""

ida_typeinf.NTF_CHKSYNC
"""
(set_numbered_type, set_named_type)

check that synchronization to IDB passed OK
"""

ida_typeinf.NTF_FIXNAME
"""
(set_named_type, set_numbered_type only)

force-validate the name of the type when setting
"""

ida_typeinf.NTF_IDBENC
"""
the name is given in the IDB encoding; non-ASCII bytes will be decoded
accordingly (set_named_type, set_numbered_type only)
"""

ida_typeinf.NTF_NOBASE
"""
don't inspect base tils (for get_named_type)
"""

ida_typeinf.NTF_NOCUR
"""
don't inspect current til file (for get_named_type)
"""

ida_typeinf.NTF_REPLACE
"""
replace original type (for set_named_type)
"""

ida_typeinf.NTF_SYMM
"""
only one of 'NTF_TYPE' and 'NTF_SYMU' , 'NTF_SYMM' can be used

symbol, name is mangled ('_func')
"""

ida_typeinf.NTF_SYMU
"""
symbol, name is unmangled ('func')
"""

ida_typeinf.NTF_TYPE
"""
type name
"""

ida_typeinf.NTF_UMANGLED
"""
name is unmangled (don't use this flag)
"""

ida_typeinf.PCN_CHR
"""
character
"""

ida_typeinf.PCN_DEC
"""
decimal
"""

ida_typeinf.PCN_DECSEXT
"""
automatically extend sign of signed decimal numbers
"""

ida_typeinf.PCN_HEX
"""
hexadecimal
"""

ida_typeinf.PCN_LZHEX
"""
print leading zeroes for hexdecimal number
"""

ida_typeinf.PCN_NEGSIGN
"""
print negated value (-N) for negative numbers
"""

ida_typeinf.PCN_OCT
"""
octal
"""

ida_typeinf.PCN_RADIX
"""
number base to use
"""

ida_typeinf.PCN_UNSIGNED
"""
add 'u' suffix
"""

ida_typeinf.PDF_DEF_BASE
"""
Include base types: __int8, __int16, etc..
"""

ida_typeinf.PDF_DEF_FWD
"""
Allow forward declarations.
"""

ida_typeinf.PDF_HEADER_CMT
"""
Prepend output with a descriptive comment.
"""

ida_typeinf.PDF_INCL_DEPS
"""
Include all type dependencies.
"""

ida_typeinf.PIO_IGNORE_PTRS
"""
do not follow pointers
"""

ida_typeinf.PIO_NOATTR_FAIL
"""
missing attributes are not ok
"""

ida_typeinf.PRALOC_STKOFF
"""
print stack offsets
"""

ida_typeinf.PRALOC_VERIFY
"""
interr if illegal argloc
"""

ida_typeinf.PRTYPE_1LINE
"""
print to one line
"""

ida_typeinf.PRTYPE_COLORED
"""
add color tag COLOR_SYMBOL for any parentheses, commas and colons
"""

ida_typeinf.PRTYPE_CPP
"""
use c++ name (only for 'print_type()' )
"""

ida_typeinf.PRTYPE_DEF
"""
 'tinfo_t' : print definition, if available
"""

ida_typeinf.PRTYPE_MULTI
"""
print to many lines
"""

ida_typeinf.PRTYPE_NOARGS
"""
 'tinfo_t' : do not print function argument names
"""

ida_typeinf.PRTYPE_NOARRS
"""
 'tinfo_t' : print arguments with 'FAI_ARRAY' as pointers
"""

ida_typeinf.PRTYPE_NOREGEX
"""
do not apply regular expressions to beautify name
"""

ida_typeinf.PRTYPE_NORES
"""
 'tinfo_t' : never resolve types (meaningful with PRTYPE_DEF)
"""

ida_typeinf.PRTYPE_PRAGMA
"""
print pragmas for alignment
"""

ida_typeinf.PRTYPE_RESTORE
"""
 'tinfo_t' : print restored types for 'FAI_ARRAY' and 'FAI_STRUCT'
"""

ida_typeinf.PRTYPE_SEMI
"""
append ; to the end
"""

ida_typeinf.PRTYPE_TYPE
"""
print type declaration (not variable declaration)
"""

ida_typeinf.PT_HIGH
"""
(with hidden args, etc)

assume high level prototypes
"""

ida_typeinf.PT_LOWER
"""
lower the function prototypes
"""

ida_typeinf.PT_NDC
"""
don't decorate names
"""

ida_typeinf.PT_PACKMASK
"""
mask for pack alignment values
"""

ida_typeinf.PT_RAWARGS
"""
leave argument names unchanged (do not remove underscores)
"""

ida_typeinf.PT_REPLACE
"""
replace the old type (used in idc)
"""

ida_typeinf.PT_SIL
"""
silent, no messages
"""

ida_typeinf.PT_TYP
"""
return declared type information
"""

ida_typeinf.PT_VAR
"""
return declared object information
"""

ida_typeinf.RESERVED_BYTE
"""
multifunctional purpose
"""

ida_typeinf.SETCOMP_BY_USER
"""
invoked by user, cannot be replaced by module/loader
"""

ida_typeinf.SETCOMP_ONLY_ABI
"""
ignore cc field complete, use only abiname
"""

ida_typeinf.SETCOMP_ONLY_ID
"""
cc has only 'id' field the rest will be set to defaults corresponding
to the program bitness
"""

ida_typeinf.SETCOMP_OVERRIDE
"""
may override old compiler info
"""

ida_typeinf.STRMEM_ANON
"""
can be combined with 'STRMEM_NAME' : look inside anonymous members
too.
"""

ida_typeinf.STRMEM_AUTO
"""
get member by offset if struct, or get member by index if union - nb:
union: index is stored in the udm->offset field!nb: struct: offset is
in bytes (not in bits)!
"""

ida_typeinf.STRMEM_CASTABLE_TO
"""
can be combined with 'STRMEM_TYPE' : member type must be castable to
the specified type
"""

ida_typeinf.STRMEM_INDEX
"""
get member by number- in: udm->offset - is a member number
"""

ida_typeinf.STRMEM_MAXS
"""
get biggest member by size.
"""

ida_typeinf.STRMEM_MINS
"""
get smallest member by size.
"""

ida_typeinf.STRMEM_NAME
"""
get member by name- in: udm->name - the desired member name.
"""

ida_typeinf.STRMEM_OFFSET
"""
get member by offset- in: udm->offset - is a member offset in bits
"""

ida_typeinf.STRMEM_SIZE
"""
get member by size.- in: udm->size - the desired member size.
"""

ida_typeinf.STRMEM_SKIP_EMPTY
"""
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' skip empty
members (i.e. having zero size) only last empty member can be returned
"""

ida_typeinf.STRMEM_TYPE
"""
get member by type. - in: udm->type - the desired member type. member
types are compared with tinfo_t::equals_to()
"""

ida_typeinf.STRMEM_VFTABLE
"""
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' get vftable
instead of the base class
"""

ida_typeinf.SUDT_ALIGN
"""
to match the offsets and size info

recalculate field alignments, struct packing, etc
"""

ida_typeinf.SUDT_CONST
"""
only for serialize_udt: make type const
"""

ida_typeinf.SUDT_FAST
"""
serialize without verifying offsets and alignments
"""

ida_typeinf.SUDT_GAPS
"""
allow to fill gaps with additional members (_BYTE[])
"""

ida_typeinf.SUDT_SORT
"""
fields are not sorted by offset, sort them first
"""

ida_typeinf.SUDT_TRUNC
"""
serialize: truncate useless strings from fields, fldcmts
"""

ida_typeinf.SUDT_UNEX
"""
references to nonexistent member types are acceptable in this case it
is better to set the corresponding 'udt_member_t::fda' field to the
type alignment. if this field is not set, ida will try to guess the
alignment.
"""

ida_typeinf.SUDT_VOLATILE
"""
only for serialize_udt: make type volatile
"""

ida_typeinf.TAENUM_64BIT
"""
enum: store 64-bit values
"""

ida_typeinf.TAENUM_SIGNED
"""
enum: signed
"""

ida_typeinf.TAENUM_UNSIGNED
"""
enum: unsigned
"""

ida_typeinf.TAFLD_BASECLASS
"""
field: do not include but inherit from the current field
"""

ida_typeinf.TAFLD_UNALIGNED
"""
field: unaligned field
"""

ida_typeinf.TAFLD_VFTABLE
"""
field: ptr to virtual function table
"""

ida_typeinf.TAFLD_VIRTBASE
"""
field: virtual base (not supported yet)
"""

ida_typeinf.TAH_ALL
"""
all defined bits
"""

ida_typeinf.TAH_BYTE
"""
type attribute header byte
"""

ida_typeinf.TAH_HASATTRS
"""
has extended attributes
"""

ida_typeinf.TAPTR_PTR32
"""
ptr: __ptr32
"""

ida_typeinf.TAPTR_PTR64
"""
ptr: __ptr64
"""

ida_typeinf.TAPTR_RESTRICT
"""
ptr: __restrict
"""

ida_typeinf.TAPTR_SHIFTED
"""
ptr: __shifted(parent_struct, delta)
"""

ida_typeinf.TAUDT_CPPOBJ
"""
struct: a c++ object, not simple pod type
"""

ida_typeinf.TAUDT_MSSTRUCT
"""
struct: gcc msstruct attribute
"""

ida_typeinf.TAUDT_UNALIGNED
"""
struct: unaligned struct
"""

ida_typeinf.TAUDT_VFTABLE
"""
struct: is virtual function table
"""

ida_typeinf.TA_FORMAT
"""
info about the 'format' argument 3 times pack_dd: 'format_functype_t'
, argument number of 'format', argument number of '...'
"""

ida_typeinf.TA_ORG_ARRDIM
"""
the original array dimension (pack_dd)
"""

ida_typeinf.TA_ORG_TYPEDEF
"""
the original typedef name (simple string)
"""

ida_typeinf.TCMP_ANYBASE
"""
accept any base class when casting
"""

ida_typeinf.TCMP_AUTOCAST
"""
can t1 be cast into t2 automatically?
"""

ida_typeinf.TCMP_CALL
"""
can t1 be called with t2 type?
"""

ida_typeinf.TCMP_DECL
"""
compare declarations without resolving them
"""

ida_typeinf.TCMP_DELPTR
"""
remove pointer from types before comparing
"""

ida_typeinf.TCMP_EQUAL
"""
are types equal?
"""

ida_typeinf.TCMP_IGNMODS
"""
ignore const/volatile modifiers
"""

ida_typeinf.TCMP_MANCAST
"""
can t1 be cast into t2 manually?
"""

ida_typeinf.TCMP_SKIPTHIS
"""
skip the first function argument in comparison
"""

ida_typeinf.TIL_ADD_ALREADY
"""
the base til was already added
"""

ida_typeinf.TIL_ADD_FAILED
"""
see errbuf
"""

ida_typeinf.TIL_ADD_OK
"""
some tils were added
"""

ida_typeinf.TIL_ALI
"""
type aliases are present (this bit is used only on the disk)
"""

ida_typeinf.TIL_ESI
"""
extended sizeof info (short, long, longlong)
"""

ida_typeinf.TIL_MAC
"""
til has macro table
"""

ida_typeinf.TIL_MOD
"""
til has been modified, should be saved
"""

ida_typeinf.TIL_ORD
"""
type ordinal numbers are present
"""

ida_typeinf.TIL_SLD
"""
sizeof(long double)
"""

ida_typeinf.TIL_STM
"""
til has extra streams
"""

ida_typeinf.TIL_UNI
"""
universal til for any compiler
"""

ida_typeinf.TIL_ZIP
"""
pack buckets using zip
"""

ida_typeinf.TINFO_DEFINITE
"""
this is a definite type
"""

ida_typeinf.TINFO_DELAYFUNC
"""
if type is a function and no function exists at ea, schedule its
creation and argument renaming to auto-analysis otherwise try to
create it immediately
"""

ida_typeinf.TINFO_GUESSED
"""
this is a guessed type
"""

ida_typeinf.TINFO_STRICT
"""
never convert given type to another one before applying
"""

ida_typeinf.TVIS_CMT
"""
new comment is present
"""

ida_typeinf.TVIS_NAME
"""
new name is present
"""

ida_typeinf.TVIS_TYPE
"""
new type info is present
"""

ida_typeinf.TVST_DEF
"""
visit type definition (meaningful for typerefs)
"""

ida_typeinf.TVST_PRUNE
"""
don't visit children of current type
"""

ida_typeinf.VALSTR_OPEN
"""
printed opening curly brace '{'
"""
=== ida_typeinf EPYDOC INJECTIONS END ===
Help on function calc_dataseg in module ida_ua:

calc_dataseg(*args) -> 'ea_t'
    calc_dataseg(insn, n=-1, rgnum=-1) -> ea_t
    
    
    Get data segment for the instruction operand. 'opnum' and 'rgnum' are
    meaningful only if the processor has segment registers.
    
    @param insn (C++: const  insn_t  &)
    @param n (C++: int)
    @param rgnum (C++: int)

Help on function can_decode in module ida_ua:

can_decode(*args) -> 'bool'
    can_decode(ea) -> bool
    
    
    Can the bytes at address 'ea' be decoded as instruction?
    
    @param ea: linear address (C++: ea_t)
    @return: whether or not the contents at that address could be a valid
             instruction

Help on function construct_macro in module ida_ua:

construct_macro(*args) -> 'bool'
    construct_macro(insn, enable, build_macro) -> bool
    
    
    See ua.hpp's construct_macro().

Help on function create_insn in module ida_ua:

create_insn(*args) -> 'int'
    create_insn(ea, out=None) -> int
    
    
    Create an instruction at the specified address. This function checks
    if an instruction is present at the specified address and will try to
    create one if there is none. It will fail if there is a data item or
    other items hindering the creation of the new instruction. This
    function will also fill the 'out' structure.
    
    @param ea: linear address (C++: ea_t)
    @param out: the resulting instruction (C++: insn_t  *)
    @return: the length of the instruction or 0

Help on function create_outctx in module ida_ua:

create_outctx(*args) -> 'outctx_base_t *'
    create_outctx(ea, F=0, suspop=0) -> outctx_base_t
    
    
    Create a new output context. To delete it, just use "delete pctx"
    
    @param ea (C++: ea_t)
    @param F (C++: flags_t)
    @param suspop (C++: int)

Help on function decode_insn in module ida_ua:

decode_insn(*args) -> 'int'
    decode_insn(out, ea) -> int
    
    
    Analyze the specified address and fill 'out'. This function does not
    modify the database. It just tries to interpret the specified address
    as an instruction and fills the 'out' structure.
    
    @param out: the resulting instruction (C++: insn_t  *)
    @param ea: linear address (C++: ea_t)
    @return: the length of the (possible) instruction or 0

Help on function decode_preceding_insn in module ida_ua:

decode_preceding_insn(*args) -> 'PyObject *'
    decode_preceding_insn(out, ea) -> PyObject *
    
    
    Decodes the preceding instruction. Please check ua.hpp / decode_preceding_insn()
    @param ea: current ea
    @param out: instruction storage
    @return: tuple(preceeding_ea or BADADDR, farref = Boolean)

Help on function decode_prev_insn in module ida_ua:

decode_prev_insn(*args) -> 'ea_t'
    decode_prev_insn(out, ea) -> ea_t
    
    
    Decode previous instruction if it exists, fill 'out'.
    
    @param out: the resulting instruction (C++: insn_t  *)
    @param ea: the address to decode the previous instruction from (C++:
               ea_t)
    @return: the previous instruction address ( BADADDR -no such insn)

Help on function get_dtype_by_size in module ida_ua:

get_dtype_by_size(*args) -> 'int'
    get_dtype_by_size(size) -> int
    
    
    Get 'op_t::dtype' from size.
    
    
    @param size (C++: asize_t)

Help on function get_dtype_flag in module ida_ua:

get_dtype_flag(*args) -> 'flags_t'
    get_dtype_flag(dtype) -> flags_t
    
    
    Get flags for 'op_t::dtype' field.
    
    
    @param dtype (C++: op_dtype_t)

Help on function get_dtype_size in module ida_ua:

get_dtype_size(*args) -> 'size_t'
    get_dtype_size(dtype) -> size_t
    
    
    Get size of opt_::dtype field.
    
    
    @param dtype (C++: op_dtype_t)

Help on function get_immvals in module ida_ua:

get_immvals(*args) -> 'PyObject *'
    get_immvals(ea, n, F=0) -> PyObject *
    
    
    Get immediate values at the specified address. This function decodes
    instruction at the specified address or inspects the data item. It
    finds immediate values and copies them to 'out'. This function will
    store the original value of the operands in 'out', unless the last
    bits of 'F' are "...0 11111111", in which case the transformed values
    (as needed for printing) will be stored instead.
    
    @param ea: address to analyze (C++: ea_t)
    @param n: number of operand (0.. UA_MAXOP -1), -1 means all operands
              (C++: int)
    @param F: flags for the specified address (C++: flags_t)
    @return: number of immediate values (0..2* UA_MAXOP )

Help on function get_lookback in module ida_ua:

get_lookback(*args) -> 'int'
    get_lookback() -> int
    
    
    Number of instructions to look back. This variable is not used by the
    kernel. Its value may be specified in ida.cfg: LOOKBACK = <number>.
    IDP may use it as you like it. (TMS module uses it)

Help on function get_printable_immvals in module ida_ua:

get_printable_immvals(*args) -> 'PyObject *'
    get_printable_immvals(ea, n, F=0) -> PyObject *
    
    
    Get immediate ready-to-print values at the specified address
    
    @param ea: address to analyze (C++: ea_t)
    @param n: number of operand (0.. UA_MAXOP -1), -1 means all operands
              (C++: int)
    @param F: flags for the specified address (C++: flags_t)
    @return: number of immediate values (0..2* UA_MAXOP )

Help on function guess_table_address in module ida_ua:

guess_table_address(*args) -> 'ea_t'
    guess_table_address(insn) -> ea_t
    
    
    Guess the jump table address (ibm pc specific)
    
    
    @param insn (C++: const  insn_t  &)

Help on function guess_table_size in module ida_ua:

guess_table_size(*args) -> 'asize_t'
    guess_table_size(insn, jump_table) -> asize_t
    
    
    Guess the jump table size.
    
    
    @param insn (C++: const  insn_t  &)
    @param jump_table (C++: ea_t)

Help on function insn_add_cref in module ida_ua:

insn_add_cref(*args) -> 'void'
    insn_add_cref(insn, to, opoff, type)

Help on function insn_add_dref in module ida_ua:

insn_add_dref(*args) -> 'void'
    insn_add_dref(insn, to, opoff, type)

Help on function insn_add_off_drefs in module ida_ua:

insn_add_off_drefs(*args) -> 'ea_t'
    insn_add_off_drefs(insn, x, type, outf) -> ea_t

Help on function insn_create_stkvar in module ida_ua:

insn_create_stkvar(*args) -> 'bool'
    insn_create_stkvar(insn, x, v, flags) -> bool

Help on class insn_t in module ida_ua:

class insn_t(builtins.object)
 |  Proxy of C++ insn_t class.
 |  
 |  Methods defined here:
 |  
 |  __get_auxpref__(self, *args) -> 'uint16'
 |      __get_auxpref__(self) -> uint16
 |  
 |  __get_operand__(self, *args) -> 'op_t *'
 |      __get_operand__(self, n) -> op_t
 |  
 |  __get_ops__(self, *args) -> 'wrapped_array_t< op_t,8 >'
 |      __get_ops__(self) -> operands_array
 |  
 |  __getitem__(self, idx)
 |      Operands can be accessed directly as indexes
 |      @return op_t: Returns an operand of type op_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> insn_t
 |  
 |  __iter__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __set_auxpref__(self, *args) -> 'void'
 |      __set_auxpref__(self, v)
 |  
 |  __swig_destroy__ = delete_insn_t(...)
 |      delete_insn_t(self)
 |  
 |  add_cref(self, *args) -> 'void'
 |      add_cref(self, to, opoff, type)
 |  
 |  add_dref(self, *args) -> 'void'
 |      add_dref(self, to, opoff, type)
 |  
 |  add_off_drefs(self, *args) -> 'ea_t'
 |      add_off_drefs(self, x, type, outf) -> ea_t
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, other)
 |  
 |  create_op_data(self, *args) -> 'bool'
 |      create_op_data(self, ea_, opoff, dtype) -> bool
 |      create_op_data(self, ea_, op) -> bool
 |  
 |  create_stkvar(self, *args) -> 'bool'
 |      create_stkvar(self, x, v, flags_) -> bool
 |  
 |  get_canon_feature(self, *args) -> 'uint32'
 |      get_canon_feature(self) -> uint32
 |  
 |  get_canon_mnem(self, *args) -> 'char const *'
 |      get_canon_mnem(self) -> char const *
 |  
 |  get_next_byte(self, *args) -> 'uint8'
 |      get_next_byte(self) -> uint8
 |  
 |  get_next_dword(self, *args) -> 'uint32'
 |      get_next_dword(self) -> uint32
 |  
 |  get_next_qword(self, *args) -> 'uint64'
 |      get_next_qword(self) -> uint64
 |  
 |  get_next_word(self, *args) -> 'uint16'
 |      get_next_word(self) -> uint16
 |  
 |  is_64bit(self, *args) -> 'bool'
 |      is_64bit(self) -> bool
 |  
 |  is_canon_insn(self, *args) -> 'bool'
 |      is_canon_insn(self) -> bool
 |  
 |  is_macro(self, *args) -> 'bool'
 |      is_macro(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  Op1
 |  
 |  Op2
 |  
 |  Op3
 |  
 |  Op4
 |  
 |  Op5
 |  
 |  Op6
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  auxpref
 |      __get_auxpref__(self) -> uint16
 |  
 |  cs
 |      insn_t_cs_get(self) -> ea_t
 |  
 |  ea
 |      insn_t_ea_get(self) -> ea_t
 |  
 |  flags
 |      insn_t_flags_get(self) -> int16
 |  
 |  insnpref
 |      insn_t_insnpref_get(self) -> char
 |  
 |  ip
 |      insn_t_ip_get(self) -> ea_t
 |  
 |  itype
 |      insn_t_itype_get(self) -> uint16
 |  
 |  ops
 |      __get_ops__(self) -> operands_array
 |  
 |  segpref
 |      insn_t_segpref_get(self) -> char
 |  
 |  size
 |      insn_t_size_get(self) -> uint16
 |  
 |  thisown
 |      The membership flag

Help on function insn_t__from_ptrval__ in module ida_ua:

insn_t__from_ptrval__(*args) -> 'insn_t *'
    insn_t__from_ptrval__(ptrval) -> insn_t

Help on function is_floating_dtype in module ida_ua:

is_floating_dtype(*args) -> 'bool'
    is_floating_dtype(dtype) -> bool
    
    
    Is a floating type operand?
    
    
    @param dtype (C++: op_dtype_t)

Help on function map_code_ea in module ida_ua:

map_code_ea(*args) -> 'ea_t'
    map_code_ea(insn, addr, opnum) -> ea_t
    map_code_ea(insn, op) -> ea_t
    
    
    Map a code address. This function takes into account the segment
    translations.
    
    @param insn: the current instruction (C++: const  insn_t  &)
    @param addr: the referenced address to map (C++: ea_t)
    @param opnum: operand number (C++: int)

Help on function map_data_ea in module ida_ua:

map_data_ea(*args) -> 'ea_t'
    map_data_ea(insn, addr, opnum=-1) -> ea_t
    map_data_ea(insn, op) -> ea_t
    
    
    Map a data address.
    
    @param insn: the current instruction (C++: const  insn_t  &)
    @param addr: the referenced address to map (C++: ea_t)
    @param opnum: operand number (C++: int)

Help on function map_ea in module ida_ua:

map_ea(*args) -> 'ea_t'
    map_ea(insn, op, iscode) -> ea_t
    map_ea(insn, addr, opnum, iscode) -> ea_t

Help on class op_t in module ida_ua:

class op_t(builtins.object)
 |  Proxy of C++ op_t class.
 |  
 |  Methods defined here:
 |  
 |  __get_addr__(self, *args) -> 'ea_t'
 |      __get_addr__(self) -> ea_t
 |  
 |  __get_reg_phrase__(self, *args) -> 'uint16'
 |      __get_reg_phrase__(self) -> uint16
 |  
 |  __get_specval__(self, *args) -> 'ea_t'
 |      __get_specval__(self) -> ea_t
 |  
 |  __get_value__(self, *args) -> 'ea_t'
 |      __get_value__(self) -> ea_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> op_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __set_addr__(self, *args) -> 'void'
 |      __set_addr__(self, v)
 |  
 |  __set_reg_phrase__(self, *args) -> 'void'
 |      __set_reg_phrase__(self, r)
 |  
 |  __set_specval__(self, *args) -> 'void'
 |      __set_specval__(self, v)
 |  
 |  __set_value__(self, *args) -> 'void'
 |      __set_value__(self, v)
 |  
 |  __swig_destroy__ = delete_op_t(...)
 |      delete_op_t(self)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, other)
 |  
 |  clr_shown(self, *args) -> 'void'
 |      clr_shown(self)
 |  
 |  has_reg(self, r)
 |      Checks if the operand accesses the given processor register
 |  
 |  is_imm(self, *args) -> 'bool'
 |      is_imm(self, v) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self, r) -> bool
 |  
 |  set_shown(self, *args) -> 'void'
 |      set_shown(self)
 |  
 |  shown(self, *args) -> 'bool'
 |      shown(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  addr
 |      __get_addr__(self) -> ea_t
 |  
 |  dtype
 |      op_t_dtype_get(self) -> op_dtype_t
 |  
 |  flags
 |      op_t_flags_get(self) -> uchar
 |  
 |  n
 |      op_t_n_get(self) -> uchar
 |  
 |  offb
 |      op_t_offb_get(self) -> char
 |  
 |  offo
 |      op_t_offo_get(self) -> char
 |  
 |  phrase
 |      __get_reg_phrase__(self) -> uint16
 |  
 |  reg
 |      __get_reg_phrase__(self) -> uint16
 |  
 |  specflag1
 |      op_t_specflag1_get(self) -> char
 |  
 |  specflag2
 |      op_t_specflag2_get(self) -> char
 |  
 |  specflag3
 |      op_t_specflag3_get(self) -> char
 |  
 |  specflag4
 |      op_t_specflag4_get(self) -> char
 |  
 |  specval
 |      __get_specval__(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      op_t_type_get(self) -> optype_t
 |  
 |  value
 |      __get_value__(self) -> ea_t

Help on function op_t__from_ptrval__ in module ida_ua:

op_t__from_ptrval__(*args) -> 'op_t *'
    op_t__from_ptrval__(ptrval) -> op_t

Help on class operands_array in module ida_ua:

class operands_array(builtins.object)
 |  Proxy of C++ wrapped_array_t< op_t,8 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'op_t const &'
 |      __getitem__(self, i) -> op_t
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> operands_array
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_operands_array(...)
 |      delete_operands_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  data
 |      operands_array_data_get(self) -> op_t (&)[8]
 |  
 |  thisown
 |      The membership flag

Help on class outctx_base_t in module ida_ua:

class outctx_base_t(builtins.object)
 |  Proxy of C++ outctx_base_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  close_comment(self, *args) -> 'void'
 |      close_comment(self)
 |  
 |  clr_gen_label(self, *args) -> 'void'
 |      clr_gen_label(self)
 |  
 |  display_voids(self, *args) -> 'bool'
 |      display_voids(self) -> bool
 |  
 |  flush_buf(self, *args) -> 'bool'
 |      flush_buf(self, buf, indent=-1) -> bool
 |  
 |  flush_outbuf(self, *args) -> 'bool'
 |      flush_outbuf(self, indent=-1) -> bool
 |  
 |  forbid_annotations(self, *args) -> 'int'
 |      forbid_annotations(self) -> int
 |  
 |  force_code(self, *args) -> 'bool'
 |      force_code(self) -> bool
 |  
 |  gen_block_cmt(self, *args) -> 'bool'
 |      gen_block_cmt(self, cmt, color) -> bool
 |  
 |  gen_border_line(self, *args) -> 'bool'
 |      gen_border_line(self, solid=False) -> bool
 |  
 |  gen_cmt_line(self, *args) -> 'bool'
 |      gen_cmt_line(self, format) -> bool
 |  
 |  gen_collapsed_line(self, *args) -> 'bool'
 |      gen_collapsed_line(self, format) -> bool
 |  
 |  gen_empty_line(self, *args) -> 'bool'
 |      gen_empty_line(self) -> bool
 |  
 |  gen_empty_line_without_annotations(self, *args) -> 'void'
 |      gen_empty_line_without_annotations(self)
 |  
 |  gen_printf(self, *args) -> 'bool'
 |      gen_printf(self, indent, format) -> bool
 |  
 |  gen_xref_lines(self, *args) -> 'bool'
 |      gen_xref_lines(self) -> bool
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
 |  
 |  init_lines_array(self, *args) -> 'void'
 |      init_lines_array(self, answers, maxsize)
 |  
 |  multiline(self, *args) -> 'bool'
 |      multiline(self) -> bool
 |  
 |  only_main_line(self, *args) -> 'bool'
 |      only_main_line(self) -> bool
 |  
 |  out_addr_tag(self, *args) -> 'void'
 |      out_addr_tag(self, ea)
 |  
 |  out_btoa(self, *args) -> 'void'
 |      out_btoa(self, Word, radix=0)
 |  
 |  out_char(self, *args) -> 'void'
 |      out_char(self, c)
 |  
 |  out_chars(self, *args) -> 'void'
 |      out_chars(self, c, n)
 |  
 |  out_colored_register_line(self, *args) -> 'void'
 |      out_colored_register_line(self, str)
 |  
 |  out_keyword(self, *args) -> 'void'
 |      out_keyword(self, str)
 |  
 |  out_line(self, *args) -> 'void'
 |      out_line(self, str, color=0)
 |  
 |  out_long(self, *args) -> 'void'
 |      out_long(self, v, radix)
 |  
 |  out_name_expr(self, *args) -> 'bool'
 |      out_name_expr(self, x, ea, off=BADADDR) -> bool
 |  
 |  out_printf(self, *args) -> 'void'
 |      out_printf(self, format)
 |  
 |  out_register(self, *args) -> 'void'
 |      out_register(self, str)
 |  
 |  out_spaces(self, *args) -> 'void'
 |      out_spaces(self, len)
 |  
 |  out_symbol(self, *args) -> 'void'
 |      out_symbol(self, c)
 |  
 |  out_tagoff(self, *args) -> 'void'
 |      out_tagoff(self, tag)
 |  
 |  out_tagon(self, *args) -> 'void'
 |      out_tagon(self, tag)
 |  
 |  out_value(self, *args) -> 'flags_t'
 |      out_value(self, x, outf=0) -> flags_t
 |  
 |  print_label_now(self, *args) -> 'bool'
 |      print_label_now(self) -> bool
 |  
 |  restore_ctxflags(self, *args) -> 'void'
 |      restore_ctxflags(self, saved_flags)
 |  
 |  retrieve_cmt(self, *args) -> 'ssize_t'
 |      retrieve_cmt(self) -> ssize_t
 |  
 |  retrieve_name(self, *args) -> 'ssize_t'
 |      retrieve_name(self, arg2, arg3) -> ssize_t
 |  
 |  set_comment_addr(self, *args) -> 'void'
 |      set_comment_addr(self, ea)
 |  
 |  set_dlbind_opnd(self, *args) -> 'void'
 |      set_dlbind_opnd(self)
 |  
 |  set_gen_cmt(self, *args) -> 'void'
 |      set_gen_cmt(self, on=True)
 |  
 |  set_gen_demangled_label(self, *args) -> 'void'
 |      set_gen_demangled_label(self)
 |  
 |  set_gen_label(self, *args) -> 'void'
 |      set_gen_label(self)
 |  
 |  set_gen_xrefs(self, *args) -> 'void'
 |      set_gen_xrefs(self, on=True)
 |  
 |  setup_outctx(self, *args) -> 'void'
 |      setup_outctx(self, prefix, makeline_flags)
 |  
 |  stack_view(self, *args) -> 'bool'
 |      stack_view(self) -> bool
 |  
 |  term_outctx(self, *args) -> 'int'
 |      term_outctx(self, prefix=None) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  default_lnnum
 |      outctx_base_t_default_lnnum_get(self) -> int
 |  
 |  insn_ea
 |      outctx_base_t_insn_ea_get(self) -> ea_t
 |  
 |  outbuf
 |      outctx_base_t_outbuf_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on function outctx_base_t__from_ptrval__ in module ida_ua:

outctx_base_t__from_ptrval__(*args) -> 'outctx_base_t *'
    outctx_base_t__from_ptrval__(ptrval) -> outctx_base_t

Help on class outctx_t in module ida_ua:

class outctx_t(outctx_base_t)
 |  Proxy of C++ outctx_t class.
 |  
 |  Method resolution order:
 |      outctx_t
 |      outctx_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  gen_func_footer(self, *args) -> 'void'
 |      gen_func_footer(self, pfn)
 |  
 |  gen_func_header(self, *args) -> 'void'
 |      gen_func_header(self, pfn)
 |  
 |  gen_header(self, *args) -> 'void'
 |      gen_header(self, flags=((1 << 0)|(1 << 1)), proc_name=None, proc_flavour=None)
 |  
 |  gen_header_extra(self, *args) -> 'void'
 |      gen_header_extra(self)
 |  
 |  gen_xref_lines(self, *args) -> 'bool'
 |      gen_xref_lines(self) -> bool
 |  
 |  out_custom_mnem(self, *args) -> 'void'
 |      out_custom_mnem(self, mnem, width=8, postfix=None)
 |  
 |  out_data(self, *args) -> 'void'
 |      out_data(self, analyze_only)
 |  
 |  out_immchar_cmts(self, *args) -> 'void'
 |      out_immchar_cmts(self)
 |  
 |  out_mnem(self, *args) -> 'void'
 |      out_mnem(self, width=8, postfix=None)
 |  
 |  out_mnemonic(self, *args) -> 'void'
 |      out_mnemonic(self)
 |  
 |  out_one_operand(self, *args) -> 'bool'
 |      out_one_operand(self, n) -> bool
 |  
 |  out_specea(self, *args) -> 'bool'
 |      out_specea(self, segtype) -> bool
 |  
 |  retrieve_cmt(self, *args) -> 'ssize_t'
 |      retrieve_cmt(self) -> ssize_t
 |  
 |  retrieve_name(self, *args) -> 'ssize_t'
 |      retrieve_name(self, arg2, arg3) -> ssize_t
 |  
 |  set_bin_state(self, *args) -> 'void'
 |      set_bin_state(self, value)
 |  
 |  setup_outctx(self, *args) -> 'void'
 |      setup_outctx(self, prefix, flags)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bin_ea
 |      outctx_t_bin_ea_get(self) -> ea_t
 |  
 |  bin_state
 |      outctx_t_bin_state_get(self) -> char
 |  
 |  bin_width
 |      outctx_t_bin_width_get(self) -> int
 |  
 |  curlabel
 |      outctx_t_curlabel_get(self) -> qstring *
 |  
 |  gl_bpsize
 |      outctx_t_gl_bpsize_get(self) -> int
 |  
 |  insn
 |      outctx_t_insn_get(self) -> insn_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  wif
 |      outctx_t_wif_get(self) -> printop_t
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from outctx_base_t:
 |  
 |  close_comment(self, *args) -> 'void'
 |      close_comment(self)
 |  
 |  clr_gen_label(self, *args) -> 'void'
 |      clr_gen_label(self)
 |  
 |  display_voids(self, *args) -> 'bool'
 |      display_voids(self) -> bool
 |  
 |  flush_buf(self, *args) -> 'bool'
 |      flush_buf(self, buf, indent=-1) -> bool
 |  
 |  flush_outbuf(self, *args) -> 'bool'
 |      flush_outbuf(self, indent=-1) -> bool
 |  
 |  forbid_annotations(self, *args) -> 'int'
 |      forbid_annotations(self) -> int
 |  
 |  force_code(self, *args) -> 'bool'
 |      force_code(self) -> bool
 |  
 |  gen_block_cmt(self, *args) -> 'bool'
 |      gen_block_cmt(self, cmt, color) -> bool
 |  
 |  gen_border_line(self, *args) -> 'bool'
 |      gen_border_line(self, solid=False) -> bool
 |  
 |  gen_cmt_line(self, *args) -> 'bool'
 |      gen_cmt_line(self, format) -> bool
 |  
 |  gen_collapsed_line(self, *args) -> 'bool'
 |      gen_collapsed_line(self, format) -> bool
 |  
 |  gen_empty_line(self, *args) -> 'bool'
 |      gen_empty_line(self) -> bool
 |  
 |  gen_empty_line_without_annotations(self, *args) -> 'void'
 |      gen_empty_line_without_annotations(self)
 |  
 |  gen_printf(self, *args) -> 'bool'
 |      gen_printf(self, indent, format) -> bool
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
 |  
 |  init_lines_array(self, *args) -> 'void'
 |      init_lines_array(self, answers, maxsize)
 |  
 |  multiline(self, *args) -> 'bool'
 |      multiline(self) -> bool
 |  
 |  only_main_line(self, *args) -> 'bool'
 |      only_main_line(self) -> bool
 |  
 |  out_addr_tag(self, *args) -> 'void'
 |      out_addr_tag(self, ea)
 |  
 |  out_btoa(self, *args) -> 'void'
 |      out_btoa(self, Word, radix=0)
 |  
 |  out_char(self, *args) -> 'void'
 |      out_char(self, c)
 |  
 |  out_chars(self, *args) -> 'void'
 |      out_chars(self, c, n)
 |  
 |  out_colored_register_line(self, *args) -> 'void'
 |      out_colored_register_line(self, str)
 |  
 |  out_keyword(self, *args) -> 'void'
 |      out_keyword(self, str)
 |  
 |  out_line(self, *args) -> 'void'
 |      out_line(self, str, color=0)
 |  
 |  out_long(self, *args) -> 'void'
 |      out_long(self, v, radix)
 |  
 |  out_name_expr(self, *args) -> 'bool'
 |      out_name_expr(self, x, ea, off=BADADDR) -> bool
 |  
 |  out_printf(self, *args) -> 'void'
 |      out_printf(self, format)
 |  
 |  out_register(self, *args) -> 'void'
 |      out_register(self, str)
 |  
 |  out_spaces(self, *args) -> 'void'
 |      out_spaces(self, len)
 |  
 |  out_symbol(self, *args) -> 'void'
 |      out_symbol(self, c)
 |  
 |  out_tagoff(self, *args) -> 'void'
 |      out_tagoff(self, tag)
 |  
 |  out_tagon(self, *args) -> 'void'
 |      out_tagon(self, tag)
 |  
 |  out_value(self, *args) -> 'flags_t'
 |      out_value(self, x, outf=0) -> flags_t
 |  
 |  print_label_now(self, *args) -> 'bool'
 |      print_label_now(self) -> bool
 |  
 |  restore_ctxflags(self, *args) -> 'void'
 |      restore_ctxflags(self, saved_flags)
 |  
 |  set_comment_addr(self, *args) -> 'void'
 |      set_comment_addr(self, ea)
 |  
 |  set_dlbind_opnd(self, *args) -> 'void'
 |      set_dlbind_opnd(self)
 |  
 |  set_gen_cmt(self, *args) -> 'void'
 |      set_gen_cmt(self, on=True)
 |  
 |  set_gen_demangled_label(self, *args) -> 'void'
 |      set_gen_demangled_label(self)
 |  
 |  set_gen_label(self, *args) -> 'void'
 |      set_gen_label(self)
 |  
 |  set_gen_xrefs(self, *args) -> 'void'
 |      set_gen_xrefs(self, on=True)
 |  
 |  stack_view(self, *args) -> 'bool'
 |      stack_view(self) -> bool
 |  
 |  term_outctx(self, *args) -> 'int'
 |      term_outctx(self, prefix=None) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from outctx_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  default_lnnum
 |      outctx_base_t_default_lnnum_get(self) -> int
 |  
 |  insn_ea
 |      outctx_base_t_insn_ea_get(self) -> ea_t
 |  
 |  outbuf
 |      outctx_base_t_outbuf_get(self) -> qstring *

Help on function outctx_t__from_ptrval__ in module ida_ua:

outctx_t__from_ptrval__(*args) -> 'outctx_t *'
    outctx_t__from_ptrval__(ptrval) -> outctx_t

Help on function print_insn_mnem in module ida_ua:

print_insn_mnem(*args) -> 'qstring *'
    print_insn_mnem(ea) -> str
    
    
    Print instruction mnemonics.
    
    @param ea: linear address of the instruction (C++: ea_t)
    @return: success

Help on function print_operand in module ida_ua:

print_operand(*args) -> 'qstring *'
    print_operand(ea, n, getn_flags=0, newtype=None) -> str
    
    
    Generate text representation for operand #n. This function will
    generate the text representation of the specified operand (includes
    color codes.)
    
    @param ea: the item address (instruction or data) (C++: ea_t)
    @param n: operand number (0,1,2...). meaningful only for instructions
              (C++: int)
    @param getn_flags (C++: int)
    @param newtype: if specified, print the operand using the specified
                    type (C++: struct  printop_t  *)
    @return: success

=== ida_ua EPYDOC INJECTIONS ===
ida_ua.FCBF_CONT
"""
don't stop on decoding, or any other kind of error
"""

ida_ua.FCBF_DELIM
"""
add the 'ash'-specified delimiters around the generated data. Note: if
those are not defined and the INFFL_ALLASM is not set,
'format_charlit()' will return an error
"""

ida_ua.FCBF_ERR_REPL
"""
of a hex representation of the problematic byte

in case of an error, use a CP_REPLCHAR instead
"""

ida_ua.FCBF_FF_LIT
"""
in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER
Y WITH DIAERESIS) If both this, and FCBF_REPL are specified, this will
take precedence
"""

ida_ua.INSN_64BIT
"""
belongs to 64bit segment?
"""

ida_ua.INSN_MACRO
"""
macro instruction
"""

ida_ua.INSN_MODMAC
"""
may modify the database to make room for the macro insn
"""

ida_ua.OF_NO_BASE_DISP
"""
base displacement doesn't exist. meaningful only for 'o_displ' type.
if set, base displacement ( 'op_t::addr' ) doesn't exist.
"""

ida_ua.OF_NUMBER
"""
the operand can be converted to a number only
"""

ida_ua.OF_OUTER_DISP
"""
outer displacement exists. meaningful only for 'o_displ' type. if set,
outer displacement ( 'op_t::value' ) exists.
"""

ida_ua.OF_SHOW
"""
should the operand be displayed?
"""

ida_ua.OOFS_IFSIGN
"""
output sign if needed
"""

ida_ua.OOFS_NEEDSIGN
"""
always out sign (+-)
"""

ida_ua.OOFS_NOSIGN
"""
don't output sign, forbid the user to change the sign
"""

ida_ua.OOFW_16
"""
16 bit width
"""

ida_ua.OOFW_24
"""
24 bit width
"""

ida_ua.OOFW_32
"""
32 bit width
"""

ida_ua.OOFW_64
"""
64 bit width
"""

ida_ua.OOFW_8
"""
8 bit width
"""

ida_ua.OOFW_IMM
"""
take from x.dtype
"""

ida_ua.OOF_ADDR
"""
output x.addr, otherwise x.value
"""

ida_ua.OOF_ANYSERIAL
"""
if enum: select first available serial
"""

ida_ua.OOF_NOBNOT
"""
prohibit use of binary not
"""

ida_ua.OOF_NUMBER
"""
always as a number
"""

ida_ua.OOF_OUTER
"""
output outer operand
"""

ida_ua.OOF_SIGNED
"""
output as signed if < 0
"""

ida_ua.OOF_SIGNMASK
"""
sign symbol (+/-) output
"""

ida_ua.OOF_SPACES
"""
currently works only for floating point numbers

do not suppress leading spaces
"""

ida_ua.OOF_WIDTHMASK
"""
width of value in bits
"""

ida_ua.OOF_ZSTROFF
"""
meaningful only if is_stroff(uFlag) append a struct field name if the
field offset is zero? if 'AFL_ZSTROFF' is set, then this flag is
ignored.
"""

ida_ua.PACK_FORM_DEF
"""
(! 'o_reg' + 'dt_packreal' )

packed factor defined.
"""

ida_ua.dt_bitfild
"""
bit field (mc680x0)
"""

ida_ua.dt_byte
"""
8 bit integer
"""

ida_ua.dt_byte16
"""
128 bit integer
"""

ida_ua.dt_byte32
"""
256 bit integer
"""

ida_ua.dt_byte64
"""
512 bit integer
"""

ida_ua.dt_code
"""
ptr to code (not used?)
"""

ida_ua.dt_double
"""
8 byte floating point
"""

ida_ua.dt_dword
"""
32 bit integer
"""

ida_ua.dt_float
"""
4 byte floating point
"""

ida_ua.dt_fword
"""
48 bit
"""

ida_ua.dt_half
"""
2-byte floating point
"""

ida_ua.dt_ldbl
"""
long double (which may be different from tbyte)
"""

ida_ua.dt_packreal
"""
packed real format for mc68040
"""

ida_ua.dt_qword
"""
64 bit integer
"""

ida_ua.dt_string
"""
pointer to asciiz string
"""

ida_ua.dt_tbyte
"""
variable size (\\ph{tbyte_size}) floating point
"""

ida_ua.dt_unicode
"""
pointer to unicode string
"""

ida_ua.dt_void
"""
none
"""

ida_ua.dt_word
"""
16 bit integer
"""
=== ida_ua EPYDOC INJECTIONS END ===
Help on function add_cref in module ida_xref:

add_cref(*args) -> 'bool'
    add_cref(frm, to, type) -> bool
    
    
    Create a code cross-reference.
    
    @param to: linear address of referenced instruction (C++: ea_t)
    @param type: cross-reference type (C++: cref_t)
    @return: success

Help on function add_dref in module ida_xref:

add_dref(*args) -> 'bool'
    add_dref(frm, to, type) -> bool
    
    
    Create a data cross-reference.
    
    @param to: linear address of referenced data (C++: ea_t)
    @param type: cross-reference type (C++: dref_t)
    @return: success (may fail if user-defined xref exists from->to)

Help on function calc_switch_cases in module ida_xref:

calc_switch_cases(*args) -> 'cases_and_targets_t *'
    calc_switch_cases(ea, si) -> cases_and_targets_t
    
    
    Get information about a switch's cases.
    
    The returned information can be used as follows:
    
        for idx in range(len(results.cases)):
            cur_case = results.cases[idx]
            for cidx in range(len(cur_case)):
                print("case: %d" % cur_case[cidx])
            print("  goto 0x%x" % results.targets[idx])
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: a structure with 2 members: 'cases', and 'targets'.

Help on class cases_and_targets_t in module ida_xref:

class cases_and_targets_t(builtins.object)
 |  Proxy of C++ cases_and_targets_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cases_and_targets_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cases_and_targets_t(...)
 |      delete_cases_and_targets_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cases
 |      cases_and_targets_t_cases_get(self) -> casevec_t
 |  
 |  targets
 |      cases_and_targets_t_targets_get(self) -> eavec_t *
 |  
 |  thisown
 |      The membership flag

Help on class casevec_t in module ida_xref:

class casevec_t(builtins.object)
 |  Proxy of C++ qvector< qvector< sval_t > > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |  
 |  __getitem__(self, *args) -> 'qvector< signed-ea-like-numeric-type > const &'↗
 |      __getitem__(self, i) -> qvector< signed-ea-like-numeric-type > const &↗
 |  
 |  __init__(self, *args)
 |      __init__(self) -> casevec_t
 |      __init__(self, x) -> casevec_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |  
 |  __swig_destroy__ = delete_casevec_t(...)
 |      delete_casevec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |  
 |  append = push_back(self, *args) -> 'qvector< signed-ea-like-numeric-type > &'↗
 |  
 |  at = __getitem__(self, *args) -> 'qvector< signed-ea-like-numeric-type > const &'↗
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< qvector< signed-ea-like-numeric-type > >::const_iterator'↗
 |      begin(self) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |      begin(self) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator↗
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< qvector< signed-ea-like-numeric-type > >::const_iterator'↗
 |      end(self) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |      end(self) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator↗
 |  
 |  erase(self, *args) -> 'qvector< qvector< signed-ea-like-numeric-type > >::iterator'↗
 |      erase(self, it) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |      erase(self, first, last) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |  
 |  extract(self, *args) -> 'qvector< signed-ea-like-numeric-type > *'↗
 |      extract(self) -> qvector< signed-ea-like-numeric-type > *↗
 |  
 |  find(self, *args) -> 'qvector< qvector< signed-ea-like-numeric-type > >::const_iterator'↗
 |      find(self, x) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |      find(self, x) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator↗
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=qvector< signed-ea-like-numeric-type >())↗
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |  
 |  insert(self, *args) -> 'qvector< qvector< signed-ea-like-numeric-type > >::iterator'↗
 |      insert(self, it, x) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'qvector< signed-ea-like-numeric-type > &'↗
 |      push_back(self, x)
 |      push_back(self) -> qvector< signed-ea-like-numeric-type > &↗
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      resize(self, _newsize)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function create_switch_table in module ida_xref:

create_switch_table(*args) -> 'bool'
    create_switch_table(ea, si) -> bool
    
    
    Create switch table from the switch information
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: Boolean

Help on function create_switch_xrefs in module ida_xref:

create_switch_xrefs(*args) -> 'bool'
    create_switch_xrefs(ea, si) -> bool
    
    
    This function creates xrefs from the indirect jump.
    
    Usually there is no need to call this function directly because the kernel
    will call it for switch tables
    
    Note: Custom switch information are not supported yet.
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: Boolean

Help on function del_cref in module ida_xref:

del_cref(*args) -> 'int'
    del_cref(frm, to, expand) -> int
    
    
    Delete a code cross-reference.
    
    @param to: linear address of referenced instruction (C++: ea_t)
    @param expand: policy to delete the referenced instruction   1: plan
                   to delete the referenced instruction if it has no more
                   references.   0: don't delete the referenced
                   instruction even if no more cross-references point to
                   it (C++: bool)

Help on function del_dref in module ida_xref:

del_dref(*args) -> 'void'
    del_dref(frm, to)
    
    
    Delete a data cross-reference.
    
    @param to: linear address of referenced data (C++: ea_t)

Help on function delete_switch_table in module ida_xref:

delete_switch_table(*args) -> 'void'
    delete_switch_table(jump_ea, si)

Help on function get_first_cref_from in module ida_xref:

get_first_cref_from(*args) -> 'ea_t'
    get_first_cref_from(frm) -> ea_t
    
    
    Get first instruction referenced from the specified instruction. If
    the specified instruction passes execution to the next instruction
    then the next instruction is returned. Otherwise the lowest referenced
    address is returned (remember that xrefs are kept sorted!).
    
    @return: first referenced address. The  lastXR  variable contains type
             of the reference. If the specified instruction doesn't
             reference to other instructions then returns  BADADDR .

Help on function get_first_cref_to in module ida_xref:

get_first_cref_to(*args) -> 'ea_t'
    get_first_cref_to(to) -> ea_t
    
    
    Get first instruction referencing to the specified instruction. If the
    specified instruction may be executed immediately after its previous
    instruction then the previous instruction is returned. Otherwise the
    lowest referencing address is returned. (remember that xrefs are kept
    sorted!).
    
    @param to: linear address of referenced instruction (C++: ea_t)
    @return: linear address of the first referencing instruction or
             BADADDR . The  lastXR  variable contains type of the
             reference.

Help on function get_first_dref_from in module ida_xref:

get_first_dref_from(*args) -> 'ea_t'
    get_first_dref_from(frm) -> ea_t
    
    
    Get first data referenced from the specified address.
    
    @return: linear address of first (lowest) data referenced from the
             specified address. The  lastXR  variable contains type of the
             reference. Return  BADADDR  if the specified instruction/data
             doesn't reference to anything.

Help on function get_first_dref_to in module ida_xref:

get_first_dref_to(*args) -> 'ea_t'
    get_first_dref_to(to) -> ea_t
    
    
    Get address of instruction/data referencing to the specified data.
    
    @param to: linear address of referencing instruction or data (C++:
               ea_t)
    @return: BADADDR  if nobody refers to the specified data. The  lastXR
             variable contains type of the reference.

Help on function get_first_fcref_from in module ida_xref:

get_first_fcref_from(*args) -> 'ea_t'
    get_first_fcref_from(frm) -> ea_t

Help on function get_first_fcref_to in module ida_xref:

get_first_fcref_to(*args) -> 'ea_t'
    get_first_fcref_to(to) -> ea_t

Help on function get_next_cref_from in module ida_xref:

get_next_cref_from(*args) -> 'ea_t'
    get_next_cref_from(frm, current) -> ea_t
    
    
    Get next instruction referenced from the specified instruction.
    
    @param current: linear address of current referenced instruction This
                    value is returned by  get_first_cref_from()  or
                    previous call to  get_next_cref_from()  functions.
                    (C++: ea_t)
    @return: next referenced address or  BADADDR . The  lastXR  variable
             contains type of the reference.

Help on function get_next_cref_to in module ida_xref:

get_next_cref_to(*args) -> 'ea_t'
    get_next_cref_to(to, current) -> ea_t
    
    
    Get next instruction referencing to the specified instruction.
    
    @param to: linear address of referenced instruction (C++: ea_t)
    @param current: linear address of current referenced instruction This
                    value is returned by  get_first_cref_to()  or previous
                    call to  get_next_cref_to()  functions. (C++: ea_t)
    @return: linear address of the next referencing instruction or
             BADADDR . The  lastXR  variable contains type of the
             reference.

Help on function get_next_dref_from in module ida_xref:

get_next_dref_from(*args) -> 'ea_t'
    get_next_dref_from(frm, current) -> ea_t
    
    
    Get next data referenced from the specified address.
    
    @param current: linear address of current referenced data. This value
                    is returned by  get_first_dref_from()  or previous
                    call to  get_next_dref_from()  functions. (C++: ea_t)
    @return: linear address of next data or  BADADDR . The  lastXR
             variable contains type of the reference

Help on function get_next_dref_to in module ida_xref:

get_next_dref_to(*args) -> 'ea_t'
    get_next_dref_to(to, current) -> ea_t
    
    
    Get address of instruction/data referencing to the specified data
    
    @param to: linear address of referencing instruction or data (C++:
               ea_t)
    @param current: current linear address. This value is returned by
                    get_first_dref_to()  or previous call to
                    get_next_dref_to()  functions. (C++: ea_t)
    @return: BADADDR  if nobody refers to the specified data. The  lastXR
             variable contains type of the reference.

Help on function get_next_fcref_from in module ida_xref:

get_next_fcref_from(*args) -> 'ea_t'
    get_next_fcref_from(frm, current) -> ea_t

Help on function get_next_fcref_to in module ida_xref:

get_next_fcref_to(*args) -> 'ea_t'
    get_next_fcref_to(to, current) -> ea_t

Help on function has_external_refs in module ida_xref:

has_external_refs(*args) -> 'bool'
    has_external_refs(pfn, ea) -> bool
    
    
    Has a location external to the function references?
    
    
    @param pfn (C++: func_t  *)
    @param ea (C++: ea_t)

Help on class xrefblk_t in module ida_xref:

class xrefblk_t(builtins.object)
 |  Proxy of C++ xrefblk_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> xrefblk_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_xrefblk_t(...)
 |      delete_xrefblk_t(self)
 |  
 |  first_from(self, *args) -> 'bool'
 |      first_from(self, _from, flags) -> bool
 |  
 |  first_to(self, *args) -> 'bool'
 |      first_to(self, _to, flags) -> bool
 |  
 |  next_from(self, *args) -> 'bool'
 |      next_from(self) -> bool
 |      next_from(self, _from, _to, flags) -> bool
 |  
 |  next_to(self, *args) -> 'bool'
 |      next_to(self) -> bool
 |      next_to(self, _from, _to, flags) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  frm
 |      xrefblk_t_frm_get(self) -> ea_t
 |  
 |  iscode
 |      xrefblk_t_iscode_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  to
 |      xrefblk_t_to_get(self) -> ea_t
 |  
 |  type
 |      xrefblk_t_type_get(self) -> uchar
 |  
 |  user
 |      xrefblk_t_user_get(self) -> uchar

Help on function xrefchar in module ida_xref:

xrefchar(*args) -> 'char'
    xrefchar(xrtype) -> char
    
    
    Get character describing the xref type.
    
    @param xrtype: combination of  Cross-Reference type flags  and a
                   cref_t  of  dref_t  value (C++: char)

=== ida_xref EPYDOC INJECTIONS ===
ida_xref.XREF_ALL
"""
return all references
"""

ida_xref.XREF_BASE
"""
Reference to the base part of an offset.
"""

ida_xref.XREF_DATA
"""
return data references only
"""

ida_xref.XREF_FAR
"""
don't return ordinary flow xrefs
"""

ida_xref.XREF_MASK
"""
Mask to get xref type.
"""

ida_xref.XREF_PASTEND
"""
Reference is past item. This bit may be passed to 'add_dref()'
functions but it won't be saved in the database. It will prevent the
destruction of eventual alignment directives.
"""

ida_xref.XREF_TAIL
"""
Reference to tail byte in extrn symbols.
"""

ida_xref.XREF_USER
"""
User specified xref. This xref will not be deleted by IDA. This bit
should be combined with the existing xref types ( 'cref_t' & 'dref_t'
) Cannot be used for fl_F xrefs
"""
=== ida_xref EPYDOC INJECTIONS END ===
Help on function AddSeg in module idc:

AddSeg(startea, endea, base, use32, align, comb)

Help on function AutoMark in module idc:

AutoMark(ea, qtype)
    Plan to analyze an address

Help on class DeprecatedIDCError in module idc:

class DeprecatedIDCError(builtins.Exception)
 |  Exception for deprecated function calls
 |  
 |  Method resolution order:
 |      DeprecatedIDCError
 |      builtins.Exception
 |      builtins.BaseException
 |      builtins.object
 |  
 |  Data descriptors defined here:
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.Exception:
 |  
 |  __init__(self, /, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __new__(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.BaseException:
 |  
 |  __delattr__(self, name, /)
 |      Implement delattr(self, name).
 |  
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |  
 |  __reduce__(...)
 |      helper for pickle
 |  
 |  __repr__(self, /)
 |      Return repr(self).
 |  
 |  __setattr__(self, name, value, /)
 |      Implement setattr(self, name, value).
 |  
 |  __setstate__(...)
 |  
 |  __str__(self, /)
 |      Return str(self).
 |  
 |  with_traceback(...)
 |      Exception.with_traceback(tb) --
 |      set self.__traceback__ to tb and return self.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from builtins.BaseException:
 |  
 |  __cause__
 |      exception cause
 |  
 |  __context__
 |      exception context
 |  
 |  __dict__
 |  
 |  __suppress_context__
 |  
 |  __traceback__
 |  
 |  args

Help on function EVAL_FAILURE in module idc:

EVAL_FAILURE(code)
    Check the result of eval_idc() for evaluation failures
    
    @param code: result of eval_idc()
    
    @return: True if there was an evaluation error

Help on function get_cmt in module ida_bytes:

get_cmt(*args) -> 'qstring *'
    get_cmt(ea, rptble) -> str
    
    
    Get an indented comment.
    
    @param ea: linear address. may point to tail byte, the function will
               find start of the item (C++: ea_t)
    @param rptble: get repeatable comment? (C++: bool)
    @return: size of comment or -1

Help on function GetDisasm in module idc:

GetDisasm(ea)
    Get disassembly line
    
    @param ea: linear address of instruction
    
    @return: "" - could not decode instruction at the specified location
    
    @note: this function may not return exactly the same mnemonics
           as you see on the screen.

Help on function GetDouble in module idc:

GetDouble(ea)
    Get value of a floating point number (8 bytes)
    This function assumes number stored using IEEE format
    and in the same endianness as integers.
    
    @param ea: linear address
    
    @return: double

Help on function GetFloat in module idc:

GetFloat(ea)
    Get value of a floating point number (4 bytes)
    This function assumes number stored using IEEE format
    and in the same endianness as integers.
    
    @param ea: linear address
    
    @return: float

Help on function GetLocalType in module idc:

GetLocalType(ordinal, flags)
    Retrieve a local type declaration
    @param flags: any of PRTYPE_* constants
    @return: local type as a C declaration or ""

Help on function LoadFile in module idc:

LoadFile(filepath, pos, ea, size)
    Load file into IDA database
    
    @param filepath: path to input file
    @param pos: position in the file
    @param ea: linear address to load
    @param size: number of bytes to load
    
    @return: 0 - error, 1 - ok

Help on function MakeVar in module idc:

MakeVar(ea)
    Mark the location as "variable"
    
    @param ea: address to mark
    
    @return: None
    
    @note: All that IDA does is to mark the location as "variable".
    Nothing else, no additional analysis is performed.
    This function may disappear in the future.

Help on function SaveFile in module idc:

SaveFile(filepath, pos, ea, size)
    Save from IDA database to file
    
    @param filepath: path to output file
    @param pos: position in the file
    @param ea: linear address to save from
    @param size: number of bytes to save
    
    @return: 0 - error, 1 - ok

Help on function SetPrcsr in module idc:

SetPrcsr(processor)

Help on function SetType in module idc:

SetType(ea, newtype)
    Set type of function/variable
    
    @param ea: the address of the object
    @param newtype: the type string in C declaration form.
                Must contain the closing ';'
                if specified as an empty string, then the
                item associated with 'ea' will be deleted.
    
    @return: 1-ok, 0-failed.

Help on function SizeOf in module idc:

SizeOf(typestr)
    Returns the size of the type. It is equivalent to IDC's sizeof().
    Use name, tp, fld = idc.parse_decl() ; SizeOf(tp) to retrieve the size
    @return: -1 if typestring is not valid otherwise the size of the type

Help on function _IDC_GetAttr in module idc:

_IDC_GetAttr(obj, attrmap, attroffs)
    Internal function to generically get object attributes
    Do not use unless you know what you are doing

Help on function _IDC_SetAttr in module idc:

_IDC_SetAttr(obj, attrmap, attroffs, value)
    Internal function to generically set object attributes
    Do not use unless you know what you are doing

Help on function __DbgValue in module idc:

__DbgValue(ea, len)

Help on function __GetArrayById in module idc:

__GetArrayById(array_id)
    Get an array, by its ID.
    
    This (internal) wrapper around 'idaaip.netnode(array_id)'
    will ensure a certain safety around the retrieval of
    arrays (by catching quite unexpect[ed|able] exceptions,
    and making sure we don't create & use `transient' netnodes).
    
    @param array_id: A positive, valid array ID.

Help on class __dummy_netnode in module idc:

class __dummy_netnode(builtins.object)
 |  Implements, in an "always failing" fashion, the
 |  netnode functions that are necessary for the
 |  array-related functions.
 |  
 |  The sole purpose of this singleton class is to
 |  serve as a placeholder for netnode-manipulating
 |  functions, that don't want to each have to perform
 |  checks on the existence of the netnode.
 |  (..in other words: it avoids a bunch of if/else's).
 |  
 |  See __GetArrayById() for more info.
 |  
 |  Methods defined here:
 |  
 |  altdel(self, *args)
 |  
 |  altfirst(self, *args)
 |  
 |  altlast(self, *args)
 |  
 |  altnext(self, *args)
 |  
 |  altprev(self, *args)
 |  
 |  altset(self, *args)
 |  
 |  altval(self, *args)
 |  
 |  hashdel(self, *args)
 |  
 |  hashfirst(self, *args)
 |  
 |  hashlast(self, *args)
 |  
 |  hashnext(self, *args)
 |  
 |  hashprev(self, *args)
 |  
 |  hashset(self, *args)
 |  
 |  hashset_buf(self, *args)
 |  
 |  hashset_idx(self, *args)
 |  
 |  hashstr(self, *args)
 |  
 |  hashstr_buf(self, *args)
 |  
 |  hashval(self, *args)
 |  
 |  hashval_long(self, *args)
 |  
 |  index(self, *args)
 |  
 |  kill(self, *args)
 |  
 |  rename(self, *args)
 |  
 |  supdel(self, *args)
 |  
 |  supfirst(self, *args)
 |  
 |  suplast(self, *args)
 |  
 |  supnext(self, *args)
 |  
 |  supprev(self, *args)
 |  
 |  supset(self, *args)
 |  
 |  supval(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  instance = <idc.__dummy_netnode object>

Help on function __l2m1 in module idc:

__l2m1(v)
    Long to minus 1: If the 'v' appears to be the
    'signed long' version of -1, then return -1.
    Otherwise, return 'v'.

Help on function __warn_once_deprecated_proto_confusion in module idc:

__warn_once_deprecated_proto_confusion(what, alternative)

Help on function _get_modules in module idc:

_get_modules()
    INTERNAL: Enumerate process modules

Help on function add_auto_stkpnt in module idc:

add_auto_stkpnt(func_ea, ea, delta)
    Add automatical SP register change point
    @param func_ea: function start
    @param ea: linear address where SP changes
               usually this is the end of the instruction which
               modifies the stack pointer (insn.ea+insn.size)
    @param delta: difference between old and new values of SP
    @return: 1-ok, 0-failed

Help on function add_bpt in module ida_dbg:

add_bpt(*args) -> 'bool'
    add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
    add_bpt(bpt) -> bool
    
    
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous
    function)}Only one breakpoint can exist at a given address.
    
    @param ea: any address in the process memory space. Depending on the
               architecture, hardware breakpoints always be setup at
               random address. For example, on x86, hardware breakpoints
               should be aligned depending on their size. Moreover, on the
               x86 architecture, it is impossible to setup more than 4
               hardware breakpoints. (C++: ea_t)
    @param size: size of the breakpoint (irrelevant for software
                 breakpoints): As for the address, hardware breakpoints
                 can't always be setup with random size. (C++: asize_t)
    @param type: type of the breakpoint ( BPT_SOFT  for software
                 breakpoint) special case  BPT_DEFAULT  ( BPT_SOFT |
                 BPT_EXEC ): try to add instruction breakpoint of the
                 appropriate type as follows: software bpt if supported,
                 hwbpt otherwise (C++: bpttype_t)

Help on function add_cref in module ida_xref:

add_cref(*args) -> 'bool'
    add_cref(frm, to, type) -> bool
    
    
    Create a code cross-reference.
    
    @param to: linear address of referenced instruction (C++: ea_t)
    @param type: cross-reference type (C++: cref_t)
    @return: success

Help on function add_default_til in module idc:

add_default_til(name)
    Load a type library
    
    @param name: name of type library.
    @return: 1-ok, 0-failed.

Help on function add_dref in module ida_xref:

add_dref(*args) -> 'bool'
    add_dref(frm, to, type) -> bool
    
    
    Create a data cross-reference.
    
    @param to: linear address of referenced data (C++: ea_t)
    @param type: cross-reference type (C++: dref_t)
    @return: success (may fail if user-defined xref exists from->to)

Help on function add_entry in module ida_entry:

add_entry(*args) -> 'bool'
    add_entry(ord, ea, name, makecode, flags=0) -> bool
    
    
    Add an entry point to the list of entry points.
    
    @param ord: ordinal number if ordinal number is equal to 'ea' then
                ordinal is not used (C++: uval_t)
    @param ea: linear address (C++: ea_t)
    @param name: name of entry point. If the specified location already
                 has a name, the old name will be appended to the regular
                 comment. If name == NULL, then the old name will be
                 retained. (C++: const char *)
    @param makecode: should the kernel convert bytes at the entry point to
                     instruction(s) (C++: bool)
    @param flags: See AEF_* (C++: int)
    @return: success (currently always true)

Help on function add_enum in module idc:

add_enum(idx, name, flag)
    Add a new enum type
    
    @param idx: serial number of the new enum.
            If another enum with the same serial number
            exists, then all enums with serial
            numbers >= the specified idx get their
            serial numbers incremented (in other words,
            the new enum is put in the middle of the list of enums).
    
            If idx >= get_enum_qty() or idx == idaapi.BADNODE
            then the new enum is created at the end of
            the list of enums.
    
    @param name: name of the enum.
    @param flag: flags for representation of numeric constants
                 in the definition of enum.
    
    @return: id of new enum or BADADDR

Help on function add_enum_member in module idc:

add_enum_member(enum_id, name, value, bmask)
    Add a member of enum - a symbolic constant
    
    @param enum_id: id of enum
    @param name: name of symbolic constant. Must be unique in the program.
    @param value: value of symbolic constant.
    @param bmask: bitmask of the constant
        ordinary enums accept only ida_enum.DEFMASK as a bitmask
        all bits set in value should be set in bmask too
    
    @return: 0-ok, otherwise error code (one of ENUM_MEMBER_ERROR_*)

Help on function add_func in module ida_funcs:

add_func(*args) -> 'bool'
    add_func(ea1, ea2=BADADDR) -> bool
    
    
    Add a new function. If the function end address is 'BADADDR' , then
    IDA will try to determine the function bounds by calling
    find_func_bounds(..., 'FIND_FUNC_DEFINE' ).
    
    @param ea1: start address (C++: ea_t)
    @param ea2: end address (C++: ea_t)
    @return: success

Help on function add_hidden_range in module ida_bytes:

add_hidden_range(*args) -> 'bool'
    add_hidden_range(ea1, ea2, description, header, footer, color) -> bool
    
    
    Mark a range of addresses as hidden. The range will be created in the
    invisible state with the default color
    
    @param ea1: linear address of start of the address range (C++: ea_t)
    @param ea2: linear address of end of the address range (C++: ea_t)
    @param description: range parameters (C++: const char *)
    @param header: range parameters (C++: const char *)
    @param footer: range parameters (C++: const char *)
    @param color (C++: bgcolor_t)
    @return: success

Help on function add_idc_hotkey in module ida_kernwin:

add_idc_hotkey(*args) -> 'int'
    add_idc_hotkey(hotkey, idcfunc) -> int
    
    
    Add hotkey for IDC function ( 'ui_add_idckey' ).
    
    @param hotkey: hotkey name (C++: const char *)
    @param idcfunc: IDC function name (C++: const char *)
    @return: IDC hotkey error codes

Help on function add_segm_ex in module idc:

add_segm_ex(startea, endea, base, use32, align, comb, flags)
    Create a new segment
    
    @param startea: linear address of the start of the segment
    @param endea: linear address of the end of the segment
               this address will not belong to the segment
               'endea' should be higher than 'startea'
    @param base: base paragraph or selector of the segment.
               a paragraph is 16byte memory chunk.
               If a selector value is specified, the selector should be
               already defined.
    @param use32: 0: 16bit segment, 1: 32bit segment, 2: 64bit segment
    @param align: segment alignment. see below for alignment values
    @param comb: segment combination. see below for combination values.
    @param flags: combination of ADDSEG_... bits
    
    @return: 0-failed, 1-ok

Help on function add_sourcefile in module ida_lines:

add_sourcefile(*args) -> 'bool'
    add_sourcefile(ea1, ea2, filename) -> bool
    
    
    Mark a range of address as belonging to a source file. An address
    range may belong only to one source file. A source file may be
    represented by several address ranges.
    
    @param ea1: linear address of start of the address range (C++: ea_t)
    @param ea2: linear address of end of the address range (excluded)
                (C++: ea_t)
    @param filename: name of source file. (C++: const char *)
    @return: success

Help on function add_struc in module idc:

add_struc(index, name, is_union)
    Define a new structure type
    
    @param index: index of new structure type
                  If another structure has the specified index,
                  then index of that structure and all other
                  structures will be incremented, freeing the specifed
                  index. If index is == -1, then the biggest index
                  number will be used.
                  See get_first_struc_idx() for the explanation of
                  structure indices and IDs.
    @param name: name of the new structure type.
    @param is_union: 0: structure
                     1: union
    
    @return: -1 if can't define structure type because of
             bad structure name: the name is ill-formed or is
             already used in the program.
             otherwise returns ID of the new structure type

Help on function add_struc_member in module idc:

add_struc_member(sid, name, offset, flag, typeid, nbytes, target=-1, tdelta=0, reftype=2)
    Add structure member
    
    @param sid: structure type ID
    @param name: name of the new member
    @param offset: offset of the new member
                   -1 means to add at the end of the structure
    @param flag: type of the new member. Should be one of
                 FF_BYTE..FF_PACKREAL (see above) combined with FF_DATA
    @param typeid: if is_struct(flag) then typeid specifies the structure id for the member
                   if is_off0(flag) then typeid specifies the offset base.
                   if is_strlit(flag) then typeid specifies the string type (STRTYPE_...).
                   if is_stroff(flag) then typeid specifies the structure id
                   if is_enum(flag) then typeid specifies the enum id
                   if is_custom(flags) then typeid specifies the dtid and fid: dtid|(fid<<16)
                   Otherwise typeid should be -1.
    @param nbytes: number of bytes in the new member
    
    @param target: target address of the offset expr. You may specify it as
                   -1, ida will calculate it itself
    @param tdelta: offset target delta. usually 0
    @param reftype: see REF_... definitions
    
    @note: The remaining arguments are allowed only if is_off0(flag) and you want
           to specify a complex offset expression
    
    @return: 0 - ok, otherwise error code (one of STRUC_ERROR_*)

Help on function add_user_stkpnt in module ida_frame:

add_user_stkpnt(*args) -> 'bool'
    add_user_stkpnt(ea, delta) -> bool
    
    
    Add user-defined SP register change point.
    
    @param ea: linear address where SP changes (C++: ea_t)
    @param delta: difference between old and new values of SP (C++:
                  sval_t)
    @return: success

Help on function append_func_tail in module idc:

append_func_tail(funcea, ea1, ea2)
    Append a function chunk to the function
    
    @param funcea: any address in the function
    @param ea1: start of function tail
    @param ea2: end of function tail
    @return: 0 if failed, 1 if success
    
    @note: If a chunk exists at the specified addresses, it must have exactly
           the specified boundaries

Help on function apply_type in module idc:

apply_type(ea, py_type, flags=1)
    Apply the specified type to the address
    
    @param ea: the address of the object
    @param py_type: typeinfo tuple (type, fields) as get_tinfo() returns
                 or tuple (name, type, fields) as parse_decl() returns
                 or None
                if specified as None, then the
                item associated with 'ea' will be deleted.
    @param flags: combination of TINFO_... constants or 0
    @return: Boolean

Help on function ask_seg in module ida_kernwin:

ask_seg(defval, format)
    # ----------------------------------------------------------------------

Help on function ask_yn in module ida_kernwin:

ask_yn(*args) -> 'int'
    ask_yn(deflt, format) -> int
    
    
    Display a dialog box and get choice from "Yes", "No", "Cancel".
    
    @param deflt: default choice: one of  Button IDs (C++: int)
    @param format: The question in printf() style format (C++: const char
                   *)
    @return: the selected button (one of  Button IDs ). Esc key returns
             ASKBTN_CANCEL .

Help on function atoa in module idc:

atoa(ea)
    Convert address value to a string
    Return address in the form 'seg000:1234'
    (the same as in line prefixes)
    
    @param ea: address to format

Help on function atol in module idc:

atol(s)

Help on function attach_process in module ida_dbg:

attach_process(*args) -> 'int'
    attach_process(pid=pid_t(-1), event_id=-1) -> int
    
    
    Attach the debugger to a running process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_attach'
    }This function shouldn't be called as a request if 'NO_PROCESS' is
    used.
    
    @param pid: PID of the process to attach to. If  NO_PROCESS , a dialog
                box will interactively ask the user for the process to
                attach to. (C++: pid_t)
    @param event_id (C++: int)

Help on function auto_mark_range in module ida_auto:

auto_mark_range(*args) -> 'void'
    auto_mark_range(start, end, type)
    
    
    Put range of addresses into a queue. 'start' may be higher than 'end',
    the kernel will swap them in this case. 'end' doesn't belong to the
    range.
    
    @param start (C++: ea_t)
    @param end (C++: ea_t)
    @param type (C++: atype_t)

Help on function auto_unmark in module ida_auto:

auto_unmark(*args) -> 'void'
    auto_unmark(start, end, type)
    
    
    Remove range of addresses from a queue. 'start' may be higher than
    'end', the kernel will swap them in this case. 'end' doesn't belong to
    the range.
    
    @param start (C++: ea_t)
    @param end (C++: ea_t)
    @param type (C++: atype_t)

Help on function auto_wait in module ida_auto:

auto_wait(*args) -> 'bool'
    auto_wait() -> bool
    
    
    Process everything in the queues and return true.
    
    @return: false if the user clicked cancel. (the wait box must be
             displayed by the caller if desired)

Help on function batch in module idc:

batch(batch)
    Enable/disable batch mode of operation
    
    @param batch: batch mode
            0 - ida will display dialog boxes and wait for the user input
            1 - ida will not display dialog boxes, warnings, etc.
    
    @return: old balue of batch flag

Help on function byte_value in module idc:

byte_value(F)
    Get byte value from flags
    Get value of byte provided that the byte is initialized.
    This macro works ok only for 8-bit byte machines.

Help on function calc_gtn_flags in module ida_name:

calc_gtn_flags(fromaddr, ea)
    Calculate flags for get_ea_name() function
    
    @param fromaddr: the referring address. May be BADADDR.
    @param ea: linear address
    
    @return: flags

Help on function call_system in module idc:

call_system(command)
    Execute an OS command.
    
    @param command: command line to execute
    
    @return: error code from OS
    
    @note:
    IDA will wait for the started program to finish.
    In order to start the command in parallel, use OS methods.
    For example, you may start another program in parallel using
    "start" command.

Help on function can_exc_continue in module idc:

can_exc_continue()
    Can it continue after EXCEPTION event?
    
    @return: boolean

Help on function check_bpt in module ida_dbg:

check_bpt(*args) -> 'int'
    check_bpt(ea) -> int
    
    
    Check the breakpoint at the specified address.
    
    @param ea (C++: ea_t)
    @return: one of  Breakpoint status codes

Help on function choose_func in module idc:

choose_func(title)
    Ask the user to select a function
    
    Arguments:
    
    @param title: title of the dialog box
    
    @return: -1 - user refused to select a function
             otherwise returns the selected function start address

Help on function clear_trace in module idc:

clear_trace(filename)
    Clear the current trace buffer

Help on function create_align in module ida_bytes:

create_align(*args) -> 'bool'
    create_align(ea, length, alignment) -> bool
    
    
    Alignment: 0 or 2..32. If it is 0, is will be calculated.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param alignment (C++: int)

Help on function create_array in module idc:

create_array(name)
    Create array.
    
    @param name: The array name.
    
    @return: -1 in case of failure, a valid array_id otherwise.

Help on function create_byte in module idc:

create_byte(ea)
    Convert the current item to a byte
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_custdata in module ida_bytes:

create_custdata(*args) -> 'bool'
    create_custdata(ea, length, dtid, fid, force=False) -> bool
    
    
    Convert to custom data type.
    
    
    @param ea (C++: ea_t)
    @param length (C++: asize_t)
    @param dtid (C++: int)
    @param fid (C++: int)
    @param force (C++: bool)

Help on function create_data in module ida_bytes:

create_data(*args) -> 'bool'
    create_data(ea, dataflag, size, tid) -> bool
    
    
    Convert to data (byte, word, dword, etc). This function may be used to
    create arrays.
    
    @param ea: linear address (C++: ea_t)
    @param dataflag: type of data. Value of function  byte_flag() ,
                     word_flag() , etc. (C++: flags_t)
    @param size: size of array in bytes. should be divisible by the size
                 of one item of the specified type. for variable sized
                 items it can be specified as 0, and the kernel will try
                 to calculate the size. (C++: asize_t)
    @param tid: type id. If the specified type is a structure, then tid is
                structure id. Otherwise should be  BADNODE . (C++: tid_t)
    @return: success

Help on function create_double in module idc:

create_double(ea)
    Convert the current item to a double floating point (8 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_dword in module idc:

create_dword(ea)
    Convert the current item to a double word (4 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_float in module idc:

create_float(ea)
    Convert the current item to a floating point (4 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_insn in module ida_ua:

create_insn(*args) -> 'int'
    create_insn(ea, out=None) -> int
    
    
    Create an instruction at the specified address. This function checks
    if an instruction is present at the specified address and will try to
    create one if there is none. It will fail if there is a data item or
    other items hindering the creation of the new instruction. This
    function will also fill the 'out' structure.
    
    @param ea: linear address (C++: ea_t)
    @param out: the resulting instruction (C++: insn_t  *)
    @return: the length of the instruction or 0

Help on function create_oword in module idc:

create_oword(ea)
    Convert the current item to an octa word (16 bytes/128 bits)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_pack_real in module idc:

create_pack_real(ea)
    Convert the current item to a packed real (10 or 12 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_qword in module idc:

create_qword(ea)
    Convert the current item to a quadro word (8 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_strlit in module idc:

create_strlit(ea, endea)
    Create a string.
    
    This function creates a string (the string type is determined by the
    value of get_inf_attr(INF_STRTYPE))
    
    @param ea: linear address
    @param endea: ending address of the string (excluded)
        if endea == BADADDR, then length of string will be calculated
        by the kernel
    
    @return: 1-ok, 0-failure
    
    @note: The type of an existing string is returned by get_str_type()

Help on function create_struct in module idc:

create_struct(ea, size, strname)
    Convert the current item to a structure instance
    
    @param ea: linear address
    @param size: structure size in bytes. -1 means that the size
        will be calculated automatically
    @param strname: name of a structure type
    
    @return: 1-ok, 0-failure

Help on function create_tbyte in module idc:

create_tbyte(ea)
    Convert the current item to a tbyte (10 or 12 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_word in module idc:

create_word(ea)
    Convert the current item to a word (2 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_yword in module idc:

create_yword(ea)
    Convert the current item to a ymm word (32 bytes/256 bits)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function define_exception in module ida_dbg:

define_exception(*args) -> 'char const *'
    define_exception(code, name, desc, flags) -> char const *
    
    
    Convenience function: define new exception code.
    
    @param code: exception code (cannot be 0) (C++: uint)
    @param name: exception name (cannot be empty or NULL) (C++: const char
                 *)
    @param desc: exception description (maybe NULL) (C++: const char *)
    @param flags: combination of  Exception info flags (C++: int)
    @return: failure message or NULL. You must call  store_exceptions()
             if this function succeeds

Help on function define_local_var in module idc:

define_local_var(start, end, location, name)
    Create a local variable
    
    @param start: start of address range for the local variable
    @param end: end of address range for the local variable
    @param location: the variable location in the "[bp+xx]" form where xx is
                     a number. The location can also be specified as a
                     register name.
    @param name: name of the local variable
    
    @return: 1-ok, 0-failure
    
    @note: For the stack variables the end address is ignored.
           If there is no function at 'start' then this function.
           will fail.

Help on function del_array_element in module idc:

del_array_element(tag, array_id, idx)
    Delete an array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of an element.
    
    @return: 1 in case of success, 0 otherwise.

Help on function del_bpt in module ida_dbg:

del_bpt(*args) -> 'bool'
    del_bpt(ea) -> bool
    del_bpt(bptloc) -> bool
    
    
    Delete an existing breakpoint in the debugged process. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    @param ea: any address in the breakpoint range (C++: ea_t)

Help on function del_cref in module ida_xref:

del_cref(*args) -> 'int'
    del_cref(frm, to, expand) -> int
    
    
    Delete a code cross-reference.
    
    @param to: linear address of referenced instruction (C++: ea_t)
    @param expand: policy to delete the referenced instruction   1: plan
                   to delete the referenced instruction if it has no more
                   references.   0: don't delete the referenced
                   instruction even if no more cross-references point to
                   it (C++: bool)

Help on function del_dref in module ida_xref:

del_dref(*args) -> 'void'
    del_dref(frm, to)
    
    
    Delete a data cross-reference.
    
    @param to: linear address of referenced data (C++: ea_t)

Help on function del_enum in module ida_enum:

del_enum(*args) -> 'void'
    del_enum(id)
    
    
    Delete an enum type.
    
    
    @param id (C++: enum_t)

Help on function del_enum_member in module idc:

del_enum_member(enum_id, value, serial, bmask)
    Delete a member of enum - a symbolic constant
    
    @param enum_id: id of enum
    @param value: value of symbolic constant.
    @param serial: serial number of the constant in the
        enumeration. See op_enum() for for details.
    @param bmask: bitmask of the constant ordinary enums accept
        only ida_enum.DEFMASK as a bitmask
    
    @return: 1-ok, 0-failed

Help on function del_extra_cmt in module ida_lines:

del_extra_cmt(*args) -> 'void'
    del_extra_cmt(ea, what)

Help on function del_fixup in module ida_fixup:

del_fixup(*args) -> 'void'
    del_fixup(source)
    
    
    Delete fixup information.
    
    
    @param source (C++: ea_t)

Help on function del_func in module ida_funcs:

del_func(*args) -> 'bool'
    del_func(ea) -> bool
    
    
    Delete a function.
    
    @param ea: any address in the function entry chunk (C++: ea_t)
    @return: success

Help on function del_hash_string in module idc:

del_hash_string(hash_id, key)
    Delete a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element
    
    @return: 1 upon success, 0 otherwise.

Help on function del_hidden_range in module ida_bytes:

del_hidden_range(*args) -> 'bool'
    del_hidden_range(ea) -> bool
    
    
    Delete hidden range.
    
    @param ea: any address in the hidden range (C++: ea_t)
    @return: success

Help on function del_idc_hotkey in module ida_kernwin:

del_idc_hotkey(*args) -> 'bool'
    del_idc_hotkey(hotkey) -> bool
    
    
    Delete IDC function hotkey ( 'ui_del_idckey' ).
    
    @param hotkey: hotkey name (C++: const char *)

Help on function del_items in module ida_bytes:

del_items(*args) -> 'bool'
    del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool
    
    
    Convert item (instruction/data) to unexplored bytes. The whole item
    (including the head and tail bytes) will be destroyed. It is allowed
    to pass any address in the item to this function
    
    @param ea: any address within the first item to delete (C++: ea_t)
    @param flags: combination of  Unexplored byte conversion flags (C++:
                  int)
    @param nbytes: number of bytes in the range to be undefined (C++:
                   asize_t)
    @param may_destroy: optional routine invoked before deleting a head
                        item. If callback returns false then item has not
                        to be deleted and operation fails (C++:
                        may_destroy_cb_t  *)
    @return: true on sucessful operation, otherwise false

Help on function del_segm in module ida_segment:

del_segm(*args) -> 'bool'
    del_segm(ea, flags) -> bool
    
    
    Delete a segment.
    
    @param ea: any address belonging to the segment (C++: ea_t)
    @param flags: Segment modification flags (C++: int)

Help on function del_selector in module ida_segment:

del_selector(*args) -> 'void'
    del_selector(selector)
    
    
    Delete mapping of a selector. Be wary of deleting selectors that are
    being used in the program, this can make a mess in the segments.
    
    @param selector: number of selector to remove from the translation
                     table (C++: sel_t)

Help on function del_source_linnum in module ida_nalt:

del_source_linnum(*args) -> 'void'
    del_source_linnum(ea)

Help on function del_sourcefile in module ida_lines:

del_sourcefile(*args) -> 'bool'
    del_sourcefile(ea) -> bool
    
    
    Delete information about the source file.
    
    @param ea: linear address (C++: ea_t)
    @return: success

Help on function del_stkpnt in module idc:

del_stkpnt(func_ea, ea)
    Delete SP register change point
    
    @param func_ea: function start
    @param ea: linear address
    @return: 1-ok, 0-failed

Help on function del_struc in module idc:

del_struc(sid)
    Delete a structure type
    
    @param sid: structure type ID
    
    @return: 0 if bad structure type ID is passed
             1 otherwise the structure type is deleted. All data
             and other structure types referencing to the
             deleted structure type will be displayed as array
             of bytes.

Help on function del_struc_member in module idc:

del_struc_member(sid, member_offset)
    Delete structure member
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    
    @return: != 0 - ok.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.

Help on function delete_all_segments in module idc:

delete_all_segments()
    Delete all segments, instructions, comments, i.e. everything
    except values of bytes.

Help on function delete_array in module idc:

delete_array(array_id)
    Delete array, by its ID.
    
    @param array_id: The ID of the array to delete.

Help on function demangle_name in module idc:

demangle_name(name, disable_mask)
    demangle_name a name
    
    @param name: name to demangle
    @param disable_mask: a mask that tells how to demangle the name
            it is a good idea to get this mask using
            get_inf_attr(INF_SHORT_DN) or get_inf_attr(INF_LONG_DN)
    
    @return: a demangled name
        If the input name cannot be demangled, returns None

Help on function detach_process in module ida_dbg:

detach_process(*args) -> 'bool'
    detach_process() -> bool
    
    
    Detach the debugger from the debugged process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_detach' }

Help on function diff_trace_file in module ida_dbg:

diff_trace_file(*args) -> 'bool'
    diff_trace_file(nonnul_filename) -> bool
    
    
    Show difference between the current trace and the one from 'filename'.

Help on function enable_bpt in module ida_dbg:

enable_bpt(*args) -> 'bool'
    enable_bpt(ea, enable=True) -> bool
    enable_bpt(bptloc, enable=True) -> bool

Help on function enable_tracing in module idc:

enable_tracing(trace_level, enable)
    Enable step tracing
    
    @param trace_level:  what kind of trace to modify
    @param enable: 0: turn off, 1: turn on
    
    @return: success

Help on function error in module ida_kernwin:

error(*args) -> 'void'
    error(format)
    
    
    Display a fatal message in a message box and quit IDA
    
    @param format: message to print

Help on function eval_idc in module idc:

eval_idc(expr)
    Evaluate an IDC expression
    
    @param expr: an expression
    
    @return: the expression value. If there are problems, the returned value will be "IDC_FAILURE: xxx"
             where xxx is the error description
    
    @note: Python implementation evaluates IDC only, while IDC can call other registered languages

Help on function exit_process in module ida_dbg:

exit_process(*args) -> 'bool'
    exit_process() -> bool
    
    
    Terminate the debugging of the current process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_exit' }

Help on function expand_struc in module idc:

expand_struc(sid, offset, delta, recalc)
    Expand or shrink a structure type
    @param id: structure type ID
    @param offset: offset in the structure
    @param delta: how many bytes to add or remove
    @param recalc: recalculate the locations where the structure
                               type is used
    @return: != 0 - ok

Help on function fclose in module idc:

fclose(handle)

Help on function fgetc in module idc:

fgetc(handle)

Help on function filelength in module idc:

filelength(handle)

Help on function find_binary in module idc:

find_binary(ea, flag, searchstr, radix=16, from_bc695=False)

Help on function find_code in module ida_search:

find_code(*args) -> 'ea_t'
    find_code(ea, sflag) -> ea_t
    
    
    Find next code address.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_data in module ida_search:

find_data(*args) -> 'ea_t'
    find_data(ea, sflag) -> ea_t
    
    
    Find next data address.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_defined in module ida_search:

find_defined(*args) -> 'ea_t'
    find_defined(ea, sflag) -> ea_t
    
    
    Find next ea that is the start of an instruction or data.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_func_end in module idc:

find_func_end(ea)
    Determine a new function boundaries
    
    @param ea: starting address of a new function
    
    @return: if a function already exists, then return its end address.
            If a function end cannot be determined, the return BADADDR
            otherwise return the end address of the new function

Help on function find_imm in module ida_search:

find_imm(*args) -> 'int *'
    find_imm(newEA, sflag, srchValue) -> ea_t
    
    
    Find next immediate operand with the given value.
    
    
    @param newEA (C++: ea_t)
    @param sflag (C++: int)
    @param srchValue (C++: uval_t)

Help on function find_selector in module idc:

find_selector(val)
    Find a selector which has the specifed value
    
    @param val: value to search for
    
    @return: the selector number if found,
             otherwise the input value (val & 0xFFFF)
    
    @note: selector values are always in paragraphs

Help on function find_suspop in module ida_search:

find_suspop(*args) -> 'int *'
    find_suspop(ea, sflag) -> ea_t
    
    
    Find next suspicious operand.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function find_text in module idc:

find_text(ea, flag, y, x, searchstr, from_bc695=False)

Help on function find_unknown in module ida_search:

find_unknown(*args) -> 'ea_t'
    find_unknown(ea, sflag) -> ea_t
    
    
    Find next unexplored address.
    
    
    @param ea (C++: ea_t)
    @param sflag (C++: int)

Help on function first_func_chunk in module idc:

first_func_chunk(funcea)
    Get the first function chunk of the specified function
    
    @param funcea: any address in the function
    
    @return: the function entry point or BADADDR
    
    @note: This function returns the first (main) chunk of the specified function

Help on function fopen in module idc:

fopen(f, mode)
    #----------------------------------------------------------------------------
    #                            F I L E   I / O
    #----------------------------------------------------------------------------

Help on function force_bl_call in module idc:

force_bl_call(ea)
    Force BL instruction to be a call
    
    @param ea: address of the BL instruction
    
    @return: 1-ok, 0-failed

Help on function force_bl_jump in module idc:

force_bl_jump(ea)
    Some ARM compilers in Thumb mode use BL (branch-and-link)
    instead of B (branch) for long jumps, since BL has more range.
    By default, IDA tries to determine if BL is a jump or a call.
    You can override IDA's decision using commands in Edit/Other menu
    (Force BL call/Force BL jump) or the following two functions.
    
    Force BL instruction to be a jump
    
    @param ea: address of the BL instruction
    
    @return: 1-ok, 0-failed

Help on function form in module idc:

form(format, *args)

Help on function fprintf in module idc:

fprintf(handle, format, *args)

Help on function fputc in module idc:

fputc(byte, handle)

Help on function fseek in module idc:

fseek(handle, offset, origin)

Help on function ftell in module idc:

ftell(handle)

Help on function func_contains in module idc:

func_contains(func_ea, ea)
    Does the given function contain the given address?
    
    @param func_ea: any address belonging to the function
    @param ea: linear address
    
    @return:  success

Help on function gen_file in module idc:

gen_file(filetype, path, ea1, ea2, flags)
    Generate an output file
    
    @param filetype:  type of output file. One of OFILE_... symbols. See below.
    @param path:  the output file path (will be overwritten!)
    @param ea1:   start address. For some file types this argument is ignored
    @param ea2:   end address. For some file types this argument is ignored
    @param flags: bit combination of GENFLG_...
    
    @returns: number of the generated lines.
                -1 if an error occurred
                OFILE_EXE: 0-can't generate exe file, 1-ok

Help on function gen_flow_graph in module idc:

gen_flow_graph(outfile, title, ea1, ea2, flags)
    Generate a flow chart GDL file
    
    @param outfile: output file name. GDL extension will be used
    @param title: graph title
    @param ea1: beginning of the range to flow chart
    @param ea2: end of the range to flow chart.
    @param flags: combination of CHART_... constants
    
    @note: If ea2 == BADADDR then ea1 is treated as an address within a function.
           That function will be flow charted.

Help on function gen_simple_call_chart in module idc:

gen_simple_call_chart(outfile, title, flags)
    Generate a function call graph GDL file
    
    @param outfile: output file name. GDL extension will be used
    @param title:   graph title
    @param flags:   combination of CHART_GEN_GDL, CHART_WINGRAPH, CHART_NOLIBFUNCS

Help on function generate_disasm_line in module idc:

generate_disasm_line(ea, flags)
    Get disassembly line
    
    @param ea: linear address of instruction
    
    @param flags: combination of the GENDSM_ flags, or 0
    
    @return: "" - could not decode instruction at the specified location
    
    @note: this function may not return exactly the same mnemonics
           as you see on the screen.

Help on function get_array_element in module idc:

get_array_element(tag, array_id, idx)
    Get value of array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of an element.
    
    @return: Value of the specified array element. Note that
             this function may return char or long result. Unexistent
             array elements give zero as a result.

Help on function get_array_id in module idc:

get_array_id(name)
    Get array array_id, by name.
    
    @param name: The array name.
    
    @return: -1 in case of failure (i.e., no array with that
             name exists), a valid array_id otherwise.

Help on function get_bmask_cmt in module idc:

get_bmask_cmt(enum_id, bmask, repeatable)
    Get bitmask comment (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    @param repeatable: type of comment, 0-regular, 1-repeatable
    
    @return: comment attached to bitmask or None

Help on function get_bmask_name in module idc:

get_bmask_name(enum_id, bmask)
    Get bitmask name (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    
    @return: name of bitmask or None

Help on function get_marked_pos in module ida_idc:

get_marked_pos(*args) -> 'ea_t'
    get_marked_pos(slot) -> ea_t

Help on function get_mark_comment in module ida_idc:

get_mark_comment(*args) -> 'PyObject *'
    get_mark_comment(slot) -> PyObject *

Help on function get_bpt_attr in module idc:

get_bpt_attr(ea, bptattr)
    Get the characteristics of a breakpoint
    
    @param ea: any address in the breakpoint range
    @param bptattr: the desired attribute code, one of BPTATTR_... constants
    
    @return: the desired attribute value or -1

Help on function get_bpt_ea in module idc:

get_bpt_ea(n)
    Get breakpoint address
    
    @param n: number of breakpoint, is in range 0..get_bpt_qty()-1
    
    @return: address of the breakpoint or BADADDR

Help on function get_bpt_qty in module ida_dbg:

get_bpt_qty(*args) -> 'int'
    get_bpt_qty() -> int
    
    
    Get number of breakpoints. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function get_bpt_tev_ea in module ida_dbg:

get_bpt_tev_ea(*args) -> 'ea_t'
    get_bpt_tev_ea(n) -> ea_t
    
    
    Get the address associated to a read, read/write or execution trace
    event. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}Usually, a breakpoint is associated with a read, read/write
    or execution trace event. However, the returned address could be any
    address in the range of this breakpoint. If the breakpoint was deleted
    after the trace event, the address no longer corresponds to a valid
    breakpoint.
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @return: BADADDR  if not a read, read/write or execution trace event.

Help on function get_bytes in module idc:

get_bytes(ea, size, use_dbg=False)
    Return the specified number of bytes of the program
    
    @param ea: linear address
    
    @param size: size of buffer in normal 8-bit bytes
    
    @param use_dbg: if True, use debugger memory, otherwise just the database
    
    @return: None on failure
             otherwise a string containing the read bytes

Help on function get_call_tev_callee in module ida_dbg:

get_call_tev_callee(*args) -> 'ea_t'
    get_call_tev_callee(n) -> ea_t
    
    
    Get the called function from a function call trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @return: BADADDR  if not a function call event.

Help on function get_color in module idc:

get_color(ea, what)
    Get item color
    
    @param ea: address of the item
    @param what: type of the item (one of  CIC_* constants)
    
    @return: color code in RGB (hex 0xBBGGRR)

Help on function get_curline in module idc:

get_curline()
    Get the disassembly line at the cursor
    
    @return: string

Help on function get_current_thread in module ida_dbg:

get_current_thread(*args) -> 'thid_t'
    get_current_thread() -> thid_t
    
    
    Get current thread ID. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}

Help on function get_db_byte in module ida_bytes:

get_db_byte(*args) -> 'uchar'
    get_db_byte(ea) -> uchar
    
    
    Get one byte (8-bit) of the program at 'ea' from the database. Works
    even if the debugger is active. See also 'get_dbg_byte()' to read the
    process memory directly. This function works only for 8bit byte
    processors.
    
    @param ea (C++: ea_t)

Help on function get_debugger_event_cond in module ida_dbg:

get_debugger_event_cond(*args) -> 'char const *'
    get_debugger_event_cond() -> char const *

Help on function get_entry in module ida_entry:

get_entry(*args) -> 'ea_t'
    get_entry(ord) -> ea_t
    
    
    Get entry point address by its ordinal
    
    @param ord: ordinal number of entry point (C++: uval_t)
    @return: address or  BADADDR

Help on function get_entry_name in module ida_entry:

get_entry_name(*args) -> 'qstring *'
    get_entry_name(ord) -> str
    
    
    Get name of the entry point by its ordinal.
    
    @param ord: ordinal number of entry point (C++: uval_t)
    @return: size of entry name or -1

Help on function get_entry_ordinal in module ida_entry:

get_entry_ordinal(*args) -> 'uval_t'
    get_entry_ordinal(idx) -> uval_t
    
    
    Get ordinal number of an entry point.
    
    @param idx: internal number of entry point. Should be in the range 0..
                get_entry_qty() -1 (C++: size_t)
    @return: ordinal number or 0.

Help on function get_entry_qty in module ida_entry:

get_entry_qty(*args) -> 'size_t'
    get_entry_qty() -> size_t
    
    
    Get number of entry points.

Help on function get_enum in module ida_enum:

get_enum(*args) -> 'enum_t'
    get_enum(name) -> enum_t
    
    
    Get enum by name.
    
    
    @param name (C++: const char *)

Help on function get_enum_cmt in module ida_enum:

get_enum_cmt(*args) -> 'qstring *'
    get_enum_cmt(id, repeatable) -> str
    
    
    Get enum comment.
    
    
    @param id (C++: enum_t)
    @param repeatable (C++: bool)

Help on function get_enum_flag in module ida_enum:

get_enum_flag(*args) -> 'flags_t'
    get_enum_flag(id) -> flags_t
    
    
    Get flags determining the representation of the enum. (currently they
    define the numeric base: octal, decimal, hex, bin) and signness.
    
    @param id (C++: enum_t)

Help on function get_enum_idx in module ida_enum:

get_enum_idx(*args) -> 'uval_t'
    get_enum_idx(id) -> uval_t
    
    
    Get serial number of enum. The serial number determines the place of
    the enum in the enum window.
    
    @param id (C++: enum_t)

Help on function get_enum_member in module idc:

get_enum_member(enum_id, value, serial, bmask)
    Get id of constant
    
    @param enum_id: id of enum
    @param value: value of constant
    @param serial: serial number of the constant in the
              enumeration. See op_enum() for details.
    @param bmask: bitmask of the constant
              ordinary enums accept only ida_enum.DEFMASK as a bitmask
    
    @return: id of constant or -1 if error

Help on function get_enum_member_bmask in module ida_enum:

get_enum_member_bmask(*args) -> 'bmask_t'
    get_enum_member_bmask(id) -> bmask_t
    
    
    Get bitmask of an enum member.
    
    
    @param id (C++: const_t)

Help on function get_enum_member_by_name in module ida_enum:

get_enum_member_by_name(*args) -> 'const_t'
    get_enum_member_by_name(name) -> const_t
    
    
    Get a reference to an enum member by its name.
    
    
    @param name (C++: const char *)

Help on function get_enum_member_cmt in module idc:

get_enum_member_cmt(const_id, repeatable)
    Get comment of a constant
    
    @param const_id: id of const
    @param repeatable: 0:get regular comment, 1:get repeatable comment
    
    @return: comment string

Help on function get_enum_member_enum in module ida_enum:

get_enum_member_enum(*args) -> 'enum_t'
    get_enum_member_enum(id) -> enum_t
    
    
    Get the parent enum of an enum member.
    
    
    @param id (C++: const_t)

Help on function get_enum_member_name in module idc:

get_enum_member_name(const_id)
    Get name of a constant
    
    @param const_id: id of const
    
    Returns: name of constant

Help on function get_enum_member_value in module ida_enum:

get_enum_member_value(*args) -> 'uval_t'
    get_enum_member_value(id) -> uval_t
    
    
    Get value of an enum member.
    
    
    @param id (C++: const_t)

Help on function get_enum_name in module ida_enum:

get_enum_name(*args) -> 'qstring *'
    get_enum_name(id) -> str
    
    
    Get name of enum.
    
    
    @param id (C++: enum_t)

Help on function get_enum_qty in module ida_enum:

get_enum_qty(*args) -> 'size_t'
    get_enum_qty() -> size_t
    
    
    Get number of declared 'enum_t' types.

Help on function get_enum_size in module ida_enum:

get_enum_size(*args) -> 'size_t'
    get_enum_size(id) -> size_t
    
    
    Get the number of the members of the enum.
    
    
    @param id (C++: enum_t)

Help on function get_enum_width in module ida_enum:

get_enum_width(*args) -> 'size_t'
    get_enum_width(id) -> size_t
    
    
    Get the width of a enum element allowed values: 0
    (unspecified),1,2,4,8,16,32,64
    
    @param id (C++: enum_t)

Help on function get_event_bpt_hea in module idc:

get_event_bpt_hea()
    Get hardware address for BREAKPOINT event
    
    @return: hardware address

Help on function get_event_ea in module idc:

get_event_ea()
    Get ea for debug event
    
    @return: ea

Help on function get_event_exc_code in module idc:

get_event_exc_code()
    Get exception code for EXCEPTION event
    
    @return: exception code

Help on function get_event_exc_ea in module idc:

get_event_exc_ea()
    Get address for EXCEPTION event
    
    @return: adress of exception

Help on function get_event_exc_info in module idc:

get_event_exc_info()
    Get info for EXCEPTION event
    
    @return: info string

Help on function get_event_exit_code in module idc:

get_event_exit_code()
    Get exit code for debug event
    
    @return: exit code for PROCESS_EXITED, THREAD_EXITED events

Help on function get_event_id in module idc:

get_event_id()
    Get ID of debug event
    
    @return: event ID

Help on function get_event_info in module idc:

get_event_info()
    Get debug event info
    
    @return: event info: for THREAD_STARTED (thread name)
                         for LIB_UNLOADED (unloaded library name)
                         for INFORMATION (message to display)

Help on function get_event_module_base in module idc:

get_event_module_base()
    Get module base for debug event
    
    @return: module base

Help on function get_event_module_name in module idc:

get_event_module_name()
    Get module name for debug event
    
    @return: module name

Help on function get_event_module_size in module idc:

get_event_module_size()
    Get module size for debug event
    
    @return: module size

Help on function get_event_pid in module idc:

get_event_pid()
    Get process ID for debug event
    
    @return: process ID

Help on function get_event_tid in module idc:

get_event_tid()
    Get type ID for debug event
    
    @return: type ID

Help on function get_extra_cmt in module ida_lines:

get_extra_cmt(*args) -> 'int'
    get_extra_cmt(ea, what) -> ssize_t

Help on function get_fchunk_attr in module idc:

get_fchunk_attr(ea, attr)
    Get a function chunk attribute
    
    @param ea: any address in the chunk
    @param attr: one of: FUNCATTR_START, FUNCATTR_END, FUNCATTR_OWNER, FUNCATTR_REFQTY
    
    @return: desired attribute or -1

Help on function get_fchunk_referer in module ida_funcs:

get_fchunk_referer(*args) -> 'ea_t'
    get_fchunk_referer(ea, idx) -> ea_t

Help on function get_first_bmask in module ida_enum:

get_first_bmask(*args) -> 'bmask_t'
    get_first_bmask(id) -> bmask_t
    
    
    Get first bitmask in the enum (bitfield)
    
    @param id (C++: enum_t)
    @return: the smallest bitmask for enum, or DEFMASK

Help on function get_first_cref_from in module ida_xref:

get_first_cref_from(*args) -> 'ea_t'
    get_first_cref_from(frm) -> ea_t
    
    
    Get first instruction referenced from the specified instruction. If
    the specified instruction passes execution to the next instruction
    then the next instruction is returned. Otherwise the lowest referenced
    address is returned (remember that xrefs are kept sorted!).
    
    @return: first referenced address. The  lastXR  variable contains type
             of the reference. If the specified instruction doesn't
             reference to other instructions then returns  BADADDR .

Help on function get_first_cref_to in module ida_xref:

get_first_cref_to(*args) -> 'ea_t'
    get_first_cref_to(to) -> ea_t
    
    
    Get first instruction referencing to the specified instruction. If the
    specified instruction may be executed immediately after its previous
    instruction then the previous instruction is returned. Otherwise the
    lowest referencing address is returned. (remember that xrefs are kept
    sorted!).
    
    @param to: linear address of referenced instruction (C++: ea_t)
    @return: linear address of the first referencing instruction or
             BADADDR . The  lastXR  variable contains type of the
             reference.

Help on function get_first_dref_from in module ida_xref:

get_first_dref_from(*args) -> 'ea_t'
    get_first_dref_from(frm) -> ea_t
    
    
    Get first data referenced from the specified address.
    
    @return: linear address of first (lowest) data referenced from the
             specified address. The  lastXR  variable contains type of the
             reference. Return  BADADDR  if the specified instruction/data
             doesn't reference to anything.

Help on function get_first_dref_to in module ida_xref:

get_first_dref_to(*args) -> 'ea_t'
    get_first_dref_to(to) -> ea_t
    
    
    Get address of instruction/data referencing to the specified data.
    
    @param to: linear address of referencing instruction or data (C++:
               ea_t)
    @return: BADADDR  if nobody refers to the specified data. The  lastXR
             variable contains type of the reference.

Help on function get_first_enum_member in module idc:

get_first_enum_member(enum_id, bmask)
    Get first constant in the enum
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant (ordinary enums accept only ida_enum.DEFMASK as a bitmask)
    
    @return: value of constant or idaapi.BADNODE no constants are defined
             All constants are sorted by their values as unsigned longs.

Help on function get_first_fcref_from in module ida_xref:

get_first_fcref_from(*args) -> 'ea_t'
    get_first_fcref_from(frm) -> ea_t

Help on function get_first_fcref_to in module ida_xref:

get_first_fcref_to(*args) -> 'ea_t'
    get_first_fcref_to(to) -> ea_t

Help on function get_first_hash_key in module idc:

get_first_hash_key(hash_id)
    Get the first key in the hash.
    
    @param hash_id: The hash ID.
    
    @return: the key, 0 otherwise.

Help on function get_first_index in module idc:

get_first_index(tag, array_id)
    Get index of the first existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    
    @return: -1 if the array is empty, otherwise index of first array
             element of given type.

Help on function get_first_member in module idc:

get_first_member(sid)
    Get offset of the first member of a structure
    
    @param sid: structure type ID
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if structure has no members,
             otherwise returns offset of the first member.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_first_module in module idc:

get_first_module()
    Enumerate process modules
    
    @return: first module's base address or None on failure

Help on function get_first_seg in module idc:

get_first_seg()
    Get first segment
    
    @return: address of the start of the first segment
        BADADDR - no segments are defined

Help on function get_first_struc_idx in module ida_struct:

get_first_struc_idx(*args) -> 'uval_t'
    get_first_struc_idx() -> uval_t
    
    
    Get index of first structure.
    
    @return: BADADDR  if no known structures, 0 otherwise

Help on function get_fixup_target_dis in module idc:

get_fixup_target_dis(ea)
    Get fixup target displacement
    
    @param ea: address to get information about
    
    @return: 0 - no fixup at the specified address
                 otherwise returns fixup target displacement

Help on function get_fixup_target_flags in module idc:

get_fixup_target_flags(ea)
    Get fixup target flags
    
    @param ea: address to get information about
    
    @return: 0 - no fixup at the specified address
                 otherwise returns fixup target flags

Help on function get_fixup_target_off in module idc:

get_fixup_target_off(ea)
    Get fixup target offset
    
    @param ea: address to get information about
    
    @return: BADADDR - no fixup at the specified address
                       otherwise returns fixup target offset

Help on function get_fixup_target_sel in module idc:

get_fixup_target_sel(ea)
    Get fixup target selector
    
    @param ea: address to get information about
    
    @return: BADSEL - no fixup at the specified address
                      otherwise returns fixup target selector

Help on function get_fixup_target_type in module idc:

get_fixup_target_type(ea)
    Get fixup target type
    
    @param ea: address to get information about
    
    @return: 0 - no fixup at the specified address
                 otherwise returns fixup type

Help on function get_forced_operand in module ida_bytes:

get_forced_operand(*args) -> 'qstring *'
    get_forced_operand(ea, n) -> str
    
    
    Get forced operand.
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, 2) (C++: int)
    @return: size of forced operand or -1

Help on function get_frame_args_size in module idc:

get_frame_args_size(ea)
    Get size of arguments in function frame which are purged upon return
    
    @param ea: any address belonging to the function
    
    @return: Size of function arguments in bytes.
             If the function doesn't have a frame, return 0
             If the function does't exist, return -1

Help on function get_frame_id in module idc:

get_frame_id(ea)
    Get ID of function frame structure
    
    @param ea: any address belonging to the function
    
    @return: ID of function frame or None In order to access stack variables
             you need to use structure member manipulaion functions with the
             obtained ID.

Help on function get_frame_lvar_size in module idc:

get_frame_lvar_size(ea)
    Get size of local variables in function frame
    
    @param ea: any address belonging to the function
    
    @return: Size of local variables in bytes.
             If the function doesn't have a frame, return 0
             If the function does't exist, return None

Help on function get_frame_regs_size in module idc:

get_frame_regs_size(ea)
    Get size of saved registers in function frame
    
    @param ea: any address belonging to the function
    
    @return: Size of saved registers in bytes.
             If the function doesn't have a frame, return 0
             This value is used as offset for BP (if FUNC_FRAME is set)
             If the function does't exist, return None

Help on function get_frame_size in module idc:

get_frame_size(ea)
    Get full size of function frame
    
    @param ea: any address belonging to the function
    @returns: Size of function frame in bytes.
                This function takes into account size of local
                variables + size of saved registers + size of
                return address + size of function arguments
                If the function doesn't have a frame, return size of
                function return address in the stack.
                If the function does't exist, return 0

Help on function get_full_flags in module ida_bytes:

get_full_flags(*args) -> 'flags_t'
    get_full_flags(ea) -> flags_t
    
    
    Get flags value for address 'ea'.
    
    @param ea (C++: ea_t)
    @return: 0 if address is not present in the program

Help on function get_func_attr in module idc:

get_func_attr(ea, attr)
    Get a function attribute
    
    @param ea: any address belonging to the function
    @param attr: one of FUNCATTR_... constants
    
    @return: BADADDR - error otherwise returns the attribute value

Help on function get_func_cmt in module idc:

get_func_cmt(ea, repeatable)
    Retrieve function comment
    
    @param ea: any address belonging to the function
    @param repeatable: 1: get repeatable comment
            0: get regular comment
    
    @return: function comment string

Help on function get_func_flags in module idc:

get_func_flags(ea)
    Retrieve function flags
    
    @param ea: any address belonging to the function
    
    @return: -1 - function doesn't exist otherwise returns the flags

Help on function get_func_name in module idc:

get_func_name(ea)
    Retrieve function name
    
    @param ea: any address belonging to the function
    
    @return: null string - function doesn't exist
            otherwise returns function name

Help on function get_func_off_str in module idc:

get_func_off_str(ea)
    Convert address to 'funcname+offset' string
    
    @param ea: address to convert
    
    @return: if the address belongs to a function then return a string
             formed as 'name+offset' where 'name' is a function name
             'offset' is offset within the function else return null string

Help on function get_hash_long in module idc:

get_hash_long(hash_id, key)
    Gets the long value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    
    @return: the 32bit or 64bit value of the element, or 0 if no such
             element.

Help on function get_hash_string in module idc:

get_hash_string(hash_id, key)
    Gets the string value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    
    @return: the string value of the element, or None if no such
             element.

Help on function get_idb_path in module idc:

get_idb_path()
    Get IDB full path
    
    This function returns full path of the current IDB database

Help on function get_inf_attr in module idc:

get_inf_attr(attr)

Help on function get_input_file_path in module ida_nalt:

get_input_file_path(*args) -> 'size_t'
    get_input_file_path() -> str
    
    
    Get full path of the input file.

Help on function get_item_end in module ida_bytes:

get_item_end(*args) -> 'ea_t'
    get_item_end(ea) -> ea_t
    
    
    Get the end address of the item at 'ea'. The returned address doesn't
    belong to the current item. Unexplored bytes are counted as 1 byte
    entities.
    
    @param ea (C++: ea_t)

Help on function get_item_head in module ida_bytes:

get_item_head(*args) -> 'ea_t'
    get_item_head(ea) -> ea_t
    
    
    Get the start address of the item at 'ea'. If there is no current
    item, then 'ea' will be returned (see definition at the end of
    'bytes.hpp' source)
    
    @param ea (C++: ea_t)

Help on function get_item_size in module idc:

get_item_size(ea)
    Get size of instruction or data item in bytes
    
    @param ea: linear address
    
    @return: 1..n

Help on function get_last_bmask in module ida_enum:

get_last_bmask(*args) -> 'bmask_t'
    get_last_bmask(id) -> bmask_t
    
    
    Get last bitmask in the enum (bitfield)
    
    @param id (C++: enum_t)
    @return: the biggest bitmask for enum, or DEFMASK

Help on function get_last_enum_member in module idc:

get_last_enum_member(enum_id, bmask)
    Get last constant in the enum
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant (ordinary enums accept only ida_enum.DEFMASK as a bitmask)
    
    @return: value of constant or idaapi.BADNODE no constants are defined
             All constants are sorted by their values
             as unsigned longs.

Help on function get_last_hash_key in module idc:

get_last_hash_key(hash_id)
    Get the last key in the hash.
    
    @param hash_id: The hash ID.
    
    @return: the key, 0 otherwise.

Help on function get_last_index in module idc:

get_last_index(tag, array_id)
    Get index of last existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    
    @return: -1 if the array is empty, otherwise index of first array
             element of given type.

Help on function get_last_member in module idc:

get_last_member(sid)
    Get offset of the last member of a structure
    
    @param sid: structure type ID
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if structure has no members,
             otherwise returns offset of the last member.
    
    @note: IDA allows 'holes' between members of a
          structure. It treats these 'holes'
          as unnamed arrays of bytes.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_last_struc_idx in module ida_struct:

get_last_struc_idx(*args) -> 'uval_t'
    get_last_struc_idx() -> uval_t
    
    
    Get index of last structure.
    
    @return: BADADDR  if no known structures,  get_struc_qty() -1
             otherwise

Help on function get_local_tinfo in module idc:

get_local_tinfo(ordinal)
    Get local type information as 'typeinfo' object
    
    @param ordinal:  slot number (1...NumberOfLocalTypes)
    @return: None on failure, or (type, fields) tuple.

Help on function get_manual_insn in module ida_bytes:

get_manual_insn(*args) -> 'qstring *'
    get_manual_insn(ea) -> str
    
    
    Retrieve the user-specified string for the manual instruction.
    
    @param ea: linear address of the instruction or data item (C++: ea_t)
    @return: size of manual instruction or -1

Help on function get_member_cmt in module idc:

get_member_cmt(sid, member_offset, repeatable)
    Get comment of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    @param repeatable: 1: get repeatable comment
                       0: get regular comment
    
    @return: None if bad structure type ID is passed
             or no such member in the structure
             otherwise returns comment of the specified member.

Help on function get_member_flag in module idc:

get_member_flag(sid, member_offset)
    Get type of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    
    @return: -1 if bad structure type ID is passed
             or no such member in the structure
             otherwise returns type of the member, see bit
             definitions above. If the member type is a structure
             then function GetMemberStrid() should be used to
             get the structure type id.

Help on function get_member_id in module idc:

get_member_id(sid, member_offset)
    @param sid: structure type ID
    @param member_offset:. The offset can be
    any offset in the member. For example,
    is a member is 4 bytes long and starts
    at offset 2, then 2,3,4,5 denote
    the same structure member.
    
    @return: -1 if bad structure type ID is passed or there is
    no member at the specified offset.
    otherwise returns the member id.

Help on function get_member_name in module idc:

get_member_name(sid, member_offset)
    Get name of a member of a structure
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    
    @return: None if bad structure type ID is passed
             or no such member in the structure
             otherwise returns name of the specified member.

Help on function get_member_offset in module idc:

get_member_offset(sid, member_name)
    Get offset of a member of a structure by the member name
    
    @param sid: structure type ID
    @param member_name: name of structure member
    
    @return: -1 if bad structure type ID is passed
             or no such member in the structure
             otherwise returns offset of the specified member.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_member_qty in module idc:

get_member_qty(sid)
    Get number of members of a structure
    
    @param sid: structure type ID
    
    @return: -1 if bad structure type ID is passed otherwise
             returns number of members.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_member_size in module idc:

get_member_size(sid, member_offset)
    Get size of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    
    @return: None if bad structure type ID is passed,
             or no such member in the structure
             otherwise returns size of the specified
             member in bytes.

Help on function get_member_strid in module idc:

get_member_strid(sid, member_offset)
    Get structure id of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    @return: -1 if bad structure type ID is passed
             or no such member in the structure
             otherwise returns structure id of the member.
             If the current member is not a structure, returns -1.

Help on function get_min_spd_ea in module idc:

get_min_spd_ea(func_ea)
    Return the address with the minimal spd (stack pointer delta)
    If there are no SP change points, then return BADADDR.
    
    @param func_ea: function start
    @return: BADDADDR - no such function

Help on function get_module_name in module idc:

get_module_name(base)
    Get process module name
    
    @param base: the base address of the module
    
    @return: required info or None

Help on function get_module_size in module idc:

get_module_size(base)
    Get process module size
    
    @param base: the base address of the module
    
    @return: required info or -1

Help on function get_name in module idc:

get_name(ea, gtn_flags=0)
    Get name at the specified address
    
    @param ea: linear address
    @param gtn_flags: how exactly the name should be retrieved.
                      combination of GN_ bits
    
    @return: "" - byte has no name

Help on function get_name_ea in module ida_name:

get_name_ea(*args) -> 'ea_t'
    get_name_ea(_from, name) -> ea_t
    
    
    Get address of the name. Dummy names (like byte_xxxx where xxxx are
    hex digits) are parsed by this function to obtain the address. The
    database is not consulted for them. This function works only with
    regular names.
    
    @param _from: linear address where the name is used. if not
                  applicable, then should be  BADADDR . (C++: ea_t)
    @param name: any name in the program or NULL (C++: const char *)
    @return: address of the name or  BADADDR

Help on function get_name_ea_simple in module idc:

get_name_ea_simple(name)
    Get linear address of a name
    
    @param name: name of program byte
    
    @return: address of the name
             BADADDR - No such name

Help on function get_next_bmask in module ida_enum:

get_next_bmask(*args) -> 'bmask_t'
    get_next_bmask(id, bmask) -> bmask_t
    
    
    Get next bitmask in the enum (bitfield)
    
    @param id (C++: enum_t)
    @param bmask (C++: bmask_t)
    @return: value of a bitmask with value higher than the specified
             value, or DEFMASK

Help on function get_next_cref_from in module ida_xref:

get_next_cref_from(*args) -> 'ea_t'
    get_next_cref_from(frm, current) -> ea_t
    
    
    Get next instruction referenced from the specified instruction.
    
    @param current: linear address of current referenced instruction This
                    value is returned by  get_first_cref_from()  or
                    previous call to  get_next_cref_from()  functions.
                    (C++: ea_t)
    @return: next referenced address or  BADADDR . The  lastXR  variable
             contains type of the reference.

Help on function get_next_cref_to in module ida_xref:

get_next_cref_to(*args) -> 'ea_t'
    get_next_cref_to(to, current) -> ea_t
    
    
    Get next instruction referencing to the specified instruction.
    
    @param to: linear address of referenced instruction (C++: ea_t)
    @param current: linear address of current referenced instruction This
                    value is returned by  get_first_cref_to()  or previous
                    call to  get_next_cref_to()  functions. (C++: ea_t)
    @return: linear address of the next referencing instruction or
             BADADDR . The  lastXR  variable contains type of the
             reference.

Help on function get_next_dref_from in module ida_xref:

get_next_dref_from(*args) -> 'ea_t'
    get_next_dref_from(frm, current) -> ea_t
    
    
    Get next data referenced from the specified address.
    
    @param current: linear address of current referenced data. This value
                    is returned by  get_first_dref_from()  or previous
                    call to  get_next_dref_from()  functions. (C++: ea_t)
    @return: linear address of next data or  BADADDR . The  lastXR
             variable contains type of the reference

Help on function get_next_dref_to in module ida_xref:

get_next_dref_to(*args) -> 'ea_t'
    get_next_dref_to(to, current) -> ea_t
    
    
    Get address of instruction/data referencing to the specified data
    
    @param to: linear address of referencing instruction or data (C++:
               ea_t)
    @param current: current linear address. This value is returned by
                    get_first_dref_to()  or previous call to
                    get_next_dref_to()  functions. (C++: ea_t)
    @return: BADADDR  if nobody refers to the specified data. The  lastXR
             variable contains type of the reference.

Help on function get_next_enum_member in module idc:

get_next_enum_member(enum_id, value, bmask)
    Get next constant in the enum
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant ordinary enums accept only ida_enum.DEFMASK as a bitmask
    @param value: value of the current constant
    
    @return: value of a constant with value higher than the specified
             value. idaapi.BADNODE no such constants exist.
             All constants are sorted by their values as unsigned longs.

Help on function get_next_fchunk in module idc:

get_next_fchunk(ea)
    Get next function chunk
    
    @param ea: any address
    
    @return:  the starting address of the next function chunk or BADADDR
    
    @note: This function enumerates all chunks of all functions in the database

Help on function get_next_fcref_from in module ida_xref:

get_next_fcref_from(*args) -> 'ea_t'
    get_next_fcref_from(frm, current) -> ea_t

Help on function get_next_fcref_to in module ida_xref:

get_next_fcref_to(*args) -> 'ea_t'
    get_next_fcref_to(to, current) -> ea_t

Help on function get_next_fixup_ea in module ida_fixup:

get_next_fixup_ea(*args) -> 'ea_t'
    get_next_fixup_ea(ea) -> ea_t
    
    
    Find next address with fixup information
    
    @param ea: current address (C++: ea_t)
    @return: the next address with fixup information, or BADADDR

Help on function get_next_func in module idc:

get_next_func(ea)
    Find next function
    
    @param ea: any address belonging to the function
    
    @return:        BADADDR - no more functions
            otherwise returns the next function start address

Help on function get_next_hash_key in module idc:

get_next_hash_key(hash_id, key)
    Get the next key in the hash.
    
    @param hash_id: The hash ID.
    @param key: The current key.
    
    @return: the next key, 0 otherwise

Help on function get_next_index in module idc:

get_next_index(tag, array_id, idx)
    Get index of the next existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of the current element.
    
    @return: -1 if no more elements, otherwise returns index of the
             next array element of given type.

Help on function get_next_module in module idc:

get_next_module(base)
    Enumerate process modules
    
    @param base: previous module's base address
    
    @return: next module's base address or None on failure

Help on function get_next_offset in module idc:

get_next_offset(sid, offset)
    Get next offset in a structure
    
    @param sid:     structure type ID
    @param offset: current offset
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if no (more) offsets in the structure,
             otherwise returns next offset in a structure.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.
           This function returns a member offset or a hole offset.
           It will return size of the structure if input
           'offset' belongs to the last member of the structure.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_next_seg in module idc:

get_next_seg(ea)
    Get next segment
    
    @param ea: linear address
    
    @return: start of the next segment
             BADADDR - no next segment

Help on function get_next_struc_idx in module ida_struct:

get_next_struc_idx(*args) -> 'uval_t'
    get_next_struc_idx(idx) -> uval_t
    
    
    Get next struct index.
    
    @param idx (C++: uval_t)
    @return: BADADDR  if resulting index is out of bounds, otherwise idx++

Help on function get_numbered_type_name in module idc:

get_numbered_type_name(ordinal)
    Retrieve a local type name
    
    @param ordinal:  slot number (1...NumberOfLocalTypes)
    
    returns: local type name or None

Help on function get_operand_type in module idc:

get_operand_type(ea, n)
    Get type of instruction operand
    
    @param ea: linear address of instruction
    @param n: number of operand:
        0 - the first operand
        1 - the second operand
    
    @return: any of o_* constants or -1 on error

Help on function get_operand_value in module idc:

get_operand_value(ea, n)
    Get number used in the operand
    
    This function returns an immediate number used in the operand
    
    @param ea: linear address of instruction
    @param n: the operand number
    
    @return: value
        operand is an immediate value  => immediate value
        operand has a displacement     => displacement
        operand is a direct memory ref => memory address
        operand is a register          => register number
        operand is a register phrase   => phrase number
        otherwise                      => -1

Help on function get_ordinal_qty in module idc:

get_ordinal_qty()
    Get number of local types + 1
    
    @return: value >= 1. 1 means that there are no local types.

Help on function get_original_byte in module ida_bytes:

get_original_byte(*args) -> 'uint64'
    get_original_byte(ea) -> uint64
    
    
    Get original byte value (that was before patching). This function
    works for wide byte processors too.
    
    @param ea (C++: ea_t)

Help on function get_prev_bmask in module ida_enum:

get_prev_bmask(*args) -> 'bmask_t'
    get_prev_bmask(id, bmask) -> bmask_t
    
    
    Get prev bitmask in the enum (bitfield)
    
    @param id (C++: enum_t)
    @param bmask (C++: bmask_t)
    @return: value of a bitmask with value lower than the specified value,
             or DEFMASK

Help on function get_prev_enum_member in module idc:

get_prev_enum_member(enum_id, value, bmask)
    Get prev constant in the enum
    
    @param enum_id: id of enum
    @param bmask  : bitmask of the constant
              ordinary enums accept only ida_enum.DEFMASK as a bitmask
    @param value: value of the current constant
    
    @return: value of a constant with value lower than the specified
        value. idaapi.BADNODE no such constants exist.
        All constants are sorted by their values as unsigned longs.

Help on function get_prev_fchunk in module idc:

get_prev_fchunk(ea)
    Get previous function chunk
    
    @param ea: any address
    
    @return: the starting address of the function chunk or BADADDR
    
    @note: This function enumerates all chunks of all functions in the database

Help on function get_prev_fixup_ea in module ida_fixup:

get_prev_fixup_ea(*args) -> 'ea_t'
    get_prev_fixup_ea(ea) -> ea_t
    
    
    Find previous address with fixup information
    
    @param ea: current address (C++: ea_t)
    @return: the previous address with fixup information, or BADADDR

Help on function get_prev_func in module idc:

get_prev_func(ea)
    Find previous function
    
    @param ea: any address belonging to the function
    
    @return: BADADDR - no more functions
            otherwise returns the previous function start address

Help on function get_prev_hash_key in module idc:

get_prev_hash_key(hash_id, key)
    Get the previous key in the hash.
    
    @param hash_id: The hash ID.
    @param key: The current key.
    
    @return: the previous key, 0 otherwise

Help on function get_prev_index in module idc:

get_prev_index(tag, array_id, idx)
    Get index of the previous existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of the current element.
    
    @return: -1 if no more elements, otherwise returns index of the
             previous array element of given type.

Help on function get_prev_offset in module idc:

get_prev_offset(sid, offset)
    Get previous offset in a structure
    
    @param sid: structure type ID
    @param offset: current offset
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if no (more) offsets in the structure,
             otherwise returns previous offset in a structure.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.
           This function returns a member offset or a hole offset.
           It will return size of the structure if input
           'offset' is bigger than the structure size.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_prev_struc_idx in module ida_struct:

get_prev_struc_idx(*args) -> 'uval_t'
    get_prev_struc_idx(idx) -> uval_t
    
    
    Get previous struct index.
    
    @param idx (C++: uval_t)
    @return: BADADDR  if resulting index is negative, otherwise idx - 1

Help on function get_process_state in module ida_dbg:

get_process_state(*args) -> 'int'
    get_process_state() -> int
    
    
    Return the state of the currently debugged process. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @return: one of  Debugged process states

Help on function get_processes in module ida_dbg:

get_processes(*args) -> 'ssize_t'
    get_processes(proclist) -> ssize_t
    
    
    Take a snapshot of running processes and return their description.
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    @param proclist (C++: procinfo_vec_t  *)
    @return: number of processes or -1 on error

Help on function get_qword in module ida_bytes:

get_qword(*args) -> 'uint64'
    get_qword(ea) -> uint64
    
    
    Get one qword (64-bit) of the program at 'ea'. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    works only for 8bit byte processors.
    
    @param ea (C++: ea_t)

Help on function get_reg_value in module idc:

get_reg_value(name)
    Get register value
    
    @param name: the register name
    
    @note: The debugger should be running. otherwise the function fails
           the register name should be valid.
           It is not necessary to use this function to get register values
           because a register name in the script will do too.
    
    @return: register value (integer or floating point)

Help on function get_ret_tev_return in module ida_dbg:

get_ret_tev_return(*args) -> 'ea_t'
    get_ret_tev_return(n) -> ea_t
    
    
    Get the return address from a function return trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @return: BADADDR  if not a function return event.

Help on function get_root_filename in module ida_nalt:

get_root_filename(*args) -> 'size_t'
    get_root_filename() -> str
    
    
    Get file name only of the input file.

Help on function get_screen_ea in module ida_kernwin:

get_screen_ea(*args) -> 'ea_t'
    get_screen_ea() -> ea_t
    
    
    Get the address at the screen cursor ( 'ui_screenea' )

Help on function get_segm_attr in module idc:

get_segm_attr(segea, attr)
    Get segment attribute
    
    @param segea: any address within segment
    @param attr: one of SEGATTR_... constants

Help on function get_segm_by_sel in module idc:

get_segm_by_sel(base)
    Get segment by segment base
    
    @param base: segment base paragraph or selector
    
    @return: linear address of the start of the segment or BADADDR
             if no such segment

Help on function get_segm_end in module idc:

get_segm_end(ea)
    Get end address of a segment
    
    @param ea: any address in the segment
    
    @return: end of segment (an address past end of the segment)
             BADADDR - the specified address doesn't belong to any segment

Help on function get_segm_name in module idc:

get_segm_name(ea)
    Get name of a segment
    
    @param ea: any address in the segment
    
    @return: "" - no segment at the specified address

Help on function get_segm_start in module idc:

get_segm_start(ea)
    Get start address of a segment
    
    @param ea: any address in the segment
    
    @return: start of segment
             BADADDR - the specified address doesn't belong to any segment

Help on function get_source_linnum in module ida_nalt:

get_source_linnum(*args) -> 'uval_t'
    get_source_linnum(ea) -> uval_t

Help on function get_sourcefile in module ida_lines:

get_sourcefile(*args) -> 'char const *'
    get_sourcefile(ea, bounds=None) -> char const *
    
    
    Get name of source file occupying the given address.
    
    @param ea: linear address (C++: ea_t)
    @param bounds: pointer to the output buffer with the address range for
                   the current file. May be NULL. (C++: range_t  *)
    @return: NULL if source file information is not found, otherwise
             returns pointer to file name

Help on function get_sp_delta in module idc:

get_sp_delta(ea)
    Get modification of SP made by the instruction
    
    @param ea: end address of the instruction
               i.e.the last address of the instruction+1
    
    @return: Get modification of SP made at the specified location
             If the specified location doesn't contain a SP change point, return 0
             Otherwise return delta of SP modification

Help on function get_spd in module idc:

get_spd(ea)
    Get current delta for the stack pointer
    
    @param ea: end address of the instruction
               i.e.the last address of the instruction+1
    
    @return: The difference between the original SP upon
             entering the function and SP for the specified address

Help on function get_sreg in module idc:

get_sreg(ea, reg)
    Get value of segment register at the specified address
    
    @param ea: linear address
    @param reg: name of segment register
    
    @return: the value of the segment register or -1 on error
    
    @note: The segment registers in 32bit program usually contain selectors,
           so to get paragraph pointed to by the segment register you need to
           call sel2para() function.

Help on function get_step_trace_options in module ida_dbg:

get_step_trace_options(*args) -> 'int'
    get_step_trace_options() -> int
    
    
    Get current step tracing options. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @return: Step trace options

Help on function get_str_type in module idc:

get_str_type(ea)
    Get string type
    
    @param ea: linear address
    
    @return: One of STRTYPE_... constants

Help on function get_strlit_contents in module idc:

get_strlit_contents(ea, length=-1, strtype=0)
    Get string contents
    @param ea: linear address
    @param length: string length. -1 means to calculate the max string length
    @param strtype: the string type (one of STRTYPE_... constants)
    
    @return: string contents or empty string

Help on function get_struc_by_idx in module ida_struct:

get_struc_by_idx(*args) -> 'tid_t'
    get_struc_by_idx(idx) -> tid_t
    
    
    Get struct id by struct number.
    
    
    @param idx (C++: uval_t)

Help on function get_struc_cmt in module ida_struct:

get_struc_cmt(*args) -> 'qstring *'
    get_struc_cmt(id, repeatable) -> str
    
    
    Get struct comment.
    
    
    @param id (C++: tid_t)
    @param repeatable (C++: bool)

Help on function get_struc_id in module ida_struct:

get_struc_id(*args) -> 'tid_t'
    get_struc_id(name) -> tid_t
    
    
    Get struct id by name.
    
    
    @param name (C++: const char *)

Help on function get_struc_idx in module ida_struct:

get_struc_idx(*args) -> 'uval_t'
    get_struc_idx(id) -> uval_t
    
    
    Get internal number of the structure.
    
    
    @param id (C++: tid_t)

Help on function get_struc_name in module ida_struct:

get_struc_name(*args) -> 'qstring *'
    get_struc_name(id, flags=0) -> str
    
    
    Get struct name by id
    
    @param id: struct id (C++: tid_t)
    @param flags: Struct name flags (C++: int)

Help on function get_struc_qty in module ida_struct:

get_struc_qty(*args) -> 'size_t'
    get_struc_qty() -> size_t
    
    
    Get number of known structures.

Help on function get_struc_size in module ida_struct:

get_struc_size(*args) -> 'asize_t'
    get_struc_size(sptr) -> asize_t
    get_struc_size(id) -> asize_t
    
    
    Get struct size (also see 'get_struc_size(tid_t)' )
    
    
    @param sptr (C++: const  struc_t  *)

Help on function get_tev_ea in module ida_dbg:

get_tev_ea(*args) -> 'ea_t'
    get_tev_ea(n) -> ea_t

Help on function get_tev_reg_mem in module ida_dbg:

get_tev_reg_mem(tev, idx)

Help on function get_tev_reg_mem_ea in module ida_dbg:

get_tev_reg_mem_ea(tev, idx)

Help on function get_tev_reg_mem_qty in module ida_dbg:

get_tev_reg_mem_qty(tev)

Help on function get_tev_qty in module ida_dbg:

get_tev_qty(*args) -> 'int'
    get_tev_qty() -> int
    
    
    Get number of trace events available in trace buffer. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

Help on function get_tev_reg_val in module ida_dbg:

get_tev_reg_val(tev, reg)

Help on function get_tev_tid in module ida_dbg:

get_tev_tid(*args) -> 'int'
    get_tev_tid(n) -> int

Help on function get_tev_type in module ida_dbg:

get_tev_type(*args) -> 'int'
    get_tev_type(n) -> int

Help on function get_thread_qty in module ida_dbg:

get_thread_qty(*args) -> 'int'
    get_thread_qty() -> int
    
    
    Get number of threads. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}

Help on function get_tinfo in module idc:

get_tinfo(ea)
    Get type information of function/variable as 'typeinfo' object
    
    @param ea: the address of the object
    @return: None on failure, or (type, fields) tuple.

Help on function get_trace_file_desc in module ida_dbg:

get_trace_file_desc(*args) -> 'qstring *'
    get_trace_file_desc(filename) -> str
    
    
    Get the file header of the specified trace file.
    
    
    @param filename (C++: const char *)

Help on function get_type in module idc:

get_type(ea)
    Get type of function/variable
    
    @param ea: the address of the object
    
    @return: type string or None if failed

Help on function get_wide_byte in module ida_bytes:

get_wide_byte(*args) -> 'uint64'
    get_wide_byte(ea) -> uint64
    
    
    Get one wide byte of the program at 'ea'. Some processors may access
    more than 8bit quantity at an address. These processors have 32-bit
    byte organization from the IDA's point of view.
    
    @param ea (C++: ea_t)

Help on function get_wide_dword in module ida_bytes:

get_wide_dword(*args) -> 'uint64'
    get_wide_dword(ea) -> uint64
    
    
    Get two wide words (4 'bytes') of the program at 'ea'. Some processors
    may access more than 8bit quantity at an address. These processors
    have 32-bit byte organization from the IDA's point of view. This
    function takes into account order of bytes specified in
    \inf{is_be()}this function works incorrectly if \ph{nbits} > 16
    
    @param ea (C++: ea_t)

Help on function get_wide_word in module ida_bytes:

get_wide_word(*args) -> 'uint64'
    get_wide_word(ea) -> uint64
    
    
    Get one wide word (2 'byte') of the program at 'ea'. Some processors
    may access more than 8bit quantity at an address. These processors
    have 32-bit byte organization from the IDA's point of view. This
    function takes into account order of bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)

Help on function get_xref_type in module idc:

get_xref_type()
    Return type of the last xref obtained by
    [RD]first/next[B0] functions.
    
    @return: constants fl_* or dr_*

Help on function getn_enum in module ida_enum:

getn_enum(*args) -> 'enum_t'
    getn_enum(n) -> enum_t
    
    
    Get enum by its ordinal number (0..n).
    
    
    @param n (C++: size_t)

Help on function getn_thread in module ida_dbg:

getn_thread(*args) -> 'thid_t'
    getn_thread(n) -> thid_t
    
    
    Get the ID of a thread. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param n: number of thread, is in range 0.. get_thread_qty() -1 (C++:
              int)
    @return: NO_THREAD  if the thread doesn't exist.

Help on function getn_thread_name in module ida_dbg:

getn_thread_name(*args) -> 'char const *'
    getn_thread_name(n) -> char const *
    
    
    Get the NAME of a thread \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param n: number of thread, is in range 0.. get_thread_qty() -1 or -1
              for the current thread (C++: int)
    @return: thread name or NULL if the thread doesn't exist.

Help on function guess_type in module idc:

guess_type(ea)
    Guess type of function/variable
    
    @param ea: the address of the object, can be the structure member id too
    
    @return: type string or None if failed

Help on function hasName in module idc:

hasName(F)

Help on function hasUserName in module idc:

hasUserName(F)

Help on function has_value in module idc:

has_value(F)

Help on function here in module idc:

here()
    # Convenience functions:

Help on function idadir in module idc:

idadir()
    Get IDA directory
    
    This function returns the directory where IDA.EXE resides

Help on function import_type in module idc:

import_type(idx, type_name)
    Copy information from type library to database
    Copy structure, union, or enum definition from the type library
    to the IDA database.
    
    @param idx: the position of the new type in the list of
                types (structures or enums) -1 means at the end of the list
    @param type_name: name of type to copy
    
    @return: BADNODE-failed, otherwise the type id (structure id or enum id)

Help on function isBin0 in module idc:

isBin0(F)

Help on function isBin1 in module idc:

isBin1(F)

Help on function isDec0 in module idc:

isDec0(F)

Help on function isDec1 in module idc:

isDec1(F)

Help on function isExtra in module idc:

isExtra(F)

Help on function isHex0 in module idc:

isHex0(F)

Help on function isHex1 in module idc:

isHex1(F)

Help on function isOct0 in module idc:

isOct0(F)

Help on function isOct1 in module idc:

isOct1(F)

Help on function isRef in module idc:

isRef(F)

Help on function is_align in module idc:

is_align(F)

Help on function is_bf in module ida_enum:

is_bf(*args) -> 'bool'
    is_bf(id) -> bool
    
    
    Is enum a bitfield? (otherwise - plain enum, no bitmasks except for
    'DEFMASK' are allowed)
    
    @param id (C++: enum_t)

Help on function is_byte in module idc:

is_byte(F)

Help on function is_char0 in module idc:

is_char0(F)

Help on function is_char1 in module idc:

is_char1(F)

Help on function is_code in module idc:

is_code(F)

Help on function is_data in module idc:

is_data(F)

Help on function is_defarg0 in module idc:

is_defarg0(F)

Help on function is_defarg1 in module idc:

is_defarg1(F)

Help on function is_double in module idc:

is_double(F)

Help on function is_dword in module idc:

is_dword(F)

Help on function is_enum0 in module idc:

is_enum0(F)

Help on function is_enum1 in module idc:

is_enum1(F)

Help on function is_event_handled in module idc:

is_event_handled()
    Is the debug event handled?
    
    @return: boolean

Help on function is_float in module idc:

is_float(F)

Help on function is_flow in module idc:

is_flow(F)

Help on function is_head in module idc:

is_head(F)

Help on function is_loaded in module idc:

is_loaded(ea)
    Is the byte initialized?

Help on function is_manual0 in module idc:

is_manual0(F)

Help on function is_manual1 in module idc:

is_manual1(F)

Help on function is_mapped in module idc:

is_mapped(ea)

Help on function is_off0 in module idc:

is_off0(F)

Help on function is_off1 in module idc:

is_off1(F)

Help on function is_oword in module idc:

is_oword(F)

Help on function is_pack_real in module idc:

is_pack_real(F)

Help on function is_qword in module idc:

is_qword(F)

Help on function is_seg0 in module idc:

is_seg0(F)

Help on function is_seg1 in module idc:

is_seg1(F)

Help on function is_stkvar0 in module idc:

is_stkvar0(F)

Help on function is_stkvar1 in module idc:

is_stkvar1(F)

Help on function is_strlit in module idc:

is_strlit(F)

Help on function is_stroff0 in module idc:

is_stroff0(F)

Help on function is_stroff1 in module idc:

is_stroff1(F)

Help on function is_struct in module idc:

is_struct(F)

Help on function is_tail in module idc:

is_tail(F)

Help on function is_tbyte in module idc:

is_tbyte(F)

Help on function is_union in module idc:

is_union(sid)
    Is a structure a union?
    
    @param sid: structure type ID
    
    @return: 1: yes, this is a union id
             0: no
    
    @note: Unions are a special kind of structures

Help on function is_unknown in module idc:

is_unknown(F)

Help on function is_valid_trace_file in module ida_dbg:

is_valid_trace_file(*args) -> 'bool'
    is_valid_trace_file(filename) -> bool
    
    
    Is the specified file a valid trace file for the current database?
    
    
    @param filename (C++: const char *)

Help on function is_word in module idc:

is_word(F)

Help on function jumpto in module ida_kernwin:

jumpto(*args) -> 'bool'
    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
    jumpto(custom_viewer, place, x, y) -> bool
    
    
    Jump to the specified address ( 'ui_jumpto' ).
    
    @param ea: destination (C++: ea_t)
    @param opnum: -1: don't change x coord (C++: int)
    @param uijmp_flags: Jump flags (C++: int)
    @return: success

Help on function load_and_run_plugin in module ida_loader:

load_and_run_plugin(*args) -> 'bool'
    load_and_run_plugin(name, arg) -> bool
    
    
    Load & run a plugin.
    
    
    @param name (C++: const char *)
    @param arg (C++: size_t)

Help on function load_debugger in module ida_dbg:

load_debugger(*args) -> 'bool'
    load_debugger(dbgname, use_remote) -> bool

Help on function load_trace_file in module ida_dbg:

load_trace_file(*args) -> 'qstring *'
    load_trace_file(filename) -> str
    
    
    Load a recorded trace file in the trace window. If the call succeeds
    and 'buf' is not null, the description of the trace stored in the
    binary trace file will be returned in 'buf'
    
    @param filename (C++: const char *)

Help on function loadfile in module idc:

loadfile(filepath, pos, ea, size)

Help on function ltoa in module idc:

ltoa(n, radix)

Help on function make_array in module idc:

make_array(ea, nitems)
    Create an array.
    
    @param ea: linear address
    @param nitems: size of array in items
    
    @note: This function will create an array of the items with the same type as
    the type of the item at 'ea'. If the byte at 'ea' is undefined, then
    this function will create an array of bytes.

Help on function move_segm in module idc:

move_segm(ea, to, flags)
    Move a segment to a new address
    This function moves all information to the new address
    It fixes up address sensitive information in the kernel
    The total effect is equal to reloading the segment to the target address
    
    @param ea: any address within the segment to move
    @param to: new segment start address
    @param flags: combination MFS_... constants
    
    @returns: MOVE_SEGM_... error code

Help on function msg in module ida_kernwin:

msg(*args) -> 'PyObject *'
    msg(o) -> PyObject *
    
    
    Display an UTF-8 string in the message window
    
    The result of the stringification of the arguments
    will be treated as an UTF-8 string.
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts

Help on function next_addr in module ida_bytes:

next_addr(*args) -> 'ea_t'
    next_addr(ea) -> ea_t
    
    
    Get next address in the program (i.e. next address which has flags).
    
    @param ea (C++: ea_t)
    @return: BADADDR  if no such address exist.

Help on function next_func_chunk in module idc:

next_func_chunk(funcea, tailea)
    Get the next function chunk of the specified function
    
    @param funcea: any address in the function
    @param tailea: any address in the current chunk
    
    @return: the starting address of the next function chunk or BADADDR
    
    @note: This function returns the next chunk of the specified function

Help on function next_head in module idc:

next_head(ea, maxea=BADADDR)↗
    Get next defined item (instruction or data) in the program
    
    @param ea: linear address to start search from
    @param maxea: the search will stop at the address
        maxea is not included in the search range
    
    @return: BADADDR - no (more) defined items

Help on function next_not_tail in module ida_bytes:

next_not_tail(*args) -> 'ea_t'
    next_not_tail(ea) -> ea_t
    
    
    Get address of next non-tail byte.
    
    @param ea (C++: ea_t)
    @return: BADADDR  if none exists.

Help on function op_bin in module ida_bytes:

op_bin(*args) -> 'bool'
    op_bin(ea, n) -> bool
    
    
    set op type to 'bin_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_chr in module ida_bytes:

op_chr(*args) -> 'bool'
    op_chr(ea, n) -> bool
    
    
    set op type to 'char_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_dec in module ida_bytes:

op_dec(*args) -> 'bool'
    op_dec(ea, n) -> bool
    
    
    set op type to 'dec_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_enum in module ida_bytes:

op_enum(*args) -> 'bool'
    op_enum(ea, n, id, serial) -> bool
    
    
    Set operand representation to be 'enum_t'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, -1) (C++: int)
    @param id: id of enum (C++: enum_t)
    @param serial: the serial number of the constant in the enumeration,
                   usually 0. the serial numbers are used if the
                   enumeration contains several constants with the same
                   value (C++: uchar)
    @return: success

Help on function op_flt in module ida_bytes:

op_flt(*args) -> 'bool'
    op_flt(ea, n) -> bool
    
    
    set op type to 'flt_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_hex in module ida_bytes:

op_hex(*args) -> 'bool'
    op_hex(ea, n) -> bool
    
    
    set op type to 'hex_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function set_forced_operand in module ida_bytes:

set_forced_operand(*args) -> 'bool'
    set_forced_operand(ea, n, op) -> bool
    
    
    Set forced operand.
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, 2) (C++: int)
    @param op: text of operand   NULL: do nothing (return 0)   "" : delete
               forced operand (C++: const char *)
    @return: success

Help on function op_num in module ida_bytes:

op_num(*args) -> 'bool'
    op_num(ea, n) -> bool
    
    
    set op type to 'num_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_oct in module ida_bytes:

op_oct(*args) -> 'bool'
    op_oct(ea, n) -> bool
    
    
    set op type to 'oct_flag()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function op_offset in module ida_offset:

op_offset(*args) -> 'int'
    op_offset(ea, n, type, target=BADADDR, base=0, tdelta=0) -> int
    
    
    See 'op_offset_ex()'
    
    
    @param ea (C++: ea_t)
    @param n (C++: int)
    @param type (C++: reftype_t)
    @param target (C++: ea_t)
    @param base (C++: ea_t)
    @param tdelta (C++: adiff_t)

Help on function op_offset_high16 in module idc:

op_offset_high16(ea, n, target)
    Convert operand to a high offset
    High offset is the upper 16bits of an offset.
    This type is used by TMS320C6 processors (and probably by other
    RISC processors too)
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands
    @param target: the full value (all 32bits) of the offset

Help on function op_plain_offset in module idc:

op_plain_offset(ea, n, base)
    Convert operand to an offset
    (for the explanations of 'ea' and 'n' please see op_bin())
    
    Example:
    ========
    
        seg000:2000 dw      1234h
    
        and there is a segment at paragraph 0x1000 and there is a data item
        within the segment at 0x1234:
    
        seg000:1234 MyString        db 'Hello, world!',0
    
        Then you need to specify a linear address of the segment base to
        create a proper offset:
    
        op_plain_offset(["seg000",0x2000],0,0x10000);
    
        and you will have:
    
        seg000:2000 dw      offset MyString
    
    Motorola 680x0 processor have a concept of "outer offsets".
    If you want to create an outer offset, you need to combine number
    of the operand with the following bit:
    
    Please note that the outer offsets are meaningful only for
    Motorola 680x0.
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands
    @param base: base of the offset as a linear address
        If base == BADADDR then the current operand becomes non-offset

Help on function op_seg in module ida_bytes:

op_seg(*args) -> 'bool'
    op_seg(ea, n) -> bool
    
    
    Set operand representation to be 'segment'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, -1) (C++: int)
    @return: success

Help on function op_stkvar in module ida_bytes:

op_stkvar(*args) -> 'bool'
    op_stkvar(ea, n) -> bool
    
    
    Set operand representation to be 'stack variable'. Should be applied
    to an instruction within a function. Should be applied after creating
    a stack var using 'insn_t::create_stkvar()' .
    
    @param ea: linear address (C++: ea_t)
    @param n: number of operand (0, 1, -1) (C++: int)
    @return: success

Help on function op_stroff in module idc:

op_stroff(ea, n, strid, delta)
    Convert operand to an offset in a structure
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands
    @param strid: id of a structure type
    @param delta: struct offset delta. usually 0. denotes the difference
                    between the structure base and the pointer into the structure.

Help on function parse_decl in module idc:

parse_decl(inputtype, flags)
    Parse type declaration
    
    @param inputtype: file name or C declarations (depending on the flags)
    @param flags: combination of PT_... constants or 0
    
    @return: None on failure or (name, type, fields) tuple

Help on function parse_decls in module idc:

parse_decls(inputtype, flags=0)
    Parse type declarations
    
    @param inputtype: file name or C declarations (depending on the flags)
    @param flags: combination of PT_... constants or 0
    
    @return: number of parsing errors (0 no errors)

Help on function patch_byte in module ida_bytes:

patch_byte(*args) -> 'bool'
    patch_byte(ea, x) -> bool
    
    
    Patch a byte of the program. The original value of the byte is saved
    and can be obtained by 'get_original_byte()' . This function works for
    wide byte processors too.
    
    @param ea (C++: ea_t)
    @param x (C++: uint64)

Help on function put_dbg_byte in module ida_dbg:

put_dbg_byte(*args) -> 'bool'
    put_dbg_byte(ea, x) -> bool
    
    
    Change one byte of the debugged process memory.
    
    @param ea: linear address (C++: ea_t)
    @param x: byte value (C++: uint32)
    @return: true if the process memory has been modified

Help on function patch_dword in module ida_bytes:

patch_dword(*args) -> 'bool'
    patch_dword(ea, x) -> bool
    
    
    Patch a dword of the program. The original value of the dword is saved
    and can be obtained by 'get_original_dword()' . This function DOESN'T
    work for wide byte processors. This function takes into account order
    of bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)
    @param x (C++: uint64)

Help on function patch_qword in module ida_bytes:

patch_qword(*args) -> 'bool'
    patch_qword(ea, x) -> bool
    
    
    Patch a qword of the program. The original value of the qword is saved
    and can be obtained by 'get_original_qword()' . This function DOESN'T
    work for wide byte processors. This function takes into account order
    of bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)
    @param x (C++: uint64)

Help on function patch_word in module ida_bytes:

patch_word(*args) -> 'bool'
    patch_word(ea, x) -> bool
    
    
    Patch a word of the program. The original value of the word is saved
    and can be obtained by 'get_original_word()' . This function works for
    wide byte processors too. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    @param ea (C++: ea_t)
    @param x (C++: uint64)

Help on function plan_and_wait in module idc:

plan_and_wait(sEA, eEA, final_pass=True)
    Perform full analysis of the range
    
    @param sEA: starting linear address
    @param eEA: ending linear address (excluded)
    @param final_pass: make the final pass over the specified range
    
    @return: 1-ok, 0-Ctrl-Break was pressed.

Help on function plan_to_apply_idasgn in module ida_funcs:

plan_to_apply_idasgn(*args) -> 'int'
    plan_to_apply_idasgn(fname) -> int
    
    
    Add a signature file to the list of planned signature files.
    
    @param fname: file name. should not contain directory part. (C++:
                  const char *)
    @return: 0 if failed, otherwise number of planned (and applied)
             signatures

Help on function prev_addr in module ida_bytes:

prev_addr(*args) -> 'ea_t'
    prev_addr(ea) -> ea_t
    
    
    Get previous address in the program.
    
    @param ea (C++: ea_t)
    @return: BADADDR  if no such address exist.

Help on function prev_head in module idc:

prev_head(ea, minea=0)
    Get previous defined item (instruction or data) in the program
    
    @param ea: linear address to start search from
    @param minea: the search will stop at the address
            minea is included in the search range
    
    @return: BADADDR - no (more) defined items

Help on function prev_not_tail in module ida_bytes:

prev_not_tail(*args) -> 'ea_t'
    prev_not_tail(ea) -> ea_t
    
    
    Get address of previous non-tail byte.
    
    @param ea (C++: ea_t)
    @return: BADADDR  if none exists.

Help on function print_decls in module idc:

print_decls(ordinals, flags)
    Print types in a format suitable for use in a header file
    
    @param ordinals: comma-separated list of type ordinals
    @param flags: combination of PDF_... constants or 0
    
    @return: string containing the type definitions

Help on _Feature in module __future__ object:

class _Feature(builtins.object)
 |  Methods defined here:
 |  
 |  __init__(self, optionalRelease, mandatoryRelease, compiler_flag)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__(self)
 |      Return repr(self).
 |  
 |  getMandatoryRelease(self)
 |      Return release in which this feature will become mandatory.
 |      
 |      This is a 5-tuple, of the same form as sys.version_info, or, if
 |      the feature was dropped, is None.
 |  
 |  getOptionalRelease(self)
 |      Return first release in which this feature was recognized.
 |      
 |      This is a 5-tuple, of the same form as sys.version_info.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function print_insn_mnem in module idc:

print_insn_mnem(ea)
    Get instruction mnemonics
    
    @param ea: linear address of instruction
    
    @return: "" - no instruction at the specified location
    
    @note: this function may not return exactly the same mnemonics
    as you see on the screen.

Help on function print_operand in module idc:

print_operand(ea, n)
    Get operand of an instruction or data
    
    @param ea: linear address of the item
    @param n: number of operand:
        0 - the first operand
        1 - the second operand
    
    @return: the current text representation of operand or ""

Help on function process_config_line in module idc:

process_config_line(directive)
    Parse one or more ida.cfg config directives
    @param directive: directives to process, for example: PACK_DATABASE=2
    
    @note: If the directives are erroneous, a fatal error will be generated.
           The settings are permanent: effective for the current session and the next ones

Help on function process_ui_action in module idc:

process_ui_action(name, flags=0)
    Invokes an IDA UI action by name
    
    @param name: Command name
    @param flags: Reserved. Must be zero
    @return: Boolean

Help on function mark_position in module ida_idc:

mark_position(*args) -> 'void'
    mark_position(ea, lnnum, x, y, slot, comment)

Help on function qexit in module ida_pro:

qexit(*args) -> 'void'
    qexit(code)
    
    
    Call qatexit functions, shut down UI and kernel, and exit.
    
    @param code: exit code (C++: int)

Help on function qsleep in module idc:

qsleep(milliseconds)
    qsleep the specified number of milliseconds
    This function suspends IDA for the specified amount of time
    
    @param milliseconds: time to sleep

Help on function read_dbg_byte in module idc:

read_dbg_byte(ea)
    Get value of program byte using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function read_dbg_dword in module idc:

read_dbg_dword(ea)
    Get value of program double-word using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function dbg_read_memory in module ida_idd:

dbg_read_memory(*args) -> 'PyObject *'
    dbg_read_memory(ea, sz) -> PyObject *
    
    
    Reads from the debugee's memory at the specified ea
    @return:
        - The read buffer (as a string)
        - Or None on failure

Help on function read_dbg_qword in module idc:

read_dbg_qword(ea)
    Get value of program quadro-word using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function read_dbg_word in module idc:

read_dbg_word(ea)
    Get value of program word using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function read_selection_end in module idc:

read_selection_end()
    Get end address of the selected range
    
    @return: BADADDR - the user has not selected an range

Help on function read_selection_start in module idc:

read_selection_start()
    Get start address of the selected range
    returns BADADDR - the user has not selected an range

Help on function readlong in module idc:

readlong(handle, mostfirst)

Help on function readshort in module idc:

readshort(handle, mostfirst)

Help on function readstr in module idc:

readstr(handle)

Help on function rebase_program in module ida_segment:

rebase_program(*args) -> 'int'
    rebase_program(delta, flags) -> int
    
    
    Rebase the whole program by 'delta' bytes.
    
    @param delta: number of bytes to move the program (C++: adiff_t)
    @param flags: Move segment flags  it is recommended to use
                  MSF_FIXONCE  so that the loader takes care of global
                  variables it stored in the database (C++: int)
    @return: Move segment result codes

Help on function recalc_spd in module ida_frame:

recalc_spd(*args) -> 'bool'
    recalc_spd(cur_ea) -> bool
    
    
    Recalculate SP delta for an instruction that stops execution. The next
    instruction is not reached from the current instruction. We need to
    recalculate SP for the next instruction.This function will create a
    new automatic SP register change point if necessary. It should be
    called from the emulator (emu.cpp) when auto_state == 'AU_USED' if the
    current instruction doesn't pass the execution flow to the next
    instruction.
    
    @param cur_ea: linear address of the current instruction (C++: ea_t)

Help on function refresh_debugger_memory in module ida_dbg:

refresh_debugger_memory(*args) -> 'PyObject *'
    refresh_debugger_memory() -> PyObject *
    
    
    Refreshes the debugger memory
    @return: Nothing

Help on function refresh_idaview_anyway in module ida_kernwin:

refresh_idaview_anyway(*args) -> 'void'
    refresh_idaview_anyway()
    
    
    Refresh all disassembly views ( 'ui_refresh' ), forces an immediate
    refresh. Please consider 'request_refresh()' instead

Help on function refresh_choosers in module ida_kernwin:

refresh_choosers(*args) -> 'void'
    refresh_choosers()

Help on function remove_fchunk in module idc:

remove_fchunk(funcea, tailea)
    Remove a function chunk from the function
    
    @param funcea: any address in the function
    @param tailea: any address in the function chunk to remove
    
    @return: 0 if failed, 1 if success

Help on function rename_array in module idc:

rename_array(array_id, newname)
    Rename array, by its ID.
    
    @param id: The ID of the array to rename.
    @param newname: The new name of the array.
    
    @return: 1 in case of success, 0 otherwise

Help on function rename_entry in module ida_entry:

rename_entry(*args) -> 'bool'
    rename_entry(ord, name, flags=0) -> bool
    
    
    Rename entry point.
    
    @param ord: ordinal number of the entry point (C++: uval_t)
    @param name: name of entry point. If the specified location already
                 has a name, the old name will be appended to a repeatable
                 comment. (C++: const char *)
    @param flags: See AEF_* (C++: int)
    @return: success

Help on function resume_process in module idc:

resume_process()

Help on function resume_thread in module ida_dbg:

resume_thread(*args) -> 'int'
    resume_thread(tid) -> int
    
    
    Resume thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    @param tid: thread id (C++: thid_t)

Help on function retrieve_input_file_md5 in module ida_nalt:

retrieve_input_file_md5(*args) -> 'uchar [ANY]'
    retrieve_input_file_md5() -> str
    
    
    Get input file md5.

Help on function rotate_byte in module idc:

rotate_byte(x, count)

Help on function rotate_dword in module idc:

rotate_dword(x, count)

Help on function rotate_left in module idc:

rotate_left(value, count, nbits, offset)
    Rotate a value to the left (or right)
    
    @param value: value to rotate
    @param count: number of times to rotate. negative counter means
                  rotate to the right
    @param nbits: number of bits to rotate
    @param offset: offset of the first bit to rotate
    
    @return: the value with the specified field rotated
             all other bits are not modified

Help on function rotate_word in module idc:

rotate_word(x, count)

Help on function run_to in module ida_dbg:

run_to(*args) -> 'bool'
    run_to(ea, pid=pid_t(-1), tid=0) -> bool
    
    
    Execute the process until the given address is reached. If no process
    is active, a new process is started. Technically, the debugger sets up
    a temporary breakpoint at the given address, and continues (or starts)
    the execution of the whole process. So, all threads continue their
    execution! \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_run_to' }
    
    @param ea: target address (C++: ea_t)
    @param pid: not used yet. please do not specify this parameter. (C++:
                pid_t)
    @param tid: not used yet. please do not specify this parameter. (C++:
                thid_t)

Help on function save_database in module idc:

save_database(idbname, flags=0)
    Save current database to the specified idb file
    
    @param idbname: name of the idb file. if empty, the current idb
                    file will be used.
    @param flags: combination of ida_loader.DBFL_... bits or 0

Help on function save_trace_file in module ida_dbg:

save_trace_file(*args) -> 'bool'
    save_trace_file(filename, description) -> bool
    
    
    Save the current trace in the specified file.
    
    
    @param filename (C++: const char *)
    @param description (C++: const char *)

Help on function savefile in module idc:

savefile(filepath, pos, ea, size)

Help on function sel2para in module idc:

sel2para(sel)
    Get a selector value
    
    @param sel: the selector number
    
    @return: selector value if found
             otherwise the input value (sel)
    
    @note: selector values are always in paragraphs

Help on function select_thread in module ida_dbg:

select_thread(*args) -> 'bool'
    select_thread(tid) -> bool
    
    
    Select the given thread as the current debugged thread. All thread
    related execution functions will work on this thread. The process must
    be suspended to select a new thread. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param tid: ID of the thread to select (C++: thid_t)
    @return: false if the thread doesn't exist.

Help on function selector_by_name in module idc:

selector_by_name(segname)
    Get segment selector by name
    
    @param segname: name of segment
    
    @return: segment selector or BADADDR

Help on function send_dbg_command in module idc:

send_dbg_command(cmd)
    Sends a command to the debugger module and returns the output string.
    An exception will be raised if the debugger is not running or the current debugger does not export
    the 'send_dbg_command' IDC command.

Help on function set_array_long in module idc:

set_array_long(array_id, idx, value)
    Sets the long value of an array element.
    
    @param array_id: The array ID.
    @param idx: Index of an element.
    @param value: 32bit or 64bit value to store in the array
    
    @return: 1 in case of success, 0 otherwise

Help on function set_array_params in module idc:

set_array_params(ea, flags, litems, align)
    Set array representation format
    
    @param ea: linear address
    @param flags: combination of AP_... constants or 0
    @param litems: number of items per line. 0 means auto
    @param align: element alignment
                  - -1: do not align
                  - 0:  automatic alignment
                  - other values: element width
    
    @return: 1-ok, 0-failure

Help on function set_array_string in module idc:

set_array_string(array_id, idx, value)
    Sets the string value of an array element.
    
    @param array_id: The array ID.
    @param idx: Index of an element.
    @param value: String value to store in the array
    
    @return: 1 in case of success, 0 otherwise

Help on function set_bmask_cmt in module idc:

set_bmask_cmt(enum_id, bmask, cmt, repeatable)
    Set bitmask comment (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    @param cmt: comment
    repeatable - type of comment, 0-regular, 1-repeatable
    
    @return: 1-ok, 0-failed

Help on function set_bmask_name in module idc:

set_bmask_name(enum_id, bmask, name)
    Set bitmask name (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    @param name: name of bitmask
    
    @return: 1-ok, 0-failed

Help on function set_bpt_attr in module idc:

set_bpt_attr(address, bptattr, value)
        modifiable characteristics of a breakpoint
    
    @param address: any address in the breakpoint range
    @param bptattr: the attribute code, one of BPTATTR_* constants
                    BPTATTR_CND is not allowed, see set_bpt_cond()
    @param value: the attibute value
    
    @return: success

Help on function set_bpt_cond in module idc:

set_bpt_cond(ea, cnd, is_lowcnd=0)
    Set breakpoint condition
    
    @param ea: any address in the breakpoint range
    @param cnd: breakpoint condition
    @param is_lowcnd: 0 - regular condition, 1 - low level condition
    
    @return: success

Help on function set_cmt in module ida_bytes:

set_cmt(*args) -> 'bool'
    set_cmt(ea, comm, rptble) -> bool
    
    
    Set an indented comment.
    
    @param ea: linear address (C++: ea_t)
    @param comm: comment string   NULL: do nothing (return 0)   "" :
                 delete comment (C++: const char *)
    @param rptble: is repeatable? (C++: bool)
    @return: success

Help on function set_color in module idc:

set_color(ea, what, color)
    Set item color
    
    @param ea: address of the item
    @param what: type of the item (one of CIC_* constants)
    @param color: new color code in RGB (hex 0xBBGGRR)
    
    @return: success (True or False)

Help on function set_debugger_event_cond in module ida_dbg:

set_debugger_event_cond(*args) -> 'void'
    set_debugger_event_cond(nonnul_cond)

Help on function set_debugger_options in module ida_dbg:

set_debugger_options(*args) -> 'uint'
    set_debugger_options(options) -> uint
    
    
    Set debugger options. Replaces debugger options with the specification
    combination 'Debugger options'
    
    @param options (C++: uint)
    @return: the old debugger options

Help on function set_default_sreg_value in module idc:

set_default_sreg_value(ea, reg, value)
    Set default segment register value for a segment
    
    @param ea: any address in the segment
               if no segment is present at the specified address
               then all segments will be affected
    @param reg: name of segment register
    @param value: default value of the segment register. -1-undefined.

Help on function set_enum_bf in module ida_enum:

set_enum_bf(*args) -> 'bool'
    set_enum_bf(id, bf) -> bool
    
    
    Set 'bitfield' bit of enum (i.e. convert it to a bitfield)
    
    
    @param id (C++: enum_t)
    @param bf (C++: bool)

Help on function set_enum_cmt in module ida_enum:

set_enum_cmt(*args) -> 'bool'
    set_enum_cmt(id, cmt, repeatable) -> bool
    
    
    Set comment for enum type.
    
    
    @param id (C++: enum_t)
    @param cmt (C++: const char *)
    @param repeatable (C++: bool)

Help on function set_enum_flag in module ida_enum:

set_enum_flag(*args) -> 'bool'
    set_enum_flag(id, flag) -> bool
    
    
    Set data representation flags.
    
    
    @param id (C++: enum_t)
    @param flag (C++: flags_t)

Help on function set_enum_idx in module ida_enum:

set_enum_idx(*args) -> 'bool'
    set_enum_idx(id, idx) -> bool
    
    
    Set serial number of enum. Also see 'get_enum_idx()' .
    
    @param id (C++: enum_t)
    @param idx (C++: size_t)

Help on function set_enum_member_cmt in module ida_enum:

set_enum_member_cmt(*args) -> 'bool'
    set_enum_member_cmt(id, cmt, repeatable) -> bool
    
    
    Set comment for enum member.
    
    
    @param id (C++: const_t)
    @param cmt (C++: const char *)
    @param repeatable (C++: bool)

Help on function set_enum_member_name in module ida_enum:

set_enum_member_name(*args) -> 'bool'
    set_enum_member_name(id, name) -> bool
    
    
    Set name of enum member.
    
    
    @param id (C++: const_t)
    @param name (C++: const char *)

Help on function set_enum_name in module ida_enum:

set_enum_name(*args) -> 'bool'
    set_enum_name(id, name) -> bool
    
    
    Set name of enum type.
    
    
    @param id (C++: enum_t)
    @param name (C++: const char *)

Help on function set_enum_width in module ida_enum:

set_enum_width(*args) -> 'bool'
    set_enum_width(id, width) -> bool
    
    
    See comment for 'get_enum_width()'
    
    
    @param id (C++: enum_t)
    @param width (C++: int)

Help on function set_fchunk_attr in module idc:

set_fchunk_attr(ea, attr, value)
    Set a function chunk attribute
    
    @param ea: any address in the chunk
    @param attr: only FUNCATTR_START, FUNCATTR_END, FUNCATTR_OWNER
    @param value: desired value
    
    @return: 0 if failed, 1 if success

Help on function set_fixup in module idc:

set_fixup(ea, fixuptype, fixupflags, targetsel, targetoff, displ)
    Set fixup information
    
    @param ea: address to set fixup information about
    @param fixuptype:  fixup type. see get_fixup_target_type()
                       for possible fixup types.
    @param fixupflags: fixup flags. see get_fixup_target_flags()
                       for possible fixup types.
    @param targetsel:  target selector
    @param targetoff:  target offset
    @param displ:      displacement
    
    @return:        none

Help on function set_flag in module idc:

set_flag(off, bit, value)
    #--------------------------------------------------------------------------

Help on function set_frame_size in module idc:

set_frame_size(ea, lvsize, frregs, argsize)
    Make function frame
    
    @param ea: any address belonging to the function
    @param lvsize: size of function local variables
    @param frregs: size of saved registers
    @param argsize: size of function arguments
    
    @return: ID of function frame or -1
             If the function did not have a frame, the frame
             will be created. Otherwise the frame will be modified

Help on function set_func_attr in module idc:

set_func_attr(ea, attr, value)
    Set a function attribute
    
    @param ea: any address belonging to the function
    @param attr: one of FUNCATTR_... constants
    @param value: new value of the attribute
    
    @return: 1-ok, 0-failed

Help on function set_func_cmt in module idc:

set_func_cmt(ea, cmt, repeatable)
    Set function comment
    
    @param ea: any address belonging to the function
    @param cmt: a function comment line
    @param repeatable: 1: get repeatable comment
            0: get regular comment

Help on function set_func_end in module ida_funcs:

set_func_end(*args) -> 'bool'
    set_func_end(ea, newend) -> bool
    
    
    Move function chunk end address.
    
    @param ea: any address in the function (C++: ea_t)
    @param newend: new end address of the function (C++: ea_t)
    @return: success

Help on function set_func_flags in module idc:

set_func_flags(ea, flags)
    Change function flags
    
    @param ea: any address belonging to the function
    @param flags: see get_func_flags() for explanations
    
    @return: !=0 - ok

Help on function set_hash_long in module idc:

set_hash_long(hash_id, key, value)
    Sets the long value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    @param value: 32bit or 64bit value to store in the hash
    
    @return: 1 in case of success, 0 otherwise

Help on function set_hash_string in module idc:

set_hash_string(hash_id, key, value)
    Sets the string value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    @param value: string value to store in the hash
    
    @return: 1 in case of success, 0 otherwise

Help on function set_ida_state in module ida_auto:

set_ida_state(*args) -> 'idastate_t'
    set_ida_state(st) -> idastate_t
    
    
    Change IDA status indicator value
    
    @param st: - new indicator status (C++: idastate_t)
    @return: old indicator status

Help on function set_inf_attr in module idc:

set_inf_attr(attr, value)

Help on function set_local_type in module idc:

set_local_type(ordinal, input, flags)
    Parse one type declaration and store it in the specified slot
    
    @param ordinal:  slot number (1...NumberOfLocalTypes)
                     -1 means allocate new slot or reuse the slot
                     of the existing named type
    @param input:  C declaration. Empty input empties the slot
    @param flags:  combination of PT_... constants or 0
    
    @return: slot number or 0 if error

Help on function set_manual_insn in module ida_bytes:

set_manual_insn(*args) -> 'void'
    set_manual_insn(ea, manual_insn)
    
    
    Set manual instruction string.
    
    @param ea: linear address of the instruction or data item (C++: ea_t)
    @param manual_insn: "" - delete manual string. NULL - do nothing (C++:
                        const char *)

Help on function set_member_cmt in module idc:

set_member_cmt(sid, member_offset, comment, repeatable)
    Change structure member comment
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    @param comment: new comment of the structure member
    @param repeatable: 1: change repeatable comment
                       0: change regular comment
    
    @return: != 0 - ok

Help on function set_member_name in module idc:

set_member_name(sid, member_offset, name)
    Change structure member name
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    @param name: new name of the member
    
    @return: != 0 - ok.

Help on function set_member_type in module idc:

set_member_type(sid, member_offset, flag, typeid, nitems, target=-1, tdelta=0, reftype=2)
    Change structure member type
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    @param flag: new type of the member. Should be one of
                 FF_BYTE..FF_PACKREAL (see above) combined with FF_DATA
    @param typeid: if is_struct(flag) then typeid specifies the structure id for the member
                   if is_off0(flag) then typeid specifies the offset base.
                   if is_strlit(flag) then typeid specifies the string type (STRTYPE_...).
                   if is_stroff(flag) then typeid specifies the structure id
                   if is_enum(flag) then typeid specifies the enum id
                   if is_custom(flags) then typeid specifies the dtid and fid: dtid|(fid<<16)
                   Otherwise typeid should be -1.
    @param nitems: number of items in the member
    
    @param target: target address of the offset expr. You may specify it as
                   -1, ida will calculate it itself
    @param tdelta: offset target delta. usually 0
    @param reftype: see REF_... definitions
    
    @note: The remaining arguments are allowed only if is_off0(flag) and you want
           to specify a complex offset expression
    
    @return: !=0 - ok.

Help on function set_name in module idc:

set_name(ea, name, flags=0)
    Rename an address
    
    @param ea: linear address
    @param name: new name of address. If name == "", then delete old name
    @param flags: combination of SN_... constants
    
    @return: 1-ok, 0-failure

Help on function set_processor_type in module ida_idp:

set_processor_type(*args) -> 'bool'
    set_processor_type(procname, level) -> bool
    
    
    Set target processor type. Once a processor module is loaded, it
    cannot be replaced until we close the idb.
    
    @param procname: name of processor type (one of names present in
                     \ph{psnames}) (C++: const char *)
    @param level: SETPROC_ (C++: setproc_level_t)
    @return: success

Help on function set_reg_value in module idc:

set_reg_value(value, name)
    Set register value
    
    @param name: the register name
    @param value: new register value
    
    @note: The debugger should be running
           It is not necessary to use this function to set register values.
           A register name in the left side of an assignment will do too.

Help on function set_remote_debugger in module ida_dbg:

set_remote_debugger(*args) -> 'void'
    set_remote_debugger(host, _pass, port=-1)
    
    
    Set remote debugging options. Should be used before starting the
    debugger.
    
    @param host: If empty, IDA will use local debugger. If NULL, the host
                 will not be set. (C++: const char *)
    @param port: If -1, the default port number will be used (C++: int)

Help on function set_root_filename in module ida_nalt:

set_root_filename(*args) -> 'void'
    set_root_filename(file)
    
    
    Set full path of the input file.
    
    
    @param file (C++: const char *)

Help on function set_segm_addressing in module idc:

set_segm_addressing(ea, bitness)
    Change segment addressing
    
    @param ea: any address in the segment
    @param bitness: 0: 16bit, 1: 32bit, 2: 64bit
    
    @return: success (boolean)

Help on function set_segm_alignment in module idc:

set_segm_alignment(ea, alignment)
    Change alignment of the segment
    
    @param ea: any address in the segment
    @param alignment: new alignment of the segment (one of the sa... constants)
    
    @return: success (boolean)

Help on function set_segm_attr in module idc:

set_segm_attr(segea, attr, value)
    Set segment attribute
    
    @param segea: any address within segment
    @param attr: one of SEGATTR_... constants
    
    @note: Please note that not all segment attributes are modifiable.
           Also some of them should be modified using special functions
           like set_segm_addressing, etc.

Help on function set_segm_class in module idc:

set_segm_class(ea, segclass)
    Change class of the segment
    
    @param ea: any address in the segment
    @param segclass: new class of the segment
    
    @return: success (boolean)

Help on function set_segm_combination in module idc:

set_segm_combination(segea, comb)
    Change combination of the segment
    
    @param segea: any address in the segment
    @param comb: new combination of the segment (one of the sc... constants)
    
    @return: success (boolean)

Help on function set_segm_name in module idc:

set_segm_name(ea, name)
    Change name of the segment
    
    @param ea: any address in the segment
    @param name: new name of the segment
    
    @return: success (boolean)

Help on function set_segm_type in module idc:

set_segm_type(segea, segtype)
    Set segment type
    
    @param segea: any address within segment
    @param segtype: new segment type:
    
    @return: !=0 - ok

Help on function set_segment_bounds in module idc:

set_segment_bounds(ea, startea, endea, flags)
    Change segment boundaries
    
    @param ea: any address in the segment
    @param startea: new start address of the segment
    @param endea: new end address of the segment
    @param flags: combination of SEGMOD_... flags
    
    @return: boolean success

Help on function set_selector in module ida_segment:

set_selector(*args) -> 'int'
    set_selector(selector, paragraph) -> int
    
    
    Set mapping of selector to a paragraph. You should call this
    functionbeforecreating a segment which uses the selector, otherwise
    the creation of the segment will fail.
    
    @param selector: number of selector to map   if selector ==  BADSEL ,
                     then return 0 (fail)   if the selector has had a
                     mapping, old mapping is destroyed   if the selector
                     number is equal to paragraph value, then the mapping
                     is destroyed because we don't need to keep trivial
                     mappings. (C++: sel_t)
    @param paragraph: paragraph to map selector (C++: ea_t)

Help on function set_source_linnum in module ida_nalt:

set_source_linnum(*args) -> 'void'
    set_source_linnum(ea, lnnum)

Help on function set_step_trace_options in module ida_dbg:

set_step_trace_options(*args) -> 'void'
    set_step_trace_options(options)
    
    
    Modify step tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param options (C++: int)

Help on function change_storage_type in module ida_bytes:

change_storage_type(*args) -> 'error_t'
    change_storage_type(start_ea, end_ea, stt) -> error_t
    
    
    Change flag storage type for address range.
    
    @param start_ea: should be lower than end_ea. (C++: ea_t)
    @param end_ea: does not belong to the range. (C++: ea_t)
    @param stt: storage_type_t (C++: storage_type_t)
    @return: error code

Help on function set_struc_cmt in module ida_struct:

set_struc_cmt(*args) -> 'bool'
    set_struc_cmt(id, cmt, repeatable) -> bool
    
    
    Set structure comment.
    
    
    @param id (C++: tid_t)
    @param cmt (C++: const char *)
    @param repeatable (C++: bool)

Help on function set_struc_idx in module idc:

set_struc_idx(sid, index)
    Change structure index
    
    @param sid: structure type ID
    @param index: new index of the structure
    
    @return: != 0 - ok
    
    @note: See get_first_struc_idx() for the explanation of
           structure indices and IDs.

Help on function set_struc_name in module ida_struct:

set_struc_name(*args) -> 'bool'
    set_struc_name(id, name) -> bool
    
    
    Set structure name.
    
    
    @param id (C++: tid_t)
    @param name (C++: const char *)

Help on function set_tail_owner in module idc:

set_tail_owner(tailea, funcea)
    Change the function chunk owner
    
    @param tailea: any address in the function chunk
    @param funcea: the starting address of the new owner
    
    @return: False if failed, True if success
    
    @note: The new owner must already have the chunk appended before the call

Help on function set_target_assembler in module ida_idp:

set_target_assembler(*args) -> 'bool'
    set_target_assembler(asmnum) -> bool
    
    
    Set target assembler.
    
    @param asmnum: number of assembler in the current processor module
                   (C++: int)
    @return: success

Help on function set_trace_file_desc in module ida_dbg:

set_trace_file_desc(*args) -> 'bool'
    set_trace_file_desc(filename, description) -> bool
    
    
    Change the description of the specified trace file.
    
    
    @param filename (C++: const char *)
    @param description (C++: const char *)

Help on function split_sreg_range in module idc:

split_sreg_range(ea, reg, value, tag=2)
    Set value of a segment register.
    
    @param ea: linear address
    @param reg: name of a register, like "cs", "ds", "es", etc.
    @param value: new value of the segment register.
    @param tag: of SR_... constants
    
    @note: IDA keeps tracks of all the points where segment register change their
           values. This function allows you to specify the correct value of a segment
           register if IDA is not able to find the corrent value.

Help on function start_process in module ida_dbg:

start_process(*args) -> 'int'
    start_process(path=None, args=None, sdir=None) -> int
    
    
    Start a process in the debugger. \sq{Type, Asynchronous function -
    available as Request, Notification, 'dbg_process_start' }You can also
    use the 'run_to()' function to easily start the execution of a process
    until a given address is reached.For all parameters, a NULL value
    indicates the debugger will take the value from the defined Process
    Options.
    
    @param path: path to the executable to start (C++: const char *)
    @param args: arguments to pass to process (C++: const char *)
    @param sdir: starting directory for the process (C++: const char *)

Help on function step_into in module ida_dbg:

step_into(*args) -> 'bool'
    step_into() -> bool
    
    
    Execute one instruction in the current thread. Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_into' }

Help on function step_over in module ida_dbg:

step_over(*args) -> 'bool'
    step_over() -> bool
    
    
    Execute one instruction in the current thread, but without entering
    into functions. Others threads keep suspended. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_step_over' }

Help on function step_until_ret in module ida_dbg:

step_until_ret(*args) -> 'bool'
    step_until_ret() -> bool
    
    
    Execute instructions in the current thread until a function return
    instruction is executed (aka "step out"). Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_until_ret' }

Help on function strlen in module idc:

strlen(s)

Help on function strstr in module idc:

strstr(s1, s2)

Help on function substr in module idc:

substr(s, x1, x2)

Help on function suspend_process in module ida_dbg:

suspend_process(*args) -> 'bool'
    suspend_process() -> bool
    
    
    Suspend the process in the debugger. \sq{ Type,Synchronous function
    (if in a notification handler)Asynchronous function (everywhere
    else)available as Request, Notification,none (if in a notification
    handler) 'dbg_suspend_process' (everywhere else) }The
    'suspend_process()' function can be called from a notification handler
    to force the stopping of the process. In this case, no notification
    will be generated. When you suspend a process, the running command is
    always aborted.

Help on function suspend_thread in module ida_dbg:

suspend_thread(*args) -> 'int'
    suspend_thread(tid) -> int
    
    
    Suspend thread. Suspending a thread may deadlock the whole application
    if the suspended was owning some synchronization objects. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    @param tid: thread id (C++: thid_t)

Help on function take_memory_snapshot in module ida_segment:

take_memory_snapshot(*args) -> 'bool'
    take_memory_snapshot(only_loader_segs) -> bool
    
    
    Take a memory snapshot of the running process.
    
    @param only_loader_segs: only is_loader_segm() segments will be
                             affected (C++: bool)
    @return: success

Help on function to_ea in module idc:

to_ea(seg, off)
    Return value of expression: ((seg<<4) + off)

Help on function toggle_bnot in module idc:

toggle_bnot(ea, n)
    Toggle the bitwise not operator for the operand
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands

Help on function toggle_sign in module ida_bytes:

toggle_sign(*args) -> 'bool'
    toggle_sign(ea, n) -> bool
    
    
    Toggle sign of n-th operand. allowed values of n: 0-first operand,
    1-other operands
    
    @param ea (C++: ea_t)
    @param n (C++: int)

Help on function update_extra_cmt in module ida_lines:

update_extra_cmt(*args) -> 'void'
    update_extra_cmt(ea, what, str)

Help on function update_hidden_range in module idc:

update_hidden_range(ea, visible)
    Set hidden range state
    
    @param ea:      any address belonging to the hidden range
    @param visible: new state of the range
    
    @return: != 0 - ok

Help on function validate_idb_names in module idc:

validate_idb_names(do_repair=0)
    check consistency of IDB name records
    @param do_repair: try to repair netnode header it TRUE
    @return: number of inconsistent name records

Help on function value_is_float in module idc:

value_is_float(var)

Help on function value_is_func in module idc:

value_is_func(var)

Help on function value_is_int64 in module idc:

value_is_int64(var)

Help on function value_is_long in module idc:

value_is_long(var)

Help on function value_is_pvoid in module idc:

value_is_pvoid(var)

Help on function value_is_string in module idc:

value_is_string(var)
    #         List of built-in functions
    #         --------------------------
    #
    # The following conventions are used in this list:
    #   'ea' is a linear address
    #   'success' is 0 if a function failed, 1 otherwise
    #   'void' means that function returns no meaningful value (always 0)
    #
    #  All function parameter conversions are made automatically.
    #
    # ----------------------------------------------------------------------------
    #                       M I S C E L L A N E O U S
    # ----------------------------------------------------------------------------

Help on function wait_for_next_event in module ida_dbg:

wait_for_next_event(*args) -> 'dbg_event_code_t'
    wait_for_next_event(wfne, timeout) -> dbg_event_code_t
    
    
    Wait for the next event.This function (optionally) resumes the process
    execution, and waits for a debugger event until a possible timeout
    occurs.
    
    @param wfne: combination of  Wait for debugger event flags  constants
                 (C++: int)
    @param timeout: number of seconds to wait, -1-infinity (C++: int)
    @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <=
             0)

Help on function warning in module ida_kernwin:

warning(*args) -> 'void'
    warning(format)
    
    
    Display a message in a message box
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts
    The user will be able to hide messages if they appear twice in a row on
    the screen

Help on function write_dbg_memory in module idc:

write_dbg_memory(ea, data)
    Write to debugger memory.
    
    @param ea: linear address
    @param data: string to write
    @return: number of written bytes (-1 - network/debugger error)
    
    Thread-safe function (may be called only from the main thread and debthread)

Help on function writelong in module idc:

writelong(handle, dword, mostfirst)

Help on function writeshort in module idc:

writeshort(handle, word, mostfirst)

Help on function writestr in module idc:

writestr(handle, s)

Help on function xtol in module idc:

xtol(s)

