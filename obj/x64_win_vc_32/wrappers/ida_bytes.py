# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""IDA Plugin SDK API wrapper: bytes"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_bytes
else:
    import _ida_bytes

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_range

def enable_flags(*args):
    r"""enable_flags(start_ea, end_ea, stt) -> error_t"""
    return _ida_bytes.enable_flags(*args)

def disable_flags(*args):
    r"""disable_flags(start_ea, end_ea) -> error_t"""
    return _ida_bytes.disable_flags(*args)

def change_storage_type(*args):
    r"""change_storage_type(start_ea, end_ea, stt) -> error_t"""
    return _ida_bytes.change_storage_type(*args)

def next_addr(*args):
    r"""next_addr(ea) -> ea_t"""
    return _ida_bytes.next_addr(*args)

def prev_addr(*args):
    r"""prev_addr(ea) -> ea_t"""
    return _ida_bytes.prev_addr(*args)

def next_chunk(*args):
    r"""next_chunk(ea) -> ea_t"""
    return _ida_bytes.next_chunk(*args)

def prev_chunk(*args):
    r"""prev_chunk(ea) -> ea_t"""
    return _ida_bytes.prev_chunk(*args)

def chunk_start(*args):
    r"""chunk_start(ea) -> ea_t"""
    return _ida_bytes.chunk_start(*args)

def chunk_size(*args):
    r"""chunk_size(ea) -> asize_t"""
    return _ida_bytes.chunk_size(*args)

def free_chunk(*args):
    r"""free_chunk(bottom, size, step) -> ea_t"""
    return _ida_bytes.free_chunk(*args)

def next_unknown(*args):
    r"""next_unknown(ea, maxea) -> ea_t"""
    return _ida_bytes.next_unknown(*args)

def prev_unknown(*args):
    r"""prev_unknown(ea, minea) -> ea_t"""
    return _ida_bytes.prev_unknown(*args)

def prev_head(*args):
    r"""prev_head(ea, minea) -> ea_t"""
    return _ida_bytes.prev_head(*args)

def next_head(*args):
    r"""next_head(ea, maxea) -> ea_t"""
    return _ida_bytes.next_head(*args)

def prev_not_tail(*args):
    r"""prev_not_tail(ea) -> ea_t"""
    return _ida_bytes.prev_not_tail(*args)

def next_not_tail(*args):
    r"""next_not_tail(ea) -> ea_t"""
    return _ida_bytes.next_not_tail(*args)

def get_item_head(*args):
    r"""get_item_head(ea) -> ea_t"""
    return _ida_bytes.get_item_head(*args)

def get_item_end(*args):
    r"""get_item_end(ea) -> ea_t"""
    return _ida_bytes.get_item_end(*args)

def calc_max_item_end(*args):
    r"""calc_max_item_end(ea, how=15) -> ea_t"""
    return _ida_bytes.calc_max_item_end(*args)
ITEM_END_FIXUP = _ida_bytes.ITEM_END_FIXUP

ITEM_END_INITED = _ida_bytes.ITEM_END_INITED

ITEM_END_NAME = _ida_bytes.ITEM_END_NAME

ITEM_END_XREF = _ida_bytes.ITEM_END_XREF


def get_item_size(*args):
    r"""get_item_size(ea) -> asize_t"""
    return _ida_bytes.get_item_size(*args)

def is_mapped(*args):
    r"""is_mapped(ea) -> bool"""
    return _ida_bytes.is_mapped(*args)

def get_flags_ex(*args):
    r"""get_flags_ex(ea, how) -> flags_t"""
    return _ida_bytes.get_flags_ex(*args)
GFE_VALUE = _ida_bytes.GFE_VALUE


def get_flags(*args):
    r"""get_flags(ea) -> flags_t"""
    return _ida_bytes.get_flags(*args)

def get_full_flags(*args):
    r"""get_full_flags(ea) -> flags_t"""
    return _ida_bytes.get_full_flags(*args)

def get_item_flag(*args):
    r"""get_item_flag(_from, n, ea, appzero) -> flags_t"""
    return _ida_bytes.get_item_flag(*args)
MS_VAL = _ida_bytes.MS_VAL

FF_IVL = _ida_bytes.FF_IVL


def has_value(*args):
    r"""has_value(F) -> bool"""
    return _ida_bytes.has_value(*args)

def del_value(*args):
    r"""del_value(ea)"""
    return _ida_bytes.del_value(*args)

def is_loaded(*args):
    r"""is_loaded(ea) -> bool"""
    return _ida_bytes.is_loaded(*args)

def nbits(*args):
    r"""nbits(ea) -> int"""
    return _ida_bytes.nbits(*args)

def bytesize(*args):
    r"""bytesize(ea) -> int"""
    return _ida_bytes.bytesize(*args)

def get_byte(*args):
    r"""get_byte(ea) -> uchar"""
    return _ida_bytes.get_byte(*args)

def get_db_byte(*args):
    r"""get_db_byte(ea) -> uchar"""
    return _ida_bytes.get_db_byte(*args)

def get_word(*args):
    r"""get_word(ea) -> ushort"""
    return _ida_bytes.get_word(*args)

def get_dword(*args):
    r"""get_dword(ea) -> uint32"""
    return _ida_bytes.get_dword(*args)

def get_qword(*args):
    r"""get_qword(ea) -> uint64"""
    return _ida_bytes.get_qword(*args)

def get_wide_byte(*args):
    r"""get_wide_byte(ea) -> uint64"""
    return _ida_bytes.get_wide_byte(*args)

def get_wide_word(*args):
    r"""get_wide_word(ea) -> uint64"""
    return _ida_bytes.get_wide_word(*args)

def get_wide_dword(*args):
    r"""get_wide_dword(ea) -> uint64"""
    return _ida_bytes.get_wide_dword(*args)

def get_16bit(*args):
    r"""get_16bit(ea) -> uint32"""
    return _ida_bytes.get_16bit(*args)

def get_32bit(*args):
    r"""get_32bit(ea) -> uint32"""
    return _ida_bytes.get_32bit(*args)

def get_64bit(*args):
    r"""get_64bit(ea) -> uint64"""
    return _ida_bytes.get_64bit(*args)

def get_data_value(*args):
    r"""get_data_value(v, ea, size) -> bool"""
    return _ida_bytes.get_data_value(*args)

def get_original_byte(*args):
    r"""get_original_byte(ea) -> uint64"""
    return _ida_bytes.get_original_byte(*args)

def get_original_word(*args):
    r"""get_original_word(ea) -> uint64"""
    return _ida_bytes.get_original_word(*args)

def get_original_dword(*args):
    r"""get_original_dword(ea) -> uint64"""
    return _ida_bytes.get_original_dword(*args)

def get_original_qword(*args):
    r"""get_original_qword(ea) -> uint64"""
    return _ida_bytes.get_original_qword(*args)

def put_byte(*args):
    r"""put_byte(ea, x) -> bool"""
    return _ida_bytes.put_byte(*args)

def put_word(*args):
    r"""put_word(ea, x)"""
    return _ida_bytes.put_word(*args)

def put_dword(*args):
    r"""put_dword(ea, x)"""
    return _ida_bytes.put_dword(*args)

def put_qword(*args):
    r"""put_qword(ea, x)"""
    return _ida_bytes.put_qword(*args)

def patch_byte(*args):
    r"""patch_byte(ea, x) -> bool"""
    return _ida_bytes.patch_byte(*args)

def patch_word(*args):
    r"""patch_word(ea, x) -> bool"""
    return _ida_bytes.patch_word(*args)

def patch_dword(*args):
    r"""patch_dword(ea, x) -> bool"""
    return _ida_bytes.patch_dword(*args)

def patch_qword(*args):
    r"""patch_qword(ea, x) -> bool"""
    return _ida_bytes.patch_qword(*args)

def revert_byte(*args):
    r"""revert_byte(ea) -> bool"""
    return _ida_bytes.revert_byte(*args)

def add_byte(*args):
    r"""add_byte(ea, value)"""
    return _ida_bytes.add_byte(*args)

def add_word(*args):
    r"""add_word(ea, value)"""
    return _ida_bytes.add_word(*args)

def add_dword(*args):
    r"""add_dword(ea, value)"""
    return _ida_bytes.add_dword(*args)

def add_qword(*args):
    r"""add_qword(ea, value)"""
    return _ida_bytes.add_qword(*args)

def get_zero_ranges(*args):
    r"""get_zero_ranges(zranges, range) -> bool"""
    return _ida_bytes.get_zero_ranges(*args)
GMB_READALL = _ida_bytes.GMB_READALL

GMB_WAITBOX = _ida_bytes.GMB_WAITBOX


def put_bytes(*args):
    r"""put_bytes(ea, buf)"""
    return _ida_bytes.put_bytes(*args)

def patch_bytes(*args):
    r"""patch_bytes(ea, buf)"""
    return _ida_bytes.patch_bytes(*args)
MS_CLS = _ida_bytes.MS_CLS

FF_CODE = _ida_bytes.FF_CODE

FF_DATA = _ida_bytes.FF_DATA

FF_TAIL = _ida_bytes.FF_TAIL

FF_UNK = _ida_bytes.FF_UNK


def is_code(*args):
    r"""is_code(F) -> bool"""
    return _ida_bytes.is_code(*args)

def f_is_code(*args):
    r"""f_is_code(F, arg2) -> bool"""
    return _ida_bytes.f_is_code(*args)

def is_data(*args):
    r"""is_data(F) -> bool"""
    return _ida_bytes.is_data(*args)

def f_is_data(*args):
    r"""f_is_data(F, arg2) -> bool"""
    return _ida_bytes.f_is_data(*args)

def is_tail(*args):
    r"""is_tail(F) -> bool"""
    return _ida_bytes.is_tail(*args)

def f_is_tail(*args):
    r"""f_is_tail(F, arg2) -> bool"""
    return _ida_bytes.f_is_tail(*args)

def is_not_tail(*args):
    r"""is_not_tail(F) -> bool"""
    return _ida_bytes.is_not_tail(*args)

def f_is_not_tail(*args):
    r"""f_is_not_tail(F, arg2) -> bool"""
    return _ida_bytes.f_is_not_tail(*args)

def is_unknown(*args):
    r"""is_unknown(F) -> bool"""
    return _ida_bytes.is_unknown(*args)

def is_head(*args):
    r"""is_head(F) -> bool"""
    return _ida_bytes.is_head(*args)

def f_is_head(*args):
    r"""f_is_head(F, arg2) -> bool"""
    return _ida_bytes.f_is_head(*args)

def del_items(*args):
    r"""del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool"""
    return _ida_bytes.del_items(*args)
DELIT_SIMPLE = _ida_bytes.DELIT_SIMPLE

DELIT_EXPAND = _ida_bytes.DELIT_EXPAND

DELIT_DELNAMES = _ida_bytes.DELIT_DELNAMES

DELIT_NOTRUNC = _ida_bytes.DELIT_NOTRUNC

DELIT_NOUNAME = _ida_bytes.DELIT_NOUNAME

DELIT_NOCMT = _ida_bytes.DELIT_NOCMT


def is_manual_insn(*args):
    r"""is_manual_insn(ea) -> bool"""
    return _ida_bytes.is_manual_insn(*args)

def get_manual_insn(*args):
    r"""get_manual_insn(ea) -> ssize_t"""
    return _ida_bytes.get_manual_insn(*args)

def set_manual_insn(*args):
    r"""set_manual_insn(ea, manual_insn)"""
    return _ida_bytes.set_manual_insn(*args)
MS_COMM = _ida_bytes.MS_COMM

FF_COMM = _ida_bytes.FF_COMM

FF_REF = _ida_bytes.FF_REF

FF_LINE = _ida_bytes.FF_LINE

FF_NAME = _ida_bytes.FF_NAME

FF_LABL = _ida_bytes.FF_LABL

FF_FLOW = _ida_bytes.FF_FLOW

FF_SIGN = _ida_bytes.FF_SIGN

FF_BNOT = _ida_bytes.FF_BNOT

FF_UNUSED = _ida_bytes.FF_UNUSED


def is_flow(*args):
    r"""is_flow(F) -> bool"""
    return _ida_bytes.is_flow(*args)

def has_extra_cmts(*args):
    r"""has_extra_cmts(F) -> bool"""
    return _ida_bytes.has_extra_cmts(*args)

def f_has_extra_cmts(*args):
    r"""f_has_extra_cmts(f, arg2) -> bool"""
    return _ida_bytes.f_has_extra_cmts(*args)

def has_cmt(*args):
    r"""has_cmt(F) -> bool"""
    return _ida_bytes.has_cmt(*args)

def f_has_cmt(*args):
    r"""f_has_cmt(f, arg2) -> bool"""
    return _ida_bytes.f_has_cmt(*args)

def has_xref(*args):
    r"""has_xref(F) -> bool"""
    return _ida_bytes.has_xref(*args)

def f_has_xref(*args):
    r"""f_has_xref(f, arg2) -> bool"""
    return _ida_bytes.f_has_xref(*args)

def has_name(*args):
    r"""has_name(F) -> bool"""
    return _ida_bytes.has_name(*args)

def f_has_name(*args):
    r"""f_has_name(f, arg2) -> bool"""
    return _ida_bytes.f_has_name(*args)
FF_ANYNAME = _ida_bytes.FF_ANYNAME


def has_dummy_name(*args):
    r"""has_dummy_name(F) -> bool"""
    return _ida_bytes.has_dummy_name(*args)

def f_has_dummy_name(*args):
    r"""f_has_dummy_name(f, arg2) -> bool"""
    return _ida_bytes.f_has_dummy_name(*args)

def has_auto_name(*args):
    r"""has_auto_name(F) -> bool"""
    return _ida_bytes.has_auto_name(*args)

def has_any_name(*args):
    r"""has_any_name(F) -> bool"""
    return _ida_bytes.has_any_name(*args)

def has_user_name(*args):
    r"""has_user_name(F) -> bool"""
    return _ida_bytes.has_user_name(*args)

def f_has_user_name(*args):
    r"""f_has_user_name(F, arg2) -> bool"""
    return _ida_bytes.f_has_user_name(*args)

def is_invsign(*args):
    r"""is_invsign(ea, F, n) -> bool"""
    return _ida_bytes.is_invsign(*args)

def toggle_sign(*args):
    r"""toggle_sign(ea, n) -> bool"""
    return _ida_bytes.toggle_sign(*args)

def is_bnot(*args):
    r"""is_bnot(ea, F, n) -> bool"""
    return _ida_bytes.is_bnot(*args)

def toggle_bnot(*args):
    r"""toggle_bnot(ea, n) -> bool"""
    return _ida_bytes.toggle_bnot(*args)

def is_lzero(*args):
    r"""is_lzero(ea, n) -> bool"""
    return _ida_bytes.is_lzero(*args)

def set_lzero(*args):
    r"""set_lzero(ea, n) -> bool"""
    return _ida_bytes.set_lzero(*args)

def clr_lzero(*args):
    r"""clr_lzero(ea, n) -> bool"""
    return _ida_bytes.clr_lzero(*args)

def toggle_lzero(*args):
    r"""toggle_lzero(ea, n) -> bool"""
    return _ida_bytes.toggle_lzero(*args)

def leading_zero_important(*args):
    r"""leading_zero_important(ea, n) -> bool"""
    return _ida_bytes.leading_zero_important(*args)
MS_0TYPE = _ida_bytes.MS_0TYPE

FF_0VOID = _ida_bytes.FF_0VOID

FF_0NUMH = _ida_bytes.FF_0NUMH

FF_0NUMD = _ida_bytes.FF_0NUMD

FF_0CHAR = _ida_bytes.FF_0CHAR

FF_0SEG = _ida_bytes.FF_0SEG

FF_0OFF = _ida_bytes.FF_0OFF

FF_0NUMB = _ida_bytes.FF_0NUMB

FF_0NUMO = _ida_bytes.FF_0NUMO

FF_0ENUM = _ida_bytes.FF_0ENUM

FF_0FOP = _ida_bytes.FF_0FOP

FF_0STRO = _ida_bytes.FF_0STRO

FF_0STK = _ida_bytes.FF_0STK

FF_0FLT = _ida_bytes.FF_0FLT

FF_0CUST = _ida_bytes.FF_0CUST

MS_1TYPE = _ida_bytes.MS_1TYPE

FF_1VOID = _ida_bytes.FF_1VOID

FF_1NUMH = _ida_bytes.FF_1NUMH

FF_1NUMD = _ida_bytes.FF_1NUMD

FF_1CHAR = _ida_bytes.FF_1CHAR

FF_1SEG = _ida_bytes.FF_1SEG

FF_1OFF = _ida_bytes.FF_1OFF

FF_1NUMB = _ida_bytes.FF_1NUMB

FF_1NUMO = _ida_bytes.FF_1NUMO

FF_1ENUM = _ida_bytes.FF_1ENUM

FF_1FOP = _ida_bytes.FF_1FOP

FF_1STRO = _ida_bytes.FF_1STRO

FF_1STK = _ida_bytes.FF_1STK

FF_1FLT = _ida_bytes.FF_1FLT

FF_1CUST = _ida_bytes.FF_1CUST


def is_defarg0(*args):
    r"""is_defarg0(F) -> bool"""
    return _ida_bytes.is_defarg0(*args)

def is_defarg1(*args):
    r"""is_defarg1(F) -> bool"""
    return _ida_bytes.is_defarg1(*args)

def is_off0(*args):
    r"""is_off0(F) -> bool"""
    return _ida_bytes.is_off0(*args)

def is_off1(*args):
    r"""is_off1(F) -> bool"""
    return _ida_bytes.is_off1(*args)

def is_char0(*args):
    r"""is_char0(F) -> bool"""
    return _ida_bytes.is_char0(*args)

def is_char1(*args):
    r"""is_char1(F) -> bool"""
    return _ida_bytes.is_char1(*args)

def is_seg0(*args):
    r"""is_seg0(F) -> bool"""
    return _ida_bytes.is_seg0(*args)

def is_seg1(*args):
    r"""is_seg1(F) -> bool"""
    return _ida_bytes.is_seg1(*args)

def is_enum0(*args):
    r"""is_enum0(F) -> bool"""
    return _ida_bytes.is_enum0(*args)

def is_enum1(*args):
    r"""is_enum1(F) -> bool"""
    return _ida_bytes.is_enum1(*args)

def is_stroff0(*args):
    r"""is_stroff0(F) -> bool"""
    return _ida_bytes.is_stroff0(*args)

def is_stroff1(*args):
    r"""is_stroff1(F) -> bool"""
    return _ida_bytes.is_stroff1(*args)

def is_stkvar0(*args):
    r"""is_stkvar0(F) -> bool"""
    return _ida_bytes.is_stkvar0(*args)

def is_stkvar1(*args):
    r"""is_stkvar1(F) -> bool"""
    return _ida_bytes.is_stkvar1(*args)

def is_float0(*args):
    r"""is_float0(F) -> bool"""
    return _ida_bytes.is_float0(*args)

def is_float1(*args):
    r"""is_float1(F) -> bool"""
    return _ida_bytes.is_float1(*args)

def is_custfmt0(*args):
    r"""is_custfmt0(F) -> bool"""
    return _ida_bytes.is_custfmt0(*args)

def is_custfmt1(*args):
    r"""is_custfmt1(F) -> bool"""
    return _ida_bytes.is_custfmt1(*args)

def is_numop0(*args):
    r"""is_numop0(F) -> bool"""
    return _ida_bytes.is_numop0(*args)

def is_numop1(*args):
    r"""is_numop1(F) -> bool"""
    return _ida_bytes.is_numop1(*args)

def get_optype_flags0(*args):
    r"""get_optype_flags0(F) -> flags_t"""
    return _ida_bytes.get_optype_flags0(*args)

def get_optype_flags1(*args):
    r"""get_optype_flags1(F) -> flags_t"""
    return _ida_bytes.get_optype_flags1(*args)
OPND_OUTER = _ida_bytes.OPND_OUTER

OPND_MASK = _ida_bytes.OPND_MASK

OPND_ALL = _ida_bytes.OPND_ALL


def is_defarg(*args):
    r"""is_defarg(F, n) -> bool"""
    return _ida_bytes.is_defarg(*args)

def is_off(*args):
    r"""is_off(F, n) -> bool"""
    return _ida_bytes.is_off(*args)

def is_char(*args):
    r"""is_char(F, n) -> bool"""
    return _ida_bytes.is_char(*args)

def is_seg(*args):
    r"""is_seg(F, n) -> bool"""
    return _ida_bytes.is_seg(*args)

def is_enum(*args):
    r"""is_enum(F, n) -> bool"""
    return _ida_bytes.is_enum(*args)

def is_manual(*args):
    r"""is_manual(F, n) -> bool"""
    return _ida_bytes.is_manual(*args)

def is_stroff(*args):
    r"""is_stroff(F, n) -> bool"""
    return _ida_bytes.is_stroff(*args)

def is_stkvar(*args):
    r"""is_stkvar(F, n) -> bool"""
    return _ida_bytes.is_stkvar(*args)

def is_fltnum(*args):
    r"""is_fltnum(F, n) -> bool"""
    return _ida_bytes.is_fltnum(*args)

def is_custfmt(*args):
    r"""is_custfmt(F, n) -> bool"""
    return _ida_bytes.is_custfmt(*args)

def is_numop(*args):
    r"""is_numop(F, n) -> bool"""
    return _ida_bytes.is_numop(*args)

def is_suspop(*args):
    r"""is_suspop(ea, F, n) -> bool"""
    return _ida_bytes.is_suspop(*args)

def op_adds_xrefs(*args):
    r"""op_adds_xrefs(F, n) -> bool"""
    return _ida_bytes.op_adds_xrefs(*args)

def set_op_type(*args):
    r"""set_op_type(ea, type, n) -> bool"""
    return _ida_bytes.set_op_type(*args)

def op_seg(*args):
    r"""op_seg(ea, n) -> bool"""
    return _ida_bytes.op_seg(*args)

def op_enum(*args):
    r"""op_enum(ea, n, id, serial) -> bool"""
    return _ida_bytes.op_enum(*args)

def get_enum_id(*args):
    r"""get_enum_id(ea, n) -> enum_t"""
    return _ida_bytes.get_enum_id(*args)

def op_stroff(*args):
    r"""op_stroff(insn, n, path, path_len, delta) -> bool"""
    return _ida_bytes.op_stroff(*args)

def get_stroff_path(*args):
    r"""get_stroff_path(path, delta, ea, n) -> int"""
    return _ida_bytes.get_stroff_path(*args)

def op_stkvar(*args):
    r"""op_stkvar(ea, n) -> bool"""
    return _ida_bytes.op_stkvar(*args)

def set_forced_operand(*args):
    r"""set_forced_operand(ea, n, op) -> bool"""
    return _ida_bytes.set_forced_operand(*args)

def get_forced_operand(*args):
    r"""get_forced_operand(ea, n) -> ssize_t"""
    return _ida_bytes.get_forced_operand(*args)

def is_forced_operand(*args):
    r"""is_forced_operand(ea, n) -> bool"""
    return _ida_bytes.is_forced_operand(*args)

def char_flag(*args):
    r"""char_flag() -> flags_t"""
    return _ida_bytes.char_flag(*args)

def off_flag(*args):
    r"""off_flag() -> flags_t"""
    return _ida_bytes.off_flag(*args)

def enum_flag(*args):
    r"""enum_flag() -> flags_t"""
    return _ida_bytes.enum_flag(*args)

def stroff_flag(*args):
    r"""stroff_flag() -> flags_t"""
    return _ida_bytes.stroff_flag(*args)

def stkvar_flag(*args):
    r"""stkvar_flag() -> flags_t"""
    return _ida_bytes.stkvar_flag(*args)

def flt_flag(*args):
    r"""flt_flag() -> flags_t"""
    return _ida_bytes.flt_flag(*args)

def custfmt_flag(*args):
    r"""custfmt_flag() -> flags_t"""
    return _ida_bytes.custfmt_flag(*args)

def seg_flag(*args):
    r"""seg_flag() -> flags_t"""
    return _ida_bytes.seg_flag(*args)

def num_flag(*args):
    r"""num_flag() -> flags_t"""
    return _ida_bytes.num_flag(*args)

def hex_flag(*args):
    r"""hex_flag() -> flags_t"""
    return _ida_bytes.hex_flag(*args)

def dec_flag(*args):
    r"""dec_flag() -> flags_t"""
    return _ida_bytes.dec_flag(*args)

def oct_flag(*args):
    r"""oct_flag() -> flags_t"""
    return _ida_bytes.oct_flag(*args)

def bin_flag(*args):
    r"""bin_flag() -> flags_t"""
    return _ida_bytes.bin_flag(*args)

def op_chr(*args):
    r"""op_chr(ea, n) -> bool"""
    return _ida_bytes.op_chr(*args)

def op_num(*args):
    r"""op_num(ea, n) -> bool"""
    return _ida_bytes.op_num(*args)

def op_hex(*args):
    r"""op_hex(ea, n) -> bool"""
    return _ida_bytes.op_hex(*args)

def op_dec(*args):
    r"""op_dec(ea, n) -> bool"""
    return _ida_bytes.op_dec(*args)

def op_oct(*args):
    r"""op_oct(ea, n) -> bool"""
    return _ida_bytes.op_oct(*args)

def op_bin(*args):
    r"""op_bin(ea, n) -> bool"""
    return _ida_bytes.op_bin(*args)

def op_flt(*args):
    r"""op_flt(ea, n) -> bool"""
    return _ida_bytes.op_flt(*args)

def op_custfmt(*args):
    r"""op_custfmt(ea, n, fid) -> bool"""
    return _ida_bytes.op_custfmt(*args)

def clr_op_type(*args):
    r"""clr_op_type(ea, n) -> bool"""
    return _ida_bytes.clr_op_type(*args)

def get_default_radix(*args):
    r"""get_default_radix() -> int"""
    return _ida_bytes.get_default_radix(*args)

def get_radix(*args):
    r"""get_radix(F, n) -> int"""
    return _ida_bytes.get_radix(*args)
DT_TYPE = _ida_bytes.DT_TYPE

FF_BYTE = _ida_bytes.FF_BYTE

FF_WORD = _ida_bytes.FF_WORD

FF_DWORD = _ida_bytes.FF_DWORD

FF_QWORD = _ida_bytes.FF_QWORD

FF_TBYTE = _ida_bytes.FF_TBYTE

FF_STRLIT = _ida_bytes.FF_STRLIT

FF_STRUCT = _ida_bytes.FF_STRUCT

FF_OWORD = _ida_bytes.FF_OWORD

FF_FLOAT = _ida_bytes.FF_FLOAT

FF_DOUBLE = _ida_bytes.FF_DOUBLE

FF_PACKREAL = _ida_bytes.FF_PACKREAL

FF_ALIGN = _ida_bytes.FF_ALIGN

FF_CUSTOM = _ida_bytes.FF_CUSTOM

FF_YWORD = _ida_bytes.FF_YWORD

FF_ZWORD = _ida_bytes.FF_ZWORD


def code_flag(*args):
    r"""code_flag() -> flags_t"""
    return _ida_bytes.code_flag(*args)

def byte_flag(*args):
    r"""byte_flag() -> flags_t"""
    return _ida_bytes.byte_flag(*args)

def word_flag(*args):
    r"""word_flag() -> flags_t"""
    return _ida_bytes.word_flag(*args)

def dword_flag(*args):
    r"""dword_flag() -> flags_t"""
    return _ida_bytes.dword_flag(*args)

def qword_flag(*args):
    r"""qword_flag() -> flags_t"""
    return _ida_bytes.qword_flag(*args)

def oword_flag(*args):
    r"""oword_flag() -> flags_t"""
    return _ida_bytes.oword_flag(*args)

def yword_flag(*args):
    r"""yword_flag() -> flags_t"""
    return _ida_bytes.yword_flag(*args)

def zword_flag(*args):
    r"""zword_flag() -> flags_t"""
    return _ida_bytes.zword_flag(*args)

def tbyte_flag(*args):
    r"""tbyte_flag() -> flags_t"""
    return _ida_bytes.tbyte_flag(*args)

def strlit_flag(*args):
    r"""strlit_flag() -> flags_t"""
    return _ida_bytes.strlit_flag(*args)

def stru_flag(*args):
    r"""stru_flag() -> flags_t"""
    return _ida_bytes.stru_flag(*args)

def cust_flag(*args):
    r"""cust_flag() -> flags_t"""
    return _ida_bytes.cust_flag(*args)

def align_flag(*args):
    r"""align_flag() -> flags_t"""
    return _ida_bytes.align_flag(*args)

def float_flag(*args):
    r"""float_flag() -> flags_t"""
    return _ida_bytes.float_flag(*args)

def double_flag(*args):
    r"""double_flag() -> flags_t"""
    return _ida_bytes.double_flag(*args)

def packreal_flag(*args):
    r"""packreal_flag() -> flags_t"""
    return _ida_bytes.packreal_flag(*args)

def is_byte(*args):
    r"""is_byte(F) -> bool"""
    return _ida_bytes.is_byte(*args)

def is_word(*args):
    r"""is_word(F) -> bool"""
    return _ida_bytes.is_word(*args)

def is_dword(*args):
    r"""is_dword(F) -> bool"""
    return _ida_bytes.is_dword(*args)

def is_qword(*args):
    r"""is_qword(F) -> bool"""
    return _ida_bytes.is_qword(*args)

def is_oword(*args):
    r"""is_oword(F) -> bool"""
    return _ida_bytes.is_oword(*args)

def is_yword(*args):
    r"""is_yword(F) -> bool"""
    return _ida_bytes.is_yword(*args)

def is_zword(*args):
    r"""is_zword(F) -> bool"""
    return _ida_bytes.is_zword(*args)

def is_tbyte(*args):
    r"""is_tbyte(F) -> bool"""
    return _ida_bytes.is_tbyte(*args)

def is_float(*args):
    r"""is_float(F) -> bool"""
    return _ida_bytes.is_float(*args)

def is_double(*args):
    r"""is_double(F) -> bool"""
    return _ida_bytes.is_double(*args)

def is_pack_real(*args):
    r"""is_pack_real(F) -> bool"""
    return _ida_bytes.is_pack_real(*args)

def is_strlit(*args):
    r"""is_strlit(F) -> bool"""
    return _ida_bytes.is_strlit(*args)

def is_struct(*args):
    r"""is_struct(F) -> bool"""
    return _ida_bytes.is_struct(*args)

def is_align(*args):
    r"""is_align(F) -> bool"""
    return _ida_bytes.is_align(*args)

def is_custom(*args):
    r"""is_custom(F) -> bool"""
    return _ida_bytes.is_custom(*args)

def f_is_byte(*args):
    r"""f_is_byte(F, arg2) -> bool"""
    return _ida_bytes.f_is_byte(*args)

def f_is_word(*args):
    r"""f_is_word(F, arg2) -> bool"""
    return _ida_bytes.f_is_word(*args)

def f_is_dword(*args):
    r"""f_is_dword(F, arg2) -> bool"""
    return _ida_bytes.f_is_dword(*args)

def f_is_qword(*args):
    r"""f_is_qword(F, arg2) -> bool"""
    return _ida_bytes.f_is_qword(*args)

def f_is_oword(*args):
    r"""f_is_oword(F, arg2) -> bool"""
    return _ida_bytes.f_is_oword(*args)

def f_is_yword(*args):
    r"""f_is_yword(F, arg2) -> bool"""
    return _ida_bytes.f_is_yword(*args)

def f_is_tbyte(*args):
    r"""f_is_tbyte(F, arg2) -> bool"""
    return _ida_bytes.f_is_tbyte(*args)

def f_is_float(*args):
    r"""f_is_float(F, arg2) -> bool"""
    return _ida_bytes.f_is_float(*args)

def f_is_double(*args):
    r"""f_is_double(F, arg2) -> bool"""
    return _ida_bytes.f_is_double(*args)

def f_is_pack_real(*args):
    r"""f_is_pack_real(F, arg2) -> bool"""
    return _ida_bytes.f_is_pack_real(*args)

def f_is_strlit(*args):
    r"""f_is_strlit(F, arg2) -> bool"""
    return _ida_bytes.f_is_strlit(*args)

def f_is_struct(*args):
    r"""f_is_struct(F, arg2) -> bool"""
    return _ida_bytes.f_is_struct(*args)

def f_is_align(*args):
    r"""f_is_align(F, arg2) -> bool"""
    return _ida_bytes.f_is_align(*args)

def f_is_custom(*args):
    r"""f_is_custom(F, arg2) -> bool"""
    return _ida_bytes.f_is_custom(*args)

def is_same_data_type(*args):
    r"""is_same_data_type(F1, F2) -> bool"""
    return _ida_bytes.is_same_data_type(*args)

def get_flags_by_size(*args):
    r"""get_flags_by_size(size) -> flags_t"""
    return _ida_bytes.get_flags_by_size(*args)

def create_data(*args):
    r"""create_data(ea, dataflag, size, tid) -> bool"""
    return _ida_bytes.create_data(*args)

def create_byte(*args):
    r"""create_byte(ea, length) -> bool"""
    return _ida_bytes.create_byte(*args)

def create_word(*args):
    r"""create_word(ea, length) -> bool"""
    return _ida_bytes.create_word(*args)

def create_dword(*args):
    r"""create_dword(ea, length) -> bool"""
    return _ida_bytes.create_dword(*args)

def create_qword(*args):
    r"""create_qword(ea, length) -> bool"""
    return _ida_bytes.create_qword(*args)

def create_oword(*args):
    r"""create_oword(ea, length) -> bool"""
    return _ida_bytes.create_oword(*args)

def create_yword(*args):
    r"""create_yword(ea, length) -> bool"""
    return _ida_bytes.create_yword(*args)

def create_zword(*args):
    r"""create_zword(ea, length) -> bool"""
    return _ida_bytes.create_zword(*args)

def create_tbyte(*args):
    r"""create_tbyte(ea, length) -> bool"""
    return _ida_bytes.create_tbyte(*args)

def create_float(*args):
    r"""create_float(ea, length) -> bool"""
    return _ida_bytes.create_float(*args)

def create_double(*args):
    r"""create_double(ea, length) -> bool"""
    return _ida_bytes.create_double(*args)

def create_packed_real(*args):
    r"""create_packed_real(ea, length) -> bool"""
    return _ida_bytes.create_packed_real(*args)

def create_struct(*args):
    r"""create_struct(ea, length, tid) -> bool"""
    return _ida_bytes.create_struct(*args)

def create_custdata(*args):
    r"""create_custdata(ea, length, dtid, fid) -> bool"""
    return _ida_bytes.create_custdata(*args)

def create_align(*args):
    r"""create_align(ea, length, alignment) -> bool"""
    return _ida_bytes.create_align(*args)

def calc_min_align(*args):
    r"""calc_min_align(length) -> int"""
    return _ida_bytes.calc_min_align(*args)

def calc_max_align(*args):
    r"""calc_max_align(endea) -> int"""
    return _ida_bytes.calc_max_align(*args)

def calc_def_align(*args):
    r"""calc_def_align(ea, mina, maxa) -> int"""
    return _ida_bytes.calc_def_align(*args)

def create_16bit_data(*args):
    r"""create_16bit_data(ea, length) -> bool"""
    return _ida_bytes.create_16bit_data(*args)

def create_32bit_data(*args):
    r"""create_32bit_data(ea, length) -> bool"""
    return _ida_bytes.create_32bit_data(*args)
ALOPT_IGNHEADS = _ida_bytes.ALOPT_IGNHEADS

ALOPT_IGNPRINT = _ida_bytes.ALOPT_IGNPRINT

ALOPT_IGNCLT = _ida_bytes.ALOPT_IGNCLT

ALOPT_MAX4K = _ida_bytes.ALOPT_MAX4K


def get_max_strlit_length(*args):
    r"""get_max_strlit_length(ea, strtype, options=0) -> size_t"""
    return _ida_bytes.get_max_strlit_length(*args)
STRCONV_ESCAPE = _ida_bytes.STRCONV_ESCAPE

STRCONV_REPLCHAR = _ida_bytes.STRCONV_REPLCHAR

STRCONV_INCLLEN = _ida_bytes.STRCONV_INCLLEN


def create_strlit(*args):
    r"""create_strlit(start, len, strtype) -> bool"""
    return _ida_bytes.create_strlit(*args)
PSTF_TNORM = _ida_bytes.PSTF_TNORM

PSTF_TBRIEF = _ida_bytes.PSTF_TBRIEF

PSTF_TINLIN = _ida_bytes.PSTF_TINLIN

PSTF_TMASK = _ida_bytes.PSTF_TMASK

PSTF_HOTKEY = _ida_bytes.PSTF_HOTKEY

PSTF_ENC = _ida_bytes.PSTF_ENC


def get_opinfo(*args):
    r"""get_opinfo(buf, ea, n, flags) -> opinfo_t"""
    return _ida_bytes.get_opinfo(*args)

def set_opinfo(*args):
    r"""set_opinfo(ea, n, flag, ti, suppress_events=False) -> bool"""
    return _ida_bytes.set_opinfo(*args)

def get_data_elsize(*args):
    r"""get_data_elsize(ea, F, ti=None) -> asize_t"""
    return _ida_bytes.get_data_elsize(*args)

def get_full_data_elsize(*args):
    r"""get_full_data_elsize(ea, F, ti=None) -> asize_t"""
    return _ida_bytes.get_full_data_elsize(*args)

def is_varsize_item(*args):
    r"""is_varsize_item(ea, F, ti=None, itemsize=None) -> int"""
    return _ida_bytes.is_varsize_item(*args)

def can_define_item(*args):
    r"""can_define_item(ea, length, flags) -> bool"""
    return _ida_bytes.can_define_item(*args)
MS_CODE = _ida_bytes.MS_CODE

FF_FUNC = _ida_bytes.FF_FUNC

FF_IMMD = _ida_bytes.FF_IMMD

FF_JUMP = _ida_bytes.FF_JUMP


def has_immd(*args):
    r"""has_immd(F) -> bool"""
    return _ida_bytes.has_immd(*args)

def is_func(*args):
    r"""is_func(F) -> bool"""
    return _ida_bytes.is_func(*args)

def set_immd(*args):
    r"""set_immd(ea) -> bool"""
    return _ida_bytes.set_immd(*args)
class data_type_t(object):
    r"""Proxy of C++ data_type_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    props = property(_ida_bytes.data_type_t_props_get, _ida_bytes.data_type_t_props_set, doc=r"""props""")
    name = property(_ida_bytes.data_type_t_name_get, _ida_bytes.data_type_t_name_set, doc=r"""name""")
    menu_name = property(_ida_bytes.data_type_t_menu_name_get, _ida_bytes.data_type_t_menu_name_set, doc=r"""menu_name""")
    hotkey = property(_ida_bytes.data_type_t_hotkey_get, _ida_bytes.data_type_t_hotkey_set, doc=r"""hotkey""")
    asm_keyword = property(_ida_bytes.data_type_t_asm_keyword_get, _ida_bytes.data_type_t_asm_keyword_set, doc=r"""asm_keyword""")
    value_size = property(_ida_bytes.data_type_t_value_size_get, _ida_bytes.data_type_t_value_size_set, doc=r"""value_size""")

    def is_present_in_menus(self, *args):
        r"""is_present_in_menus(self) -> bool"""
        return _ida_bytes.data_type_t_is_present_in_menus(self, *args)

    def __init__(self, *args):
        r"""__init__(self, _self, name, value_size=0, menu_name=None, hotkey=None, asm_keyword=None, props=0) -> data_type_t"""
        _ida_bytes.data_type_t_swiginit(self, _ida_bytes.new_data_type_t(*args))
    __swig_destroy__ = _ida_bytes.delete_data_type_t

    def __get_id(self, *args):
        r"""__get_id(self) -> int"""
        return _ida_bytes.data_type_t___get_id(self, *args)

    id = property(__get_id)
    __real__init__ = __init__
    def __init__(self, *args):
        self.__real__init__(self, *args) # pass 'self' as part of args

    if _BC695:
        def __init__(self, name, value_size = 0, menu_name = None, hotkey = None, asm_keyword = None, props = 0):
            args = (name, value_size, menu_name, hotkey, asm_keyword, props)
            self.__real__init__(self, *args) # pass 'self' as part of args



# Register data_type_t in _ida_bytes:
_ida_bytes.data_type_t_swigregister(data_type_t)
DTP_NODUP = _ida_bytes.DTP_NODUP


class data_format_t(object):
    r"""Proxy of C++ data_format_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    props = property(_ida_bytes.data_format_t_props_get, _ida_bytes.data_format_t_props_set, doc=r"""props""")
    name = property(_ida_bytes.data_format_t_name_get, _ida_bytes.data_format_t_name_set, doc=r"""name""")
    menu_name = property(_ida_bytes.data_format_t_menu_name_get, _ida_bytes.data_format_t_menu_name_set, doc=r"""menu_name""")
    hotkey = property(_ida_bytes.data_format_t_hotkey_get, _ida_bytes.data_format_t_hotkey_set, doc=r"""hotkey""")
    value_size = property(_ida_bytes.data_format_t_value_size_get, _ida_bytes.data_format_t_value_size_set, doc=r"""value_size""")
    text_width = property(_ida_bytes.data_format_t_text_width_get, _ida_bytes.data_format_t_text_width_set, doc=r"""text_width""")

    def is_present_in_menus(self, *args):
        r"""is_present_in_menus(self) -> bool"""
        return _ida_bytes.data_format_t_is_present_in_menus(self, *args)

    def __init__(self, *args):
        r"""__init__(self, _self, name, value_size=0, menu_name=None, props=0, hotkey=None, text_width=0) -> data_format_t"""
        _ida_bytes.data_format_t_swiginit(self, _ida_bytes.new_data_format_t(*args))
    __swig_destroy__ = _ida_bytes.delete_data_format_t

    def __get_id(self, *args):
        r"""__get_id(self) -> int"""
        return _ida_bytes.data_format_t___get_id(self, *args)

    id = property(__get_id)
    __real__init__ = __init__
    def __init__(self, *args):
        self.__real__init__(self, *args) # pass 'self' as part of args

    if _BC695:
        def __init__(self, name, value_size = 0, menu_name = None, props = 0, hotkey = None, text_width = 0):
            args = (name, value_size, menu_name, props, hotkey, text_width)
            self.__real__init__(self, *args) # pass 'self' as part of args



# Register data_format_t in _ida_bytes:
_ida_bytes.data_format_t_swigregister(data_format_t)


def get_custom_data_type(*args):
    r"""get_custom_data_type(dtid) -> data_type_t"""
    return _ida_bytes.get_custom_data_type(*args)

def get_custom_data_format(*args):
    r"""get_custom_data_format(dfid) -> data_format_t"""
    return _ida_bytes.get_custom_data_format(*args)

def attach_custom_data_format(*args):
    r"""attach_custom_data_format(dtid, dfid) -> bool"""
    return _ida_bytes.attach_custom_data_format(*args)

def detach_custom_data_format(*args):
    r"""detach_custom_data_format(dtid, dfid) -> bool"""
    return _ida_bytes.detach_custom_data_format(*args)

def is_attached_custom_data_format(*args):
    r"""is_attached_custom_data_format(dtid, dfid) -> bool"""
    return _ida_bytes.is_attached_custom_data_format(*args)

def get_custom_data_types(*args):
    r"""get_custom_data_types(out, min_size=0, max_size=BADADDR) -> int"""
    return _ida_bytes.get_custom_data_types(*args)

def get_custom_data_formats(*args):
    r"""get_custom_data_formats(out, dtid) -> int"""
    return _ida_bytes.get_custom_data_formats(*args)

def find_custom_data_type(*args):
    r"""find_custom_data_type(name) -> int"""
    return _ida_bytes.find_custom_data_type(*args)

def find_custom_data_format(*args):
    r"""find_custom_data_format(name) -> int"""
    return _ida_bytes.find_custom_data_format(*args)

def set_cmt(*args):
    r"""set_cmt(ea, comm, rptble) -> bool"""
    return _ida_bytes.set_cmt(*args)

def get_cmt(*args):
    r"""get_cmt(ea, rptble) -> ssize_t"""
    return _ida_bytes.get_cmt(*args)

def append_cmt(*args):
    r"""append_cmt(ea, str, rptble) -> bool"""
    return _ida_bytes.append_cmt(*args)

def get_predef_insn_cmt(*args):
    r"""get_predef_insn_cmt(ins) -> ssize_t"""
    return _ida_bytes.get_predef_insn_cmt(*args)

def find_byte(*args):
    r"""find_byte(sEA, size, value, bin_search_flags) -> ea_t"""
    return _ida_bytes.find_byte(*args)

def find_byter(*args):
    r"""find_byter(sEA, size, value, bin_search_flags) -> ea_t"""
    return _ida_bytes.find_byter(*args)
PBSENC_DEF1BPU = _ida_bytes.PBSENC_DEF1BPU

PBSENC_ALL = _ida_bytes.PBSENC_ALL

BIN_SEARCH_CASE = _ida_bytes.BIN_SEARCH_CASE

BIN_SEARCH_NOCASE = _ida_bytes.BIN_SEARCH_NOCASE

BIN_SEARCH_NOBREAK = _ida_bytes.BIN_SEARCH_NOBREAK

BIN_SEARCH_INITED = _ida_bytes.BIN_SEARCH_INITED

BIN_SEARCH_NOSHOW = _ida_bytes.BIN_SEARCH_NOSHOW

BIN_SEARCH_FORWARD = _ida_bytes.BIN_SEARCH_FORWARD

BIN_SEARCH_BACKWARD = _ida_bytes.BIN_SEARCH_BACKWARD


def next_inited(*args):
    r"""next_inited(ea, maxea) -> ea_t"""
    return _ida_bytes.next_inited(*args)

def prev_inited(*args):
    r"""prev_inited(ea, minea) -> ea_t"""
    return _ida_bytes.prev_inited(*args)

def equal_bytes(*args):
    r"""equal_bytes(ea, image, mask, len, sense_case) -> bool"""
    return _ida_bytes.equal_bytes(*args)
class hidden_range_t(ida_range.range_t):
    r"""Proxy of C++ hidden_range_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    description = property(_ida_bytes.hidden_range_t_description_get, _ida_bytes.hidden_range_t_description_set, doc=r"""description""")
    header = property(_ida_bytes.hidden_range_t_header_get, _ida_bytes.hidden_range_t_header_set, doc=r"""header""")
    footer = property(_ida_bytes.hidden_range_t_footer_get, _ida_bytes.hidden_range_t_footer_set, doc=r"""footer""")
    visible = property(_ida_bytes.hidden_range_t_visible_get, _ida_bytes.hidden_range_t_visible_set, doc=r"""visible""")
    color = property(_ida_bytes.hidden_range_t_color_get, _ida_bytes.hidden_range_t_color_set, doc=r"""color""")

    def __init__(self, *args):
        r"""__init__(self) -> hidden_range_t"""
        _ida_bytes.hidden_range_t_swiginit(self, _ida_bytes.new_hidden_range_t(*args))
    __swig_destroy__ = _ida_bytes.delete_hidden_range_t

# Register hidden_range_t in _ida_bytes:
_ida_bytes.hidden_range_t_swigregister(hidden_range_t)


def update_hidden_range(*args):
    r"""update_hidden_range(ha) -> bool"""
    return _ida_bytes.update_hidden_range(*args)

def add_hidden_range(*args):
    r"""add_hidden_range(ea1, ea2, description, header, footer, color) -> bool"""
    return _ida_bytes.add_hidden_range(*args)

def get_hidden_range(*args):
    r"""get_hidden_range(ea) -> hidden_range_t"""
    return _ida_bytes.get_hidden_range(*args)

def getn_hidden_range(*args):
    r"""getn_hidden_range(n) -> hidden_range_t"""
    return _ida_bytes.getn_hidden_range(*args)

def get_hidden_range_qty(*args):
    r"""get_hidden_range_qty() -> int"""
    return _ida_bytes.get_hidden_range_qty(*args)

def get_hidden_range_num(*args):
    r"""get_hidden_range_num(ea) -> int"""
    return _ida_bytes.get_hidden_range_num(*args)

def get_prev_hidden_range(*args):
    r"""get_prev_hidden_range(ea) -> hidden_range_t"""
    return _ida_bytes.get_prev_hidden_range(*args)

def get_next_hidden_range(*args):
    r"""get_next_hidden_range(ea) -> hidden_range_t"""
    return _ida_bytes.get_next_hidden_range(*args)

def get_first_hidden_range(*args):
    r"""get_first_hidden_range() -> hidden_range_t"""
    return _ida_bytes.get_first_hidden_range(*args)

def get_last_hidden_range(*args):
    r"""get_last_hidden_range() -> hidden_range_t"""
    return _ida_bytes.get_last_hidden_range(*args)

def del_hidden_range(*args):
    r"""del_hidden_range(ea) -> bool"""
    return _ida_bytes.del_hidden_range(*args)

def add_mapping(*args):
    r"""add_mapping(_from, to, size) -> bool"""
    return _ida_bytes.add_mapping(*args)

def del_mapping(*args):
    r"""del_mapping(ea)"""
    return _ida_bytes.del_mapping(*args)

def use_mapping(*args):
    r"""use_mapping(ea) -> ea_t"""
    return _ida_bytes.use_mapping(*args)

def get_mappings_qty(*args):
    r"""get_mappings_qty() -> size_t"""
    return _ida_bytes.get_mappings_qty(*args)

def get_mapping(*args):
    r"""get_mapping(n) -> bool"""
    return _ida_bytes.get_mapping(*args)

def visit_patched_bytes(*args):
    r"""visit_patched_bytes(ea1, ea2, py_callable) -> int"""
    return _ida_bytes.visit_patched_bytes(*args)

def next_that(*args):
    r"""next_that(ea, maxea, callable) -> ea_t"""
    return _ida_bytes.next_that(*args)

def prev_that(*args):
    r"""prev_that(ea, minea, callable) -> ea_t"""
    return _ida_bytes.prev_that(*args)

def get_bytes(*args):
    r"""get_bytes(ea, size, gmb_flags=0x01) -> PyObject *"""
    return _ida_bytes.get_bytes(*args)

def get_bytes_and_mask(*args):
    r"""get_bytes_and_mask(ea, size, gmb_flags=0x01) -> PyObject *"""
    return _ida_bytes.get_bytes_and_mask(*args)

def get_strlit_contents(*args):
    r"""get_strlit_contents(ea, py_len, type, flags=0) -> PyObject *"""
    return _ida_bytes.get_strlit_contents(*args)

def bin_search(*args):
    r"""bin_search(start_ea, end_ea, image, mask, step, flags) -> ea_t"""
    return _ida_bytes.bin_search(*args)

def print_strlit_type(*args):
    r"""print_strlit_type(strtype, flags=0) -> PyObject *"""
    return _ida_bytes.print_strlit_type(*args)

def get_octet(*args):
    r"""get_octet(ea, v, nbit) -> PyObject *"""
    return _ida_bytes.get_octet(*args)

def get_8bit(*args):
    r"""get_8bit(ea, v, nbit) -> PyObject *"""
    return _ida_bytes.get_8bit(*args)

#<pycode(py_bytes)>
#</pycode(py_bytes)>


def register_custom_data_type(*args):
    r"""register_custom_data_type(py_dt) -> int"""
    return _ida_bytes.register_custom_data_type(*args)

def unregister_custom_data_type(*args):
    r"""unregister_custom_data_type(dtid) -> bool"""
    return _ida_bytes.unregister_custom_data_type(*args)

def register_custom_data_format(*args):
    r"""register_custom_data_format(py_df) -> int"""
    return _ida_bytes.register_custom_data_format(*args)

def unregister_custom_data_format(*args):
    r"""unregister_custom_data_format(dfid) -> bool"""
    return _ida_bytes.unregister_custom_data_format(*args)

#<pycode(py_bytes_custdata)>
DTP_NODUP = 0x0001
# -----------------------------------------------------------------------
def __walk_types_and_formats(formats, type_action, format_action, installing):
    broken = False
    for f in formats:
        if len(f) == 1:
            if not format_action(f[0], 0):
                broken = True
                break
        else:
            dt  = f[0]
            dfs = f[1:]
# install data type before installing formats
            if installing and not type_action(dt):
                broken = True
                break
# process formats using the correct dt.id
            for df in dfs:
                if not format_action(df, dt.id):
                    broken = True
                    break
# uninstall data type after uninstalling formats
            if not installing and not type_action(dt):
                broken = True
                break
    return not broken

# -----------------------------------------------------------------------
def register_data_types_and_formats(formats):
    """
    Registers multiple data types and formats at once.
    To register one type/format at a time use register_custom_data_type/register_custom_data_format

    It employs a special table of types and formats described below:

    The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
    If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
    many_formats = [
      (pascal_data_type(), pascal_data_format()),
      (simplevm_data_type(), simplevm_data_format()),
      (makedword_data_format(),),
      (simplevm_data_format(),)
    ]
    The first two tuples describe data types and their associated formats.
    The last two tuples describe two data formats to be used with built-in data types.
    The data format may be attached to several data types. The id of the
    data format is stored in the first data_format_t object. For example:
    assert many_formats[1][1] != -1
    assert many_formats[2][0] != -1
    assert many_formats[3][0] == -1
    """
    def __reg_format(df, dtid):
        dfid = register_custom_data_format(df);
        if dfid == -1:
            dfid = find_custom_data_format(df.name);
            if dfid == -1:
              return False
        attach_custom_data_format(dtid, dfid)
        if dtid == 0:
            print("Registered format '%s' with built-in types, ID=%d" % (df.name, dfid))
        else:
            print("   Registered format '%s', ID=%d (dtid=%d)" % (df.name, dfid, dtid))
        return True

    def __reg_type(dt):
        register_custom_data_type(dt)
        print("Registered type '%s', ID=%d" % (dt.name, dt.id))
        return dt.id != -1
    ok = __walk_types_and_formats(formats, __reg_type, __reg_format, True)
    return 1 if ok else -1

# -----------------------------------------------------------------------
def unregister_data_types_and_formats(formats):
    """As opposed to register_data_types_and_formats(), this function
    unregisters multiple data types and formats at once.
    """
    def __unreg_format(df, dtid):
        print("%snregistering format '%s'" % ("U" if dtid == 0 else "   u", df.name))
        unregister_custom_data_format(df.id)
        return True

    def __unreg_type(dt):
        print("Unregistering type '%s', ID=%d" % (dt.name, dt.id))
        unregister_custom_data_type(dt.id)
        return True
    ok = __walk_types_and_formats(formats, __unreg_type, __unreg_format, False)
    return 1 if ok else -1

#--------------------------------------------------------------------------
#
#
#<pydoc>
#class data_type_t(object):
#    """
#    The following optional callback methods can be implemented
#    in a data_type_t subclass
#    """
#
#    def may_create_at(ea, nbytes):
#        """May create data?
#        No such callback means: always succeed (i.e., no restriction where
#        such a data type can be created.)
#        @param ea: candidate address for the data item
#        @param nbytes: candidate size for the data item
#        @return: True/False
#        """
#        return True
#
#    def calc_item_size(ea, maxsize):
#        """This callback is used to determine size of the (possible)
#        item at `ea`.
#        No such callback means that datatype is of fixed size `value_size`.
#        (thus, this callback is required only for varsize datatypes.)
#        @param ea: address of the item
#        @param maxsize: maximum size of the item
#        @return: 0 - no such item can be created/displayed
#        """
#        return 0
#
#
#class data_format_t(object):
#    """
#    The following callback methods can be implemented
#    in a data_format_t subclass
#    """
#
#    def printf(value, current_ea, operand_num, dtid):
#        """Convert `value` to colored string using custom format.
#        @param value: value to print (of type 'str', sequence of bytes)
#        @param current_ea: current address (BADADDR if unknown)
#        @param operand_num: current operand number
#        @param dtid: custom data type id
#        @return: string representing data
#        """
#        return None
#
#    def scan(input, current_ea, operand_num):
#        """Convert uncolored string (user input) to the value.
#        This callback is called from the debugger when an user enters a
#        new value for a register with a custom data representation (e.g.,
#        an MMX register.)
#        @param input: input string
#        @param current_ea: current address (BADADDR if unknown)
#        @param operand_num: current operand number (-1 if unknown)
#        @return: tuple(bool, string)
#                 (True, output value) or
#                 (False, error message)
#        """
#        return (False, "Not implemented")
#
#    def analyze(current_ea, operand_num):
#        """Analyze custom data format occurrence.
#        This callback is called in 2 cases:
#        - after emulating an instruction (after a call of
#          'ev_emu_insn') if its operand is marked as "custom data
#          representation"
#        - when emulating data (this is done using a call of
#          'ev_out_data' with analyze_only == true). This is the right
#          place to create cross references from the current item.
#        @param current_ea: current address (BADADDR if unknown)
#        @param operand_num: current operand number
#        """
#        pass
#
#
#</pydoc>
#</pycode(py_bytes_custdata)>


if _BC695:
    ACFOPT_ASCII=0
    ACFOPT_CONVMASK=0
    ACFOPT_ESCAPE=STRCONV_ESCAPE
    ACFOPT_UTF16=0
    ACFOPT_UTF8=0
    DOUNK_DELNAMES=DELIT_DELNAMES
    DOUNK_EXPAND=DELIT_EXPAND
    DOUNK_NOTRUNC=DELIT_NOTRUNC
    DOUNK_SIMPLE=DELIT_SIMPLE
    FF_ASCI=FF_STRLIT
    FF_DWRD=FF_DWORD
    FF_OWRD=FF_OWORD
    FF_QWRD=FF_QWORD
    FF_STRU=FF_STRUCT
    FF_TBYT=FF_TBYTE
    FF_VAR=0
    FF_YWRD=FF_YWORD
    FF_ZWRD=FF_ZWORD
    GFE_NOVALUE=0
    add_hidden_area=add_hidden_range
    asciflag=strlit_flag
    delValue=del_value
    del_hidden_area=del_hidden_range
    do16bit=create_16bit_data
    do32bit=create_32bit_data
    doAlign=create_align
    doByte=create_byte
    doCustomData=create_custdata
    doDouble=create_double
    doDwrd=create_dword
    doExtra=ida_idaapi._BC695.false_p
    doFloat=create_float
    doImmd=set_immd
    doOwrd=create_oword
    doPackReal=create_packed_real
    doQwrd=create_qword
    doStruct=create_struct
    doTbyt=create_tbyte
    doWord=create_word
    doYwrd=create_yword
    doZwrd=create_zword
    do_data_ex=create_data
    do_unknown=del_items
    def do_unknown_range(ea, size, flags):
        return del_items(ea, flags, size) # swap 2 last args
    dwrdflag=dword_flag
    f_hasRef=f_has_xref
    f_isASCII=f_is_strlit
    f_isAlign=f_is_align
    f_isByte=f_is_byte
    f_isCode=f_is_code
    f_isCustom=f_is_custom
    f_isData=f_is_data
    f_isDouble=f_is_double
    f_isDwrd=f_is_dword
    f_isFloat=f_is_float
    f_isHead=f_is_head
    f_isNotTail=f_is_not_tail
    f_isOwrd=f_is_oword
    f_isPackReal=f_is_pack_real
    f_isQwrd=f_is_qword
    f_isStruct=f_is_struct
    f_isTail=f_is_tail
    f_isTbyt=f_is_tbyte
    f_isWord=f_is_word
    f_isYwrd=f_is_yword
    getDefaultRadix=get_default_radix
    getFlags=get_full_flags
    get_long=get_dword
    get_full_byte=get_wide_byte
    get_full_word=get_wide_word
    get_full_long=get_wide_dword
    get_original_long=get_original_dword
    put_long=put_dword
    patch_long=patch_dword
    add_long=add_dword
    getRadix=get_radix
    get_ascii_contents=get_strlit_contents
    get_ascii_contents2=get_strlit_contents
    get_flags_novalue=get_flags
    get_hidden_area=get_hidden_range
    get_hidden_area_num=get_hidden_range_num
    get_hidden_area_qty=get_hidden_range_qty
    def get_many_bytes(ea, size):
        return get_bytes(ea, size)
    def get_many_bytes_ex(ea, size):
        return get_bytes_and_mask(ea, size)
    get_max_ascii_length=get_max_strlit_length
    get_next_hidden_area=get_next_hidden_range
    get_prev_hidden_area=get_prev_hidden_range
    get_zero_areas=get_zero_ranges
    getn_hidden_area=getn_hidden_range
    hasExtra=has_extra_cmts
    hasRef=has_xref
    hasValue=has_value
    hidden_area_t=hidden_range_t
    isASCII=is_strlit
    isAlign=is_align
    isByte=is_byte
    isChar=is_char
    isChar0=is_char0
    isChar1=is_char1
    isCode=is_code
    isCustFmt=is_custfmt
    isCustFmt0=is_custfmt0
    isCustFmt1=is_custfmt1
    isCustom=is_custom
    isData=is_data
    isDefArg=is_defarg
    isDefArg0=is_defarg0
    isDefArg1=is_defarg1
    isDouble=is_double
    isDwrd=is_dword
    isEnabled=is_mapped
    isEnum=is_enum
    isEnum0=is_enum0
    isEnum1=is_enum1
    isFloat=is_float
    isFloat0=is_float0
    isFloat1=is_float1
    isFlow=is_flow
    isFltnum=is_fltnum
    isFop=is_forced_operand
    isFunc=is_func
    isHead=is_head
    isImmd=has_immd
    isLoaded=is_loaded
    isNotTail=is_not_tail
    isNum=is_numop
    isNum0=is_numop0
    isNum1=is_numop1
    isOff=is_off
    isOff0=is_off0
    isOff1=is_off1
    isOwrd=is_oword
    isPackReal=is_pack_real
    isQwrd=is_qword
    isSeg=is_seg
    isSeg0=is_seg0
    isSeg1=is_seg1
    isStkvar=is_stkvar
    isStkvar0=is_stkvar0
    isStkvar1=is_stkvar1
    isStroff=is_stroff
    isStroff0=is_stroff0
    isStroff1=is_stroff1
    isStruct=is_struct
    isTail=is_tail
    isTbyt=is_tbyte
    isUnknown=is_unknown
    isVoid=is_suspop
    isWord=is_word
    isYwrd=is_yword
    isZwrd=is_zword
    make_ascii_string=create_strlit
    noExtra=ida_idaapi._BC695.false_p
    noType=clr_op_type
    owrdflag=oword_flag
    patch_many_bytes=patch_bytes
    print_ascii_string_type=print_strlit_type
    put_many_bytes=put_bytes
    qwrdflag=qword_flag
    tbytflag=tbyte_flag
    update_hidden_area=update_hidden_range
    ywrdflag=yword_flag
    zwrdflag=zword_flag
    def get_opinfo(*args):
        import ida_nalt
        if isinstance(args[3], ida_nalt.opinfo_t): # 6.95: ea, n, flags, buf
            ea, n, flags, buf = args
        else:                                      # 7.00: buf, ea, n, flags
            buf, ea, n, flags = args
        return _ida_bytes.get_opinfo(buf, ea, n, flags)
    def doASCI(ea, length):
        import ida_netnode
        return create_data(ea, FF_STRLIT, length, ida_netnode.BADNODE)
    FF_3BYTE=FF_BYTE
    chunksize=chunk_size
    chunkstart=chunk_start
    do3byte=ida_idaapi._BC695.false_p
    f_is3byte=ida_idaapi._BC695.false_p
    freechunk=free_chunk
    get_3byte=ida_idaapi._BC695.false_p
    is3byte=ida_idaapi._BC695.false_p
    nextaddr=next_addr
    nextchunk=next_chunk
    nextthat=next_that
    prevaddr=prev_addr
    prevchunk=prev_chunk
    prevthat=prev_that
    tribyteflag=byte_flag
    alignflag=align_flag
    binflag=bin_flag
    byteflag=byte_flag
    charflag=char_flag
    codeflag=code_flag
    custflag=cust_flag
    custfmtflag=custfmt_flag
    decflag=dec_flag
    doubleflag=double_flag
    enumflag=enum_flag
    floatflag=float_flag
    fltflag=flt_flag
    hexflag=hex_flag
    numflag=num_flag
    octflag=oct_flag
    offflag=off_flag
    packrealflag=packreal_flag
    segflag=seg_flag
    stkvarflag=stkvar_flag
    stroffflag=stroff_flag
    struflag=stru_flag
    wordflag=word_flag
    invalidate_visea_cache=ida_idaapi._BC695.false_p
    @bc695redef
    def op_stroff(*args):
        insn, n, path, path_len, delta = args
        import ida_ua
        if not isinstance(insn, ida_ua.insn_t):
            tmp = ida_ua.insn_t()
            ida_ua.decode_insn(tmp, insn)
            insn = tmp
        return _ida_bytes.op_stroff(insn, n, path, path_len, delta)




