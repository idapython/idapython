# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""IDA Plugin SDK API wrapper: kernwin"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_kernwin
else:
    import _ida_kernwin

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func


def refresh_choosers(*args):
    r"""refresh_choosers()"""
    return _ida_kernwin.refresh_choosers(*args)

def textctrl_info_t_create(*args):
    r"""textctrl_info_t_create() -> PyObject *"""
    return _ida_kernwin.textctrl_info_t_create(*args)

def textctrl_info_t_destroy(*args):
    r"""textctrl_info_t_destroy(py_obj) -> bool"""
    return _ida_kernwin.textctrl_info_t_destroy(*args)

def textctrl_info_t_get_clink(*args):
    r"""textctrl_info_t_get_clink(_self) -> textctrl_info_t *"""
    return _ida_kernwin.textctrl_info_t_get_clink(*args)

def textctrl_info_t_get_clink_ptr(*args):
    r"""textctrl_info_t_get_clink_ptr(_self) -> PyObject *"""
    return _ida_kernwin.textctrl_info_t_get_clink_ptr(*args)

def register_timer(*args):
    r"""register_timer(interval, py_callback) -> PyObject *"""
    return _ida_kernwin.register_timer(*args)

def unregister_timer(*args):
    r"""unregister_timer(py_timerctx) -> PyObject *"""
    return _ida_kernwin.unregister_timer(*args)

def choose_idasgn(*args):
    r"""choose_idasgn() -> PyObject *"""
    return _ida_kernwin.choose_idasgn(*args)

def get_highlight(*args):
    r"""get_highlight(v) -> PyObject *"""
    return _ida_kernwin.get_highlight(*args)

def py_load_custom_icon_fn(*args):
    r"""py_load_custom_icon_fn(filename) -> int"""
    return _ida_kernwin.py_load_custom_icon_fn(*args)

def py_load_custom_icon_data(*args):
    r"""py_load_custom_icon_data(data, format) -> int"""
    return _ida_kernwin.py_load_custom_icon_data(*args)

def msg(*args):
    r"""msg(o) -> PyObject *"""
    return _ida_kernwin.msg(*args)

def ask_text(*args):
    r"""ask_text(max_size, defval, prompt) -> PyObject *"""
    return _ida_kernwin.ask_text(*args)

def ask_str(*args):
    r"""ask_str(defval, hist, prompt) -> PyObject *"""
    return _ida_kernwin.ask_str(*args)

def str2ea(*args):
    r"""str2ea(str, screenEA=BADADDR) -> ea_t"""
    return _ida_kernwin.str2ea(*args)

def process_ui_action(*args):
    r"""process_ui_action(name, flags=0) -> bool"""
    return _ida_kernwin.process_ui_action(*args)

def del_hotkey(*args):
    r"""del_hotkey(pyctx) -> bool"""
    return _ida_kernwin.del_hotkey(*args)

def add_hotkey(*args):
    r"""add_hotkey(hotkey, pyfunc) -> PyObject *"""
    return _ida_kernwin.add_hotkey(*args)

def take_database_snapshot(*args):
    r"""take_database_snapshot(ss) -> PyObject *"""
    return _ida_kernwin.take_database_snapshot(*args)

def py_ss_restore_callback(*args):
    r"""py_ss_restore_callback(err_msg, userdata)"""
    return _ida_kernwin.py_ss_restore_callback(*args)

def restore_database_snapshot(*args):
    r"""restore_database_snapshot(ss, pyfunc_or_none, pytuple_or_none) -> PyObject *"""
    return _ida_kernwin.restore_database_snapshot(*args)

def execute_sync(*args):
    r"""execute_sync(py_callable, reqf) -> int"""
    return _ida_kernwin.execute_sync(*args)

def execute_ui_requests(*args):
    r"""execute_ui_requests(py_list) -> bool"""
    return _ida_kernwin.execute_ui_requests(*args)
class jobj_wrapper_t(object):
    r"""Proxy of C++ jobj_wrapper_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def get_dict(self, *args):
        r"""get_dict(self) -> PyObject *"""
        return _ida_kernwin.jobj_wrapper_t_get_dict(self, *args)

# Register jobj_wrapper_t in _ida_kernwin:
_ida_kernwin.jobj_wrapper_t_swigregister(jobj_wrapper_t)

class UI_Hooks(object):
    r"""Proxy of C++ UI_Hooks class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ida_kernwin.delete_UI_Hooks

    def hook(self, *args):
        r"""hook(self) -> bool"""
        return _ida_kernwin.UI_Hooks_hook(self, *args)

    def unhook(self, *args):
        r"""unhook(self) -> bool"""
        return _ida_kernwin.UI_Hooks_unhook(self, *args)

    def range(self, *args):
        r"""range(self)"""
        return _ida_kernwin.UI_Hooks_range(self, *args)

    def idcstart(self, *args):
        r"""idcstart(self)"""
        return _ida_kernwin.UI_Hooks_idcstart(self, *args)

    def idcstop(self, *args):
        r"""idcstop(self)"""
        return _ida_kernwin.UI_Hooks_idcstop(self, *args)

    def suspend(self, *args):
        r"""suspend(self)"""
        return _ida_kernwin.UI_Hooks_suspend(self, *args)

    def resume(self, *args):
        r"""resume(self)"""
        return _ida_kernwin.UI_Hooks_resume(self, *args)

    def saving(self, *args):
        r"""saving(self)"""
        return _ida_kernwin.UI_Hooks_saving(self, *args)

    def saved(self, *args):
        r"""saved(self)"""
        return _ida_kernwin.UI_Hooks_saved(self, *args)

    def term(self, *args):
        r"""term(self)"""
        return _ida_kernwin.UI_Hooks_term(self, *args)

    def debugger_menu_change(self, *args):
        r"""debugger_menu_change(self, enable) -> int"""
        return _ida_kernwin.UI_Hooks_debugger_menu_change(self, *args)

    def widget_visible(self, *args):
        r"""widget_visible(self, widget)"""
        return _ida_kernwin.UI_Hooks_widget_visible(self, *args)

    def widget_closing(self, *args):
        r"""widget_closing(self, widget)"""
        return _ida_kernwin.UI_Hooks_widget_closing(self, *args)

    def widget_invisible(self, *args):
        r"""widget_invisible(self, widget)"""
        return _ida_kernwin.UI_Hooks_widget_invisible(self, *args)

    def get_ea_hint(self, *args):
        r"""get_ea_hint(self, ea) -> PyObject *"""
        return _ida_kernwin.UI_Hooks_get_ea_hint(self, *args)

    def get_item_hint(self, *args):
        r"""get_item_hint(self, ea, max_lines) -> PyObject *"""
        return _ida_kernwin.UI_Hooks_get_item_hint(self, *args)

    def get_custom_viewer_hint(self, *args):
        r"""get_custom_viewer_hint(self, viewer, place) -> PyObject *"""
        return _ida_kernwin.UI_Hooks_get_custom_viewer_hint(self, *args)

    def database_inited(self, *args):
        r"""database_inited(self, is_new_database, idc_script)"""
        return _ida_kernwin.UI_Hooks_database_inited(self, *args)

    def ready_to_run(self, *args):
        r"""ready_to_run(self)"""
        return _ida_kernwin.UI_Hooks_ready_to_run(self, *args)

    def preprocess_action(self, *args):
        r"""preprocess_action(self, name)"""
        return _ida_kernwin.UI_Hooks_preprocess_action(self, *args)

    def postprocess_action(self, *args):
        r"""postprocess_action(self)"""
        return _ida_kernwin.UI_Hooks_postprocess_action(self, *args)

    def get_chooser_item_attrs(self, *args):
        r"""get_chooser_item_attrs(self, chooser, n, attrs)"""
        return _ida_kernwin.UI_Hooks_get_chooser_item_attrs(self, *args)

    def updating_actions(self, *args):
        r"""updating_actions(self, ctx)"""
        return _ida_kernwin.UI_Hooks_updating_actions(self, *args)

    def updated_actions(self, *args):
        r"""updated_actions(self)"""
        return _ida_kernwin.UI_Hooks_updated_actions(self, *args)

    def populating_widget_popup(self, *args):
        r"""populating_widget_popup(self, widget, popup_handle, ctx=None)"""
        return _ida_kernwin.UI_Hooks_populating_widget_popup(self, *args)

    def finish_populating_widget_popup(self, *args):
        r"""finish_populating_widget_popup(self, widget, popup_handle, ctx=None)"""
        return _ida_kernwin.UI_Hooks_finish_populating_widget_popup(self, *args)

    def plugin_loaded(self, *args):
        r"""plugin_loaded(self, plugin_info)"""
        return _ida_kernwin.UI_Hooks_plugin_loaded(self, *args)

    def plugin_unloading(self, *args):
        r"""plugin_unloading(self, plugin_info)"""
        return _ida_kernwin.UI_Hooks_plugin_unloading(self, *args)

    def current_widget_changed(self, *args):
        r"""current_widget_changed(self, widget, prev_widget)"""
        return _ida_kernwin.UI_Hooks_current_widget_changed(self, *args)

    def screen_ea_changed(self, *args):
        r"""screen_ea_changed(self, ea, prev_ea)"""
        return _ida_kernwin.UI_Hooks_screen_ea_changed(self, *args)

    def create_desktop_widget(self, *args):
        r"""create_desktop_widget(self, title, cfg) -> PyObject *"""
        return _ida_kernwin.UI_Hooks_create_desktop_widget(self, *args)

    def __init__(self, *args):
        r"""__init__(self) -> UI_Hooks"""
        if self.__class__ == UI_Hooks:
            _self = None
        else:
            _self = self
        _ida_kernwin.UI_Hooks_swiginit(self, _ida_kernwin.new_UI_Hooks(_self, *args))
    def __disown__(self):
        self.this.disown()
        _ida_kernwin.disown_UI_Hooks(self)
        return weakref.proxy(self)

# Register UI_Hooks in _ida_kernwin:
_ida_kernwin.UI_Hooks_swigregister(UI_Hooks)


def register_action(*args):
    r"""register_action(desc) -> bool"""
    return _ida_kernwin.register_action(*args)

def get_registered_actions(*args):
    r"""get_registered_actions() -> PyObject *"""
    return _ida_kernwin.get_registered_actions(*args)

def attach_dynamic_action_to_popup(*args):
    r"""attach_dynamic_action_to_popup(widget, popup_handle, desc, popuppath=None, flags=0) -> bool"""
    return _ida_kernwin.attach_dynamic_action_to_popup(*args)
class disasm_line_t(object):
    r"""Proxy of C++ disasm_line_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ida_kernwin.delete_disasm_line_t

    def __init__(self, *args):
        r"""
        __init__(self) -> disasm_line_t
        __init__(self, other) -> disasm_line_t
        """
        _ida_kernwin.disasm_line_t_swiginit(self, _ida_kernwin.new_disasm_line_t(*args))
    at = property(_ida_kernwin.disasm_line_t_at_get, _ida_kernwin.disasm_line_t_at_set, doc=r"""at""")
    line = property(_ida_kernwin.disasm_line_t_line_get, _ida_kernwin.disasm_line_t_line_set, doc=r"""line""")
    prefix_color = property(_ida_kernwin.disasm_line_t_prefix_color_get, _ida_kernwin.disasm_line_t_prefix_color_set, doc=r"""prefix_color""")
    bg_color = property(_ida_kernwin.disasm_line_t_bg_color_get, _ida_kernwin.disasm_line_t_bg_color_set, doc=r"""bg_color""")
    is_default = property(_ida_kernwin.disasm_line_t_is_default_get, _ida_kernwin.disasm_line_t_is_default_set, doc=r"""is_default""")

# Register disasm_line_t in _ida_kernwin:
_ida_kernwin.disasm_line_t_swigregister(disasm_line_t)


def gen_disasm_text(*args):
    r"""gen_disasm_text(text, ea1, ea2, truncate_lines)"""
    return _ida_kernwin.gen_disasm_text(*args)

def set_nav_colorizer(*args):
    r"""set_nav_colorizer(new_py_colorizer) -> nav_colorizer_t *"""
    return _ida_kernwin.set_nav_colorizer(*args)

def call_nav_colorizer(*args):
    r"""call_nav_colorizer(col, ea, nbytes) -> uint32"""
    return _ida_kernwin.call_nav_colorizer(*args)

def msg_get_lines(*args):
    r"""msg_get_lines(count=-1) -> PyObject *"""
    return _ida_kernwin.msg_get_lines(*args)

def TWidget__from_ptrval__(*args):
    r"""TWidget__from_ptrval__(ptrval) -> TWidget *"""
    return _ida_kernwin.TWidget__from_ptrval__(*args)
mbox_internal = _ida_kernwin.mbox_internal

mbox_info = _ida_kernwin.mbox_info

mbox_warning = _ida_kernwin.mbox_warning

mbox_error = _ida_kernwin.mbox_error

mbox_nomem = _ida_kernwin.mbox_nomem

mbox_feedback = _ida_kernwin.mbox_feedback

mbox_readerror = _ida_kernwin.mbox_readerror

mbox_writeerror = _ida_kernwin.mbox_writeerror

mbox_filestruct = _ida_kernwin.mbox_filestruct

mbox_wait = _ida_kernwin.mbox_wait

mbox_hide = _ida_kernwin.mbox_hide

mbox_replace = _ida_kernwin.mbox_replace

chtype_generic = _ida_kernwin.chtype_generic

chtype_idasgn = _ida_kernwin.chtype_idasgn

chtype_entry = _ida_kernwin.chtype_entry

chtype_name = _ida_kernwin.chtype_name

chtype_stkvar_xref = _ida_kernwin.chtype_stkvar_xref

chtype_xref = _ida_kernwin.chtype_xref

chtype_enum = _ida_kernwin.chtype_enum

chtype_enum_by_value = _ida_kernwin.chtype_enum_by_value

chtype_func = _ida_kernwin.chtype_func

chtype_segm = _ida_kernwin.chtype_segm

chtype_struc = _ida_kernwin.chtype_struc

chtype_strpath = _ida_kernwin.chtype_strpath

chtype_idatil = _ida_kernwin.chtype_idatil

chtype_enum_by_value_and_size = _ida_kernwin.chtype_enum_by_value_and_size

chtype_srcp = _ida_kernwin.chtype_srcp

beep_default = _ida_kernwin.beep_default

TCCRT_INVALID = _ida_kernwin.TCCRT_INVALID

TCCRT_FLAT = _ida_kernwin.TCCRT_FLAT

TCCRT_GRAPH = _ida_kernwin.TCCRT_GRAPH

TCCRT_PROXIMITY = _ida_kernwin.TCCRT_PROXIMITY

TCCPT_INVALID = _ida_kernwin.TCCPT_INVALID

TCCPT_PLACE = _ida_kernwin.TCCPT_PLACE

TCCPT_SIMPLELINE_PLACE = _ida_kernwin.TCCPT_SIMPLELINE_PLACE

TCCPT_IDAPLACE = _ida_kernwin.TCCPT_IDAPLACE

TCCPT_ENUMPLACE = _ida_kernwin.TCCPT_ENUMPLACE

TCCPT_STRUCTPLACE = _ida_kernwin.TCCPT_STRUCTPLACE

VME_UNKNOWN = _ida_kernwin.VME_UNKNOWN

VME_LEFT_BUTTON = _ida_kernwin.VME_LEFT_BUTTON

VME_RIGHT_BUTTON = _ida_kernwin.VME_RIGHT_BUTTON

VME_MID_BUTTON = _ida_kernwin.VME_MID_BUTTON

SETMENU_POSMASK = _ida_kernwin.SETMENU_POSMASK

SETMENU_INS = _ida_kernwin.SETMENU_INS

SETMENU_APP = _ida_kernwin.SETMENU_APP

SETMENU_FIRST = _ida_kernwin.SETMENU_FIRST

CREATETB_ADV = _ida_kernwin.CREATETB_ADV

HIF_IDENTIFIER = _ida_kernwin.HIF_IDENTIFIER

HIF_REGISTER = _ida_kernwin.HIF_REGISTER

HIF_LOCKED = _ida_kernwin.HIF_LOCKED

REG_HINTS_MARKER = _ida_kernwin.REG_HINTS_MARKER

REG_HINTS_MARKER_LEN = _ida_kernwin.REG_HINTS_MARKER_LEN

SRCDBG_HINTS_MARKER = _ida_kernwin.SRCDBG_HINTS_MARKER

SRCDBG_HINTS_MARKER_LEN = _ida_kernwin.SRCDBG_HINTS_MARKER_LEN


def get_kernel_version(*args):
    r"""get_kernel_version() -> ssize_t"""
    return _ida_kernwin.get_kernel_version(*args)
class place_t(object):
    r"""Proxy of C++ place_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    lnnum = property(_ida_kernwin.place_t_lnnum_get, _ida_kernwin.place_t_lnnum_set, doc=r"""lnnum""")

    def _print(self, *args):
        r"""_print(self, out_buf, ud)"""
        return _ida_kernwin.place_t__print(self, *args)

    def touval(self, *args):
        r"""touval(self, ud) -> uval_t"""
        return _ida_kernwin.place_t_touval(self, *args)

    def clone(self, *args):
        r"""clone(self) -> place_t"""
        return _ida_kernwin.place_t_clone(self, *args)

    def copyfrom(self, *args):
        r"""copyfrom(self, _from)"""
        return _ida_kernwin.place_t_copyfrom(self, *args)

    def makeplace(self, *args):
        r"""makeplace(self, ud, x, lnnum) -> place_t"""
        return _ida_kernwin.place_t_makeplace(self, *args)

    def compare(self, *args):
        r"""compare(self, t2) -> int"""
        return _ida_kernwin.place_t_compare(self, *args)

    def adjust(self, *args):
        r"""adjust(self, ud)"""
        return _ida_kernwin.place_t_adjust(self, *args)

    def prev(self, *args):
        r"""prev(self, ud) -> bool"""
        return _ida_kernwin.place_t_prev(self, *args)

    def next(self, *args):
        r"""next(self, ud) -> bool"""
        return _ida_kernwin.place_t_next(self, *args)

    def beginning(self, *args):
        r"""beginning(self, ud) -> bool"""
        return _ida_kernwin.place_t_beginning(self, *args)

    def ending(self, *args):
        r"""ending(self, ud) -> bool"""
        return _ida_kernwin.place_t_ending(self, *args)

    def id(self, *args):
        r"""id(self) -> int"""
        return _ida_kernwin.place_t_id(self, *args)

    def name(self, *args):
        r"""name(self) -> char const *"""
        return _ida_kernwin.place_t_name(self, *args)

    def toea(self, *args):
        r"""toea(self) -> ea_t"""
        return _ida_kernwin.place_t_toea(self, *args)

    def rebase(self, *args):
        r"""rebase(self, arg2) -> bool"""
        return _ida_kernwin.place_t_rebase(self, *args)

    def enter(self, *args):
        r"""enter(self, arg2) -> place_t"""
        return _ida_kernwin.place_t_enter(self, *args)

    def leave(self, *args):
        r"""leave(self, arg2)"""
        return _ida_kernwin.place_t_leave(self, *args)

    @staticmethod
    def as_idaplace_t(*args):
        r"""as_idaplace_t(p) -> idaplace_t"""
        return _ida_kernwin.place_t_as_idaplace_t(*args)

    @staticmethod
    def as_enumplace_t(*args):
        r"""as_enumplace_t(p) -> enumplace_t"""
        return _ida_kernwin.place_t_as_enumplace_t(*args)

    @staticmethod
    def as_structplace_t(*args):
        r"""as_structplace_t(p) -> structplace_t"""
        return _ida_kernwin.place_t_as_structplace_t(*args)

    @staticmethod
    def as_simpleline_place_t(*args):
        r"""as_simpleline_place_t(p) -> simpleline_place_t"""
        return _ida_kernwin.place_t_as_simpleline_place_t(*args)

    def generate(self, *args):
        r"""generate(self, ud, maxsize) -> PyObject *"""
        return _ida_kernwin.place_t_generate(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_place_t

# Register place_t in _ida_kernwin:
_ida_kernwin.place_t_swigregister(place_t)

def place_t_as_idaplace_t(*args):
    r"""place_t_as_idaplace_t(p) -> idaplace_t"""
    return _ida_kernwin.place_t_as_idaplace_t(*args)

def place_t_as_enumplace_t(*args):
    r"""place_t_as_enumplace_t(p) -> enumplace_t"""
    return _ida_kernwin.place_t_as_enumplace_t(*args)

def place_t_as_structplace_t(*args):
    r"""place_t_as_structplace_t(p) -> structplace_t"""
    return _ida_kernwin.place_t_as_structplace_t(*args)

def place_t_as_simpleline_place_t(*args):
    r"""place_t_as_simpleline_place_t(p) -> simpleline_place_t"""
    return _ida_kernwin.place_t_as_simpleline_place_t(*args)

DEFAULT_PLACE_LNNUM = _ida_kernwin.DEFAULT_PLACE_LNNUM

class simpleline_t(object):
    r"""Proxy of C++ simpleline_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    line = property(_ida_kernwin.simpleline_t_line_get, _ida_kernwin.simpleline_t_line_set, doc=r"""line""")
    color = property(_ida_kernwin.simpleline_t_color_get, _ida_kernwin.simpleline_t_color_set, doc=r"""color""")
    bgcolor = property(_ida_kernwin.simpleline_t_bgcolor_get, _ida_kernwin.simpleline_t_bgcolor_set, doc=r"""bgcolor""")

    def __init__(self, *args):
        r"""
        __init__(self) -> simpleline_t
        __init__(self, c, str) -> simpleline_t
        __init__(self, str) -> simpleline_t
        __init__(self, str) -> simpleline_t
        """
        _ida_kernwin.simpleline_t_swiginit(self, _ida_kernwin.new_simpleline_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_simpleline_t

# Register simpleline_t in _ida_kernwin:
_ida_kernwin.simpleline_t_swigregister(simpleline_t)

class simpleline_place_t(place_t):
    r"""Proxy of C++ simpleline_place_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    n = property(_ida_kernwin.simpleline_place_t_n_get, _ida_kernwin.simpleline_place_t_n_set, doc=r"""n""")
    __swig_destroy__ = _ida_kernwin.delete_simpleline_place_t

# Register simpleline_place_t in _ida_kernwin:
_ida_kernwin.simpleline_place_t_swigregister(simpleline_place_t)

class idaplace_t(place_t):
    r"""Proxy of C++ idaplace_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ea = property(_ida_kernwin.idaplace_t_ea_get, _ida_kernwin.idaplace_t_ea_set, doc=r"""ea""")
    __swig_destroy__ = _ida_kernwin.delete_idaplace_t

# Register idaplace_t in _ida_kernwin:
_ida_kernwin.idaplace_t_swigregister(idaplace_t)

class enumplace_t(place_t):
    r"""Proxy of C++ enumplace_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    idx = property(_ida_kernwin.enumplace_t_idx_get, _ida_kernwin.enumplace_t_idx_set, doc=r"""idx""")
    bmask = property(_ida_kernwin.enumplace_t_bmask_get, _ida_kernwin.enumplace_t_bmask_set, doc=r"""bmask""")
    value = property(_ida_kernwin.enumplace_t_value_get, _ida_kernwin.enumplace_t_value_set, doc=r"""value""")
    serial = property(_ida_kernwin.enumplace_t_serial_get, _ida_kernwin.enumplace_t_serial_set, doc=r"""serial""")
    __swig_destroy__ = _ida_kernwin.delete_enumplace_t

# Register enumplace_t in _ida_kernwin:
_ida_kernwin.enumplace_t_swigregister(enumplace_t)

class structplace_t(place_t):
    r"""Proxy of C++ structplace_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    idx = property(_ida_kernwin.structplace_t_idx_get, _ida_kernwin.structplace_t_idx_set, doc=r"""idx""")
    offset = property(_ida_kernwin.structplace_t_offset_get, _ida_kernwin.structplace_t_offset_set, doc=r"""offset""")
    __swig_destroy__ = _ida_kernwin.delete_structplace_t

# Register structplace_t in _ida_kernwin:
_ida_kernwin.structplace_t_swigregister(structplace_t)

PCF_EA_CAPABLE = _ida_kernwin.PCF_EA_CAPABLE


def internal_register_place_class(*args):
    r"""internal_register_place_class(tmplate, flags, owner, sdk_version) -> int"""
    return _ida_kernwin.internal_register_place_class(*args)

def get_place_class(*args):
    r"""get_place_class(out_flags, out_sdk_version, id) -> place_t"""
    return _ida_kernwin.get_place_class(*args)

def get_place_class_template(*args):
    r"""get_place_class_template(id) -> place_t"""
    return _ida_kernwin.get_place_class_template(*args)

def is_place_class_ea_capable(*args):
    r"""is_place_class_ea_capable(id) -> bool"""
    return _ida_kernwin.is_place_class_ea_capable(*args)

def get_place_class_id(*args):
    r"""get_place_class_id(name) -> int"""
    return _ida_kernwin.get_place_class_id(*args)
class twinpos_t(object):
    r"""Proxy of C++ twinpos_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    at = property(_ida_kernwin.twinpos_t_at_get, _ida_kernwin.twinpos_t_at_set, doc=r"""at""")
    x = property(_ida_kernwin.twinpos_t_x_get, _ida_kernwin.twinpos_t_x_set, doc=r"""x""")

    def __init__(self, *args):
        r"""
        __init__(self) -> twinpos_t
        __init__(self, t) -> twinpos_t
        __init__(self, t, x0) -> twinpos_t
        """
        _ida_kernwin.twinpos_t_swiginit(self, _ida_kernwin.new_twinpos_t(*args))

    def __ne__(self, *args):
        r"""__ne__(self, r) -> bool"""
        return _ida_kernwin.twinpos_t___ne__(self, *args)

    def __eq__(self, *args):
        r"""__eq__(self, r) -> bool"""
        return _ida_kernwin.twinpos_t___eq__(self, *args)

    def place_as_idaplace_t(self):
        return place_t.as_idaplace_t(self.at)
    def place_as_enumplace_t(self):
        return place_t.as_enumplace_t(self.at)
    def place_as_structplace_t(self):
        return place_t.as_structplace_t(self.at)
    def place_as_simpleline_place_t(self):
        return place_t.as_simpleline_place_t(self.at)

    def place(self, view):
        ptype = get_viewer_place_type(view)
        if ptype == TCCPT_IDAPLACE:
            return self.place_as_idaplace_t()
        elif ptype == TCCPT_ENUMPLACE:
            return self.place_as_enumplace_t()
        elif ptype == TCCPT_STRUCTPLACE:
            return self.place_as_structplace_t()
        elif ptype == TCCPT_SIMPLELINE_PLACE:
            return self.place_as_simpleline_place_t()
        else:
            return self.at

    __swig_destroy__ = _ida_kernwin.delete_twinpos_t

# Register twinpos_t in _ida_kernwin:
_ida_kernwin.twinpos_t_swigregister(twinpos_t)


def request_refresh(*args):
    r"""request_refresh(mask, cnd=True)"""
    return _ida_kernwin.request_refresh(*args)

def clear_refresh_request(*args):
    r"""clear_refresh_request(mask)"""
    return _ida_kernwin.clear_refresh_request(*args)

def is_refresh_requested(*args):
    r"""is_refresh_requested(mask) -> bool"""
    return _ida_kernwin.is_refresh_requested(*args)
BWN_UNKNOWN = _ida_kernwin.BWN_UNKNOWN

BWN_EXPORTS = _ida_kernwin.BWN_EXPORTS

BWN_IMPORTS = _ida_kernwin.BWN_IMPORTS

BWN_NAMES = _ida_kernwin.BWN_NAMES

BWN_FUNCS = _ida_kernwin.BWN_FUNCS

BWN_STRINGS = _ida_kernwin.BWN_STRINGS

BWN_SEGS = _ida_kernwin.BWN_SEGS

BWN_SEGREGS = _ida_kernwin.BWN_SEGREGS

BWN_SELS = _ida_kernwin.BWN_SELS

BWN_SIGNS = _ida_kernwin.BWN_SIGNS

BWN_TILS = _ida_kernwin.BWN_TILS

BWN_LOCTYPS = _ida_kernwin.BWN_LOCTYPS

BWN_CALLS = _ida_kernwin.BWN_CALLS

BWN_PROBS = _ida_kernwin.BWN_PROBS

BWN_BPTS = _ida_kernwin.BWN_BPTS

BWN_THREADS = _ida_kernwin.BWN_THREADS

BWN_MODULES = _ida_kernwin.BWN_MODULES

BWN_TRACE = _ida_kernwin.BWN_TRACE

BWN_CALL_STACK = _ida_kernwin.BWN_CALL_STACK

BWN_XREFS = _ida_kernwin.BWN_XREFS

BWN_SEARCH = _ida_kernwin.BWN_SEARCH

BWN_FRAME = _ida_kernwin.BWN_FRAME

BWN_NAVBAND = _ida_kernwin.BWN_NAVBAND

BWN_ENUMS = _ida_kernwin.BWN_ENUMS

BWN_STRUCTS = _ida_kernwin.BWN_STRUCTS

BWN_DISASM = _ida_kernwin.BWN_DISASM

BWN_DUMP = _ida_kernwin.BWN_DUMP

BWN_NOTEPAD = _ida_kernwin.BWN_NOTEPAD

BWN_OUTPUT = _ida_kernwin.BWN_OUTPUT

BWN_CLI = _ida_kernwin.BWN_CLI

BWN_WATCH = _ida_kernwin.BWN_WATCH

BWN_LOCALS = _ida_kernwin.BWN_LOCALS

BWN_STKVIEW = _ida_kernwin.BWN_STKVIEW

BWN_CHOOSER = _ida_kernwin.BWN_CHOOSER

BWN_SHORTCUTCSR = _ida_kernwin.BWN_SHORTCUTCSR

BWN_SHORTCUTWIN = _ida_kernwin.BWN_SHORTCUTWIN

BWN_CPUREGS = _ida_kernwin.BWN_CPUREGS

BWN_SO_STRUCTS = _ida_kernwin.BWN_SO_STRUCTS

BWN_SO_OFFSETS = _ida_kernwin.BWN_SO_OFFSETS

BWN_CMDPALCSR = _ida_kernwin.BWN_CMDPALCSR

BWN_CMDPALWIN = _ida_kernwin.BWN_CMDPALWIN

BWN_SNIPPETS = _ida_kernwin.BWN_SNIPPETS

BWN_CUSTVIEW = _ida_kernwin.BWN_CUSTVIEW

BWN_ADDRWATCH = _ida_kernwin.BWN_ADDRWATCH

BWN_PSEUDOCODE = _ida_kernwin.BWN_PSEUDOCODE

BWN_CALLS_CALLERS = _ida_kernwin.BWN_CALLS_CALLERS

BWN_CALLS_CALLEES = _ida_kernwin.BWN_CALLS_CALLEES

BWN_MDVIEWCSR = _ida_kernwin.BWN_MDVIEWCSR

BWN_STACK = _ida_kernwin.BWN_STACK

BWN_DISASMS = _ida_kernwin.BWN_DISASMS

BWN_DUMPS = _ida_kernwin.BWN_DUMPS

BWN_SEARCHS = _ida_kernwin.BWN_SEARCHS

IWID_EXPORTS = _ida_kernwin.IWID_EXPORTS

IWID_IMPORTS = _ida_kernwin.IWID_IMPORTS

IWID_NAMES = _ida_kernwin.IWID_NAMES

IWID_FUNCS = _ida_kernwin.IWID_FUNCS

IWID_STRINGS = _ida_kernwin.IWID_STRINGS

IWID_SEGS = _ida_kernwin.IWID_SEGS

IWID_SEGREGS = _ida_kernwin.IWID_SEGREGS

IWID_SELS = _ida_kernwin.IWID_SELS

IWID_SIGNS = _ida_kernwin.IWID_SIGNS

IWID_TILS = _ida_kernwin.IWID_TILS

IWID_LOCTYPS = _ida_kernwin.IWID_LOCTYPS

IWID_CALLS = _ida_kernwin.IWID_CALLS

IWID_PROBS = _ida_kernwin.IWID_PROBS

IWID_BPTS = _ida_kernwin.IWID_BPTS

IWID_THREADS = _ida_kernwin.IWID_THREADS

IWID_MODULES = _ida_kernwin.IWID_MODULES

IWID_TRACE = _ida_kernwin.IWID_TRACE

IWID_STACK = _ida_kernwin.IWID_STACK

IWID_XREFS = _ida_kernwin.IWID_XREFS

IWID_SEARCHS = _ida_kernwin.IWID_SEARCHS

IWID_FRAME = _ida_kernwin.IWID_FRAME

IWID_NAVBAND = _ida_kernwin.IWID_NAVBAND

IWID_ENUMS = _ida_kernwin.IWID_ENUMS

IWID_STRUCTS = _ida_kernwin.IWID_STRUCTS

IWID_DISASMS = _ida_kernwin.IWID_DISASMS

IWID_DUMPS = _ida_kernwin.IWID_DUMPS

IWID_NOTEPAD = _ida_kernwin.IWID_NOTEPAD

IWID_OUTPUT = _ida_kernwin.IWID_OUTPUT

IWID_CLI = _ida_kernwin.IWID_CLI

IWID_WATCH = _ida_kernwin.IWID_WATCH

IWID_LOCALS = _ida_kernwin.IWID_LOCALS

IWID_STKVIEW = _ida_kernwin.IWID_STKVIEW

IWID_CHOOSER = _ida_kernwin.IWID_CHOOSER

IWID_SHORTCUTCSR = _ida_kernwin.IWID_SHORTCUTCSR

IWID_SHORTCUTWIN = _ida_kernwin.IWID_SHORTCUTWIN

IWID_CPUREGS = _ida_kernwin.IWID_CPUREGS

IWID_SO_STRUCTS = _ida_kernwin.IWID_SO_STRUCTS

IWID_SO_OFFSETS = _ida_kernwin.IWID_SO_OFFSETS

IWID_CMDPALCSR = _ida_kernwin.IWID_CMDPALCSR

IWID_CMDPALWIN = _ida_kernwin.IWID_CMDPALWIN

IWID_SNIPPETS = _ida_kernwin.IWID_SNIPPETS

IWID_CUSTVIEW = _ida_kernwin.IWID_CUSTVIEW

IWID_ADDRWATCH = _ida_kernwin.IWID_ADDRWATCH

IWID_PSEUDOCODE = _ida_kernwin.IWID_PSEUDOCODE

IWID_CALLS_CALLERS = _ida_kernwin.IWID_CALLS_CALLERS

IWID_CALLS_CALLEES = _ida_kernwin.IWID_CALLS_CALLEES

IWID_MDVIEWCSR = _ida_kernwin.IWID_MDVIEWCSR

IWID_IDAMEMOS = _ida_kernwin.IWID_IDAMEMOS

IWID_ALL = _ida_kernwin.IWID_ALL


def is_chooser_widget(*args):
    r"""is_chooser_widget(t) -> bool"""
    return _ida_kernwin.is_chooser_widget(*args)
CHITEM_BOLD = _ida_kernwin.CHITEM_BOLD

CHITEM_ITALIC = _ida_kernwin.CHITEM_ITALIC

CHITEM_UNDER = _ida_kernwin.CHITEM_UNDER

CHITEM_STRIKE = _ida_kernwin.CHITEM_STRIKE

CHITEM_GRAY = _ida_kernwin.CHITEM_GRAY

CHOOSER_NOMAINMENU = _ida_kernwin.CHOOSER_NOMAINMENU

CHOOSER_NOSTATUSBAR = _ida_kernwin.CHOOSER_NOSTATUSBAR

class chooser_item_attrs_t(object):
    r"""Proxy of C++ chooser_item_attrs_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flags = property(_ida_kernwin.chooser_item_attrs_t_flags_get, _ida_kernwin.chooser_item_attrs_t_flags_set, doc=r"""flags""")
    color = property(_ida_kernwin.chooser_item_attrs_t_color_get, _ida_kernwin.chooser_item_attrs_t_color_set, doc=r"""color""")

    def __init__(self, *args):
        r"""__init__(self) -> chooser_item_attrs_t"""
        _ida_kernwin.chooser_item_attrs_t_swiginit(self, _ida_kernwin.new_chooser_item_attrs_t(*args))

    def reset(self, *args):
        r"""reset(self)"""
        return _ida_kernwin.chooser_item_attrs_t_reset(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_chooser_item_attrs_t

# Register chooser_item_attrs_t in _ida_kernwin:
_ida_kernwin.chooser_item_attrs_t_swigregister(chooser_item_attrs_t)

CHOOSER_NO_SELECTION = _ida_kernwin.CHOOSER_NO_SELECTION

CHOOSER_MULTI_SELECTION = _ida_kernwin.CHOOSER_MULTI_SELECTION

CHOOSER_POPUP_MENU = _ida_kernwin.CHOOSER_POPUP_MENU

CHOOSER_MENU_EDIT = _ida_kernwin.CHOOSER_MENU_EDIT

CHOOSER_MENU_JUMP = _ida_kernwin.CHOOSER_MENU_JUMP

CHOOSER_MENU_SEARCH = _ida_kernwin.CHOOSER_MENU_SEARCH

nat_lib = _ida_kernwin.nat_lib

nat_fun = _ida_kernwin.nat_fun

nat_cod = _ida_kernwin.nat_cod

nat_dat = _ida_kernwin.nat_dat

nat_und = _ida_kernwin.nat_und

nat_ext = _ida_kernwin.nat_ext

nat_err = _ida_kernwin.nat_err

nat_gap = _ida_kernwin.nat_gap

nat_cur = _ida_kernwin.nat_cur

nat_auto = _ida_kernwin.nat_auto

nat_lum = _ida_kernwin.nat_lum

nat_last = _ida_kernwin.nat_last

CVH_USERDATA = _ida_kernwin.CVH_USERDATA

CVH_KEYDOWN = _ida_kernwin.CVH_KEYDOWN

CVH_POPUP = _ida_kernwin.CVH_POPUP

CVH_DBLCLICK = _ida_kernwin.CVH_DBLCLICK

CVH_CURPOS = _ida_kernwin.CVH_CURPOS

CVH_CLOSE = _ida_kernwin.CVH_CLOSE

CVH_CLICK = _ida_kernwin.CVH_CLICK

CVH_QT_AWARE = _ida_kernwin.CVH_QT_AWARE

CVH_HELP = _ida_kernwin.CVH_HELP

CVH_MOUSEMOVE = _ida_kernwin.CVH_MOUSEMOVE

CDVH_USERDATA = _ida_kernwin.CDVH_USERDATA

CDVH_SRCVIEW = _ida_kernwin.CDVH_SRCVIEW

CDVH_LINES_CLICK = _ida_kernwin.CDVH_LINES_CLICK

CDVH_LINES_DBLCLICK = _ida_kernwin.CDVH_LINES_DBLCLICK

CDVH_LINES_POPUP = _ida_kernwin.CDVH_LINES_POPUP

CDVH_LINES_DRAWICON = _ida_kernwin.CDVH_LINES_DRAWICON

CDVH_LINES_LINENUM = _ida_kernwin.CDVH_LINES_LINENUM

CDVH_LINES_ICONMARGIN = _ida_kernwin.CDVH_LINES_ICONMARGIN

CDVH_LINES_RADIX = _ida_kernwin.CDVH_LINES_RADIX

CDVH_LINES_ALIGNMENT = _ida_kernwin.CDVH_LINES_ALIGNMENT

VES_SHIFT = _ida_kernwin.VES_SHIFT

VES_ALT = _ida_kernwin.VES_ALT

VES_CTRL = _ida_kernwin.VES_CTRL

VES_MOUSE_LEFT = _ida_kernwin.VES_MOUSE_LEFT

VES_MOUSE_RIGHT = _ida_kernwin.VES_MOUSE_RIGHT

VES_MOUSE_MIDDLE = _ida_kernwin.VES_MOUSE_MIDDLE

VES_META = _ida_kernwin.VES_META

msg_activated = _ida_kernwin.msg_activated

msg_deactivated = _ida_kernwin.msg_deactivated

msg_click = _ida_kernwin.msg_click

msg_dblclick = _ida_kernwin.msg_dblclick

msg_closed = _ida_kernwin.msg_closed

msg_keydown = _ida_kernwin.msg_keydown

class renderer_pos_info_t(object):
    r"""Proxy of C++ renderer_pos_info_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""__init__(self) -> renderer_pos_info_t"""
        _ida_kernwin.renderer_pos_info_t_swiginit(self, _ida_kernwin.new_renderer_pos_info_t(*args))
    node = property(_ida_kernwin.renderer_pos_info_t_node_get, _ida_kernwin.renderer_pos_info_t_node_set, doc=r"""node""")
    cx = property(_ida_kernwin.renderer_pos_info_t_cx_get, _ida_kernwin.renderer_pos_info_t_cx_set, doc=r"""cx""")
    cy = property(_ida_kernwin.renderer_pos_info_t_cy_get, _ida_kernwin.renderer_pos_info_t_cy_set, doc=r"""cy""")
    sx = property(_ida_kernwin.renderer_pos_info_t_sx_get, _ida_kernwin.renderer_pos_info_t_sx_set, doc=r"""sx""")

    def __eq__(self, *args):
        r"""__eq__(self, r) -> bool"""
        return _ida_kernwin.renderer_pos_info_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""__ne__(self, r) -> bool"""
        return _ida_kernwin.renderer_pos_info_t___ne__(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_renderer_pos_info_t

# Register renderer_pos_info_t in _ida_kernwin:
_ida_kernwin.renderer_pos_info_t_swigregister(renderer_pos_info_t)

class view_mouse_event_location_t(object):
    r"""Proxy of C++ view_mouse_event_location_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ea = property(_ida_kernwin.view_mouse_event_location_t_ea_get, _ida_kernwin.view_mouse_event_location_t_ea_set, doc=r"""ea""")
    item = property(_ida_kernwin.view_mouse_event_location_t_item_get, _ida_kernwin.view_mouse_event_location_t_item_set, doc=r"""item""")

    def __init__(self, *args):
        r"""__init__(self) -> view_mouse_event_location_t"""
        _ida_kernwin.view_mouse_event_location_t_swiginit(self, _ida_kernwin.new_view_mouse_event_location_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_view_mouse_event_location_t

# Register view_mouse_event_location_t in _ida_kernwin:
_ida_kernwin.view_mouse_event_location_t_swigregister(view_mouse_event_location_t)

class view_mouse_event_t(object):
    r"""Proxy of C++ view_mouse_event_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rtype = property(_ida_kernwin.view_mouse_event_t_rtype_get, _ida_kernwin.view_mouse_event_t_rtype_set, doc=r"""rtype""")
    x = property(_ida_kernwin.view_mouse_event_t_x_get, _ida_kernwin.view_mouse_event_t_x_set, doc=r"""x""")
    y = property(_ida_kernwin.view_mouse_event_t_y_get, _ida_kernwin.view_mouse_event_t_y_set, doc=r"""y""")
    location = property(_ida_kernwin.view_mouse_event_t_location_get, _ida_kernwin.view_mouse_event_t_location_set, doc=r"""location""")
    state = property(_ida_kernwin.view_mouse_event_t_state_get, _ida_kernwin.view_mouse_event_t_state_set, doc=r"""state""")
    button = property(_ida_kernwin.view_mouse_event_t_button_get, _ida_kernwin.view_mouse_event_t_button_set, doc=r"""button""")
    renderer_pos = property(_ida_kernwin.view_mouse_event_t_renderer_pos_get, _ida_kernwin.view_mouse_event_t_renderer_pos_set, doc=r"""renderer_pos""")

    def __init__(self, *args):
        r"""__init__(self) -> view_mouse_event_t"""
        _ida_kernwin.view_mouse_event_t_swiginit(self, _ida_kernwin.new_view_mouse_event_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_view_mouse_event_t

# Register view_mouse_event_t in _ida_kernwin:
_ida_kernwin.view_mouse_event_t_swigregister(view_mouse_event_t)

view_activated = _ida_kernwin.view_activated

view_deactivated = _ida_kernwin.view_deactivated

view_keydown = _ida_kernwin.view_keydown

view_click = _ida_kernwin.view_click

view_dblclick = _ida_kernwin.view_dblclick

view_curpos = _ida_kernwin.view_curpos

view_created = _ida_kernwin.view_created

view_close = _ida_kernwin.view_close

view_switched = _ida_kernwin.view_switched

view_mouse_over = _ida_kernwin.view_mouse_over

view_loc_changed = _ida_kernwin.view_loc_changed

view_mouse_moved = _ida_kernwin.view_mouse_moved

lcr_unknown = _ida_kernwin.lcr_unknown

lcr_goto = _ida_kernwin.lcr_goto

lcr_user_switch = _ida_kernwin.lcr_user_switch

lcr_auto_switch = _ida_kernwin.lcr_auto_switch

lcr_jump = _ida_kernwin.lcr_jump

lcr_navigate = _ida_kernwin.lcr_navigate

lcr_scroll = _ida_kernwin.lcr_scroll

lcr_internal = _ida_kernwin.lcr_internal

LCMD_SYNC = _ida_kernwin.LCMD_SYNC

class locchange_md_t(object):
    r"""Proxy of C++ locchange_md_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""__init__(self, _reason, _sync) -> locchange_md_t"""
        _ida_kernwin.locchange_md_t_swiginit(self, _ida_kernwin.new_locchange_md_t(*args))

    def reason(self, *args):
        r"""reason(self) -> locchange_reason_t"""
        return _ida_kernwin.locchange_md_t_reason(self, *args)

    def is_sync(self, *args):
        r"""is_sync(self) -> bool"""
        return _ida_kernwin.locchange_md_t_is_sync(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_locchange_md_t

# Register locchange_md_t in _ida_kernwin:
_ida_kernwin.locchange_md_t_swigregister(locchange_md_t)

MFF_FAST = _ida_kernwin.MFF_FAST

MFF_READ = _ida_kernwin.MFF_READ

MFF_WRITE = _ida_kernwin.MFF_WRITE

MFF_NOWAIT = _ida_kernwin.MFF_NOWAIT

class ui_requests_t(object):
    r"""Proxy of C++ ui_requests_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""__init__(self) -> ui_requests_t"""
        _ida_kernwin.ui_requests_t_swiginit(self, _ida_kernwin.new_ui_requests_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_ui_requests_t

# Register ui_requests_t in _ida_kernwin:
_ida_kernwin.ui_requests_t_swigregister(ui_requests_t)

UIJMP_ACTIVATE = _ida_kernwin.UIJMP_ACTIVATE

UIJMP_DONTPUSH = _ida_kernwin.UIJMP_DONTPUSH

UIJMP_IDAVIEW = _ida_kernwin.UIJMP_IDAVIEW

class action_ctx_base_t(object):
    r"""Proxy of C++ action_ctx_base_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""__init__(self) -> action_ctx_base_t"""
        _ida_kernwin.action_ctx_base_t_swiginit(self, _ida_kernwin.new_action_ctx_base_t(*args))

    def reset(self, *args):
        r"""reset(self)"""
        return _ida_kernwin.action_ctx_base_t_reset(self, *args)
    widget = property(_ida_kernwin.action_ctx_base_t_widget_get, _ida_kernwin.action_ctx_base_t_widget_set, doc=r"""widget""")
    widget_type = property(_ida_kernwin.action_ctx_base_t_widget_type_get, _ida_kernwin.action_ctx_base_t_widget_type_set, doc=r"""widget_type""")
    widget_title = property(_ida_kernwin.action_ctx_base_t_widget_title_get, _ida_kernwin.action_ctx_base_t_widget_title_set, doc=r"""widget_title""")
    chooser_selection = property(_ida_kernwin.action_ctx_base_t_chooser_selection_get, _ida_kernwin.action_ctx_base_t_chooser_selection_set, doc=r"""chooser_selection""")
    action = property(_ida_kernwin.action_ctx_base_t_action_get, _ida_kernwin.action_ctx_base_t_action_set, doc=r"""action""")
    cur_flags = property(_ida_kernwin.action_ctx_base_t_cur_flags_get, _ida_kernwin.action_ctx_base_t_cur_flags_set, doc=r"""cur_flags""")

    def has_flag(self, *args):
        r"""has_flag(self, flag) -> bool"""
        return _ida_kernwin.action_ctx_base_t_has_flag(self, *args)
    cur_ea = property(_ida_kernwin.action_ctx_base_t_cur_ea_get, _ida_kernwin.action_ctx_base_t_cur_ea_set, doc=r"""cur_ea""")
    cur_extracted_ea = property(_ida_kernwin.action_ctx_base_t_cur_extracted_ea_get, _ida_kernwin.action_ctx_base_t_cur_extracted_ea_set, doc=r"""cur_extracted_ea""")
    cur_func = property(_ida_kernwin.action_ctx_base_t_cur_func_get, _ida_kernwin.action_ctx_base_t_cur_func_set, doc=r"""cur_func""")
    cur_fchunk = property(_ida_kernwin.action_ctx_base_t_cur_fchunk_get, _ida_kernwin.action_ctx_base_t_cur_fchunk_set, doc=r"""cur_fchunk""")
    cur_struc = property(_ida_kernwin.action_ctx_base_t_cur_struc_get, _ida_kernwin.action_ctx_base_t_cur_struc_set, doc=r"""cur_struc""")
    cur_strmem = property(_ida_kernwin.action_ctx_base_t_cur_strmem_get, _ida_kernwin.action_ctx_base_t_cur_strmem_set, doc=r"""cur_strmem""")
    cur_enum = property(_ida_kernwin.action_ctx_base_t_cur_enum_get, _ida_kernwin.action_ctx_base_t_cur_enum_set, doc=r"""cur_enum""")
    cur_seg = property(_ida_kernwin.action_ctx_base_t_cur_seg_get, _ida_kernwin.action_ctx_base_t_cur_seg_set, doc=r"""cur_seg""")
    regname = property(_ida_kernwin.action_ctx_base_t_regname_get, _ida_kernwin.action_ctx_base_t_regname_set, doc=r"""regname""")
    focus = property(_ida_kernwin.action_ctx_base_t_focus_get, _ida_kernwin.action_ctx_base_t_focus_set, doc=r"""focus""")
    reserved = property(_ida_kernwin.action_ctx_base_t_reserved_get, _ida_kernwin.action_ctx_base_t_reserved_set, doc=r"""reserved""")

    def _get_form(self, *args):
        r"""_get_form(self) -> TWidget *"""
        return _ida_kernwin.action_ctx_base_t__get_form(self, *args)

    def _get_form_type(self, *args):
        r"""_get_form_type(self) -> twidget_type_t"""
        return _ida_kernwin.action_ctx_base_t__get_form_type(self, *args)

    def _get_form_title(self, *args):
        r"""_get_form_title(self) -> qstring"""
        return _ida_kernwin.action_ctx_base_t__get_form_title(self, *args)


    form = property(_get_form)
    form_type = property(_get_form_type)
    form_title = property(_get_form_title)


    __swig_destroy__ = _ida_kernwin.delete_action_ctx_base_t

# Register action_ctx_base_t in _ida_kernwin:
_ida_kernwin.action_ctx_base_t_swigregister(action_ctx_base_t)
ACF_HAS_SELECTION = _ida_kernwin.ACF_HAS_SELECTION

ACF_XTRN_EA = _ida_kernwin.ACF_XTRN_EA


AHF_VERSION = _ida_kernwin.AHF_VERSION

AHF_VERSION_MASK = _ida_kernwin.AHF_VERSION_MASK

AST_ENABLE_ALWAYS = _ida_kernwin.AST_ENABLE_ALWAYS

AST_ENABLE_FOR_IDB = _ida_kernwin.AST_ENABLE_FOR_IDB

AST_ENABLE_FOR_WIDGET = _ida_kernwin.AST_ENABLE_FOR_WIDGET

AST_ENABLE = _ida_kernwin.AST_ENABLE

AST_DISABLE_ALWAYS = _ida_kernwin.AST_DISABLE_ALWAYS

AST_DISABLE_FOR_IDB = _ida_kernwin.AST_DISABLE_FOR_IDB

AST_DISABLE_FOR_WIDGET = _ida_kernwin.AST_DISABLE_FOR_WIDGET

AST_DISABLE = _ida_kernwin.AST_DISABLE


def is_action_enabled(*args):
    r"""is_action_enabled(s) -> bool"""
    return _ida_kernwin.is_action_enabled(*args)
class action_desc_t(object):
    r"""Proxy of C++ action_desc_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cb = property(_ida_kernwin.action_desc_t_cb_get, _ida_kernwin.action_desc_t_cb_set, doc=r"""cb""")
    name = property(_ida_kernwin.action_desc_t_name_get, _ida_kernwin.action_desc_t_name_set, doc=r"""name""")
    label = property(_ida_kernwin.action_desc_t_label_get, _ida_kernwin.action_desc_t_label_set, doc=r"""label""")
    owner = property(_ida_kernwin.action_desc_t_owner_get, _ida_kernwin.action_desc_t_owner_set, doc=r"""owner""")
    shortcut = property(_ida_kernwin.action_desc_t_shortcut_get, _ida_kernwin.action_desc_t_shortcut_set, doc=r"""shortcut""")
    tooltip = property(_ida_kernwin.action_desc_t_tooltip_get, _ida_kernwin.action_desc_t_tooltip_set, doc=r"""tooltip""")
    icon = property(_ida_kernwin.action_desc_t_icon_get, _ida_kernwin.action_desc_t_icon_set, doc=r"""icon""")
    flags = property(_ida_kernwin.action_desc_t_flags_get, _ida_kernwin.action_desc_t_flags_set, doc=r"""flags""")

    def __init__(self, *args):
        r"""__init__(self, name, label, handler, shortcut=None, tooltip=None, icon=-1, flags=0) -> action_desc_t"""
        _ida_kernwin.action_desc_t_swiginit(self, _ida_kernwin.new_action_desc_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_action_desc_t

# Register action_desc_t in _ida_kernwin:
_ida_kernwin.action_desc_t_swigregister(action_desc_t)
ADF_OWN_HANDLER = _ida_kernwin.ADF_OWN_HANDLER


AA_NONE = _ida_kernwin.AA_NONE

AA_LABEL = _ida_kernwin.AA_LABEL

AA_SHORTCUT = _ida_kernwin.AA_SHORTCUT

AA_TOOLTIP = _ida_kernwin.AA_TOOLTIP

AA_ICON = _ida_kernwin.AA_ICON

AA_STATE = _ida_kernwin.AA_STATE

AA_CHECKABLE = _ida_kernwin.AA_CHECKABLE

AA_CHECKED = _ida_kernwin.AA_CHECKED

AA_VISIBILITY = _ida_kernwin.AA_VISIBILITY


def cancel_exec_request(*args):
    r"""cancel_exec_request(req_id) -> bool"""
    return _ida_kernwin.cancel_exec_request(*args)

def banner(*args):
    r"""banner(wait) -> bool"""
    return _ida_kernwin.banner(*args)

def is_msg_inited(*args):
    r"""is_msg_inited() -> bool"""
    return _ida_kernwin.is_msg_inited(*args)

def refresh_idaview(*args):
    r"""refresh_idaview()"""
    return _ida_kernwin.refresh_idaview(*args)

def refresh_idaview_anyway(*args):
    r"""refresh_idaview_anyway()"""
    return _ida_kernwin.refresh_idaview_anyway(*args)

def analyzer_options(*args):
    r"""analyzer_options()"""
    return _ida_kernwin.analyzer_options(*args)

def get_screen_ea(*args):
    r"""get_screen_ea() -> ea_t"""
    return _ida_kernwin.get_screen_ea(*args)

def get_opnum(*args):
    r"""get_opnum() -> int"""
    return _ida_kernwin.get_opnum(*args)

def get_cursor(*args):
    r"""get_cursor() -> bool"""
    return _ida_kernwin.get_cursor(*args)

def get_output_cursor(*args):
    r"""get_output_cursor() -> bool"""
    return _ida_kernwin.get_output_cursor(*args)

def get_curline(*args):
    r"""get_curline() -> char const *"""
    return _ida_kernwin.get_curline(*args)

def open_url(*args):
    r"""open_url(url)"""
    return _ida_kernwin.open_url(*args)

def get_hexdump_ea(*args):
    r"""get_hexdump_ea(hexdump_num) -> ea_t"""
    return _ida_kernwin.get_hexdump_ea(*args)

def get_key_code(*args):
    r"""get_key_code(keyname) -> ushort"""
    return _ida_kernwin.get_key_code(*args)

def lookup_key_code(*args):
    r"""lookup_key_code(key, shift, is_qt) -> ushort"""
    return _ida_kernwin.lookup_key_code(*args)

def refresh_navband(*args):
    r"""refresh_navband(force)"""
    return _ida_kernwin.refresh_navband(*args)

def refresh_chooser(*args):
    r"""refresh_chooser(title) -> bool"""
    return _ida_kernwin.refresh_chooser(*args)

def close_chooser(*args):
    r"""close_chooser(title) -> bool"""
    return _ida_kernwin.close_chooser(*args)

def set_dock_pos(*args):
    r"""set_dock_pos(src_ctrl, dest_ctrl, orient, left=0, top=0, right=0, bottom=0) -> bool"""
    return _ida_kernwin.set_dock_pos(*args)

def free_custom_icon(*args):
    r"""free_custom_icon(icon_id)"""
    return _ida_kernwin.free_custom_icon(*args)
class __qtimer_t(object):
    r"""Proxy of C++ __qtimer_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""__init__(self) -> __qtimer_t"""
        _ida_kernwin.__qtimer_t_swiginit(self, _ida_kernwin.new___qtimer_t(*args))
    __swig_destroy__ = _ida_kernwin.delete___qtimer_t

# Register __qtimer_t in _ida_kernwin:
_ida_kernwin.__qtimer_t_swigregister(__qtimer_t)


def unregister_action(*args):
    r"""unregister_action(name) -> bool"""
    return _ida_kernwin.unregister_action(*args)

def create_toolbar(*args):
    r"""create_toolbar(name, label, before=None, flags=0) -> bool"""
    return _ida_kernwin.create_toolbar(*args)

def delete_toolbar(*args):
    r"""delete_toolbar(name) -> bool"""
    return _ida_kernwin.delete_toolbar(*args)

def create_menu(*args):
    r"""create_menu(name, label, before=None) -> bool"""
    return _ida_kernwin.create_menu(*args)

def delete_menu(*args):
    r"""delete_menu(name) -> bool"""
    return _ida_kernwin.delete_menu(*args)

def attach_action_to_menu(*args):
    r"""attach_action_to_menu(menupath, name, flags) -> bool"""
    return _ida_kernwin.attach_action_to_menu(*args)

def detach_action_from_menu(*args):
    r"""detach_action_from_menu(menupath, name) -> bool"""
    return _ida_kernwin.detach_action_from_menu(*args)

def attach_action_to_toolbar(*args):
    r"""attach_action_to_toolbar(toolbar_name, name) -> bool"""
    return _ida_kernwin.attach_action_to_toolbar(*args)

def detach_action_from_toolbar(*args):
    r"""detach_action_from_toolbar(toolbar_name, name) -> bool"""
    return _ida_kernwin.detach_action_from_toolbar(*args)

def register_and_attach_to_menu(*args):
    r"""register_and_attach_to_menu(menupath, name, label, shortcut, flags, handler, owner) -> bool"""
    return _ida_kernwin.register_and_attach_to_menu(*args)

def display_widget(*args):
    r"""display_widget(widget, options)"""
    return _ida_kernwin.display_widget(*args)

def close_widget(*args):
    r"""close_widget(widget, options)"""
    return _ida_kernwin.close_widget(*args)

def activate_widget(*args):
    r"""activate_widget(widget, take_focus)"""
    return _ida_kernwin.activate_widget(*args)

def find_widget(*args):
    r"""find_widget(caption) -> TWidget *"""
    return _ida_kernwin.find_widget(*args)

def get_current_widget(*args):
    r"""get_current_widget() -> TWidget *"""
    return _ida_kernwin.get_current_widget(*args)

def get_widget_type(*args):
    r"""get_widget_type(widget) -> twidget_type_t"""
    return _ida_kernwin.get_widget_type(*args)

def get_widget_title(*args):
    r"""get_widget_title(widget) -> bool"""
    return _ida_kernwin.get_widget_title(*args)

def custom_viewer_jump(*args):
    r"""custom_viewer_jump(v, loc, flags) -> bool"""
    return _ida_kernwin.custom_viewer_jump(*args)

def ea_viewer_history_push_and_jump(*args):
    r"""ea_viewer_history_push_and_jump(v, ea, x, y, lnnum) -> bool"""
    return _ida_kernwin.ea_viewer_history_push_and_jump(*args)

def get_ea_viewer_history_info(*args):
    r"""get_ea_viewer_history_info(nback, nfwd, v) -> bool"""
    return _ida_kernwin.get_ea_viewer_history_info(*args)

def repaint_custom_viewer(*args):
    r"""repaint_custom_viewer(custom_viewer)"""
    return _ida_kernwin.repaint_custom_viewer(*args)

def jumpto(*args):
    r"""
    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
    jumpto(custom_viewer, place, x, y) -> bool
    """
    return _ida_kernwin.jumpto(*args)

def get_custom_viewer_place(*args):
    r"""get_custom_viewer_place(custom_viewer, mouse) -> place_t"""
    return _ida_kernwin.get_custom_viewer_place(*args)

def is_idaq(*args):
    r"""is_idaq() -> bool"""
    return _ida_kernwin.is_idaq(*args)

def attach_action_to_popup(*args):
    r"""attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0) -> bool"""
    return _ida_kernwin.attach_action_to_popup(*args)

def detach_action_from_popup(*args):
    r"""detach_action_from_popup(widget, name) -> bool"""
    return _ida_kernwin.detach_action_from_popup(*args)

def update_action_label(*args):
    r"""update_action_label(name, label) -> bool"""
    return _ida_kernwin.update_action_label(*args)

def update_action_shortcut(*args):
    r"""update_action_shortcut(name, shortcut) -> bool"""
    return _ida_kernwin.update_action_shortcut(*args)

def update_action_tooltip(*args):
    r"""update_action_tooltip(name, tooltip) -> bool"""
    return _ida_kernwin.update_action_tooltip(*args)

def update_action_icon(*args):
    r"""update_action_icon(name, icon) -> bool"""
    return _ida_kernwin.update_action_icon(*args)

def update_action_state(*args):
    r"""update_action_state(name, state) -> bool"""
    return _ida_kernwin.update_action_state(*args)

def update_action_checkable(*args):
    r"""update_action_checkable(name, checkable) -> bool"""
    return _ida_kernwin.update_action_checkable(*args)

def update_action_checked(*args):
    r"""update_action_checked(name, checked) -> bool"""
    return _ida_kernwin.update_action_checked(*args)

def update_action_visibility(*args):
    r"""update_action_visibility(name, visible) -> bool"""
    return _ida_kernwin.update_action_visibility(*args)

def get_action_label(*args):
    r"""get_action_label(name) -> bool"""
    return _ida_kernwin.get_action_label(*args)

def get_action_shortcut(*args):
    r"""get_action_shortcut(name) -> bool"""
    return _ida_kernwin.get_action_shortcut(*args)

def get_action_tooltip(*args):
    r"""get_action_tooltip(name) -> bool"""
    return _ida_kernwin.get_action_tooltip(*args)

def get_action_icon(*args):
    r"""get_action_icon(name) -> bool"""
    return _ida_kernwin.get_action_icon(*args)

def get_action_state(*args):
    r"""get_action_state(name) -> bool"""
    return _ida_kernwin.get_action_state(*args)

def get_action_checkable(*args):
    r"""get_action_checkable(name) -> bool"""
    return _ida_kernwin.get_action_checkable(*args)

def get_action_checked(*args):
    r"""get_action_checked(name) -> bool"""
    return _ida_kernwin.get_action_checked(*args)

def get_action_visibility(*args):
    r"""get_action_visibility(name) -> bool"""
    return _ida_kernwin.get_action_visibility(*args)

def set_custom_viewer_qt_aware(*args):
    r"""set_custom_viewer_qt_aware(custom_viewer) -> bool"""
    return _ida_kernwin.set_custom_viewer_qt_aware(*args)

def get_custom_viewer_curline(*args):
    r"""get_custom_viewer_curline(custom_viewer, mouse) -> char const *"""
    return _ida_kernwin.get_custom_viewer_curline(*args)

def get_output_curline(*args):
    r"""get_output_curline(mouse) -> bool"""
    return _ida_kernwin.get_output_curline(*args)

def get_output_selected_text(*args):
    r"""get_output_selected_text() -> bool"""
    return _ida_kernwin.get_output_selected_text(*args)

def get_current_viewer(*args):
    r"""get_current_viewer() -> TWidget *"""
    return _ida_kernwin.get_current_viewer(*args)

def get_view_renderer_type(*args):
    r"""get_view_renderer_type(v) -> tcc_renderer_type_t"""
    return _ida_kernwin.get_view_renderer_type(*args)

def set_view_renderer_type(*args):
    r"""set_view_renderer_type(v, rt)"""
    return _ida_kernwin.set_view_renderer_type(*args)

def create_empty_widget(*args):
    r"""create_empty_widget(title, icon=-1) -> TWidget *"""
    return _ida_kernwin.create_empty_widget(*args)

def msg_clear(*args):
    r"""msg_clear()"""
    return _ida_kernwin.msg_clear(*args)

def msg_save(*args):
    r"""msg_save(path) -> bool"""
    return _ida_kernwin.msg_save(*args)

def get_active_modal_widget(*args):
    r"""get_active_modal_widget() -> TWidget *"""
    return _ida_kernwin.get_active_modal_widget(*args)

def get_navband_pixel(*args):
    r"""get_navband_pixel(ea) -> int"""
    return _ida_kernwin.get_navband_pixel(*args)

def get_navband_ea(*args):
    r"""get_navband_ea(pixel) -> ea_t"""
    return _ida_kernwin.get_navband_ea(*args)

def get_window_id(*args):
    r"""get_window_id(name=None) -> void *"""
    return _ida_kernwin.get_window_id(*args)

def read_selection(*args):
    r"""read_selection(v, p1, p2) -> bool"""
    return _ida_kernwin.read_selection(*args)

def read_range_selection(*args):
    r"""read_range_selection(v) -> bool"""
    return _ida_kernwin.read_range_selection(*args)

def unmark_selection(*args):
    r"""unmark_selection()"""
    return _ida_kernwin.unmark_selection(*args)

def create_code_viewer(*args):
    r"""create_code_viewer(custview, flags=0, parent=None) -> TWidget *"""
    return _ida_kernwin.create_code_viewer(*args)

def set_code_viewer_handler(*args):
    r"""set_code_viewer_handler(code_viewer, handler_id, handler_or_data) -> void *"""
    return _ida_kernwin.set_code_viewer_handler(*args)

def set_code_viewer_user_data(*args):
    r"""set_code_viewer_user_data(code_viewer, ud) -> bool"""
    return _ida_kernwin.set_code_viewer_user_data(*args)

def get_viewer_user_data(*args):
    r"""get_viewer_user_data(viewer) -> void *"""
    return _ida_kernwin.get_viewer_user_data(*args)

def get_viewer_place_type(*args):
    r"""get_viewer_place_type(viewer) -> tcc_place_type_t"""
    return _ida_kernwin.get_viewer_place_type(*args)

def set_code_viewer_line_handlers(*args):
    r"""set_code_viewer_line_handlers(code_viewer, click_handler, popup_handler, dblclick_handler, drawicon_handler, linenum_handler)"""
    return _ida_kernwin.set_code_viewer_line_handlers(*args)

def set_code_viewer_lines_icon_margin(*args):
    r"""set_code_viewer_lines_icon_margin(code_viewer, margin) -> bool"""
    return _ida_kernwin.set_code_viewer_lines_icon_margin(*args)

def set_code_viewer_lines_alignment(*args):
    r"""set_code_viewer_lines_alignment(code_viewer, align) -> bool"""
    return _ida_kernwin.set_code_viewer_lines_alignment(*args)

def set_code_viewer_lines_radix(*args):
    r"""set_code_viewer_lines_radix(code_viewer, radix) -> bool"""
    return _ida_kernwin.set_code_viewer_lines_radix(*args)

def set_code_viewer_is_source(*args):
    r"""set_code_viewer_is_source(code_viewer) -> bool"""
    return _ida_kernwin.set_code_viewer_is_source(*args)

def get_tab_size(*args):
    r"""get_tab_size(path) -> int"""
    return _ida_kernwin.get_tab_size(*args)

def clr_cancelled(*args):
    r"""clr_cancelled()"""
    return _ida_kernwin.clr_cancelled(*args)

def set_cancelled(*args):
    r"""set_cancelled()"""
    return _ida_kernwin.set_cancelled(*args)

def user_cancelled(*args):
    r"""user_cancelled() -> bool"""
    return _ida_kernwin.user_cancelled(*args)

def ui_load_new_file(*args):
    r"""ui_load_new_file(temp_file, filename, pli, neflags, ploaders) -> bool"""
    return _ida_kernwin.ui_load_new_file(*args)

def ui_run_debugger(*args):
    r"""ui_run_debugger(dbgopts, exename, argc, argv) -> bool"""
    return _ida_kernwin.ui_run_debugger(*args)

def load_dbg_dbginfo(*args):
    r"""load_dbg_dbginfo(path, li=None, base=BADADDR, verbose=False) -> bool"""
    return _ida_kernwin.load_dbg_dbginfo(*args)

def add_idc_hotkey(*args):
    r"""add_idc_hotkey(hotkey, idcfunc) -> int"""
    return _ida_kernwin.add_idc_hotkey(*args)

def del_idc_hotkey(*args):
    r"""del_idc_hotkey(hotkey) -> bool"""
    return _ida_kernwin.del_idc_hotkey(*args)

def get_user_strlist_options(*args):
    r"""get_user_strlist_options(out)"""
    return _ida_kernwin.get_user_strlist_options(*args)

def set_highlight(*args):
    r"""set_highlight(viewer, str, flags) -> bool"""
    return _ida_kernwin.set_highlight(*args)

def open_exports_window(*args):
    r"""open_exports_window(ea) -> TWidget *"""
    return _ida_kernwin.open_exports_window(*args)

def open_imports_window(*args):
    r"""open_imports_window(ea) -> TWidget *"""
    return _ida_kernwin.open_imports_window(*args)

def open_names_window(*args):
    r"""open_names_window(ea) -> TWidget *"""
    return _ida_kernwin.open_names_window(*args)

def open_funcs_window(*args):
    r"""open_funcs_window(ea) -> TWidget *"""
    return _ida_kernwin.open_funcs_window(*args)

def open_strings_window(*args):
    r"""open_strings_window(ea, selstart=BADADDR, selend=BADADDR) -> TWidget *"""
    return _ida_kernwin.open_strings_window(*args)

def open_segments_window(*args):
    r"""open_segments_window(ea) -> TWidget *"""
    return _ida_kernwin.open_segments_window(*args)

def open_segregs_window(*args):
    r"""open_segregs_window(ea) -> TWidget *"""
    return _ida_kernwin.open_segregs_window(*args)

def open_selectors_window(*args):
    r"""open_selectors_window() -> TWidget *"""
    return _ida_kernwin.open_selectors_window(*args)

def open_signatures_window(*args):
    r"""open_signatures_window() -> TWidget *"""
    return _ida_kernwin.open_signatures_window(*args)

def open_tils_window(*args):
    r"""open_tils_window() -> TWidget *"""
    return _ida_kernwin.open_tils_window(*args)

def open_loctypes_window(*args):
    r"""open_loctypes_window(ordinal) -> TWidget *"""
    return _ida_kernwin.open_loctypes_window(*args)

def open_calls_window(*args):
    r"""open_calls_window(ea) -> TWidget *"""
    return _ida_kernwin.open_calls_window(*args)

def open_problems_window(*args):
    r"""open_problems_window(ea) -> TWidget *"""
    return _ida_kernwin.open_problems_window(*args)

def open_bpts_window(*args):
    r"""open_bpts_window(ea) -> TWidget *"""
    return _ida_kernwin.open_bpts_window(*args)

def open_threads_window(*args):
    r"""open_threads_window() -> TWidget *"""
    return _ida_kernwin.open_threads_window(*args)

def open_modules_window(*args):
    r"""open_modules_window() -> TWidget *"""
    return _ida_kernwin.open_modules_window(*args)

def open_trace_window(*args):
    r"""open_trace_window() -> TWidget *"""
    return _ida_kernwin.open_trace_window(*args)

def open_stack_window(*args):
    r"""open_stack_window() -> TWidget *"""
    return _ida_kernwin.open_stack_window(*args)

def open_xrefs_window(*args):
    r"""open_xrefs_window(ea) -> TWidget *"""
    return _ida_kernwin.open_xrefs_window(*args)

def open_frame_window(*args):
    r"""open_frame_window(pfn, offset) -> TWidget *"""
    return _ida_kernwin.open_frame_window(*args)

def open_navband_window(*args):
    r"""open_navband_window(ea, zoom) -> TWidget *"""
    return _ida_kernwin.open_navband_window(*args)

def open_enums_window(*args):
    r"""open_enums_window(const_id=BADADDR) -> TWidget *"""
    return _ida_kernwin.open_enums_window(*args)

def open_structs_window(*args):
    r"""open_structs_window(id=BADADDR, offset=0) -> TWidget *"""
    return _ida_kernwin.open_structs_window(*args)

def open_disasm_window(*args):
    r"""open_disasm_window(window_title, ranges=None) -> TWidget *"""
    return _ida_kernwin.open_disasm_window(*args)

def open_hexdump_window(*args):
    r"""open_hexdump_window(window_title) -> TWidget *"""
    return _ida_kernwin.open_hexdump_window(*args)

def open_notepad_window(*args):
    r"""open_notepad_window() -> TWidget *"""
    return _ida_kernwin.open_notepad_window(*args)

def choose_til(*args):
    r"""choose_til() -> bool"""
    return _ida_kernwin.choose_til(*args)

def choose_entry(*args):
    r"""choose_entry(title) -> ea_t"""
    return _ida_kernwin.choose_entry(*args)

def choose_name(*args):
    r"""choose_name(title) -> ea_t"""
    return _ida_kernwin.choose_name(*args)

def choose_stkvar_xref(*args):
    r"""choose_stkvar_xref(pfn, mptr) -> ea_t"""
    return _ida_kernwin.choose_stkvar_xref(*args)

def choose_xref(*args):
    r"""choose_xref(to) -> ea_t"""
    return _ida_kernwin.choose_xref(*args)

def choose_enum(*args):
    r"""choose_enum(title, default_id) -> enum_t"""
    return _ida_kernwin.choose_enum(*args)

def choose_enum_by_value(*args):
    r"""choose_enum_by_value(title, default_id, value, nbytes) -> enum_t"""
    return _ida_kernwin.choose_enum_by_value(*args)

def choose_func(*args):
    r"""choose_func(title, default_ea) -> func_t *"""
    return _ida_kernwin.choose_func(*args)

def choose_segm(*args):
    r"""choose_segm(title, default_ea) -> segment_t *"""
    return _ida_kernwin.choose_segm(*args)

def choose_struc(*args):
    r"""choose_struc(title) -> struc_t *"""
    return _ida_kernwin.choose_struc(*args)

def choose_srcp(*args):
    r"""choose_srcp(title) -> sreg_range_t *"""
    return _ida_kernwin.choose_srcp(*args)

def get_chooser_obj(*args):
    r"""get_chooser_obj(chooser_caption) -> void *"""
    return _ida_kernwin.get_chooser_obj(*args)

def enable_chooser_item_attrs(*args):
    r"""enable_chooser_item_attrs(chooser_caption, enable) -> bool"""
    return _ida_kernwin.enable_chooser_item_attrs(*args)

def show_wait_box(*args):
    r"""show_wait_box(format)"""
    return _ida_kernwin.show_wait_box(*args)

def hide_wait_box(*args):
    r"""hide_wait_box()"""
    return _ida_kernwin.hide_wait_box(*args)

def replace_wait_box(*args):
    r"""replace_wait_box(format)"""
    return _ida_kernwin.replace_wait_box(*args)

def beep(*args):
    r"""beep(beep_type=beep_default)"""
    return _ida_kernwin.beep(*args)

def display_copyright_warning(*args):
    r"""display_copyright_warning() -> bool"""
    return _ida_kernwin.display_copyright_warning(*args)

def ask_for_feedback(*args):
    r"""ask_for_feedback(format)"""
    return _ida_kernwin.ask_for_feedback(*args)

def _ask_addr(*args):
    r"""_ask_addr(addr, format) -> bool"""
    return _ida_kernwin._ask_addr(*args)

def _ask_seg(*args):
    r"""_ask_seg(sel, format) -> bool"""
    return _ida_kernwin._ask_seg(*args)

def _ask_long(*args):
    r"""_ask_long(value, format) -> bool"""
    return _ida_kernwin._ask_long(*args)

def error(*args):
    r"""error(format)"""
    return _ida_kernwin.error(*args)

def warning(*args):
    r"""warning(format)"""
    return _ida_kernwin.warning(*args)

def info(*args):
    r"""info(format)"""
    return _ida_kernwin.info(*args)

def nomem(*args):
    r"""nomem(format)"""
    return _ida_kernwin.nomem(*args)
ASKBTN_YES = _ida_kernwin.ASKBTN_YES

ASKBTN_NO = _ida_kernwin.ASKBTN_NO

ASKBTN_CANCEL = _ida_kernwin.ASKBTN_CANCEL

ASKBTN_BTN1 = _ida_kernwin.ASKBTN_BTN1

ASKBTN_BTN2 = _ida_kernwin.ASKBTN_BTN2

ASKBTN_BTN3 = _ida_kernwin.ASKBTN_BTN3


def ask_yn(*args):
    r"""ask_yn(deflt, format) -> int"""
    return _ida_kernwin.ask_yn(*args)

def ask_buttons(*args):
    r"""ask_buttons(Yes, No, Cancel, deflt, format) -> int"""
    return _ida_kernwin.ask_buttons(*args)
HIST_SEG = _ida_kernwin.HIST_SEG

HIST_CMT = _ida_kernwin.HIST_CMT

HIST_SRCH = _ida_kernwin.HIST_SRCH

HIST_IDENT = _ida_kernwin.HIST_IDENT

HIST_FILE = _ida_kernwin.HIST_FILE

HIST_TYPE = _ida_kernwin.HIST_TYPE

HIST_CMD = _ida_kernwin.HIST_CMD

HIST_DIR = _ida_kernwin.HIST_DIR


def ask_file(*args):
    r"""ask_file(for_saving, defval, format) -> char *"""
    return _ida_kernwin.ask_file(*args)
class addon_info_t(object):
    r"""Proxy of C++ addon_info_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cb = property(_ida_kernwin.addon_info_t_cb_get, _ida_kernwin.addon_info_t_cb_set, doc=r"""cb""")
    id = property(_ida_kernwin.addon_info_t_id_get, _ida_kernwin.addon_info_t_id_set, doc=r"""id""")
    name = property(_ida_kernwin.addon_info_t_name_get, _ida_kernwin.addon_info_t_name_set, doc=r"""name""")
    producer = property(_ida_kernwin.addon_info_t_producer_get, _ida_kernwin.addon_info_t_producer_set, doc=r"""producer""")
    version = property(_ida_kernwin.addon_info_t_version_get, _ida_kernwin.addon_info_t_version_set, doc=r"""version""")
    url = property(_ida_kernwin.addon_info_t_url_get, _ida_kernwin.addon_info_t_url_set, doc=r"""url""")
    freeform = property(_ida_kernwin.addon_info_t_freeform_get, _ida_kernwin.addon_info_t_freeform_set, doc=r"""freeform""")
    custom_data = property(_ida_kernwin.addon_info_t_custom_data_get, _ida_kernwin.addon_info_t_custom_data_set, doc=r"""custom_data""")
    custom_size = property(_ida_kernwin.addon_info_t_custom_size_get, _ida_kernwin.addon_info_t_custom_size_set, doc=r"""custom_size""")

    def __init__(self, *args):
        r"""__init__(self) -> addon_info_t"""
        _ida_kernwin.addon_info_t_swiginit(self, _ida_kernwin.new_addon_info_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_addon_info_t

# Register addon_info_t in _ida_kernwin:
_ida_kernwin.addon_info_t_swigregister(addon_info_t)
cvar = _ida_kernwin.cvar


def register_addon(*args):
    r"""register_addon(info) -> int"""
    return _ida_kernwin.register_addon(*args)

def addon_count(*args):
    r"""addon_count() -> int"""
    return _ida_kernwin.addon_count(*args)

def get_addon_info(*args):
    r"""get_addon_info(id, info) -> bool"""
    return _ida_kernwin.get_addon_info(*args)

def get_addon_info_idx(*args):
    r"""get_addon_info_idx(index, info) -> bool"""
    return _ida_kernwin.get_addon_info_idx(*args)

def add_spaces(*args):
    r"""add_spaces(str, bufsize, len) -> char *"""
    return _ida_kernwin.add_spaces(*args)
class strarray_t(object):
    r"""Proxy of C++ strarray_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_ida_kernwin.strarray_t_code_get, _ida_kernwin.strarray_t_code_set, doc=r"""code""")
    text = property(_ida_kernwin.strarray_t_text_get, _ida_kernwin.strarray_t_text_set, doc=r"""text""")

    def __init__(self, *args):
        r"""__init__(self) -> strarray_t"""
        _ida_kernwin.strarray_t_swiginit(self, _ida_kernwin.new_strarray_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_strarray_t

# Register strarray_t in _ida_kernwin:
_ida_kernwin.strarray_t_swigregister(strarray_t)

CLNL_RTRIM = _ida_kernwin.CLNL_RTRIM

CLNL_LTRIM = _ida_kernwin.CLNL_LTRIM

CLNL_FINDCMT = _ida_kernwin.CLNL_FINDCMT

CLNL_TRIM = _ida_kernwin.CLNL_TRIM


def qcleanline(*args):
    r"""qcleanline(cmt_char='\0', flags=((1 << 0)|(1 << 1))|(1 << 2)) -> ssize_t"""
    return _ida_kernwin.qcleanline(*args)

def strarray(*args):
    r"""strarray(array, array_size, code) -> char const *"""
    return _ida_kernwin.strarray(*args)

def ea2str(*args):
    r"""ea2str(ea) -> size_t"""
    return _ida_kernwin.ea2str(*args)
IK_CANCEL = _ida_kernwin.IK_CANCEL

IK_BACK = _ida_kernwin.IK_BACK

IK_TAB = _ida_kernwin.IK_TAB

IK_CLEAR = _ida_kernwin.IK_CLEAR

IK_RETURN = _ida_kernwin.IK_RETURN

IK_SHIFT = _ida_kernwin.IK_SHIFT

IK_CONTROL = _ida_kernwin.IK_CONTROL

IK_MENU = _ida_kernwin.IK_MENU

IK_PAUSE = _ida_kernwin.IK_PAUSE

IK_CAPITAL = _ida_kernwin.IK_CAPITAL

IK_KANA = _ida_kernwin.IK_KANA

IK_ESCAPE = _ida_kernwin.IK_ESCAPE

IK_MODECHANGE = _ida_kernwin.IK_MODECHANGE

IK_SPACE = _ida_kernwin.IK_SPACE

IK_PRIOR = _ida_kernwin.IK_PRIOR

IK_NEXT = _ida_kernwin.IK_NEXT

IK_END = _ida_kernwin.IK_END

IK_HOME = _ida_kernwin.IK_HOME

IK_LEFT = _ida_kernwin.IK_LEFT

IK_UP = _ida_kernwin.IK_UP

IK_RIGHT = _ida_kernwin.IK_RIGHT

IK_DOWN = _ida_kernwin.IK_DOWN

IK_SELECT = _ida_kernwin.IK_SELECT

IK_PRINT = _ida_kernwin.IK_PRINT

IK_EXECUTE = _ida_kernwin.IK_EXECUTE

IK_SNAPSHOT = _ida_kernwin.IK_SNAPSHOT

IK_INSERT = _ida_kernwin.IK_INSERT

IK_DELETE = _ida_kernwin.IK_DELETE

IK_HELP = _ida_kernwin.IK_HELP

IK_LWIN = _ida_kernwin.IK_LWIN

IK_RWIN = _ida_kernwin.IK_RWIN

IK_APPS = _ida_kernwin.IK_APPS

IK_SLEEP = _ida_kernwin.IK_SLEEP

IK_NUMPAD0 = _ida_kernwin.IK_NUMPAD0

IK_NUMPAD1 = _ida_kernwin.IK_NUMPAD1

IK_NUMPAD2 = _ida_kernwin.IK_NUMPAD2

IK_NUMPAD3 = _ida_kernwin.IK_NUMPAD3

IK_NUMPAD4 = _ida_kernwin.IK_NUMPAD4

IK_NUMPAD5 = _ida_kernwin.IK_NUMPAD5

IK_NUMPAD6 = _ida_kernwin.IK_NUMPAD6

IK_NUMPAD7 = _ida_kernwin.IK_NUMPAD7

IK_NUMPAD8 = _ida_kernwin.IK_NUMPAD8

IK_NUMPAD9 = _ida_kernwin.IK_NUMPAD9

IK_MULTIPLY = _ida_kernwin.IK_MULTIPLY

IK_ADD = _ida_kernwin.IK_ADD

IK_SEPARATOR = _ida_kernwin.IK_SEPARATOR

IK_SUBTRACT = _ida_kernwin.IK_SUBTRACT

IK_DECIMAL = _ida_kernwin.IK_DECIMAL

IK_DIVIDE = _ida_kernwin.IK_DIVIDE

IK_F1 = _ida_kernwin.IK_F1

IK_F2 = _ida_kernwin.IK_F2

IK_F3 = _ida_kernwin.IK_F3

IK_F4 = _ida_kernwin.IK_F4

IK_F5 = _ida_kernwin.IK_F5

IK_F6 = _ida_kernwin.IK_F6

IK_F7 = _ida_kernwin.IK_F7

IK_F8 = _ida_kernwin.IK_F8

IK_F9 = _ida_kernwin.IK_F9

IK_F10 = _ida_kernwin.IK_F10

IK_F11 = _ida_kernwin.IK_F11

IK_F12 = _ida_kernwin.IK_F12

IK_F13 = _ida_kernwin.IK_F13

IK_F14 = _ida_kernwin.IK_F14

IK_F15 = _ida_kernwin.IK_F15

IK_F16 = _ida_kernwin.IK_F16

IK_F17 = _ida_kernwin.IK_F17

IK_F18 = _ida_kernwin.IK_F18

IK_F19 = _ida_kernwin.IK_F19

IK_F20 = _ida_kernwin.IK_F20

IK_F21 = _ida_kernwin.IK_F21

IK_F22 = _ida_kernwin.IK_F22

IK_F23 = _ida_kernwin.IK_F23

IK_F24 = _ida_kernwin.IK_F24

IK_NUMLOCK = _ida_kernwin.IK_NUMLOCK

IK_SCROLL = _ida_kernwin.IK_SCROLL

IK_OEM_FJ_MASSHOU = _ida_kernwin.IK_OEM_FJ_MASSHOU

IK_OEM_FJ_TOUROKU = _ida_kernwin.IK_OEM_FJ_TOUROKU

IK_LSHIFT = _ida_kernwin.IK_LSHIFT

IK_RSHIFT = _ida_kernwin.IK_RSHIFT

IK_LCONTROL = _ida_kernwin.IK_LCONTROL

IK_RCONTROL = _ida_kernwin.IK_RCONTROL

IK_LMENU = _ida_kernwin.IK_LMENU

IK_RMENU = _ida_kernwin.IK_RMENU

IK_BROWSER_BACK = _ida_kernwin.IK_BROWSER_BACK

IK_BROWSER_FORWARD = _ida_kernwin.IK_BROWSER_FORWARD

IK_BROWSER_REFRESH = _ida_kernwin.IK_BROWSER_REFRESH

IK_BROWSER_STOP = _ida_kernwin.IK_BROWSER_STOP

IK_BROWSER_SEARCH = _ida_kernwin.IK_BROWSER_SEARCH

IK_BROWSER_FAVORITES = _ida_kernwin.IK_BROWSER_FAVORITES

IK_BROWSER_HOME = _ida_kernwin.IK_BROWSER_HOME

IK_VOLUME_MUTE = _ida_kernwin.IK_VOLUME_MUTE

IK_VOLUME_DOWN = _ida_kernwin.IK_VOLUME_DOWN

IK_VOLUME_UP = _ida_kernwin.IK_VOLUME_UP

IK_MEDIA_NEXT_TRACK = _ida_kernwin.IK_MEDIA_NEXT_TRACK

IK_MEDIA_PREV_TRACK = _ida_kernwin.IK_MEDIA_PREV_TRACK

IK_MEDIA_STOP = _ida_kernwin.IK_MEDIA_STOP

IK_MEDIA_PLAY_PAUSE = _ida_kernwin.IK_MEDIA_PLAY_PAUSE

IK_LAUNCH_MAIL = _ida_kernwin.IK_LAUNCH_MAIL

IK_LAUNCH_MEDIA_SELECT = _ida_kernwin.IK_LAUNCH_MEDIA_SELECT

IK_LAUNCH_APP1 = _ida_kernwin.IK_LAUNCH_APP1

IK_LAUNCH_APP2 = _ida_kernwin.IK_LAUNCH_APP2

IK_OEM_1 = _ida_kernwin.IK_OEM_1

IK_OEM_PLUS = _ida_kernwin.IK_OEM_PLUS

IK_OEM_COMMA = _ida_kernwin.IK_OEM_COMMA

IK_OEM_MINUS = _ida_kernwin.IK_OEM_MINUS

IK_OEM_PERIOD = _ida_kernwin.IK_OEM_PERIOD

IK_OEM_2 = _ida_kernwin.IK_OEM_2

IK_OEM_3 = _ida_kernwin.IK_OEM_3

IK_OEM_4 = _ida_kernwin.IK_OEM_4

IK_OEM_5 = _ida_kernwin.IK_OEM_5

IK_OEM_6 = _ida_kernwin.IK_OEM_6

IK_OEM_7 = _ida_kernwin.IK_OEM_7

IK_OEM_102 = _ida_kernwin.IK_OEM_102

IK_PLAY = _ida_kernwin.IK_PLAY

IK_ZOOM = _ida_kernwin.IK_ZOOM

IK_OEM_CLEAR = _ida_kernwin.IK_OEM_CLEAR

CB_INIT = _ida_kernwin.CB_INIT

CB_YES = _ida_kernwin.CB_YES

CB_CLOSE = _ida_kernwin.CB_CLOSE

CB_INVISIBLE = _ida_kernwin.CB_INVISIBLE

CB_DESTROYING = _ida_kernwin.CB_DESTROYING

class disasm_text_t(object):
    r"""Proxy of C++ qvector< disasm_line_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> disasm_text_t
        __init__(self, x) -> disasm_text_t
        """
        _ida_kernwin.disasm_text_t_swiginit(self, _ida_kernwin.new_disasm_text_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_disasm_text_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""pop_back(self)"""
        return _ida_kernwin.disasm_text_t_pop_back(self, *args)

    def size(self, *args):
        r"""size(self) -> size_t"""
        return _ida_kernwin.disasm_text_t_size(self, *args)

    def empty(self, *args):
        r"""empty(self) -> bool"""
        return _ida_kernwin.disasm_text_t_empty(self, *args)

    def at(self, *args):
        r"""at(self, _idx) -> disasm_line_t"""
        return _ida_kernwin.disasm_text_t_at(self, *args)

    def qclear(self, *args):
        r"""qclear(self)"""
        return _ida_kernwin.disasm_text_t_qclear(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_kernwin.disasm_text_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_kernwin.disasm_text_t_resize(self, *args)

    def grow(self, *args):
        r"""grow(self, x=disasm_line_t())"""
        return _ida_kernwin.disasm_text_t_grow(self, *args)

    def capacity(self, *args):
        r"""capacity(self) -> size_t"""
        return _ida_kernwin.disasm_text_t_capacity(self, *args)

    def reserve(self, *args):
        r"""reserve(self, cnt)"""
        return _ida_kernwin.disasm_text_t_reserve(self, *args)

    def truncate(self, *args):
        r"""truncate(self)"""
        return _ida_kernwin.disasm_text_t_truncate(self, *args)

    def swap(self, *args):
        r"""swap(self, r)"""
        return _ida_kernwin.disasm_text_t_swap(self, *args)

    def extract(self, *args):
        r"""extract(self) -> disasm_line_t"""
        return _ida_kernwin.disasm_text_t_extract(self, *args)

    def inject(self, *args):
        r"""inject(self, s, len)"""
        return _ida_kernwin.disasm_text_t_inject(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> disasm_line_t
        begin(self) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> disasm_line_t
        end(self) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_end(self, *args)

    def insert(self, *args):
        r"""insert(self, it, x) -> disasm_line_t"""
        return _ida_kernwin.disasm_text_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> disasm_line_t
        erase(self, first, last) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_erase(self, *args)

    def __len__(self, *args):
        r"""__len__(self) -> size_t"""
        return _ida_kernwin.disasm_text_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""__getitem__(self, i) -> disasm_line_t"""
        return _ida_kernwin.disasm_text_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""__setitem__(self, i, v)"""
        return _ida_kernwin.disasm_text_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register disasm_text_t in _ida_kernwin:
_ida_kernwin.disasm_text_t_swigregister(disasm_text_t)


#<pycode(py_kernwin)>
DP_LEFT           = 0x0001
DP_TOP            = 0x0002
DP_RIGHT          = 0x0004
DP_BOTTOM         = 0x0008
DP_INSIDE         = 0x0010
# if not before, then it is after
# (use DP_INSIDE | DP_BEFORE to insert a tab before a given tab)
# this flag alone cannot be used to determine orientation
DP_BEFORE         = 0x0020
# used with combination of other flags
DP_TAB            = 0x0040
DP_FLOATING       = 0x0080

# ----------------------------------------------------------------------
def load_custom_icon(file_name=None, data=None, format=None):
    """
    Loads a custom icon and returns an identifier that can be used with other APIs

    If file_name is passed then the other two arguments are ignored.

    @param file_name: The icon file name
    @param data: The icon data
    @param format: The icon data format

    @return: Icon id or 0 on failure.
             Use free_custom_icon() to free it
    """
    if file_name is not None:
       return _ida_kernwin.py_load_custom_icon_fn(file_name)
    elif not (data is None and format is None):
       return _ida_kernwin.py_load_custom_icon_data(data, format)
    else:
      return 0

# ----------------------------------------------------------------------
def ask_long(defval, format):
    res, val = _ida_kernwin._ask_long(defval, format)

    if res == 1:
        return val
    else:
        return None

# ----------------------------------------------------------------------
def ask_addr(defval, format):
    res, ea = _ida_kernwin._ask_addr(defval, format)

    if res == 1:
        return ea
    else:
        return None

# ----------------------------------------------------------------------
def ask_seg(defval, format):
    res, sel = _ida_kernwin._ask_seg(defval, format)

    if res == 1:
        return sel
    else:
        return None

# ----------------------------------------------------------------------
def ask_ident(defval, format):
    return ask_str(defval, HIST_IDENT, format)

# ----------------------------------------------------------------------
class action_handler_t(object):
    def __init__(self):
        pass

    def activate(self, ctx):
        return 0

    def update(self, ctx):
        pass

# ----------------------------------------------------------------------
# bw-compat/deprecated. You shouldn't rely on this in new code
from ida_pro import str2user

#</pycode(py_kernwin)>


def choose_find(*args):
    r"""choose_find(title) -> PyObject *"""
    return _ida_kernwin.choose_find(*args)

def choose_refresh(*args):
    r"""choose_refresh(_self)"""
    return _ida_kernwin.choose_refresh(*args)

def choose_close(*args):
    r"""choose_close(_self)"""
    return _ida_kernwin.choose_close(*args)

def choose_create(*args):
    r"""choose_create(_self) -> int"""
    return _ida_kernwin.choose_create(*args)

def choose_activate(*args):
    r"""choose_activate(_self)"""
    return _ida_kernwin.choose_activate(*args)

def _choose_get_embedded_chobj_pointer(*args):
    r"""_choose_get_embedded_chobj_pointer(_self) -> uint64"""
    return _ida_kernwin._choose_get_embedded_chobj_pointer(*args)

def get_chooser_data(*args):
    r"""get_chooser_data(chooser_caption, n) -> PyObject *"""
    return _ida_kernwin.get_chooser_data(*args)

def choose_get_widget(*args):
    r"""choose_get_widget(_self) -> TWidget *"""
    return _ida_kernwin.choose_get_widget(*args)

#<pycode(py_kernwin_choose)>
class Choose(object):
    """
    Chooser wrapper class.

    Some constants are defined in this class.
    Please refer to kernwin.hpp for more information.
    """

    CH_MODAL        = 0x01
    """Modal chooser"""

    CH_MULTI        = 0x04
    """
    Allow multi selection.
    Refer the description of the OnInsertLine(), OnDeleteLine(),
    OnEditLine(), OnSelectLine(), OnRefresh(), OnSelectionChange() to
    see a difference between single and multi selection callbacks.
    """

    CH_NOBTNS       = 0x10

    CH_ATTRS        = 0x20

    CH_NOIDB        = 0x40
    """use the chooser even without an open database, same as x0=-2"""

    CH_FORCE_DEFAULT = 0x80
    """
    If a non-modal chooser was already open, change selection to the given
    default one
    """

    CH_CAN_INS      = 0x000100
    """allow to insert new items"""

    CH_CAN_DEL      = 0x000200
    """allow to delete existing item(s)"""

    CH_CAN_EDIT     = 0x000400
    """allow to edit existing item(s)"""

    CH_CAN_REFRESH  = 0x000800
    """allow to refresh chooser"""

    CH_QFLT         =  0x1000
    """open with quick filter enabled and focused"""

    CH_QFTYP_SHIFT  = 13
    CH_QFTYP_DEFAULT     = 0 << CH_QFTYP_SHIFT
    CH_QFTYP_NORMAL      = 1 << CH_QFTYP_SHIFT
    CH_QFTYP_WHOLE_WORDS = 2 << CH_QFTYP_SHIFT
    CH_QFTYP_REGEX       = 3 << CH_QFTYP_SHIFT
    CH_QFTYP_FUZZY       = 4 << CH_QFTYP_SHIFT
    CH_QFTYP_MASK        = 0x7 << CH_QFTYP_SHIFT

    CH_NO_STATUS_BAR = 0x00010000
    """don't show a status bar"""
    CH_RESTORE       = 0x00020000
    """restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)"""

    CH_BUILTIN_SHIFT = 19
    CH_BUILTIN_MASK = 0x1F << CH_BUILTIN_SHIFT

# column flags (are specified in the widths array)
    CHCOL_PLAIN  =  0x00000000
    CHCOL_PATH   =  0x00010000
    CHCOL_HEX    =  0x00020000
    CHCOL_DEC    =  0x00030000
    CHCOL_FORMAT =  0x00070000

# special values of the chooser index
    NO_SELECTION   = -1
    """there is no selected item"""
    EMPTY_CHOOSER  = -4
    """the chooser is initialized"""
    ALREADY_EXISTS = -5
    """the non-modal chooser with the same data is already open"""
    NO_ATTR        = -6
    """some mandatory attribute is missing"""

# return value of ins(), del(), edit(), enter(), refresh() callbacks
    NOTHING_CHANGED   = 0
    ALL_CHANGED       = 1
    SELECTION_CHANGED = 2

# to construct `forbidden_cb`
    CHOOSE_HAVE_INIT    = 0x0001
    CHOOSE_HAVE_GETICON = 0x0002
    CHOOSE_HAVE_GETATTR = 0x0004
    CHOOSE_HAVE_INS     = 0x0008
    CHOOSE_HAVE_DEL     = 0x0010
    CHOOSE_HAVE_EDIT    = 0x0020
    CHOOSE_HAVE_ENTER   = 0x0040
    CHOOSE_HAVE_REFRESH = 0x0080
    CHOOSE_HAVE_SELECT  = 0x0100
    CHOOSE_HAVE_ONCLOSE = 0x0200

    class UI_Hooks_Trampoline(UI_Hooks):
        def __init__(self, v):
            UI_Hooks.__init__(self)
            self.hook()
            import weakref
            self.v = weakref.ref(v)

        def populating_widget_popup(self, form, popup_handle):
            chooser = self.v()
            if form == chooser.GetWidget() and \
               hasattr(chooser, "OnPopup") and \
               callable(getattr(chooser, "OnPopup")):
                chooser.OnPopup(form, popup_handle)

    def __init__(self, title, cols, flags = 0, popup_names = None,
                 icon=-1, x1=-1, y1=-1, x2=-1, y2=-1,
                 deflt = None,
                 embedded = False, width = None, height = None,
                 forbidden_cb = 0):
        """
        Constructs a chooser window.
        @param title: The chooser title
        @param cols: a list of colums; each list item is a list of two items
            example: [ ["Address", 10 | Choose.CHCOL_HEX],
                       ["Name",    30 | Choose.CHCOL_PLAIN] ]
        @param flags: One of CH_XXXX constants
        @param deflt: The index of the default item (0-based) for single
            selection choosers or the list of indexes for multi selection
            chooser
        @param popup_names: List of new captions to replace this list
            ["Insert", "Delete", "Edit", "Refresh"]
        @param icon: Icon index (the icon should exist in ida resources or
            an index to a custom loaded icon)
        @param x1, y1, x2, y2: The default location (for txt-version)
        @param embedded: Create as embedded chooser
        @param width: Embedded chooser width
        @param height: Embedded chooser height
        @param forbidden_cb: Explicitly forbidden callbacks
        """
        self.title = title
        self.flags = flags
        self.cols = cols
        if deflt == None:
          deflt = 0 if (flags & Choose.CH_MULTI) == 0 else [0]
        self.deflt = deflt
        self.popup_names = popup_names
        self.icon = icon
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.embedded = embedded
        self.width = width
        self.height = height
        self.forbidden_cb = forbidden_cb
        self.ui_hooks_trampoline = None # set on Show


    def Embedded(self):
        """
        Creates an embedded chooser (as opposed to Show())
        @return: Returns 0 on success or NO_ATTR
        """
        if not self.embedded:
          return Choose.NO_ATTR
        return _ida_kernwin.choose_create(self)


    def GetEmbSelection(self):
        """
        Deprecated. For embedded choosers, the selection is
        available through 'Form.EmbeddedChooserControl.selection'
        """
        return None


    def Show(self, modal=False):
        """
        Activates or creates a chooser window
        @param modal: Display as modal dialog
        @return: For all choosers it will return NO_ATTR if some mandatory
                 attribute is missing. The mandatory attributes are: flags,
                 title, cols, OnGetSize(), OnGetLine();
                 For modal choosers it will return the selected item index (0-based),
                 or NO_SELECTION if no selection,
                 or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
                 For non-modal choosers it will return 0
                 or ALREADY_EXISTS if the chooser was already open and is active now;
        """
        if self.embedded:
          return Choose.NO_ATTR
# it will be deleted and unhooked in py_choose_t::closed()
        self.ui_hooks_trampoline = self.UI_Hooks_Trampoline(self)
        if modal:
            self.flags |= Choose.CH_MODAL

# Disable the timeout
            old = _ida_idaapi.set_script_timeout(0)
            n = _ida_kernwin.choose_create(self)
            _ida_idaapi.set_script_timeout(old)

# Delete the modal chooser instance
            self.Close()

            return n
        else:
            self.flags &= ~Choose.CH_MODAL
            return _ida_kernwin.choose_create(self)


    def Activate(self):
        """Activates a visible chooser"""
        return _ida_kernwin.choose_activate(self)


    def Refresh(self):
        """Causes the refresh callback to trigger"""
        return _ida_kernwin.choose_refresh(self)


    def Close(self):
        """Closes the chooser"""
        _ida_kernwin.choose_close(self)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.choose_get_widget(self)

    def adjust_last_item(self, n):
        """
        Helper for OnDeleteLine() and OnRefresh() callbacks.
        They can be finished by the following line:
        return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
        @param: line number of the remaining select item
        @return: list of selected lines numbers (one element or empty)
        """
        cnt = self.OnGetSize();
        if cnt == 0:
            return []
# take in account deleting of the last item(s)
        if n >= cnt:
            n = cnt - 1
        return [n]
#</pycode(py_kernwin_choose)>


def textctrl_info_t_assign(*args):
    r"""textctrl_info_t_assign(_self, other) -> bool"""
    return _ida_kernwin.textctrl_info_t_assign(*args)

def textctrl_info_t_set_text(*args):
    r"""textctrl_info_t_set_text(_self, s) -> bool"""
    return _ida_kernwin.textctrl_info_t_set_text(*args)

def textctrl_info_t_get_text(*args):
    r"""textctrl_info_t_get_text(_self) -> char const *"""
    return _ida_kernwin.textctrl_info_t_get_text(*args)

def textctrl_info_t_set_flags(*args):
    r"""textctrl_info_t_set_flags(_self, flags) -> bool"""
    return _ida_kernwin.textctrl_info_t_set_flags(*args)

def textctrl_info_t_get_flags(*args):
    r"""textctrl_info_t_get_flags(_self, flags) -> unsigned int"""
    return _ida_kernwin.textctrl_info_t_get_flags(*args)

def textctrl_info_t_set_tabsize(*args):
    r"""textctrl_info_t_set_tabsize(_self, tabsize) -> bool"""
    return _ida_kernwin.textctrl_info_t_set_tabsize(*args)

def textctrl_info_t_get_tabsize(*args):
    r"""textctrl_info_t_get_tabsize(_self, tabsize) -> unsigned int"""
    return _ida_kernwin.textctrl_info_t_get_tabsize(*args)

def formchgcbfa_enable_field(*args):
    r"""formchgcbfa_enable_field(p_fa, fid, enable) -> bool"""
    return _ida_kernwin.formchgcbfa_enable_field(*args)

def formchgcbfa_show_field(*args):
    r"""formchgcbfa_show_field(p_fa, fid, show) -> bool"""
    return _ida_kernwin.formchgcbfa_show_field(*args)

def formchgcbfa_move_field(*args):
    r"""formchgcbfa_move_field(p_fa, fid, x, y, w, h) -> bool"""
    return _ida_kernwin.formchgcbfa_move_field(*args)

def formchgcbfa_get_focused_field(*args):
    r"""formchgcbfa_get_focused_field(p_fa) -> int"""
    return _ida_kernwin.formchgcbfa_get_focused_field(*args)

def formchgcbfa_set_focused_field(*args):
    r"""formchgcbfa_set_focused_field(p_fa, fid) -> bool"""
    return _ida_kernwin.formchgcbfa_set_focused_field(*args)

def formchgcbfa_refresh_field(*args):
    r"""formchgcbfa_refresh_field(p_fa, fid)"""
    return _ida_kernwin.formchgcbfa_refresh_field(*args)

def formchgcbfa_close(*args):
    r"""formchgcbfa_close(p_fa, close_normally)"""
    return _ida_kernwin.formchgcbfa_close(*args)

def formchgcbfa_get_field_value(*args):
    r"""formchgcbfa_get_field_value(p_fa, fid, ft, sz) -> PyObject *"""
    return _ida_kernwin.formchgcbfa_get_field_value(*args)

def formchgcbfa_set_field_value(*args):
    r"""formchgcbfa_set_field_value(p_fa, fid, ft, py_val) -> bool"""
    return _ida_kernwin.formchgcbfa_set_field_value(*args)

def py_get_ask_form(*args):
    r"""py_get_ask_form() -> size_t"""
    return _ida_kernwin.py_get_ask_form(*args)

def py_get_open_form(*args):
    r"""py_get_open_form() -> size_t"""
    return _ida_kernwin.py_get_open_form(*args)

def py_register_compiled_form(*args):
    r"""py_register_compiled_form(py_form)"""
    return _ida_kernwin.py_register_compiled_form(*args)

def py_unregister_compiled_form(*args):
    r"""py_unregister_compiled_form(py_form)"""
    return _ida_kernwin.py_unregister_compiled_form(*args)

#<pycode(py_kernwin_askform)>
import ida_idaapi, _ida_idaapi
import ida_pro

#ICON WARNING|QUESTION|INFO|NONE
#AUTOHIDE NONE|DATABASE|REGISTRY|SESSION
#HIDECANCEL
#BUTTON YES|NO|CANCEL "Value|NONE"
#STARTITEM {id:ItemName}
#HELP / ENDHELP
try:
    import types
    import ctypes
# On Windows, we use stdcall

# Callback for buttons
# typedef int (idaapi *buttoncb_t)(int button_code, form_actions_t &fa);

    _BUTTONCB_T = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)

# Callback for form change
# typedef int (idaapi *formchgcb_t)(int field_id, form_actions_t &fa);
    _FORMCHGCB_T = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)
except:
    try:
        _BUTTONCB_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)
        _FORMCHGCB_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)
    except:
        _BUTTONCB_T = _FORMCHGCB_T = None


# -----------------------------------------------------------------------
# textctrl_info_t clinked object
class textctrl_info_t(ida_idaapi.py_clinked_object_t):
    """Class representing textctrl_info_t"""

# Some constants
    TXTF_AUTOINDENT = 0x0001
    """Auto-indent on new line"""
    TXTF_ACCEPTTABS = 0x0002
    """Tab key inserts 'tabsize' spaces"""
    TXTF_READONLY   = 0x0004
    """Text cannot be edited (but can be selected and copied)"""
    TXTF_SELECTED   = 0x0008
    """Shows the field with its text selected"""
    TXTF_MODIFIED   = 0x0010
    """Gets/sets the modified status"""
    TXTF_FIXEDFONT  = 0x0020
    """The control uses IDA's fixed font"""

    def __init__(self, text="", flags=0, tabsize=0):
        ida_idaapi.py_clinked_object_t.__init__(self)
        if text:
            self.text = text
        if flags:
            self.flags = flags
        if tabsize:
            self.tabsize = tabsize

    def _create_clink(self):
        return _ida_kernwin.textctrl_info_t_create()

    def _del_clink(self, lnk):
        return _ida_kernwin.textctrl_info_t_destroy(lnk)

    def _get_clink_ptr(self):
        return _ida_kernwin.textctrl_info_t_get_clink_ptr(self)

    def assign(self, other):
        """Copies the contents of 'other' to 'self'"""
        return _ida_kernwin.textctrl_info_t_assign(self, other)

    def __set_text(self, s):
        """Sets the text value"""
        return _ida_kernwin.textctrl_info_t_set_text(self, s)

    def __get_text(self):
        """Sets the text value"""
        return _ida_kernwin.textctrl_info_t_get_text(self)

    def __set_flags__(self, flags):
        """Sets the flags value"""
        return _ida_kernwin.textctrl_info_t_set_flags(self, flags)

    def __get_flags__(self):
        """Returns the flags value"""
        return _ida_kernwin.textctrl_info_t_get_flags(self)

    def __set_tabsize__(self, tabsize):
        """Sets the tabsize value"""
        return _ida_kernwin.textctrl_info_t_set_tabsize(self, tabsize)

    def __get_tabsize__(self):
        """Returns the tabsize value"""
        return _ida_kernwin.textctrl_info_t_get_tabsize(self)

    value   = property(__get_text, __set_text)
    """Alias for the text property"""
    text    = property(__get_text, __set_text)
    """Text value"""
    flags   = property(__get_flags__, __set_flags__)
    """Flags value"""
    tabsize = property(__get_tabsize__, __set_tabsize__)

# -----------------------------------------------------------------------
class Form(object):

    FT_ASCII = 'A'
    """Ascii string - char *"""
    FT_SEG = 'S'
    """Segment - sel_t *"""
    FT_HEX = 'N'
    """Hex number - uval_t *"""
    FT_SHEX = 'n'
    """Signed hex number - sval_t *"""
    FT_COLOR = 'K'
    """Color button - bgcolor_t *"""
    FT_ADDR = '$'
    """Address - ea_t *"""
    FT_UINT64 = 'L'
    """default base uint64 - uint64"""
    FT_INT64 = 'l'
    """default base int64 - int64"""
    FT_RAWHEX = 'M'
    """Hex number, no 0x prefix - uval_t *"""
    FT_FILE = 'f'
    """File browse - char * at least QMAXPATH"""
    FT_DEC = 'D'
    """Decimal number - sval_t *"""
    FT_OCT = 'O'
    """Octal number, C notation - sval_t *"""
    FT_BIN = 'Y'
    """Binary number, 0b prefix - sval_t *"""
    FT_CHAR = 'H'
    """Char value -- sval_t *"""
    FT_IDENT = 'I'
    """Identifier - char * at least MAXNAMELEN"""
    FT_BUTTON = 'B'
    """Button - def handler(code)"""
    FT_DIR = 'F'
    """Path to directory - char * at least QMAXPATH"""
    FT_TYPE = 'T'
    """Type declaration - char * at least MAXSTR"""
    _FT_USHORT = '_US'
    """Unsigned short"""
    FT_FORMCHG = '%/'
    """Form change callback - formchgcb_t"""
    FT_ECHOOSER = 'E'
    """Embedded chooser - idaapi.Choose"""
    FT_MULTI_LINE_TEXT = 't'
    """Multi text control - textctrl_info_t"""
    FT_DROPDOWN_LIST   = 'b'
    """Dropdown list control - Form.DropdownControl"""
    FT_HTML_LABEL = 'h'
    """HTML label to display (only for GUI version, and for dynamic labels; no input)"""

    FT_CHKGRP = 'C'
    FT_CHKGRP2= 'c'
    FT_RADGRP = 'R'
    FT_RADGRP2= 'r'

    @staticmethod
    def fieldtype_to_ctype(tp, i64 = False):
        """
        Factory method returning a ctype class corresponding to the field type string
        """
        if tp in (Form.FT_SEG, Form.FT_HEX, Form.FT_RAWHEX, Form.FT_ADDR):
            return ctypes.c_ulonglong if i64 else ctypes.c_ulong
        elif tp in (Form.FT_SHEX, Form.FT_DEC, Form.FT_OCT, Form.FT_BIN, Form.FT_CHAR):
            return ctypes.c_longlong if i64 else ctypes.c_long
        elif tp == Form.FT_UINT64:
            return ctypes.c_ulonglong
        elif tp == Form.FT_INT64:
            return ctypes.c_longlong
        elif tp == Form.FT_COLOR:
            return ctypes.c_ulong
        elif tp == Form._FT_USHORT:
            return ctypes.c_ushort
        elif tp in (Form.FT_FORMCHG, Form.FT_ECHOOSER):
            return ctypes.c_void_p
        else:
            return None


#
# Generic argument helper classes
#
    class NumericArgument(object):
        """
        Argument representing various integer arguments (ushort, uint32, uint64, etc...)
        @param tp: One of Form.FT_XXX
        """
        DefI64 = False
        def __init__(self, tp, value):
            cls = Form.fieldtype_to_ctype(tp, self.DefI64)
            if cls is None:
                raise TypeError("Invalid numeric field type: %s" % tp)
# Get a pointer type to the ctype type
            self.arg = ctypes.pointer(cls(value))

        def __set_value(self, v):
            self.arg.contents.value = v
        value = property(lambda self: self.arg.contents.value, __set_value)


    class StringArgument(object):
        """
        Argument representing a character buffer
        """
        def __init__(self, size=None, value=None):
            if size is None:
                raise SyntaxError("The string size must be passed")

            if value is None:
                self.arg = ctypes.create_string_buffer(size)
            else:
                self.arg = ctypes.create_string_buffer(value, size)
            self.size = size

        def __set_value(self, v):
            self.arg.value = v
        value = property(lambda self: self.arg.value, __set_value)


#
# Base control class
#
    class Control(object):
        def __init__(self):
            self.id = 0
            """Automatically assigned control ID"""

            self.input_field_index = None
            """If this control is an input field, once Compile() returns this will hold its index. This is used only to compute the possible STARTITEM index"""

            self.arg = None
            """Control argument value. This could be one element or a list/tuple (for multiple args per control)"""

            self.form = None
            """Reference to the parent form. It is filled by Form.Add()"""

            self.form_hasattr = False

        def get_tag(self):
            """
            Control tag character. One of Form.FT_XXXX.
            The form class will expand the {} notation and replace them with the tags
            """
            pass

        def get_arg(self):
            """
            Control returns the parameter to be pushed on the stack
            (Of ask_form())
            """
            return self.arg

        def free(self):
            """
            Free the control
            """
# Release the parent form reference
            self.form = None

        def is_input_field(self):
            """
            Return True if this field acts as an input
            """
            return False

#
# Label controls
#
    class LabelControl(Control):
        """
        Base class for static label control
        """
        def __init__(self, tp):
            Form.Control.__init__(self)
            self.tp = tp

        def get_tag(self):
            return '%%%d%s' % (self.id, self.tp)


    class StringLabel(LabelControl):
        """
        String label control
        """
        def __init__(self, value, tp=None, sz=1024):
            """
            Type field can be one of:
            A - ascii string
            T - type declaration
            I - ident
            F - folder
            f - file
            X - command
            """
            if tp is None:
                tp = Form.FT_ASCII
            Form.LabelControl.__init__(self, tp)
            self.size  = sz
            self.arg = ctypes.create_string_buffer(value, sz)


    class NumericLabel(LabelControl, NumericArgument):
        """
        Numeric label control
        """
        def __init__(self, value, tp=None):
            if tp is None:
                tp = Form.FT_HEX
            Form.LabelControl.__init__(self, tp)
            Form.NumericArgument.__init__(self, tp, value)


#
# Group controls
#
    class GroupItemControl(Control):
        """
        Base class for group control items
        """
        def __init__(self, tag, parent):
            Form.Control.__init__(self)
            self.tag = tag
            self.parent = parent
# Item position (filled when form is compiled)
            self.pos = 0

        def assign_pos(self):
            self.pos = self.parent.next_child_pos()

        def get_tag(self):
            return "%s%d" % (self.tag, self.id)

        def is_input_field(self):
            return True


    class ChkGroupItemControl(GroupItemControl):
        """
        Checkbox group item control
        """
        def __init__(self, tag, parent):
            Form.GroupItemControl.__init__(self, tag, parent)

        def __get_value(self):
            return (self.parent.value & (1 << self.pos)) != 0

        def __set_value(self, v):
            pv = self.parent.value
            if v:
                pv = pv | (1 << self.pos)
            else:
                pv = pv & ~(1 << self.pos)

            self.parent.value = pv

        checked = property(__get_value, __set_value)
        """Get/Sets checkbox item check status"""


    class RadGroupItemControl(GroupItemControl):
        """
        Radiobox group item control
        """
        def __init__(self, tag, parent):
            Form.GroupItemControl.__init__(self, tag, parent)

        def __get_value(self):
            return self.parent.value == self.pos

        def __set_value(self, v):
            self.parent.value = self.pos

        selected = property(__get_value, __set_value)
        """Get/Sets radiobox item selection status"""


    class GroupControl(Control, NumericArgument):
        """
        Base class for group controls
        """
        def __init__(self, children_names, tag, value=0):
            Form.Control.__init__(self)
            self.children_names = children_names
            self.tag = tag
            self._reset()
            Form.NumericArgument.__init__(self, Form._FT_USHORT, value)

        def _reset(self):
            self.childpos = 0

        def next_child_pos(self):
            v = self.childpos
            self.childpos += 1
            return v

        def get_tag(self):
            return "%d" % self.id


    class ChkGroupControl(GroupControl):
        """
        Checkbox group control class.
        It holds a set of checkbox controls
        """
        ItemClass = None
        """
        Group control item factory class instance
        We need this because later we won't be treating ChkGroupControl or RadGroupControl
        individually, instead we will be working with GroupControl in general.
        """
        def __init__(self, children_names, value=0, secondary=False):
# Assign group item factory class
            if Form.ChkGroupControl.ItemClass is None:
                Form.ChkGroupControl.ItemClass = Form.ChkGroupItemControl

            Form.GroupControl.__init__(
                self,
                children_names,
                Form.FT_CHKGRP2 if secondary else Form.FT_CHKGRP,
                value)


    class RadGroupControl(GroupControl):
        """
        Radiobox group control class.
        It holds a set of radiobox controls
        """
        ItemClass = None
        def __init__(self, children_names, value=0, secondary=False):
            """
            Creates a radiogroup control.
            @param children_names: A tuple containing group item names
            @param value: Initial selected radio item
            @param secondory: Allows rendering one the same line as the previous group control.
                              Use this if you have another group control on the same line.
            """
# Assign group item factory class
            if Form.RadGroupControl.ItemClass is None:
                Form.RadGroupControl.ItemClass = Form.RadGroupItemControl

            Form.GroupControl.__init__(
                self,
                children_names,
                Form.FT_RADGRP2 if secondary else Form.FT_RADGRP,
                value)


#
# Input controls
#
    class InputControl(Control):
        """
        Generic form input control.
        It could be numeric control, string control, directory/file browsing, etc...
        """
        def __init__(self, tp, width, swidth, hlp = None):
            """
            @param width: Display width
            @param swidth: String width
            """
            Form.Control.__init__(self)
            self.tp = tp
            self.width = width
            self.switdh = swidth
            self.hlp = hlp

        def get_tag(self):
            return "%s%d:%s:%s:%s" % (
                self.tp, self.id,
                self.width,
                self.switdh,
                ":" if self.hlp is None else self.hlp)

        def is_input_field(self):
            return True


    class NumericInput(InputControl, NumericArgument):
        """
        A composite class serving as a base numeric input control class
        """
        def __init__(self, tp=None, value=0, width=50, swidth=10, hlp=None):
            if tp is None:
                tp = Form.FT_HEX
            Form.InputControl.__init__(self, tp, width, swidth, hlp)
            Form.NumericArgument.__init__(self, self.tp, value)


    class ColorInput(NumericInput):
        """
        Color button input control
        """
        def __init__(self, value = 0):
            """
            @param value: Initial color value in RGB
            """
            Form.NumericInput.__init__(self, tp=Form.FT_COLOR, value=value)


    class StringInput(InputControl, StringArgument):
        """
        Base string input control class.
        This class also constructs a StringArgument
        """
        def __init__(self,
                     tp=None,
                     width=1024,
                     swidth=40,
                     hlp=None,
                     value=None,
                     size=None):
            """
            @param width: String size. But in some cases it has special meaning. For example in FileInput control.
                          If you want to define the string buffer size then pass the 'size' argument
            @param swidth: Control width
            @param value: Initial value
            @param size: String size
            """
            if tp is None:
                tp = Form.FT_ASCII
            if not size:
                size = width
            Form.InputControl.__init__(self, tp, width, swidth, hlp)
            Form.StringArgument.__init__(self, size=size, value=value)


    class FileInput(StringInput):
        """
        File Open/Save input control
        """
        def __init__(self,
                     width=512,
                     swidth=80,
                     save=False, open=False,
                     hlp=None, value=None):

            if save == open:
                raise ValueError("Invalid mode. Choose either open or save")
            if width < 512:
                raise ValueError("Invalid width. Must be greater than 512.")

# The width field is overloaded in this control and is used
# to denote the type of the FileInput dialog (save or load)
# On the other hand it is passed as is to the StringArgument part
            Form.StringInput.__init__(
                self,
                tp=Form.FT_FILE,
                width="1" if save else "0",
                swidth=swidth,
                hlp=hlp,
                size=width,
                value=value)


    class DirInput(StringInput):
        """
        Directory browsing control
        """
        def __init__(self,
                     width=512,
                     swidth=80,
                     hlp=None,
                     value=None):

            if width < 512:
                raise ValueError("Invalid width. Must be greater than 512.")

            Form.StringInput.__init__(
                self,
                tp=Form.FT_DIR,
                width=width,
                swidth=swidth,
                hlp=hlp,
                size=width,
                value=value)


    class ButtonInput(InputControl):
        """
        Button control.
        A handler along with a 'code' (numeric value) can be associated with the button.
        This way one handler can handle many buttons based on the button code (or in other terms id or tag)
        """
        def __init__(self, handler, code="", swidth="", hlp=None):
            """
            @param handler: Button handler. A callback taking one argument which is the code.
            @param code: A code associated with the button and that is later passed to the handler.
            """
            Form.InputControl.__init__(
                self,
                Form.FT_BUTTON,
                code,
                swidth,
                hlp)
            self.handler = handler
            self.arg = _BUTTONCB_T(self.helper_cb)

        def helper_cb(self, button_code, p_fa):
# Remember the pointer to the forms_action in the parent form
            self.form.p_fa = p_fa

# Call user's handler
            r = self.handler(button_code)
            return 0 if r is None else r

        def is_input_field(self):
            return False


    class FormChangeCb(Control):
        """
        Form change handler.
        This can be thought of like a dialog procedure.
        Everytime a form action occurs, this handler will be called along with the control id.
        The programmer can then call various form actions accordingly:
          - EnableField
          - ShowField
          - MoveField
          - GetFieldValue
          - etc...

        Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)

        """
        def __init__(self, handler):
            """
            Constructs the handler.
            @param handler: The handler (preferrably a member function of a class derived from the Form class).
            """
            Form.Control.__init__(self)

# Save the handler
            self.handler = handler

# Create a callback stub
# We use this mechanism to create an intermediate step
# where we can create an 'fa' adapter for use by Python
            self.arg = _FORMCHGCB_T(self.helper_cb)

        def helper_cb(self, fid, p_fa):
# Remember the pointer to the forms_action in the parent form
            self.form.p_fa = p_fa

# Call user's handler
            r = self.handler(fid)
            return 0 if r is None else r

        def get_tag(self):
            return Form.FT_FORMCHG

        def free(self):
            Form.Control.free(self)
# Remove reference to the handler
# (Normally the handler is a member function in the parent form)
            self.handler = None


    class EmbeddedChooserControl(InputControl):
        """
        Embedded chooser control.
        This control links to a Chooser2 control created with the 'embedded=True'
        """
        def __init__(self,
                     chooser=None,
                     swidth=40,
                     hlp=None):
            """
            Embedded chooser control

            @param chooser: A chooser2 instance (must be constructed with 'embedded=True')
            """

# !! Make sure a chooser instance is passed !!
            if chooser is None or not isinstance(chooser, Choose):
                raise ValueError("Invalid chooser passed.")

# Create an embedded chooser structure from the Choose instance
            if chooser.Embedded() != 0:
                raise ValueError("Failed to create embedded chooser instance.")

# Construct input control
            Form.InputControl.__init__(self, Form.FT_ECHOOSER, "", swidth)

            self.selobj = ida_pro.sizevec_t()

# Get a pointer to the chooser_info_t and the selection vector
# (These two parameters are the needed arguments for the ask_form())
            emb = _ida_kernwin._choose_get_embedded_chobj_pointer(chooser)
            sel = self.selobj.this.__long__()

# Get a pointer to a c_void_p constructed from an address
            p_embedded = ctypes.pointer(ctypes.c_void_p.from_address(emb))
            p_sel      = ctypes.pointer(ctypes.c_void_p.from_address(sel))

# - Create the embedded chooser info on control creation
# - Do not free the embeded chooser because after we get the args
#   via Compile() the user can still call Execute() which relies
#   on the already computed args
            self.arg   = (p_embedded, p_sel)

# Save chooser instance
            self.chooser = chooser

# Add a bogus 'size' attribute
            self.size = 0


        value = property(lambda self: self.chooser)
        """Returns the embedded chooser instance"""

        def __get_selection__(self):
            if len(self.selobj):
                out = []
                for item in self.selobj:
                    out.append(int(item))
                return out
        selection = property(__get_selection__)
        """Returns the selection"""

        def free(self):
            """
            Frees the embedded chooser data
            """
            self.chooser.Close()
            self.chooser = None
            Form.Control.free(self)


    class DropdownListControl(InputControl, ida_pro._qstrvec_t):
        """
        Dropdown control
        This control allows manipulating a dropdown control
        """
        def __init__(self, items=[], readonly=True, selval=0, width=50, swidth=50, hlp = None):
            """
            @param items: A string list of items used to prepopulate the control
            @param readonly: Specifies whether the dropdown list is editable or not
            @param selval: The preselected item index (when readonly) or text value (when editable)
            @param width: the control width (n/a if the dropdown list is readonly)
            @param swidth: string width
            """

# Ignore the width if readonly was set
            if readonly:
                width = 0

# Init the input control base class
            Form.InputControl.__init__(
                self,
                Form.FT_DROPDOWN_LIST,
                width,
                swidth,
                hlp)

# Init the associated qstrvec
            ida_pro._qstrvec_t.__init__(self, items)

# Remember if readonly or not
            self.readonly = readonly

            if readonly:
# Create a C integer and remember it
                self.__selval = ctypes.c_int(selval)
                val_addr      = ctypes.addressof(self.__selval)
            else:
# Create an strvec with one qstring
                self.__selval = ida_pro._qstrvec_t([selval])
# Get address of the first element
                val_addr      = self.__selval.addressof(0)

# Two arguments:
# - argument #1: a pointer to the qstrvec containing the items
# - argument #2: an integer to hold the selection
#         or
#            #2: a qstring to hold the dropdown text control value
            self.arg = (
                ctypes.pointer(ctypes.c_void_p.from_address(self.clink_ptr)),
                ctypes.pointer(ctypes.c_void_p.from_address(val_addr))
            )


        def __set_selval(self, val):
            if self.readonly:
                self.__selval.value = val
            else:
                self.__selval[0] = val

        def __get_selval(self):
# Return the selection index
# or the entered text value
            return self.__selval.value if self.readonly else self.__selval[0]

        value  = property(__get_selval, __set_selval)
        selval = property(__get_selval, __set_selval)
        """
        Read/write the selection value.
        The value is used as an item index in readonly mode or text value in editable mode
        This value can be used only after the form has been closed.
        """

        def free(self):
            self._free()


        def set_items(self, items):
            """Sets the dropdown list items"""
            self.from_list(items)


    class MultiLineTextControl(InputControl, textctrl_info_t):
        """
        Multi line text control.
        This class inherits from textctrl_info_t. Thus the attributes are also inherited
        This control allows manipulating a multilinetext control
        """
        def __init__(self, text="", flags=0, tabsize=0, width=50, swidth=50, hlp = None):
            """
            @param text: Initial text value
            @param flags: One of textctrl_info_t.TXTF_.... values
            @param tabsize: Tab size
            @param width: Display width
            @param swidth: String width
            """
# Init the input control base class
            Form.InputControl.__init__(self, Form.FT_MULTI_LINE_TEXT, width, swidth, hlp)

# Init the associated textctrl_info base class
            textctrl_info_t.__init__(self, text=text, flags=flags, tabsize=tabsize)

# Get the argument as a pointer from the embedded ti
            self.arg = ctypes.pointer(ctypes.c_void_p.from_address(self.clink_ptr))


        def free(self):
            self._free()


#
# Form class
#
    def __init__(self, form, controls):
        """
        Contruct a Form class.
        This class wraps around ask_form() or open_form() and provides an easier / alternative syntax for describing forms.
        The form control names are wrapped inside the opening and closing curly braces and the control themselves are
        defined and instantiated via various form controls (subclasses of Form).

        @param form: The form string
        @param controls: A dictionary containing the control name as a _key_ and control object as _value_
        """
        self._reset()
        self.form = form
        """Form string"""
        self.controls = controls
        """Dictionary of controls"""
        self.__args = None

        self.title = None
        """The Form title. It will be filled when the form is compiled"""

        self.modal = True
        """By default, forms are modal"""

        self.openform_flags = 0
        """
        If non-modal, these flags will be passed to open_form.
        This is an OR'ed combination of the PluginForm.FORM_* values.
        """


    def Free(self):
        """
        Frees all resources associated with a compiled form.
        Make sure you call this function when you finish using the form.
        """

# Free all the controls
        for name, ctrl in self.__controls.items():
            if ctrl.parent_hasattr:
                delattr(self, name)
                ctrl.parent_hasattr = False
            ctrl.free()

# Reset the controls
# (Note that we are not removing the form control attributes, no need)
        self._reset()

# Unregister, so we don't try and free it again at closing-time.
        _ida_kernwin.py_unregister_compiled_form(self)


    def _reset(self):
        """
        Resets the Form class state variables
        """
        self.__controls = {}
        self.__ctrl_id = 1


    def __getitem__(self, name):
        """Returns a control object by name"""
        return self.__controls[name]


    def Add(self, name, ctrl, mkattr = True):
        """
        Low level function. Prefer AddControls() to this function.
        This function adds one control to the form.

        @param name: Control name
        @param ctrl: Control object
        @param mkattr: Create control name / control object as a form attribute
        """
# Assign a unique ID
        ctrl.id = self.__ctrl_id
        self.__ctrl_id += 1

# Create attribute with control name
        if mkattr:
            setattr(self, name, ctrl)
            ctrl.parent_hasattr = True

# Remember the control
        self.__controls[name] = ctrl

# Link the form to the control via its form attribute
        ctrl.form = self

# Is it a group? Add each child
        if isinstance(ctrl, Form.GroupControl):
            self._AddGroup(ctrl, mkattr)


    def FindControlById(self, id):
        """
        Finds a control instance given its id
        """
        for ctrl in self.__controls.values():
            if ctrl.id == id:
                return ctrl
        return None


    @staticmethod
    def _ParseFormTitle(form):
        """
        Parses the form's title from the form text
        """
        help_state = 0
        for i, line in enumerate(form.split("\n")):
            if line.startswith("STARTITEM ") or line.startswith("BUTTON "):
                continue
# Skip "HELP" and remember state
            elif help_state == 0 and line == "HELP":
                help_state = 1 # Mark inside HELP
                continue
            elif help_state == 1 and line == "ENDHELP":
                help_state = 2 # Mark end of HELP
                continue
            return line.strip()

        return None


    def _AddGroup(self, Group, mkattr=True):
        """
        Internal function.
        This function expands the group item names and creates individual group item controls

        @param Group: The group class (checkbox or radio group class)
        """

# Create group item controls for each child
        for child_name in Group.children_names:
            self.Add(
                child_name,
# Use the class factory
                Group.ItemClass(Group.tag, Group),
                mkattr)


    def AddControls(self, controls, mkattr=True):
        """
        Adds controls from a dictionary.
        The dictionary key is the control name and the value is a Form.Control object
        @param controls: The control dictionary
        """
        for name, ctrl in controls.items():
# Add the control
            self.Add(name, ctrl, mkattr)


    def CompileEx(self, form):
        """
        Low level function.
        Compiles (parses the form syntax and adds the control) the form string and
        returns the argument list to be passed the argument list to ask_form().

        The form controls are wrapped inside curly braces: {ControlName}.

        A special operator can be used to return the index of a given control by its name: {id:ControlName}.
        This is useful when you use the STARTITEM form keyword to set the initially focused control.
        (note that, technically, the index is not the same as the ID; that's because STARTITEM
        uses raw, 0-based indexes rather than control IDs to determine the focused widget.)

        @param form: Compiles the form and returns the arguments needed to be passed to ask_form()
        """
# First argument is the form string
        args = [None]

# Second argument, if form is not modal, is the set of flags
        if not self.modal:
            args.append(self.openform_flags | 0x80) # Add FORM_QWIDGET

        ctrlcnt = 1

# Reset all group control internal flags
        for ctrl in self.__controls.values():
            if isinstance(ctrl, Form.GroupControl):
                ctrl._reset()

        def next_control(form, p, first_pass):
            i1 = form.find("{", p)
            if i1 < 0:
                return form, None, None, None
            if form[i1 - 1] == '\\' and i1 > 0:
                if first_pass:
                    return next_control(form, i1 + 1, first_pass)
                else:
# Remove escape sequence and restart search
                    form = form[:i1 - 1] + form[i1:]
                    return next_control(form, i1, first_pass)
            i2 = form.find("}", i1)
            if i2 < 0:
                raise SyntaxError("No matching closing brace '}'")
            ctrlname = form[i1 + 1:i2]
            if not ctrlname:
                raise ValueError("Control %d has an invalid name!" % ctrlcnt)
            return form, i1, i2, ctrlname


        last_input_field_index = 0
# First pass: assign input_field_index values to controls
        p = 0
        while True:
            form, i1, i2, ctrlname = next_control(form, p, first_pass=True)
            if ctrlname is None:
                break
            p = i2

            if ctrlname.startswith("id:"):
                continue

            ctrl = self.__controls.get(ctrlname, None)
            if ctrl is None:
                raise ValueError("No matching control '%s'" % ctrlname)

# If this control is an input, assign its index
            if ctrl.is_input_field():
                ctrl.input_field_index = last_input_field_index
                last_input_field_index += 1


        p = 0
        while True:
            form, i1, i2, ctrlname = next_control(form, p, first_pass=False)
            if ctrlname is None:
                break

# Is it the IDOF operator?
            if ctrlname.startswith("id:"):
                idfunc = True
# Take actual ctrlname
                ctrlname = ctrlname[3:]
            else:
                idfunc = False

# Find the control
            ctrl = self.__controls.get(ctrlname, None)
            if ctrl is None:
                raise ValueError("No matching control '%s'" % ctrlname)

# Replace control name by tag
            if idfunc:
                tag = str(ctrl.input_field_index if ctrl.input_field_index is not None else ctrl.id)
            else:
                tag = ctrl.get_tag()
            taglen = len(tag)
            form = form[:i1] + tag + form[i2+1:]

# Set new position
            p = i1 + taglen

# Was it an IDOF() ? No need to push parameters
# Just ID substitution is fine
            if idfunc:
                continue


# For GroupItem controls, there are no individual arguments
# The argument is assigned for the group itself
            if isinstance(ctrl, Form.GroupItemControl):
# GroupItem controls will have their position dynamically set
                ctrl.assign_pos()
            else:
# Push argument(s)
# (Some controls need more than one argument)
                arg = ctrl.get_arg()
                if isinstance(arg, (list, tuple)):
# Push all args
                    args.extend(arg)
                else:
# Push one arg
                    args.append(arg)

            ctrlcnt += 1

# If no FormChangeCb instance was passed, and thus there's no '%/'
# in the resulting form string, let's provide a minimal one, so that
# we will retrieve 'p_fa', and thus actions that rely on it will work.
        if form.find(Form.FT_FORMCHG) < 0:
            form = form + Form.FT_FORMCHG
            fccb = Form.FormChangeCb(lambda *args: 1)
            self.Add("___dummyfchgcb", fccb)
# Regardless of the actual position of '%/' in the form
# string, a formchange callback _must_ be right after
# the form string.
            if self.modal:
                inspos = 1
            else:
                inspos = 2
            args.insert(inspos, fccb.get_arg())

# Patch in the final form string
        args[0] = form

        self.title = self._ParseFormTitle(form)
        return args


    def Compile(self):
        """
        Compiles a form and returns the form object (self) and the argument list.
        The form object will contain object names corresponding to the form elements

        @return: It will raise an exception on failure. Otherwise the return value is ignored
        """

# Reset controls
        self._reset()

# Insert controls
        self.AddControls(self.controls)

# Compile form and get args
        self.__args = self.CompileEx(self.form)

# Register this form, to make sure it will be freed at closing-time.
        _ida_kernwin.py_register_compiled_form(self)

        return (self, self.__args)


    def Compiled(self):
        """
        Checks if the form has already been compiled

        @return: Boolean
        """
        return self.__args is not None


    def _ChkCompiled(self):
        if not self.Compiled():
            raise SyntaxError("Form is not compiled")


    def Execute(self):
        """
        Displays a modal dialog containing the compiled form.
        @return: 1 - ok ; 0 - cancel
        """
        self._ChkCompiled()
        if not self.modal:
            raise SyntaxError("Form is not modal. Open() should be instead")

        return _call_ask_form(*self.__args)


    def Open(self):
        """
        Opens a widget containing the compiled form.
        """
        self._ChkCompiled()
        if self.modal:
            raise SyntaxError("Form is modal. Execute() should be instead")

        _call_open_form(*self.__args)


    def EnableField(self, ctrl, enable):
        """
        Enable or disable an input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_enable_field(self.p_fa, ctrl.id, enable)


    def ShowField(self, ctrl, show):
        """
        Show or hide an input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_show_field(self.p_fa, ctrl.id, show)


    def MoveField(self, ctrl, x, y, w, h):
        """
        Move/resize an input field

        @return: False - no such fiel
        """
        return _ida_kernwin.formchgcbfa_move_field(self.p_fa, ctrl.id, x, y, w, h)


    def GetFocusedField(self):
        """
        Get currently focused input field.
        @return: None if no field is selected otherwise the control ID
        """
        id = _ida_kernwin.formchgcbfa_get_focused_field(self.p_fa)
        return self.FindControlById(id)


    def SetFocusedField(self, ctrl):
        """
        Set currently focused input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_set_focused_field(self.p_fa, ctrl.id)


    def RefreshField(self, ctrl):
        """
        Refresh a field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_refresh_field(self.p_fa, ctrl.id)


    def Close(self, close_normally):
        """
        Close the form
        @param close_normally:
                   1: form is closed normally as if the user pressed Enter
                   0: form is closed abnormally as if the user pressed Esc
        @return: None
        """
        return _ida_kernwin.formchgcbfa_close(self.p_fa, close_normally)


    def GetControlValue(self, ctrl):
        """
        Returns the control's value depending on its type
        @param ctrl: Form control instance
        @return:
            - color button, radio controls: integer
            - file/dir input, string input and string label: string
            - embedded chooser control (0-based indices of selected items): integer list
            - for multilinetext control: textctrl_info_t
            - dropdown list controls: string (when editable) or index (when readonly)
            - None: on failure
        """
        tid, sz = self.ControlToFieldTypeIdAndSize(ctrl)
        r = _ida_kernwin.formchgcbfa_get_field_value(
                    self.p_fa,
                    ctrl.id,
                    tid,
                    sz)
# Multilinetext? Unpack the tuple into a new textctrl_info_t instance
        if r is not None and tid == 7:
            return textctrl_info_t(text=r[0], flags=r[1], tabsize=r[2])
        else:
            return r


    def SetControlValue(self, ctrl, value):
        """
        Set the control's value depending on its type
        @param ctrl: Form control instance
        @param value:
            - embedded chooser: a 0-base indices list to select embedded chooser items
            - multilinetext: a textctrl_info_t
            - dropdown list: an integer designating the selection index if readonly
                             a string designating the edit control value if not readonly
        @return: Boolean true on success
        """
        tid, _ = self.ControlToFieldTypeIdAndSize(ctrl)
        return _ida_kernwin.formchgcbfa_set_field_value(
                    self.p_fa,
                    ctrl.id,
                    tid,
                    value)


    @staticmethod
    def ControlToFieldTypeIdAndSize(ctrl):
        """
        Converts a control object to a tuple containing the field id
        and the associated buffer size
        """
# Input control depend on the associated buffer size (supplied by the user)

# Make sure you check instances types taking into account inheritance
        if isinstance(ctrl, Form.DropdownListControl):
            return (8, 1 if ctrl.readonly else 0)
        elif isinstance(ctrl, Form.MultiLineTextControl):
            return (7, 0)
        elif isinstance(ctrl, Form.EmbeddedChooserControl):
            return (5, 0)
# Group items or controls
        elif isinstance(ctrl, (Form.GroupItemControl, Form.GroupControl)):
            return (2, 0)
        elif isinstance(ctrl, Form.StringLabel):
            return (3, min(_ida_kernwin.MAXSTR, ctrl.size))
        elif isinstance(ctrl, Form.ColorInput):
            return (4, 0)
        elif isinstance(ctrl, Form.NumericInput):
# Pass the numeric control type
            return (6, ord(ctrl.tp[0]))
        elif isinstance(ctrl, Form.InputControl):
            return (1, ctrl.size)
        else:
            raise NotImplementedError("Not yet implemented")

# --------------------------------------------------------------------------
# Instantiate ask_form function pointer
try:
    import ctypes
# Setup the numeric argument size
    Form.NumericArgument.DefI64 = _ida_idaapi.BADADDR == 0xFFFFFFFFFFFFFFFF
    __ask_form_callable = ctypes.CFUNCTYPE(ctypes.c_long)(_ida_kernwin.py_get_ask_form())
    __open_form_callable = ctypes.CFUNCTYPE(ctypes.c_long)(_ida_kernwin.py_get_open_form())
except:
    def __ask_form_callable(*args):
        warning("ask_form() needs ctypes library in order to work")
        return 0
    def __open_form_callable(*args):
        warning("open_form() needs ctypes library in order to work")


def _call_ask_form(*args):
    old = _ida_idaapi.set_script_timeout(0)
    r = __ask_form_callable(*args)
    _ida_idaapi.set_script_timeout(old)
    return r

def _call_open_form(*args):
    old = _ida_idaapi.set_script_timeout(0)
    r = __open_form_callable(*args)
    _ida_idaapi.set_script_timeout(old)
#</pycode(py_kernwin_askform)>


def install_command_interpreter(*args):
    r"""install_command_interpreter(py_obj) -> int"""
    return _ida_kernwin.install_command_interpreter(*args)

def remove_command_interpreter(*args):
    r"""remove_command_interpreter(cli_idx)"""
    return _ida_kernwin.remove_command_interpreter(*args)

#<pycode(py_kernwin_cli)>
import ida_idaapi

class cli_t(ida_idaapi.pyidc_opaque_object_t):
    """
    cli_t wrapper class.

    This class allows you to implement your own command line interface handlers.
    """

    def __init__(self):
        self.__cli_idx = -1
        self.__clink__ = None


    def register(self, flags = 0, sname = None, lname = None, hint = None):
        """
        Registers the CLI.

        @param flags: Feature bits. No bits are defined yet, must be 0
        @param sname: Short name (displayed on the button)
        @param lname: Long name (displayed in the menu)
        @param hint:  Hint for the input line

        @return Boolean: True-Success, False-Failed
        """

# Already registered?
        if self.__cli_idx >= 0:
            return True

        if sname is not None: self.sname = sname
        if lname is not None: self.lname = lname
        if hint is not None:  self.hint  = hint

# Register
        self.__cli_idx = _ida_kernwin.install_command_interpreter(self)
        return False if self.__cli_idx < 0 else True


    def unregister(self):
        """
        Unregisters the CLI (if it was registered)
        """
        if self.__cli_idx < 0:
            return False

        _ida_kernwin.remove_command_interpreter(self.__cli_idx)
        self.__cli_idx = -1
        return True


    def __del__(self):
        self.unregister()

#
# Implement these methods in the subclass:
#
#<pydoc>
#    def OnExecuteLine(self, line):
#        """
#        The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.
#
#        This callback is mandatory.
#
#        @param line: typed line(s)
#        @return Boolean: True-executed line, False-ask for more lines
#        """
#        return True
#
#    def OnKeydown(self, line, x, sellen, vkey, shift):
#        """
#        A keyboard key has been pressed
#        This is a generic callback and the CLI is free to do whatever it wants.
#
#        This callback is optional.
#
#        @param line: current input line
#        @param x: current x coordinate of the cursor
#        @param sellen: current selection length (usually 0)
#        @param vkey: virtual key code. if the key has been handled, it should be returned as zero
#        @param shift: shift state
#
#        @return:
#            None - Nothing was changed
#            tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
#            It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)
#        """
#        return None
#
#    def OnCompleteLine(self, prefix, n, line, prefix_start):
#        """
#        The user pressed Tab. Find a completion number N for prefix PREFIX
#
#        This callback is optional.
#
#        @param prefix: Line prefix at prefix_start (string)
#        @param n: completion number (int)
#        @param line: the current line (string)
#        @param prefix_start: the index where PREFIX starts in LINE (int)
#
#        @return: None if no completion could be generated otherwise a String with the completion suggestion
#        """
#        return None
#</pydoc>

#</pycode(py_kernwin_cli)>

class View_Hooks(object):
    r"""Proxy of C++ View_Hooks class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ida_kernwin.delete_View_Hooks

    def hook(self, *args):
        r"""hook(self) -> bool"""
        return _ida_kernwin.View_Hooks_hook(self, *args)

    def unhook(self, *args):
        r"""unhook(self) -> bool"""
        return _ida_kernwin.View_Hooks_unhook(self, *args)

    def view_activated(self, *args):
        r"""view_activated(self, view)"""
        return _ida_kernwin.View_Hooks_view_activated(self, *args)

    def view_deactivated(self, *args):
        r"""view_deactivated(self, view)"""
        return _ida_kernwin.View_Hooks_view_deactivated(self, *args)

    def view_keydown(self, *args):
        r"""view_keydown(self, view, key, state)"""
        return _ida_kernwin.View_Hooks_view_keydown(self, *args)

    def view_click(self, *args):
        r"""view_click(self, view, event)"""
        return _ida_kernwin.View_Hooks_view_click(self, *args)

    def view_dblclick(self, *args):
        r"""view_dblclick(self, view, event)"""
        return _ida_kernwin.View_Hooks_view_dblclick(self, *args)

    def view_curpos(self, *args):
        r"""view_curpos(self, view)"""
        return _ida_kernwin.View_Hooks_view_curpos(self, *args)

    def view_created(self, *args):
        r"""view_created(self, view)"""
        return _ida_kernwin.View_Hooks_view_created(self, *args)

    def view_close(self, *args):
        r"""view_close(self, view)"""
        return _ida_kernwin.View_Hooks_view_close(self, *args)

    def view_switched(self, *args):
        r"""view_switched(self, view, rt)"""
        return _ida_kernwin.View_Hooks_view_switched(self, *args)

    def view_mouse_over(self, *args):
        r"""view_mouse_over(self, view, event)"""
        return _ida_kernwin.View_Hooks_view_mouse_over(self, *args)

    def view_loc_changed(self, *args):
        r"""view_loc_changed(self, view, now, was)"""
        return _ida_kernwin.View_Hooks_view_loc_changed(self, *args)

    def view_mouse_moved(self, *args):
        r"""view_mouse_moved(self, view, event)"""
        return _ida_kernwin.View_Hooks_view_mouse_moved(self, *args)

    def __init__(self, *args):
        r"""__init__(self) -> View_Hooks"""
        if self.__class__ == View_Hooks:
            _self = None
        else:
            _self = self
        _ida_kernwin.View_Hooks_swiginit(self, _ida_kernwin.new_View_Hooks(_self, *args))
    def __disown__(self):
        self.this.disown()
        _ida_kernwin.disown_View_Hooks(self)
        return weakref.proxy(self)

# Register View_Hooks in _ida_kernwin:
_ida_kernwin.View_Hooks_swigregister(View_Hooks)


#<pycode(py_kernwin_viewhooks)>
# -----------------------------------------------------------------------
#                           CustomIDAMemo
# -----------------------------------------------------------------------
class CustomIDAMemo(View_Hooks):
    def __init__(self):
        View_Hooks.__init__(self)

    def _graph_item_tuple(self, ve):
        item = None
        if ve.rtype in [TCCRT_GRAPH, TCCRT_PROXIMITY]:
            item = ve.location.item
        if item is not None:
            if item.is_node:
                return (item.node,)
            else:
                return (item.elp.e.src, item.elp.e.dst)
        else:
            return ()

    @staticmethod
    def _dummy_cb(*args):
        pass

    def _get_cb(self, view, cb_name):
        cb = CustomIDAMemo._dummy_cb
        if view == self.GetWidget():
            cb = getattr(self, cb_name, cb)
        return cb

    def _get_cb_arity(self, cb):
        from inspect import getargspec
        return len(getargspec(cb).args)

    def view_activated(self, view):
        return self._get_cb(view, "OnViewActivated")()

    def view_deactivated(self, view):
        return self._get_cb(view, "OnViewDeactivated")()

    def view_keydown(self, view, key, state):
        return self._get_cb(view, "OnViewKeydown")(key, state)

    def view_click(self, view, ve):
        cb = self._get_cb(view, "OnViewClick")
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            args = [ve.x, ve.y, ve.state]
            if arity >= 5:
                args.append(ve.button)
                if arity >= 6:
                    args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_dblclick(self, view, ve):
        cb = self._get_cb(view, "OnViewDblclick")
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            args = [ve.x, ve.y, ve.state]
            if arity >= 5:
                args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_curpos(self, view, *args):
        return self._get_cb(view, "OnViewCurpos")()

    def view_close(self, view, *args):
        rc = self._get_cb(view, "OnClose")()
        if view == self.GetWidget():
            ida_idaapi.pycim_view_close(self)
        return rc

    def view_switched(self, view, rt):
        return self._get_cb(view, "OnViewSwitched")(rt)

    def view_mouse_over(self, view, ve):
        cb = self._get_cb(view, "OnViewMouseOver")
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            gitpl = self._graph_item_tuple(ve)
            args = [ve.x, ve.y, ve.state, len(gitpl), gitpl]
            if arity >= 7:
                args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_loc_changed(self, view, now, was):
        return self._get_cb(view, "OnViewLocationChanged")(now, was)

    def view_mouse_moved(self, view, ve):
        cb = self._get_cb(view, "OnViewMouseMoved")
        if cb != CustomIDAMemo._dummy_cb:
            gitpl = self._graph_item_tuple(ve)
            return cb(ve.x, ve.y, ve.state, len(gitpl), gitpl, ve.renderer_pos)

# End of hooks->wrapper trampolines


    def Refresh(self):
        """
        Refreshes the view. This causes the OnRefresh() to be called
        """
        ida_idaapi.pygc_refresh(self)

    def GetCurrentRendererType(self):
        return ida_idaapi.pygc_get_current_renderer_type(self)

    def SetCurrentRendererType(self, rtype):
        """
        Set the current view's renderer.

        @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
        """
        ida_idaapi.pygc_set_current_renderer_type(self, rtype)

    def SetNodeInfo(self, node_index, node_info, flags):
        """
        Set the properties for the given node.

        Example usage (set second nodes's bg color to red):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff0000
          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)

        @param node_index: The node index.
        @param node_info: An idaapi.node_info_t instance.
        @param flags: An OR'ed value of NIF_* values.
        """
        ida_idaapi.pygc_set_node_info(self, node_index, node_info, flags)

    def SetNodesInfos(self, values):
        """
        Set the properties for the given nodes.

        Example usage (set first three nodes's bg color to purple):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff00ff
          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})

        @param values: A dictionary of 'int -> node_info_t' objects.
        """
        ida_idaapi.pygc_set_nodes_infos(self, values)

    def GetNodeInfo(self, node):
        """
        Get the properties for the given node.

        @param node: The index of the node.
        @return: A tuple (bg_color, frame_color, ea, text), or None.
        """
        return ida_idaapi.pygc_get_node_info(self, node)

    def DelNodesInfos(self, *nodes):
        """
        Delete the properties for the given node(s).

        @param nodes: A list of node IDs
        """
        return ida_idaapi.pygc_del_nodes_infos(self, nodes)

    def CreateGroups(self, groups_infos):
        """
        Send a request to modify the graph by creating a
        (set of) group(s), and perform an animation.

        Each object in the 'groups_infos' list must be of the format:
        {
          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
          "text" : <string>                    # The synthetic text for that group
        }

        @param groups_infos: A list of objects that describe those groups.
        @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
        """
        return ida_idaapi.pygc_create_groups(self, groups_infos)

    def DeleteGroups(self, groups, new_current = -1):
        """
        Send a request to delete the specified groups in the graph,
        and perform an animation.

        @param groups: A list of group node numbers.
        @param new_current: A node to focus on after the groups have been deleted
        @return: True on success, False otherwise.
        """
        return ida_idaapi.pygc_delete_groups(self, groups, new_current)

    def SetGroupsVisibility(self, groups, expand, new_current = -1):
        """
        Send a request to expand/collapse the specified groups in the graph,
        and perform an animation.

        @param groups: A list of group node numbers.
        @param expand: True to expand the group, False otherwise.
        @param new_current: A node to focus on after the groups have been expanded/collapsed.
        @return: True on success, False otherwise.
        """
        return ida_idaapi.pygc_set_groups_visibility(self, groups, expand, new_current)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return ida_idaapi.pycim_get_widget(self)

# ----------------------------------------------------------------------
# bw-compat/deprecated. You shouldn't rely on this in new code
import ida_idaapi
ida_idaapi.CustomIDAMemo = CustomIDAMemo

#</pycode(py_kernwin_viewhooks)>


def pyidag_bind(*args):
    r"""pyidag_bind(_self) -> bool"""
    return _ida_kernwin.pyidag_bind(*args)

def pyidag_unbind(*args):
    r"""pyidag_unbind(_self) -> bool"""
    return _ida_kernwin.pyidag_unbind(*args)

#<pycode(py_kernwin_idaview)>
#-------------------------------------------------------------------------
#                             IDAViewWrapper
#-------------------------------------------------------------------------
import _ida_kernwin
class IDAViewWrapper(CustomIDAMemo):
    """
    Deprecated. Use View_Hooks instead.

    Because the lifecycle of an IDAView is not trivial to track (e.g., a user
    might close, then re-open the same disassembly view), this wrapper doesn't
    bring anything superior to the View_Hooks: quite the contrary, as the
    latter is much more generic (and better maps IDA's internal model.)
    """
    def __init__(self, title):
        CustomIDAMemo.__init__(self)
        self._title = title

    def Bind(self):
        rc = _ida_kernwin.pyidag_bind(self)
        if rc:
            self.hook()
        return rc

    def Unbind(self):
        rc = _ida_kernwin.pyidag_unbind(self)
        if rc:
            self.unhook()
        return rc

#</pycode(py_kernwin_idaview)>


def pyscv_init(*args):
    r"""pyscv_init(py_link, title) -> PyObject *"""
    return _ida_kernwin.pyscv_init(*args)

def pyscv_refresh(*args):
    r"""pyscv_refresh(py_this) -> bool"""
    return _ida_kernwin.pyscv_refresh(*args)

def pyscv_delete(*args):
    r"""pyscv_delete(py_this) -> bool"""
    return _ida_kernwin.pyscv_delete(*args)

def pyscv_refresh_current(*args):
    r"""pyscv_refresh_current(py_this) -> bool"""
    return _ida_kernwin.pyscv_refresh_current(*args)

def pyscv_get_current_line(*args):
    r"""pyscv_get_current_line(py_this, mouse, notags) -> PyObject *"""
    return _ida_kernwin.pyscv_get_current_line(*args)

def pyscv_is_focused(*args):
    r"""pyscv_is_focused(py_this) -> bool"""
    return _ida_kernwin.pyscv_is_focused(*args)

def pyscv_count(*args):
    r"""pyscv_count(py_this) -> size_t"""
    return _ida_kernwin.pyscv_count(*args)

def pyscv_show(*args):
    r"""pyscv_show(py_this) -> bool"""
    return _ida_kernwin.pyscv_show(*args)

def pyscv_close(*args):
    r"""pyscv_close(py_this)"""
    return _ida_kernwin.pyscv_close(*args)

def pyscv_jumpto(*args):
    r"""pyscv_jumpto(py_this, ln, x, y) -> bool"""
    return _ida_kernwin.pyscv_jumpto(*args)

def pyscv_get_line(*args):
    r"""pyscv_get_line(py_this, nline) -> PyObject *"""
    return _ida_kernwin.pyscv_get_line(*args)

def pyscv_get_pos(*args):
    r"""pyscv_get_pos(py_this, mouse) -> PyObject *"""
    return _ida_kernwin.pyscv_get_pos(*args)

def pyscv_clear_lines(*args):
    r"""pyscv_clear_lines(py_this) -> PyObject *"""
    return _ida_kernwin.pyscv_clear_lines(*args)

def pyscv_add_line(*args):
    r"""pyscv_add_line(py_this, py_sl) -> bool"""
    return _ida_kernwin.pyscv_add_line(*args)

def pyscv_insert_line(*args):
    r"""pyscv_insert_line(py_this, nline, py_sl) -> bool"""
    return _ida_kernwin.pyscv_insert_line(*args)

def pyscv_patch_line(*args):
    r"""pyscv_patch_line(py_this, nline, offs, value) -> bool"""
    return _ida_kernwin.pyscv_patch_line(*args)

def pyscv_del_line(*args):
    r"""pyscv_del_line(py_this, nline) -> bool"""
    return _ida_kernwin.pyscv_del_line(*args)

def pyscv_get_selection(*args):
    r"""pyscv_get_selection(py_this) -> PyObject *"""
    return _ida_kernwin.pyscv_get_selection(*args)

def pyscv_get_current_word(*args):
    r"""pyscv_get_current_word(py_this, mouse) -> PyObject *"""
    return _ida_kernwin.pyscv_get_current_word(*args)

def pyscv_edit_line(*args):
    r"""pyscv_edit_line(py_this, nline, py_sl) -> bool"""
    return _ida_kernwin.pyscv_edit_line(*args)

def pyscv_get_widget(*args):
    r"""pyscv_get_widget(py_this) -> TWidget *"""
    return _ida_kernwin.pyscv_get_widget(*args)

#<pycode(py_kernwin_custview)>
class simplecustviewer_t(object):
    """The base class for implementing simple custom viewers"""

    class UI_Hooks_Trampoline(UI_Hooks):
        def __init__(self, v):
            UI_Hooks.__init__(self)
            self.hook()
            import weakref
            self.v = weakref.ref(v)

        def populating_widget_popup(self, form, popup_handle):
            my_form = self.v().GetWidget()
            if form == my_form:
                cb = self.v().OnPopup
                from inspect import getargspec
                if len(getargspec(cb).args) == 3:
                    cb(my_form, popup_handle)
                else:
                    cb() # bw-compat

    def __init__(self):
        self.__this = None
        self.ui_hooks_trampoline = self.UI_Hooks_Trampoline(self)

    def __del__(self):
        """Destructor. It also frees the associated C++ object"""
        try:
            _ida_kernwin.pyscv_delete(self.__this)
        except:
            pass

    @staticmethod
    def __make_sl_arg(line, fgcolor=None, bgcolor=None):
        return line if (fgcolor is None and bgcolor is None) else (line, fgcolor, bgcolor)

    def OnPopup(self, form, popup_handle):
        """
        Context menu popup is about to be shown. Create items dynamically if you wish
        @return: Boolean. True if you handled the event
        """
        pass

    def Create(self, title):
        """
        Creates the custom view. This should be the first method called after instantiation

        @param title: The title of the view
        @return: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
                 In this case better close existing windows
        """
        self.title = title
        self.__this = _ida_kernwin.pyscv_init(self, title)
        return True if self.__this else False

    def Close(self):
        """
        Destroys the view.
        One has to call Create() afterwards.
        Show() can be called and it will call Create() internally.
        @return: Boolean
        """
        return _ida_kernwin.pyscv_close(self.__this)

    def Show(self):
        """
        Shows an already created view. It the view was close, then it will call Create() for you
        @return: Boolean
        """
        return _ida_kernwin.pyscv_show(self.__this)

    def Refresh(self):
        return _ida_kernwin.pyscv_refresh(self.__this)

    def RefreshCurrent(self):
        """Refreshes the current line only"""
        return _ida_kernwin.pyscv_refresh_current(self.__this)

    def Count(self):
        """Returns the number of lines in the view"""
        return _ida_kernwin.pyscv_count(self.__this)

    def GetSelection(self):
        """
        Returns the selected range or None
        @return:
            - tuple(x1, y1, x2, y2)
            - None if no selection
        """
        return _ida_kernwin.pyscv_get_selection(self.__this)

    def ClearLines(self):
        """Clears all the lines"""
        _ida_kernwin.pyscv_clear_lines(self.__this)

    def AddLine(self, line, fgcolor=None, bgcolor=None):
        """
        Adds a colored line to the view
        @return: Boolean
        """
        return _ida_kernwin.pyscv_add_line(self.__this, self.__make_sl_arg(line, fgcolor, bgcolor))

    def InsertLine(self, lineno, line, fgcolor=None, bgcolor=None):
        """
        Inserts a line in the given position
        @return: Boolean
        """
        return _ida_kernwin.pyscv_insert_line(self.__this, lineno, self.__make_sl_arg(line, fgcolor, bgcolor))

    def EditLine(self, lineno, line, fgcolor=None, bgcolor=None):
        """
        Edits an existing line.
        @return: Boolean
        """
        return _ida_kernwin.pyscv_edit_line(self.__this, lineno, self.__make_sl_arg(line, fgcolor, bgcolor))

    def PatchLine(self, lineno, offs, value):
        """Patches an existing line character at the given offset. This is a low level function. You must know what you're doing"""
        return _ida_kernwin.pyscv_patch_line(self.__this, lineno, offs, value)

    def DelLine(self, lineno):
        """
        Deletes an existing line
        @return: Boolean
        """
        return _ida_kernwin.pyscv_del_line(self.__this, lineno)

    def GetLine(self, lineno):
        """
        Returns a line
        @param lineno: The line number
        @return:
            Returns a tuple (colored_line, fgcolor, bgcolor) or None
        """
        return _ida_kernwin.pyscv_get_line(self.__this, lineno)

    def GetCurrentWord(self, mouse = 0):
        """
        Returns the current word
        @param mouse: Use mouse position or cursor position
        @return: None if failed or a String containing the current word at mouse or cursor
        """
        return _ida_kernwin.pyscv_get_current_word(self.__this, mouse)

    def GetCurrentLine(self, mouse = 0, notags = 0):
        """
        Returns the current line.
        @param mouse: Current line at mouse pos
        @param notags: If True then tag_remove() will be called before returning the line
        @return: Returns the current line (colored or uncolored) or None on failure
        """
        return _ida_kernwin.pyscv_get_current_line(self.__this, mouse, notags)

    def GetPos(self, mouse = 0):
        """
        Returns the current cursor or mouse position.
        @param mouse: return mouse position
        @return: Returns a tuple (lineno, x, y)
        """
        return _ida_kernwin.pyscv_get_pos(self.__this, mouse)

    def GetLineNo(self, mouse = 0):
        """Calls GetPos() and returns the current line number or -1 on failure"""
        r = self.GetPos(mouse)
        return -1 if not r else r[0]

    def Jump(self, lineno, x=0, y=0):
        return _ida_kernwin.pyscv_jumpto(self.__this, lineno, x, y)

    def IsFocused(self):
        """Returns True if the current view is the focused view"""
        return _ida_kernwin.pyscv_is_focused(self.__this)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.pyscv_get_widget(self.__this)



# Here are all the supported events
#<pydoc>
#    def OnClick(self, shift):
#        """
#        User clicked in the view
#        @param shift: Shift flag
#        @return: Boolean. True if you handled the event
#        """
#        print "OnClick, shift=%d" % shift
#        return True
#
#    def OnDblClick(self, shift):
#        """
#        User dbl-clicked in the view
#        @param shift: Shift flag
#        @return: Boolean. True if you handled the event
#        """
#        print "OnDblClick, shift=%d" % shift
#        return True
#
#    def OnCursorPosChanged(self):
#        """
#        Cursor position changed.
#        @return: Nothing
#        """
#        print "OnCurposChanged"
#
#    def OnClose(self):
#        """
#        The view is closing. Use this event to cleanup.
#        @return: Nothing
#        """
#        print "OnClose"
#
#    def OnKeydown(self, vkey, shift):
#        """
#        User pressed a key
#        @param vkey: Virtual key code
#        @param shift: Shift flag
#        @return: Boolean. True if you handled the event
#        """
#        print "OnKeydown, vk=%d shift=%d" % (vkey, shift)
#        return False
#
#    def OnHint(self, lineno):
#        """
#        Hint requested for the given line number.
#        @param lineno: The line number (zero based)
#        @return:
#            - tuple(number of important lines, hint string)
#            - None: if no hint available
#        """
#        return (1, "OnHint, line=%d" % lineno)
#
#    def OnPopupMenu(self, menu_id):
#        """
#        A context (or popup) menu item was executed.
#        @param menu_id: ID previously registered with add_popup_menu()
#        @return: Boolean
#        """
#        print "OnPopupMenu, menu_id=" % menu_id
#        return True
#</pydoc>
#</pycode(py_kernwin_custview)>


def plgform_new(*args):
    r"""plgform_new() -> PyObject *"""
    return _ida_kernwin.plgform_new(*args)

def plgform_show(*args):
    r"""plgform_show(py_link, py_obj, caption, options=WOPN_TAB|WOPN_RESTORE) -> bool"""
    return _ida_kernwin.plgform_show(*args)

def plgform_close(*args):
    r"""plgform_close(py_link, options)"""
    return _ida_kernwin.plgform_close(*args)

def plgform_get_widget(*args):
    r"""plgform_get_widget(py_link) -> TWidget *"""
    return _ida_kernwin.plgform_get_widget(*args)

#<pycode(py_kernwin_plgform)>
import sys
class PluginForm(object):
    """
    PluginForm class.

    This form can be used to host additional controls. Please check the PyQt example.
    """

    WOPN_MDI      = 0x01 # no-op
    WOPN_TAB      = 0x02
    """attached by default to a tab"""
    WOPN_RESTORE  = 0x04
    """
    if the widget is the only widget in a floating area when
    it is closed, remember that area's geometry. The next
    time that widget is created as floating (i.e., no WOPN_TAB)
    its geometry will be restored (e.g., "Execute script"
    """
    WOPN_ONTOP    = 0x08 # no-op
    WOPN_MENU     = 0x10 # no-op
    WOPN_CENTERED = 0x20 # no-op
    WOPN_PERSIST  = 0x40
    """form will persist until explicitly closed with Close()"""


    WOPN_CREATE_ONLY = {}


    def __init__(self):
        """
        """
        self.__clink__ = _ida_kernwin.plgform_new()


    def Show(self, caption, options=0):
        """
        Creates the form if not was not created or brings to front if it was already created

        @param caption: The form caption
        @param options: One of PluginForm.WOPN_ constants
        """
        if options == self.WOPN_CREATE_ONLY:
            options = -1
        else:
            options |= PluginForm.WOPN_TAB|PluginForm.WOPN_RESTORE
        return _ida_kernwin.plgform_show(self.__clink__, self, caption, options)


    @staticmethod
    def _ensure_widget_deps(ctx):
        for key, modname in [("sip", "sip"), ("QtWidgets", "PyQt5.QtWidgets")]:
            if not hasattr(ctx, key):
                print("Note: importing '%s' module into %s" % (key, ctx))
                import importlib
                setattr(ctx, key, importlib.import_module(modname))


    @staticmethod
    def TWidgetToPyQtWidget(form, ctx = sys.modules['__main__']):
        """
        Convert a TWidget* to a QWidget to be used by PyQt

        @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
        """
        if type(form).__name__ == "SwigPyObject":
            ptr_l = long(form)
        else:
            ptr_l = form
        PluginForm._ensure_widget_deps(ctx)
        vptr = ctx.sip.voidptr(ptr_l)
        return ctx.sip.wrapinstance(vptr.__int__(), ctx.QtWidgets.QWidget)
    FormToPyQtWidget = TWidgetToPyQtWidget


    @staticmethod
    def QtWidgetToTWidget(w, ctx = sys.modules['__main__']):
        """
        Convert a QWidget to a TWidget* to be used by IDA

        @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
        """
        PluginForm._ensure_widget_deps(ctx)
        as_long = long(ctx.sip.unwrapinstance(w))
        return TWidget__from_ptrval__(as_long)


    @staticmethod
    def TWidgetToPySideWidget(tw, ctx = sys.modules['__main__']):
        """
        Use this method to convert a TWidget* to a QWidget to be used by PySide
        @param ctx: Context. Reference to a module that already imported QtWidgets module
        """
        if tw is None:
            return None
        if type(tw).__name__ == "SwigPyObject":
# Since 'tw' is a SwigPyObject, we first need to convert it to a PyCapsule.
# However, there's no easy way of doing it, so we'll use a rather brutal approach:
# converting the SwigPyObject to a 'long' (will go through 'SwigPyObject_long',
# that will return the pointer's value as a long), and then convert that value
# back to a pointer into a PyCapsule.
            ptr_l = ida_idaapi.long_type(tw)
# Warning: this is untested
            import ctypes
            ctypes.pythonapi.PyCapsule_New.restype = ctypes.py_object
            ctypes.pythonapi.PyCapsule_New.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p]
            tw = ctypes.pythonapi.PyCapsule_New(ptr_l, PluginForm.VALID_CAPSULE_NAME, 0)
        return ctx.QtGui.QWidget.FromCapsule(tw)
    FormToPySideWidget = TWidgetToPySideWidget

    def OnCreate(self, form):
        """
        This event is called when the plugin form is created.
        The programmer should populate the form when this event is triggered.

        @return: None
        """
        pass


    def OnClose(self, form):
        """
        Called when the plugin form is closed

        @return: None
        """
        pass


    def Close(self, options):
        """
        Closes the form.

        @param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)

        @return: None
        """
        return _ida_kernwin.plgform_close(self.__clink__, options)


    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.plgform_get_widget(self.__clink__)


    WCLS_SAVE           = 0x1
    """Save state in desktop config"""

    WCLS_NO_CONTEXT     = 0x2
    """Don't change the current context (useful for toolbars)"""

    WCLS_DONT_SAVE_SIZE = 0x4
    """Don't save size of the window"""

    WCLS_CLOSE_LATER    = 0x8
    """This flag should be used when Close() is called from an event handler"""
#</pycode(py_kernwin_plgform)>


if _BC695:
    AST_DISABLE_FOR_FORM=AST_DISABLE_FOR_WIDGET
    AST_ENABLE_FOR_FORM=AST_ENABLE_FOR_WIDGET
    CB_CLOSE_IDB=CB_INVISIBLE
    chtype_generic2=chtype_generic
    chtype_segreg=chtype_srcp
    close_tform=close_widget
    find_tform=find_widget
    get_current_tform=get_current_widget
    def get_highlighted_identifier():
        thing = get_highlight(get_current_viewer())
        if thing and thing[1]:
            return thing[0]
    get_tform_title=get_widget_title
    get_tform_type=get_widget_type
    is_chooser_tform=is_chooser_widget
    open_tform=display_widget
    pyscv_get_tcustom_control=pyscv_get_widget
    pyscv_get_tform=pyscv_get_widget
    __read_selection70 = read_selection
    def read_selection(*args):
        if len(args) == 0:
# bw-compat
            t0, t1, view = twinpos_t(), twinpos_t(), get_current_viewer()
            sel = __read_selection70(view, t0, t1)
            import ida_idaapi
            a0, a1 = ida_idaapi.BADADDR, ida_idaapi.BADADDR
            if sel:
                a0, a1 = t0.place(view).toea(), t1.place(view).toea()
            return sel, a0, a1
        else:
            return __read_selection70(*args)
    readsel2=read_selection
    switchto_tform=activate_widget
    umsg=msg
    import ida_ida
    def __wrap_uihooks_callback(name, do_call):
        return ida_ida.__wrap_hooks_callback(UI_Hooks, name, name.replace("widget", "tform"), do_call)
    __wrap_uihooks_callback("widget_visible", lambda cb, *args: cb(args[0], args[0]))
    __wrap_uihooks_callback("widget_invisible", lambda cb, *args: cb(args[0], args[0]))
    __wrap_uihooks_callback("populating_widget_popup", lambda cb, *args: cb(*args))
    __wrap_uihooks_callback("finish_populating_widget_popup", lambda cb, *args: cb(*args))
    __wrap_uihooks_callback("current_widget_changed", lambda cb, *args: cb(*args))
    AskUsingForm=_call_ask_form
    HIST_ADDR=0
    HIST_NUM=0
    KERNEL_VERSION_MAGIC1=0
    KERNEL_VERSION_MAGIC2=0
    OpenForm=_call_open_form
    _askaddr=_ida_kernwin._ask_addr
    _asklong=_ida_kernwin._ask_long
    _askseg=_ida_kernwin._ask_seg
    askaddr=ask_addr
    askbuttons_c=ask_buttons
    askfile_c=ask_file
    def askfile2_c(forsave, defdir, filters, fmt):
        if filters:
            fmt = "FILTER %s\n%s" % (filters, fmt)
        return ask_file(forsave, defdir, fmt)
    askident=ask_ident
    asklong=ask_long
    def askqstr(defval, fmt):
        return ask_str(defval, 0, fmt)
    askseg=ask_seg
    def askstr(hist, defval, fmt):
        return ask_str(defval, hist, fmt)
    asktext=ask_text
    askyn_c=ask_yn
    choose2_activate=choose_activate
    choose2_close=choose_close
    choose2_create=choose_create
    choose2_find=choose_find
    choose2_get_embedded=_choose_get_embedded_chobj_pointer
    choose2_get_embedded_selection=lambda *args: None
    choose2_refresh=choose_refresh
    clearBreak=clr_cancelled
    py_get_AskUsingForm=py_get_ask_form
    py_get_OpenForm=py_get_open_form
    setBreak=set_cancelled
    wasBreak=user_cancelled
    refresh_lists=refresh_choosers
#--------------------------------------------------------------------------
    class BC695_control_cmd:
        def __init__(self, cmd_id, caption, flags, menu_index, icon, emb, shortcut, is_chooser):
            self.cmd_id = cmd_id
            self.caption = caption
            self.flags = flags
            self.menu_index = menu_index
            self.icon = icon
            self.emb = emb
            self.shortcut = shortcut
            self.is_chooser = is_chooser
        @staticmethod
        def add_to_control(control, caption, flags, menu_index, icon, emb, shortcut, is_chooser):
            if getattr(control, "commands", None) is None:
                setattr(control, "commands", [])
            found = filter(lambda x: x.caption == caption, control.commands)
            if len(found) == 1:
                cmd_id = found[0].cmd_id
            else:
                cmd_id = len(control.commands)
                cmd = BC695_control_cmd(cmd_id, caption, flags, menu_index, icon, emb, shortcut, is_chooser)
                control.commands.append(cmd)
            return cmd_id
        @staticmethod
        def populate_popup(control, widget, popup):
            cmds = getattr(control, "commands", [])
            for cmd in cmds:
                if (cmd.flags & CHOOSER_POPUP_MENU) != 0:
                    desc = action_desc_t(None, cmd.caption, BC695_control_cmd_ah_t(control, cmd), cmd.shortcut, None, cmd.icon)
                    attach_dynamic_action_to_popup(widget, popup, desc)
    class BC695_control_cmd_ah_t(action_handler_t):
        def __init__(self, control, cmd):
            action_handler_t.__init__(self)
            self.control = control
            self.cmd = cmd
        def activate(self, ctx):
            if self.cmd.is_chooser:
                idx = ctx.chooser_selection[0]
                self.control.OnCommand(idx, self.cmd.cmd_id)
            else:
                self.control.OnCommand(self.cmd.cmd_id)
        def update(self, ctx):
            return AST_ENABLE_ALWAYS
    class Choose2(object):
        """v.6.95 compatible chooser wrapper class."""
        CH_MODAL        = 0x01
        CH_MULTI        = 0x04
        CH_MULTI_EDIT   = 0x08
        """
        The OnEditLine() callback will be called for all
        selected items using the START_SEL/END_SEL
        protocol.
        This bit implies #CH_MULTI.
        """
        CH_NOBTNS       = 0x10
        CH_ATTRS        = 0x20
        CH_NOIDB        = 0x40
        CH_BUILTIN_SHIFT = 19
        CH_BUILTIN_MASK = 0x1F << CH_BUILTIN_SHIFT
# column flags (are specified in the widths array)
        CHCOL_PLAIN  =  0x00000000
        CHCOL_PATH   =  0x00010000
        CHCOL_HEX    =  0x00020000
        CHCOL_DEC    =  0x00030000
        CHCOL_FORMAT =  0x00070000
# special values of the chooser index
        NO_SELECTION   = -1
        """there is no selected item"""
        START_SEL      = -2
        """before calling the first selected item"""
        END_SEL        = -3
        """after calling the last selected item"""
# the v.7.0 chooser object implementing the v.6.95 chooser
        class ChooseWrapper(Choose):
            def __init__(self, v695_chooser):
                self.link = v695_chooser
# check what non-base callbacks we have
                forbidden_cb = 0
                for cb in [("OnInsertLine", Choose.CHOOSE_HAVE_INS    ),
                           ("OnDeleteLine", Choose.CHOOSE_HAVE_DEL    ),
                           ("OnEditLine",   Choose.CHOOSE_HAVE_EDIT   ),
                           ("OnSelectLine", Choose.CHOOSE_HAVE_ENTER  ),
                           ("OnRefresh",    Choose.CHOOSE_HAVE_REFRESH),
                           ("OnSelectionChange", Choose.CHOOSE_HAVE_SELECT)]:
                    if not hasattr(self.link, cb[0]) or \
                       not callable(getattr(self.link, cb[0])):
                        forbidden_cb |= cb[1]
                Choose.__init__(
                        self, self.link.title, self.link.cols,
                        forbidden_cb = forbidden_cb)
# redirect base callbacks to the v.6.95 chooser
            def __getattr__(self, attr):
                if attr in ["OnGetSize",
                            "OnGetLine",
                            "OnGetIcon",
                            "OnGetLineAttr",
                            "OnClose"]:
                    return getattr(self.link, attr)
                return getattr(self.link, attr)
            def Show(self, modal = False):
# set `flags` and `deflt`
                self.flags = self.link.flags
                if self.link.deflt == -1:
                    self.deflt = 0
                else:
                    self.deflt = self.link.deflt - 1
                    self.flags |= Choose.CH_FORCE_DEFAULT
                if (self.flags & Choose.CH_MULTI) != 0:
                    self.deflt = [self.deflt]
# copy simple attributes from v.6.95
                for attr in ["title", "cols", "popup_names", "icon",
                             "x1", "y1", "x2", "y2",
                             "embedded", "width", "height"]:
                    if hasattr(self.link, attr):
                        setattr(self, attr, getattr(self.link, attr))
                    else:
                        delattr(self, attr)
                return Choose.Show(self, modal)
            def OnInsertLine(self, n):
# assert: hasattr(self.link, "OnInsertLine")
                self.link.OnInsertLine()
# we preserve the selection
                return (Choose.ALL_CHANGED, n)
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    return (Choose.ALL_CHANGED, n)
                else:
                    return [Choose.ALL_CHANGED] + n
            def OnDeleteLine(self, n):
# assert: hasattr(self.link, "OnDeleteLine")
                res = None
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    res = self.link.OnDeleteLine(n)
                else:
# assert: n is iterable and n
# call the callback multiple times
                  self.link.OnDeleteLine(Choose2.START_SEL)
                  res = None
                  for idx in n:
                      new_idx = self.link.OnDeleteLine(idx)
                      if res == None:
                          res = new_idx
                  self.link.OnDeleteLine(Choose2.END_SEL)
                return [Choose.ALL_CHANGED] + self.adjust_last_item(res)
            def OnEditLine(self, n):
# assert: hasattr(self.link, "OnEditLine")
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    self.link.OnEditLine(n)
                    return (Choose.ALL_CHANGED, n) # preserve the selection
# assert: n is iterable and n
                if (self.link.flags & Choose2.CH_MULTI_EDIT) == 0:
                    self.link.OnEditLine(n[0])
                    return [Choose.ALL_CHANGED] + n # preserve the selection
# call the callback multiple times
                self.link.OnEditLine(Choose2.START_SEL)
                for idx in n:
                    self.link.OnEditLine(idx)
                self.link.OnEditLine(Choose2.END_SEL)
                return [Choose.ALL_CHANGED] + n # preserve the selection
            def OnSelectLine(self, n):
# assert: hasattr(self.link, "OnSelectLine")
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    self.link.OnSelectLine(n)
                    return (Choose.ALL_CHANGED, n)
# assert: n is iterable and n
                self.link.OnSelectLine(n[0])
                return [Choose.ALL_CHANGED] + n # preserve the selection
            def OnRefresh(self, n):
# assert: hasattr(self.link, "OnRefresh")
                if (self.link.flags & Choose2.CH_MULTI) != 0:
# ignore all but the first item
                  n = n[0] if n else Choose.NO_SELECTION
                res = self.link.OnRefresh(n)
                return (Choose.ALL_CHANGED, res)
            def OnSelectionChange(self, n):
# assert: hasattr(self.link, "OnSelectionChange")
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                  n = [n] if n != Choose.NO_SELECTION else []
                self.link.OnSelectionChange(n)
            def OnPopup(self, widget, popup_handle):
                BC695_control_cmd.populate_popup(
                    self.link,
                    widget,
                    popup_handle)
        def __init__(self, title, cols, flags=0, popup_names=None,
                     icon=-1, x1=-1, y1=-1, x2=-1, y2=-1, deflt=-1,
                     embedded=False, width=None, height=None):
            """
            Constructs a chooser window.
            @param title: The chooser title
            @param cols: a list of colums; each list item is a list of two items
                example: [ ["Address", 10 | Choose2.CHCOL_HEX],
                           ["Name", 30 | Choose2.CHCOL_PLAIN] ]
            @param flags: One of CH_XXXX constants
            @param deflt: Default starting item (1-based).
                0 means that no item is selected,
                -1 means that the first item selected for a new window and
                that the selection is not updated for an existing window
            @param popup_names: list of new captions to replace this list
                ["Insert", "Delete", "Edit", "Refresh"]
            @param icon: Icon index (the icon should exist in ida resources or
                an index to a custom loaded icon)
            @param x1, y1, x2, y2: The default location (for txt-version)
            @param embedded: Create as embedded chooser
            @param width: Embedded chooser width
            @param height: Embedded chooser height
            """
# remember attributes
            self.title = title
            self.flags = flags
            self.cols = cols
            self.deflt = deflt
            self.popup_names = popup_names
            self.icon = icon
            self.x1 = x1
            self.y1 = y1
            self.x2 = x2
            self.y2 = y2
            self.embedded = embedded
            self.width = width
            self.height = height
# construct the v.7.0 chooser object
            self.chobj = Choose2.ChooseWrapper(self)
# redirect methods to the v.7.0 chooser
        def __getattr__(self, attr):
            if attr not in ["GetEmbSelection",
                            "Activate",
                            "Refresh",
                            "Close",
                            "GetWidget"]:
                raise AttributeError(attr)
            return getattr(self.chobj, attr)
        def Embedded(self):
            """
            Creates an embedded chooser (as opposed to Show())
            @return: Returns 1 on success
            """
            return 1 if self.chobj.Embedded() == 0 else 0
        def Show(self, modal=False):
            """
            Activates or creates a chooser window
            @param modal: Display as modal dialog
            @return: For modal choosers it will return the selected item index (0-based)
                     or -1 in the case of error,
                     For non-modal choosers it will return 0
                     or -1 if the chooser was already open and is active now
            """
            ret = self.chobj.Show(modal)
            return -1 if ret < 0 else ret
        def AddCommand(self,
                       caption,
                       flags = _ida_kernwin.CHOOSER_POPUP_MENU,
                       menu_index = -1,
                       icon = -1,
                       emb=None,
                       shortcut=None):
# Use the 'emb' as a sentinel. It will be passed the correct value
# from the EmbeddedChooserControl
            if self.embedded and ((emb is None) or (emb != 2002)):
                raise RuntimeError("Please add a command through "
                                   "EmbeddedChooserControl.AddCommand()")
            return BC695_control_cmd.add_to_control(
                       self, caption, flags, menu_index, icon, emb, None,
                       is_chooser=True)
# callbacks
# def OnGetSize(self):
# def OnGetLine(self, n):
# def OnGetIcon(self, n):
# def OnGetLineAttr(self, n):
# def OnInsertLine(self):
# def OnDeleteLine(self, n):
# def OnEditLine(self, n):
# def OnSelectLine(self, n):
# def OnRefresh(self, n):
# def OnSelectionChange(self, sel_list):
# def OnClose(self):
# def OnCommand(self, n, cmd_id):



if _BC695:
    PluginForm.FORM_MDI = PluginForm.WOPN_MDI
    PluginForm.FORM_TAB = PluginForm.WOPN_TAB
    PluginForm.FORM_RESTORE = PluginForm.WOPN_RESTORE
    PluginForm.FORM_ONTOP = PluginForm.WOPN_ONTOP
    PluginForm.FORM_MENU = PluginForm.WOPN_MENU
    PluginForm.FORM_CENTERED = PluginForm.WOPN_CENTERED
    PluginForm.FORM_PERSIST = PluginForm.WOPN_PERSIST
    PluginForm.FORM_SAVE = PluginForm.WCLS_SAVE
    PluginForm.FORM_NO_CONTEXT = PluginForm.WCLS_NO_CONTEXT
    PluginForm.FORM_DONT_SAVE_SIZE = PluginForm.WCLS_DONT_SAVE_SIZE
    PluginForm.FORM_CLOSE_LATER = PluginForm.WCLS_CLOSE_LATER




