# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""IDA Plugin SDK API wrapper: expr"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_expr
else:
    import _ida_expr

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func


def compile_idc_file(*args):
    r"""compile_idc_file(nonnul_line) -> bool"""
    return _ida_expr.compile_idc_file(*args)

def compile_idc_text(*args):
    r"""compile_idc_text(nonnul_line) -> bool"""
    return _ida_expr.compile_idc_text(*args)

def py_get_call_idc_func(*args):
    r"""py_get_call_idc_func() -> size_t"""
    return _ida_expr.py_get_call_idc_func(*args)

def pyw_register_idc_func(*args):
    r"""pyw_register_idc_func(name, args, py_fp) -> size_t"""
    return _ida_expr.pyw_register_idc_func(*args)

def pyw_unregister_idc_func(*args):
    r"""pyw_unregister_idc_func(ctxptr) -> bool"""
    return _ida_expr.pyw_unregister_idc_func(*args)

def pyw_convert_defvals(*args):
    r"""pyw_convert_defvals(out, py_seq) -> bool"""
    return _ida_expr.pyw_convert_defvals(*args)

def py_add_idc_func(*args):
    r"""py_add_idc_func(name, fp_ptr, args, defvals, flags) -> bool"""
    return _ida_expr.py_add_idc_func(*args)

def eval_expr(*args):
    r"""eval_expr(rv, where, line) -> bool"""
    return _ida_expr.eval_expr(*args)

def eval_idc_expr(*args):
    r"""eval_idc_expr(rv, where, line) -> bool"""
    return _ida_expr.eval_idc_expr(*args)
IDC_LANG_EXT = _ida_expr.IDC_LANG_EXT


def idcv_long(*args):
    r"""idcv_long(v) -> error_t"""
    return _ida_expr.idcv_long(*args)

def idcv_int64(*args):
    r"""idcv_int64(v) -> error_t"""
    return _ida_expr.idcv_int64(*args)

def idcv_num(*args):
    r"""idcv_num(v) -> error_t"""
    return _ida_expr.idcv_num(*args)

def idcv_string(*args):
    r"""idcv_string(v) -> error_t"""
    return _ida_expr.idcv_string(*args)

def idcv_float(*args):
    r"""idcv_float(v) -> error_t"""
    return _ida_expr.idcv_float(*args)

def idcv_object(*args):
    r"""idcv_object(v, icls=None) -> error_t"""
    return _ida_expr.idcv_object(*args)

def move_idcv(*args):
    r"""move_idcv(dst, src) -> error_t"""
    return _ida_expr.move_idcv(*args)

def copy_idcv(*args):
    r"""copy_idcv(dst, src) -> error_t"""
    return _ida_expr.copy_idcv(*args)

def deep_copy_idcv(*args):
    r"""deep_copy_idcv(dst, src) -> error_t"""
    return _ida_expr.deep_copy_idcv(*args)

def free_idcv(*args):
    r"""free_idcv(v)"""
    return _ida_expr.free_idcv(*args)

def swap_idcvs(*args):
    r"""swap_idcvs(v1, v2)"""
    return _ida_expr.swap_idcvs(*args)

def get_idcv_class_name(*args):
    r"""get_idcv_class_name(obj) -> error_t"""
    return _ida_expr.get_idcv_class_name(*args)

def get_idcv_attr(*args):
    r"""get_idcv_attr(res, obj, attr, may_use_getattr=False) -> error_t"""
    return _ida_expr.get_idcv_attr(*args)

def set_idcv_attr(*args):
    r"""set_idcv_attr(obj, attr, value, may_use_setattr=False) -> error_t"""
    return _ida_expr.set_idcv_attr(*args)

def del_idcv_attr(*args):
    r"""del_idcv_attr(obj, attr) -> error_t"""
    return _ida_expr.del_idcv_attr(*args)

def first_idcv_attr(*args):
    r"""first_idcv_attr(obj) -> char const *"""
    return _ida_expr.first_idcv_attr(*args)

def last_idcv_attr(*args):
    r"""last_idcv_attr(obj) -> char const *"""
    return _ida_expr.last_idcv_attr(*args)

def next_idcv_attr(*args):
    r"""next_idcv_attr(obj, attr) -> char const *"""
    return _ida_expr.next_idcv_attr(*args)

def prev_idcv_attr(*args):
    r"""prev_idcv_attr(obj, attr) -> char const *"""
    return _ida_expr.prev_idcv_attr(*args)

def print_idcv(*args):
    r"""print_idcv(v, name=None, indent=0) -> bool"""
    return _ida_expr.print_idcv(*args)

def get_idcv_slice(*args):
    r"""get_idcv_slice(res, v, i1, i2, flags=0) -> error_t"""
    return _ida_expr.get_idcv_slice(*args)
VARSLICE_SINGLE = _ida_expr.VARSLICE_SINGLE


def set_idcv_slice(*args):
    r"""set_idcv_slice(v, i1, i2, _in, flags=0) -> error_t"""
    return _ida_expr.set_idcv_slice(*args)

def add_idc_class(*args):
    r"""add_idc_class(name, super=None) -> idc_class_t *"""
    return _ida_expr.add_idc_class(*args)

def find_idc_class(*args):
    r"""find_idc_class(name) -> idc_class_t *"""
    return _ida_expr.find_idc_class(*args)

def deref_idcv(*args):
    r"""deref_idcv(v, vref_flags) -> idc_value_t"""
    return _ida_expr.deref_idcv(*args)
VREF_LOOP = _ida_expr.VREF_LOOP

VREF_ONCE = _ida_expr.VREF_ONCE

VREF_COPY = _ida_expr.VREF_COPY


def create_idcv_ref(*args):
    r"""create_idcv_ref(ref, v) -> bool"""
    return _ida_expr.create_idcv_ref(*args)

def add_idc_gvar(*args):
    r"""add_idc_gvar(name) -> idc_value_t"""
    return _ida_expr.add_idc_gvar(*args)

def find_idc_gvar(*args):
    r"""find_idc_gvar(name) -> idc_value_t"""
    return _ida_expr.find_idc_gvar(*args)
class idc_value_t(object):
    r"""Proxy of C++ idc_value_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    vtype = property(_ida_expr.idc_value_t_vtype_get, _ida_expr.idc_value_t_vtype_set, doc=r"""vtype""")
    num = property(_ida_expr.idc_value_t_num_get, _ida_expr.idc_value_t_num_set, doc=r"""num""")
    e = property(_ida_expr.idc_value_t_e_get, _ida_expr.idc_value_t_e_set, doc=r"""e""")
    obj = property(_ida_expr.idc_value_t_obj_get, _ida_expr.idc_value_t_obj_set, doc=r"""obj""")
    funcidx = property(_ida_expr.idc_value_t_funcidx_get, _ida_expr.idc_value_t_funcidx_set, doc=r"""funcidx""")
    pvoid = property(_ida_expr.idc_value_t_pvoid_get, _ida_expr.idc_value_t_pvoid_set, doc=r"""pvoid""")
    i64 = property(_ida_expr.idc_value_t_i64_get, _ida_expr.idc_value_t_i64_set, doc=r"""i64""")
    reserve = property(_ida_expr.idc_value_t_reserve_get, _ida_expr.idc_value_t_reserve_set, doc=r"""reserve""")

    def __init__(self, *args):
        r"""
        __init__(self, n=0) -> idc_value_t
        __init__(self, r) -> idc_value_t
        __init__(self, _str) -> idc_value_t
        __init__(self, _str) -> idc_value_t
        """
        _ida_expr.idc_value_t_swiginit(self, _ida_expr.new_idc_value_t(*args))
    __swig_destroy__ = _ida_expr.delete_idc_value_t

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_expr.idc_value_t_clear(self, *args)

    def qstr(self, *args):
        r"""
        qstr(self) -> qstring
        qstr(self) -> qstring const &
        """
        return _ida_expr.idc_value_t_qstr(self, *args)

    def c_str(self, *args):
        r"""c_str(self) -> char const *"""
        return _ida_expr.idc_value_t_c_str(self, *args)

    def u_str(self, *args):
        r"""u_str(self) -> uchar const *"""
        return _ida_expr.idc_value_t_u_str(self, *args)

    def swap(self, *args):
        r"""swap(self, v)"""
        return _ida_expr.idc_value_t_swap(self, *args)

    def is_zero(self, *args):
        r"""is_zero(self) -> bool"""
        return _ida_expr.idc_value_t_is_zero(self, *args)

    def is_integral(self, *args):
        r"""is_integral(self) -> bool"""
        return _ida_expr.idc_value_t_is_integral(self, *args)

    def is_convertible(self, *args):
        r"""is_convertible(self) -> bool"""
        return _ida_expr.idc_value_t_is_convertible(self, *args)

    def _create_empty_string(self, *args):
        r"""_create_empty_string(self)"""
        return _ida_expr.idc_value_t__create_empty_string(self, *args)

    def create_empty_string(self, *args):
        r"""create_empty_string(self)"""
        return _ida_expr.idc_value_t_create_empty_string(self, *args)

    def set_string(self, *args):
        r"""
        set_string(self, _str, len)
        set_string(self, _str)
        set_string(self, _str)
        """
        return _ida_expr.idc_value_t_set_string(self, *args)

    def set_long(self, *args):
        r"""set_long(self, v)"""
        return _ida_expr.idc_value_t_set_long(self, *args)

    def set_pvoid(self, *args):
        r"""set_pvoid(self, p)"""
        return _ida_expr.idc_value_t_set_pvoid(self, *args)

    def set_int64(self, *args):
        r"""set_int64(self, v)"""
        return _ida_expr.idc_value_t_set_int64(self, *args)

    def set_float(self, *args):
        r"""set_float(self, f)"""
        return _ida_expr.idc_value_t_set_float(self, *args)

    str = property(lambda self: self.c_str(), lambda self, v: self.set_string(v))


# Register idc_value_t in _ida_expr:
_ida_expr.idc_value_t_swigregister(idc_value_t)
VT_LONG = _ida_expr.VT_LONG

VT_FLOAT = _ida_expr.VT_FLOAT

VT_WILD = _ida_expr.VT_WILD

VT_OBJ = _ida_expr.VT_OBJ

VT_FUNC = _ida_expr.VT_FUNC

VT_STR = _ida_expr.VT_STR

VT_PVOID = _ida_expr.VT_PVOID

VT_INT64 = _ida_expr.VT_INT64

VT_REF = _ida_expr.VT_REF


class idc_global_t(object):
    r"""Proxy of C++ idc_global_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ida_expr.idc_global_t_name_get, _ida_expr.idc_global_t_name_set, doc=r"""name""")
    value = property(_ida_expr.idc_global_t_value_get, _ida_expr.idc_global_t_value_set, doc=r"""value""")

    def __init__(self, *args):
        r"""
        __init__(self) -> idc_global_t
        __init__(self, n) -> idc_global_t
        """
        _ida_expr.idc_global_t_swiginit(self, _ida_expr.new_idc_global_t(*args))
    __swig_destroy__ = _ida_expr.delete_idc_global_t

# Register idc_global_t in _ida_expr:
_ida_expr.idc_global_t_swigregister(idc_global_t)

eExecThrow = _ida_expr.eExecThrow


def find_idc_func(*args):
    r"""find_idc_func(prefix, n=0) -> bool"""
    return _ida_expr.find_idc_func(*args)
HF_DEFAULT = _ida_expr.HF_DEFAULT

HF_KEYWORD1 = _ida_expr.HF_KEYWORD1

HF_KEYWORD2 = _ida_expr.HF_KEYWORD2

HF_KEYWORD3 = _ida_expr.HF_KEYWORD3

HF_STRING = _ida_expr.HF_STRING

HF_COMMENT = _ida_expr.HF_COMMENT

HF_PREPROC = _ida_expr.HF_PREPROC

HF_NUMBER = _ida_expr.HF_NUMBER

HF_MAX = _ida_expr.HF_MAX

class highlighter_cbs_t(object):
    r"""Proxy of C++ highlighter_cbs_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ida_expr.delete_highlighter_cbs_t

    def set_style(self, *args):
        r"""set_style(self, arg0, arg1, arg2)"""
        return _ida_expr.highlighter_cbs_t_set_style(self, *args)

    def prev_block_state(self, *args):
        r"""prev_block_state(self) -> int32"""
        return _ida_expr.highlighter_cbs_t_prev_block_state(self, *args)

    def cur_block_state(self, *args):
        r"""cur_block_state(self) -> int32"""
        return _ida_expr.highlighter_cbs_t_cur_block_state(self, *args)

    def set_block_state(self, *args):
        r"""set_block_state(self, arg0)"""
        return _ida_expr.highlighter_cbs_t_set_block_state(self, *args)

    def __init__(self, *args):
        r"""__init__(self) -> highlighter_cbs_t"""
        if self.__class__ == highlighter_cbs_t:
            _self = None
        else:
            _self = self
        _ida_expr.highlighter_cbs_t_swiginit(self, _ida_expr.new_highlighter_cbs_t(_self, *args))
    def __disown__(self):
        self.this.disown()
        _ida_expr.disown_highlighter_cbs_t(self)
        return weakref.proxy(self)

# Register highlighter_cbs_t in _ida_expr:
_ida_expr.highlighter_cbs_t_swigregister(highlighter_cbs_t)


def set_header_path(*args):
    r"""set_header_path(path, add) -> bool"""
    return _ida_expr.set_header_path(*args)

def get_idc_filename(*args):
    r"""get_idc_filename(file) -> char *"""
    return _ida_expr.get_idc_filename(*args)

def exec_system_script(*args):
    r"""exec_system_script(file, complain_if_no_file=True) -> bool"""
    return _ida_expr.exec_system_script(*args)
CPL_DEL_MACROS = _ida_expr.CPL_DEL_MACROS

CPL_USE_LABELS = _ida_expr.CPL_USE_LABELS

CPL_ONLY_SAFE = _ida_expr.CPL_ONLY_SAFE


def compile_idc_snippet(*args):
    r"""compile_idc_snippet(func, text, resolver=None, only_safe_funcs=False) -> bool"""
    return _ida_expr.compile_idc_snippet(*args)

def exec_idc_script(*args):
    r"""exec_idc_script(result, path, func, args, argsnum) -> bool"""
    return _ida_expr.exec_idc_script(*args)
class idc_values_t(object):
    r"""Proxy of C++ qvector< idc_value_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> idc_values_t
        __init__(self, x) -> idc_values_t
        """
        _ida_expr.idc_values_t_swiginit(self, _ida_expr.new_idc_values_t(*args))
    __swig_destroy__ = _ida_expr.delete_idc_values_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> idc_value_t
        """
        return _ida_expr.idc_values_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""pop_back(self)"""
        return _ida_expr.idc_values_t_pop_back(self, *args)

    def size(self, *args):
        r"""size(self) -> size_t"""
        return _ida_expr.idc_values_t_size(self, *args)

    def empty(self, *args):
        r"""empty(self) -> bool"""
        return _ida_expr.idc_values_t_empty(self, *args)

    def at(self, *args):
        r"""at(self, _idx) -> idc_value_t"""
        return _ida_expr.idc_values_t_at(self, *args)

    def qclear(self, *args):
        r"""qclear(self)"""
        return _ida_expr.idc_values_t_qclear(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_expr.idc_values_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_expr.idc_values_t_resize(self, *args)

    def grow(self, *args):
        r"""grow(self, x=idc_value_t())"""
        return _ida_expr.idc_values_t_grow(self, *args)

    def capacity(self, *args):
        r"""capacity(self) -> size_t"""
        return _ida_expr.idc_values_t_capacity(self, *args)

    def reserve(self, *args):
        r"""reserve(self, cnt)"""
        return _ida_expr.idc_values_t_reserve(self, *args)

    def truncate(self, *args):
        r"""truncate(self)"""
        return _ida_expr.idc_values_t_truncate(self, *args)

    def swap(self, *args):
        r"""swap(self, r)"""
        return _ida_expr.idc_values_t_swap(self, *args)

    def extract(self, *args):
        r"""extract(self) -> idc_value_t"""
        return _ida_expr.idc_values_t_extract(self, *args)

    def inject(self, *args):
        r"""inject(self, s, len)"""
        return _ida_expr.idc_values_t_inject(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> idc_value_t
        begin(self) -> idc_value_t
        """
        return _ida_expr.idc_values_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> idc_value_t
        end(self) -> idc_value_t
        """
        return _ida_expr.idc_values_t_end(self, *args)

    def insert(self, *args):
        r"""insert(self, it, x) -> idc_value_t"""
        return _ida_expr.idc_values_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> idc_value_t
        erase(self, first, last) -> idc_value_t
        """
        return _ida_expr.idc_values_t_erase(self, *args)

    def __len__(self, *args):
        r"""__len__(self) -> size_t"""
        return _ida_expr.idc_values_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""__getitem__(self, i) -> idc_value_t"""
        return _ida_expr.idc_values_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""__setitem__(self, i, v)"""
        return _ida_expr.idc_values_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register idc_values_t in _ida_expr:
_ida_expr.idc_values_t_swigregister(idc_values_t)


#<pycode(py_expr)>
try:
    import types
    import ctypes
# Callback for IDC func callback (On Windows, we use stdcall)
# typedef error_t idaapi idc_func_t(idc_value_t *argv,idc_value_t *r);
    try:
        _IDCFUNC_CB_T = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p)
    except:
        _IDCFUNC_CB_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p)

# A trampoline function that is called from idcfunc_t that will
# call the Python callback with the argv and r properly serialized to python
    call_idc_func__ = ctypes.CFUNCTYPE(ctypes.c_long, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p)(_ida_expr.py_get_call_idc_func())
except:
    def call_idc_func__(*args):
        warning("IDC extensions need ctypes library in order to work")
        return 0
    _IDCFUNC_CB_T = None

# --------------------------------------------------------------------------
EXTFUN_BASE  = 0x0001
"""requires open database"""
EXTFUN_NORET = 0x0002
"""does not return. the interpreter may clean up its state before calling it."""
EXTFUN_SAFE  = 0x0004
"""thread safe function. may be called"""

# --------------------------------------------------------------------------
class _IdcFunction(object):
    """
    Internal class that calls pyw_call_idc_func() with a context
    """
    def __init__(self, ctxptr):
        self.ctxptr = ctxptr
# Take a reference to the ctypes callback
# (note: this will create a circular reference)
        self.cb = _IDCFUNC_CB_T(self)

    fp_ptr = property(lambda self: ctypes.cast(self.cb, ctypes.c_void_p).value)

    def __call__(self, args, res):
        return call_idc_func__(self.ctxptr, args, res)


# --------------------------------------------------------------------------
# Dictionary to remember IDC function names along with the context pointer
# retrieved by using the internal pyw_register_idc_func()
__IDC_FUNC_CTXS = {}

def del_idc_func(name):
    """
    Unregisters the specified IDC function

    @param name: IDC function name to unregister

    @return: Boolean
    """
    global __IDC_FUNC_CTXS

# Get the context
    f = __IDC_FUNC_CTXS.get(name, None)

    if f is None:
        return False # Not registered

# Break circular reference
    del f.cb

# Delete the name from the dictionary
    del __IDC_FUNC_CTXS[name]

# Delete the context and unregister the function
    return _ida_expr.pyw_unregister_idc_func(f.ctxptr)

# --------------------------------------------------------------------------
def add_idc_func(name, fp, args, defvals=None, flags=0):
    """
    Extends the IDC language by exposing a new IDC function that is backed up by a Python function

    @param name: IDC function name to expose
    @param fp: Python callable that will receive the arguments and return a tuple.
    @param args: Arguments. A tuple of idaapi.VT_XXX constants
    @param flags: IDC function flags. A combination of EXTFUN_XXX constants

    @return: Boolean
    """
    global __IDC_FUNC_CTXS

# Get the context
    f = __IDC_FUNC_CTXS.get(name, None)

# Registering a function that is already registered?
    if f is not None:
# Unregister it first
        del_idc_func(name)

# Convert the tupple argument info to a string
    args = "".join([chr(x) for x in args])

# make sure we don't have an obvious discrepancy between
# the number of args, and the provided default values
    if len(defvals) > len(args):
        return False

    vdefvals = idc_values_t()
    if not _ida_expr.pyw_convert_defvals(vdefvals, defvals):
        return False

# Create a context
    ctxptr = _ida_expr.pyw_register_idc_func(name, args, fp)
    if ctxptr == 0:
        return False

# Bind the context with the IdcFunc object
    f = _IdcFunction(ctxptr)

# Remember the Python context
    __IDC_FUNC_CTXS[name] = f

# Register IDC function with a callback
    return _ida_expr.py_add_idc_func(
                name,
                f.fp_ptr,
                args,
                vdefvals,
                flags)

#</pycode(py_expr)>


if _BC695:
    Compile=compile_idc_file
    CompileEx=compile_idc_file
    CompileLine=compile_idc_text
    VT_STR2=VT_STR
    VarCopy=copy_idcv
    VarDelAttr=del_idcv_attr
    VarDeref=deref_idcv
    VarFirstAttr=first_idcv_attr
    def VarGetAttr(obj, attr, res, may_use_getattr=False):
        return get_idcv_attr(res, obj, attr, may_use_getattr)
    VarGetClassName=get_idcv_class_name
    VarGetSlice=get_idcv_slice
    VarInt64=idcv_int64
    VarLastAttr=last_idcv_attr
    VarMove=move_idcv
    VarNextAttr=next_idcv_attr
    VarObject=idcv_object
    VarPrevAttr=prev_idcv_attr
    VarPrint=print_idcv
    VarRef=create_idcv_ref
    VarSetAttr=set_idcv_attr
    VarSetSlice=set_idcv_slice
    VarString2=idcv_string
    VarSwap=swap_idcvs
    def calc_idc_expr(where, expr, res):
        return eval_idc_expr(res, where, expr)
    def calcexpr(where, expr, res):
        return eval_expr(res, where, expr)
    def dosysfile(complain_if_no_file, fname):
        return exec_system_script(fname, complain_if_no_file)
    def execute(line):
        return eval_idc_snippet(None, line)
    py_set_idc_func_ex=py_add_idc_func
    def set_idc_func_ex(name, fp=None, args=(), flags=0):
        return add_idc_func(name, fp, args, (), flags)




