# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""IDA Plugin SDK API wrapper: xref"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_xref
else:
    import _ida_xref

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func


def create_switch_xrefs(*args):
    r"""create_switch_xrefs(ea, si) -> bool"""
    return _ida_xref.create_switch_xrefs(*args)
class cases_and_targets_t(object):
    r"""Proxy of C++ cases_and_targets_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cases = property(_ida_xref.cases_and_targets_t_cases_get, _ida_xref.cases_and_targets_t_cases_set, doc=r"""cases""")
    targets = property(_ida_xref.cases_and_targets_t_targets_get, _ida_xref.cases_and_targets_t_targets_set, doc=r"""targets""")

    def __init__(self, *args):
        r"""__init__(self) -> cases_and_targets_t"""
        _ida_xref.cases_and_targets_t_swiginit(self, _ida_xref.new_cases_and_targets_t(*args))
    __swig_destroy__ = _ida_xref.delete_cases_and_targets_t

# Register cases_and_targets_t in _ida_xref:
_ida_xref.cases_and_targets_t_swigregister(cases_and_targets_t)


def calc_switch_cases(*args):
    r"""calc_switch_cases(ea, si) -> cases_and_targets_t"""
    return _ida_xref.calc_switch_cases(*args)

def create_switch_table(*args):
    r"""create_switch_table(ea, si) -> bool"""
    return _ida_xref.create_switch_table(*args)
fl_U = _ida_xref.fl_U

fl_CF = _ida_xref.fl_CF

fl_CN = _ida_xref.fl_CN

fl_JF = _ida_xref.fl_JF

fl_JN = _ida_xref.fl_JN

fl_USobsolete = _ida_xref.fl_USobsolete

fl_F = _ida_xref.fl_F

dr_U = _ida_xref.dr_U

dr_O = _ida_xref.dr_O

dr_W = _ida_xref.dr_W

dr_R = _ida_xref.dr_R

dr_T = _ida_xref.dr_T

dr_I = _ida_xref.dr_I

XREF_USER = _ida_xref.XREF_USER

XREF_TAIL = _ida_xref.XREF_TAIL

XREF_BASE = _ida_xref.XREF_BASE

XREF_MASK = _ida_xref.XREF_MASK

XREF_PASTEND = _ida_xref.XREF_PASTEND


def xrefchar(*args):
    r"""xrefchar(xrtype) -> char"""
    return _ida_xref.xrefchar(*args)

def add_cref(*args):
    r"""add_cref(frm, to, type) -> bool"""
    return _ida_xref.add_cref(*args)

def del_cref(*args):
    r"""del_cref(frm, to, expand) -> int"""
    return _ida_xref.del_cref(*args)

def add_dref(*args):
    r"""add_dref(frm, to, type) -> bool"""
    return _ida_xref.add_dref(*args)

def del_dref(*args):
    r"""del_dref(frm, to)"""
    return _ida_xref.del_dref(*args)
class xrefblk_t(object):
    r"""Proxy of C++ xrefblk_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    frm = property(_ida_xref.xrefblk_t_frm_get, _ida_xref.xrefblk_t_frm_set, doc=r"""frm""")
    to = property(_ida_xref.xrefblk_t_to_get, _ida_xref.xrefblk_t_to_set, doc=r"""to""")
    iscode = property(_ida_xref.xrefblk_t_iscode_get, _ida_xref.xrefblk_t_iscode_set, doc=r"""iscode""")
    type = property(_ida_xref.xrefblk_t_type_get, _ida_xref.xrefblk_t_type_set, doc=r"""type""")
    user = property(_ida_xref.xrefblk_t_user_get, _ida_xref.xrefblk_t_user_set, doc=r"""user""")

    def first_from(self, *args):
        r"""first_from(self, _from, flags) -> bool"""
        return _ida_xref.xrefblk_t_first_from(self, *args)

    def first_to(self, *args):
        r"""first_to(self, _to, flags) -> bool"""
        return _ida_xref.xrefblk_t_first_to(self, *args)

    def next_from(self, *args):
        r"""
        next_from(self) -> bool
        next_from(self, _from, _to, flags) -> bool
        """
        return _ida_xref.xrefblk_t_next_from(self, *args)

    def next_to(self, *args):
        r"""
        next_to(self) -> bool
        next_to(self, _from, _to, flags) -> bool
        """
        return _ida_xref.xrefblk_t_next_to(self, *args)

    def __init__(self, *args):
        r"""__init__(self) -> xrefblk_t"""
        _ida_xref.xrefblk_t_swiginit(self, _ida_xref.new_xrefblk_t(*args))
    __swig_destroy__ = _ida_xref.delete_xrefblk_t

# Register xrefblk_t in _ida_xref:
_ida_xref.xrefblk_t_swigregister(xrefblk_t)
XREF_ALL = _ida_xref.XREF_ALL

XREF_FAR = _ida_xref.XREF_FAR

XREF_DATA = _ida_xref.XREF_DATA



def get_first_dref_from(*args):
    r"""get_first_dref_from(frm) -> ea_t"""
    return _ida_xref.get_first_dref_from(*args)

def get_next_dref_from(*args):
    r"""get_next_dref_from(frm, current) -> ea_t"""
    return _ida_xref.get_next_dref_from(*args)

def get_first_dref_to(*args):
    r"""get_first_dref_to(to) -> ea_t"""
    return _ida_xref.get_first_dref_to(*args)

def get_next_dref_to(*args):
    r"""get_next_dref_to(to, current) -> ea_t"""
    return _ida_xref.get_next_dref_to(*args)

def get_first_cref_from(*args):
    r"""get_first_cref_from(frm) -> ea_t"""
    return _ida_xref.get_first_cref_from(*args)

def get_next_cref_from(*args):
    r"""get_next_cref_from(frm, current) -> ea_t"""
    return _ida_xref.get_next_cref_from(*args)

def get_first_cref_to(*args):
    r"""get_first_cref_to(to) -> ea_t"""
    return _ida_xref.get_first_cref_to(*args)

def get_next_cref_to(*args):
    r"""get_next_cref_to(to, current) -> ea_t"""
    return _ida_xref.get_next_cref_to(*args)

def get_first_fcref_from(*args):
    r"""get_first_fcref_from(frm) -> ea_t"""
    return _ida_xref.get_first_fcref_from(*args)

def get_next_fcref_from(*args):
    r"""get_next_fcref_from(frm, current) -> ea_t"""
    return _ida_xref.get_next_fcref_from(*args)

def get_first_fcref_to(*args):
    r"""get_first_fcref_to(to) -> ea_t"""
    return _ida_xref.get_first_fcref_to(*args)

def get_next_fcref_to(*args):
    r"""get_next_fcref_to(to, current) -> ea_t"""
    return _ida_xref.get_next_fcref_to(*args)

def has_external_refs(*args):
    r"""has_external_refs(pfn, ea) -> bool"""
    return _ida_xref.has_external_refs(*args)

def delete_switch_table(*args):
    r"""delete_switch_table(jump_ea, si)"""
    return _ida_xref.delete_switch_table(*args)
class casevec_t(object):
    r"""Proxy of C++ qvector< qvector< sval_t > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> casevec_t
        __init__(self, x) -> casevec_t
        """
        _ida_xref.casevec_t_swiginit(self, _ida_xref.new_casevec_t(*args))
    __swig_destroy__ = _ida_xref.delete_casevec_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> qvector< int > &
        """
        return _ida_xref.casevec_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""pop_back(self)"""
        return _ida_xref.casevec_t_pop_back(self, *args)

    def size(self, *args):
        r"""size(self) -> size_t"""
        return _ida_xref.casevec_t_size(self, *args)

    def empty(self, *args):
        r"""empty(self) -> bool"""
        return _ida_xref.casevec_t_empty(self, *args)

    def at(self, *args):
        r"""at(self, _idx) -> qvector< int > const &"""
        return _ida_xref.casevec_t_at(self, *args)

    def qclear(self, *args):
        r"""qclear(self)"""
        return _ida_xref.casevec_t_qclear(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_xref.casevec_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_xref.casevec_t_resize(self, *args)

    def grow(self, *args):
        r"""grow(self, x=qvector< int >())"""
        return _ida_xref.casevec_t_grow(self, *args)

    def capacity(self, *args):
        r"""capacity(self) -> size_t"""
        return _ida_xref.casevec_t_capacity(self, *args)

    def reserve(self, *args):
        r"""reserve(self, cnt)"""
        return _ida_xref.casevec_t_reserve(self, *args)

    def truncate(self, *args):
        r"""truncate(self)"""
        return _ida_xref.casevec_t_truncate(self, *args)

    def swap(self, *args):
        r"""swap(self, r)"""
        return _ida_xref.casevec_t_swap(self, *args)

    def extract(self, *args):
        r"""extract(self) -> qvector< int > *"""
        return _ida_xref.casevec_t_extract(self, *args)

    def inject(self, *args):
        r"""inject(self, s, len)"""
        return _ida_xref.casevec_t_inject(self, *args)

    def __eq__(self, *args):
        r"""__eq__(self, r) -> bool"""
        return _ida_xref.casevec_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""__ne__(self, r) -> bool"""
        return _ida_xref.casevec_t___ne__(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> qvector< qvector< int > >::iterator
        begin(self) -> qvector< qvector< int > >::const_iterator
        """
        return _ida_xref.casevec_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> qvector< qvector< int > >::iterator
        end(self) -> qvector< qvector< int > >::const_iterator
        """
        return _ida_xref.casevec_t_end(self, *args)

    def insert(self, *args):
        r"""insert(self, it, x) -> qvector< qvector< int > >::iterator"""
        return _ida_xref.casevec_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> qvector< qvector< int > >::iterator
        erase(self, first, last) -> qvector< qvector< int > >::iterator
        """
        return _ida_xref.casevec_t_erase(self, *args)

    def find(self, *args):
        r"""
        find(self, x) -> qvector< qvector< int > >::iterator
        find(self, x) -> qvector< qvector< int > >::const_iterator
        """
        return _ida_xref.casevec_t_find(self, *args)

    def has(self, *args):
        r"""has(self, x) -> bool"""
        return _ida_xref.casevec_t_has(self, *args)

    def add_unique(self, *args):
        r"""add_unique(self, x) -> bool"""
        return _ida_xref.casevec_t_add_unique(self, *args)

    def _del(self, *args):
        r"""_del(self, x) -> bool"""
        return _ida_xref.casevec_t__del(self, *args)

    def __len__(self, *args):
        r"""__len__(self) -> size_t"""
        return _ida_xref.casevec_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""__getitem__(self, i) -> qvector< int > const &"""
        return _ida_xref.casevec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""__setitem__(self, i, v)"""
        return _ida_xref.casevec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register casevec_t in _ida_xref:
_ida_xref.casevec_t_swigregister(casevec_t)


#<pycode(py_xref)>

import ida_idaapi
ida_idaapi._listify_types(
        casevec_t)

#</pycode(py_xref)>



