# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""IDA Plugin SDK API wrapper: loader"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_loader
else:
    import _ida_loader

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

class qvector_snapshotvec_t(object):
    r"""Proxy of C++ qvector< snapshot_t * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> qvector_snapshotvec_t
        __init__(self, x) -> qvector_snapshotvec_t
        """
        _ida_loader.qvector_snapshotvec_t_swiginit(self, _ida_loader.new_qvector_snapshotvec_t(*args))
    __swig_destroy__ = _ida_loader.delete_qvector_snapshotvec_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> snapshot_t *&
        """
        return _ida_loader.qvector_snapshotvec_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""pop_back(self)"""
        return _ida_loader.qvector_snapshotvec_t_pop_back(self, *args)

    def size(self, *args):
        r"""size(self) -> size_t"""
        return _ida_loader.qvector_snapshotvec_t_size(self, *args)

    def empty(self, *args):
        r"""empty(self) -> bool"""
        return _ida_loader.qvector_snapshotvec_t_empty(self, *args)

    def qclear(self, *args):
        r"""qclear(self)"""
        return _ida_loader.qvector_snapshotvec_t_qclear(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_loader.qvector_snapshotvec_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_loader.qvector_snapshotvec_t_resize(self, *args)

    def capacity(self, *args):
        r"""capacity(self) -> size_t"""
        return _ida_loader.qvector_snapshotvec_t_capacity(self, *args)

    def reserve(self, *args):
        r"""reserve(self, cnt)"""
        return _ida_loader.qvector_snapshotvec_t_reserve(self, *args)

    def truncate(self, *args):
        r"""truncate(self)"""
        return _ida_loader.qvector_snapshotvec_t_truncate(self, *args)

    def swap(self, *args):
        r"""swap(self, r)"""
        return _ida_loader.qvector_snapshotvec_t_swap(self, *args)

    def extract(self, *args):
        r"""extract(self) -> snapshot_t **"""
        return _ida_loader.qvector_snapshotvec_t_extract(self, *args)

    def inject(self, *args):
        r"""inject(self, s, len)"""
        return _ida_loader.qvector_snapshotvec_t_inject(self, *args)

    def __eq__(self, *args):
        r"""__eq__(self, r) -> bool"""
        return _ida_loader.qvector_snapshotvec_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""__ne__(self, r) -> bool"""
        return _ida_loader.qvector_snapshotvec_t___ne__(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> qvector< snapshot_t * >::iterator
        begin(self) -> qvector< snapshot_t * >::const_iterator
        """
        return _ida_loader.qvector_snapshotvec_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> qvector< snapshot_t * >::iterator
        end(self) -> qvector< snapshot_t * >::const_iterator
        """
        return _ida_loader.qvector_snapshotvec_t_end(self, *args)

    def insert(self, *args):
        r"""insert(self, it, x) -> qvector< snapshot_t * >::iterator"""
        return _ida_loader.qvector_snapshotvec_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> qvector< snapshot_t * >::iterator
        erase(self, first, last) -> qvector< snapshot_t * >::iterator
        """
        return _ida_loader.qvector_snapshotvec_t_erase(self, *args)

    def find(self, *args):
        r"""
        find(self, x) -> qvector< snapshot_t * >::iterator
        find(self, x) -> qvector< snapshot_t * >::const_iterator
        """
        return _ida_loader.qvector_snapshotvec_t_find(self, *args)

    def has(self, *args):
        r"""has(self, x) -> bool"""
        return _ida_loader.qvector_snapshotvec_t_has(self, *args)

    def add_unique(self, *args):
        r"""add_unique(self, x) -> bool"""
        return _ida_loader.qvector_snapshotvec_t_add_unique(self, *args)

    def _del(self, *args):
        r"""_del(self, x) -> bool"""
        return _ida_loader.qvector_snapshotvec_t__del(self, *args)

    def __len__(self, *args):
        r"""__len__(self) -> size_t"""
        return _ida_loader.qvector_snapshotvec_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""__getitem__(self, i) -> snapshot_t"""
        return _ida_loader.qvector_snapshotvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""__setitem__(self, i, v)"""
        return _ida_loader.qvector_snapshotvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register qvector_snapshotvec_t in _ida_loader:
_ida_loader.qvector_snapshotvec_t_swigregister(qvector_snapshotvec_t)

class loader_t(object):
    r"""Proxy of C++ loader_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    version = property(_ida_loader.loader_t_version_get, _ida_loader.loader_t_version_set, doc=r"""version""")
    flags = property(_ida_loader.loader_t_flags_get, _ida_loader.loader_t_flags_set, doc=r"""flags""")

    def __init__(self, *args):
        r"""__init__(self) -> loader_t"""
        _ida_loader.loader_t_swiginit(self, _ida_loader.new_loader_t(*args))
    __swig_destroy__ = _ida_loader.delete_loader_t

# Register loader_t in _ida_loader:
_ida_loader.loader_t_swigregister(loader_t)
LDRF_RELOAD = _ida_loader.LDRF_RELOAD

LDRF_REQ_PROC = _ida_loader.LDRF_REQ_PROC

ACCEPT_ARCHIVE = _ida_loader.ACCEPT_ARCHIVE

ACCEPT_CONTINUE = _ida_loader.ACCEPT_CONTINUE

ACCEPT_FIRST = _ida_loader.ACCEPT_FIRST

NEF_SEGS = _ida_loader.NEF_SEGS

NEF_RSCS = _ida_loader.NEF_RSCS

NEF_NAME = _ida_loader.NEF_NAME

NEF_MAN = _ida_loader.NEF_MAN

NEF_FILL = _ida_loader.NEF_FILL

NEF_IMPS = _ida_loader.NEF_IMPS

NEF_FIRST = _ida_loader.NEF_FIRST

NEF_CODE = _ida_loader.NEF_CODE

NEF_RELOAD = _ida_loader.NEF_RELOAD

NEF_FLAT = _ida_loader.NEF_FLAT

NEF_MINI = _ida_loader.NEF_MINI

NEF_LOPT = _ida_loader.NEF_LOPT

NEF_LALL = _ida_loader.NEF_LALL


DLLEXT = _ida_loader.DLLEXT

LOADER_DLL = _ida_loader.LOADER_DLL


def load_binary_file(*args):
    r"""load_binary_file(filename, li, _neflags, fileoff, basepara, binoff, nbytes) -> bool"""
    return _ida_loader.load_binary_file(*args)

def process_archive(*args):
    r"""process_archive(temp_file, li, module_name, neflags, defmember, loader) -> int"""
    return _ida_loader.process_archive(*args)
OFILE_MAP = _ida_loader.OFILE_MAP

OFILE_EXE = _ida_loader.OFILE_EXE

OFILE_IDC = _ida_loader.OFILE_IDC

OFILE_LST = _ida_loader.OFILE_LST

OFILE_ASM = _ida_loader.OFILE_ASM

OFILE_DIF = _ida_loader.OFILE_DIF


def gen_file(*args):
    r"""gen_file(otype, fp, ea1, ea2, flags) -> int"""
    return _ida_loader.gen_file(*args)
GENFLG_MAPSEG = _ida_loader.GENFLG_MAPSEG

GENFLG_MAPNAME = _ida_loader.GENFLG_MAPNAME

GENFLG_MAPDMNG = _ida_loader.GENFLG_MAPDMNG

GENFLG_MAPLOC = _ida_loader.GENFLG_MAPLOC

GENFLG_IDCTYPE = _ida_loader.GENFLG_IDCTYPE

GENFLG_ASMTYPE = _ida_loader.GENFLG_ASMTYPE

GENFLG_GENHTML = _ida_loader.GENFLG_GENHTML

GENFLG_ASMINC = _ida_loader.GENFLG_ASMINC


def file2base(*args):
    r"""file2base(li, pos, ea1, ea2, patchable) -> int"""
    return _ida_loader.file2base(*args)
FILEREG_PATCHABLE = _ida_loader.FILEREG_PATCHABLE

FILEREG_NOTPATCHABLE = _ida_loader.FILEREG_NOTPATCHABLE


def base2file(*args):
    r"""base2file(fp, pos, ea1, ea2) -> int"""
    return _ida_loader.base2file(*args)

def extract_module_from_archive(*args):
    r"""extract_module_from_archive(filename, bufsize, temp_file_ptr, is_remote) -> bool"""
    return _ida_loader.extract_module_from_archive(*args)

def get_basic_file_type(*args):
    r"""get_basic_file_type(li) -> filetype_t"""
    return _ida_loader.get_basic_file_type(*args)

def get_file_type_name(*args):
    r"""get_file_type_name() -> size_t"""
    return _ida_loader.get_file_type_name(*args)

def load_ids_module(*args):
    r"""load_ids_module(fname) -> int"""
    return _ida_loader.load_ids_module(*args)

def get_plugin_options(*args):
    r"""get_plugin_options(plugin) -> char const *"""
    return _ida_loader.get_plugin_options(*args)
PLUGIN_DLL = _ida_loader.PLUGIN_DLL

MODULE_ENTRY_LOADER = _ida_loader.MODULE_ENTRY_LOADER

MODULE_ENTRY_PLUGIN = _ida_loader.MODULE_ENTRY_PLUGIN

MODULE_ENTRY_IDP = _ida_loader.MODULE_ENTRY_IDP

class idp_name_t(object):
    r"""Proxy of C++ idp_name_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lname = property(_ida_loader.idp_name_t_lname_get, _ida_loader.idp_name_t_lname_set, doc=r"""lname""")
    sname = property(_ida_loader.idp_name_t_sname_get, _ida_loader.idp_name_t_sname_set, doc=r"""sname""")
    hidden = property(_ida_loader.idp_name_t_hidden_get, _ida_loader.idp_name_t_hidden_set, doc=r"""hidden""")

    def __init__(self, *args):
        r"""__init__(self) -> idp_name_t"""
        _ida_loader.idp_name_t_swiginit(self, _ida_loader.new_idp_name_t(*args))
    __swig_destroy__ = _ida_loader.delete_idp_name_t

# Register idp_name_t in _ida_loader:
_ida_loader.idp_name_t_swigregister(idp_name_t)

class idp_desc_t(object):
    r"""Proxy of C++ idp_desc_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_ida_loader.idp_desc_t_path_get, _ida_loader.idp_desc_t_path_set, doc=r"""path""")
    mtime = property(_ida_loader.idp_desc_t_mtime_get, _ida_loader.idp_desc_t_mtime_set, doc=r"""mtime""")
    family = property(_ida_loader.idp_desc_t_family_get, _ida_loader.idp_desc_t_family_set, doc=r"""family""")
    names = property(_ida_loader.idp_desc_t_names_get, _ida_loader.idp_desc_t_names_set, doc=r"""names""")
    is_script = property(_ida_loader.idp_desc_t_is_script_get, _ida_loader.idp_desc_t_is_script_set, doc=r"""is_script""")
    checked = property(_ida_loader.idp_desc_t_checked_get, _ida_loader.idp_desc_t_checked_set, doc=r"""checked""")

    def __init__(self, *args):
        r"""__init__(self) -> idp_desc_t"""
        _ida_loader.idp_desc_t_swiginit(self, _ida_loader.new_idp_desc_t(*args))
    __swig_destroy__ = _ida_loader.delete_idp_desc_t

# Register idp_desc_t in _ida_loader:
_ida_loader.idp_desc_t_swigregister(idp_desc_t)

IDP_DLL = _ida_loader.IDP_DLL

class plugin_info_t(object):
    r"""Proxy of C++ plugin_info_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    next = property(_ida_loader.plugin_info_t_next_get, _ida_loader.plugin_info_t_next_set, doc=r"""next""")
    path = property(_ida_loader.plugin_info_t_path_get, _ida_loader.plugin_info_t_path_set, doc=r"""path""")
    org_name = property(_ida_loader.plugin_info_t_org_name_get, _ida_loader.plugin_info_t_org_name_set, doc=r"""org_name""")
    name = property(_ida_loader.plugin_info_t_name_get, _ida_loader.plugin_info_t_name_set, doc=r"""name""")
    org_hotkey = property(_ida_loader.plugin_info_t_org_hotkey_get, _ida_loader.plugin_info_t_org_hotkey_set, doc=r"""org_hotkey""")
    hotkey = property(_ida_loader.plugin_info_t_hotkey_get, _ida_loader.plugin_info_t_hotkey_set, doc=r"""hotkey""")
    arg = property(_ida_loader.plugin_info_t_arg_get, _ida_loader.plugin_info_t_arg_set, doc=r"""arg""")
    entry = property(_ida_loader.plugin_info_t_entry_get, _ida_loader.plugin_info_t_entry_set, doc=r"""entry""")
    dllmem = property(_ida_loader.plugin_info_t_dllmem_get, _ida_loader.plugin_info_t_dllmem_set, doc=r"""dllmem""")
    flags = property(_ida_loader.plugin_info_t_flags_get, _ida_loader.plugin_info_t_flags_set, doc=r"""flags""")
    comment = property(_ida_loader.plugin_info_t_comment_get, _ida_loader.plugin_info_t_comment_set, doc=r"""comment""")

    def __init__(self, *args):
        r"""__init__(self) -> plugin_info_t"""
        _ida_loader.plugin_info_t_swiginit(self, _ida_loader.new_plugin_info_t(*args))
    __swig_destroy__ = _ida_loader.delete_plugin_info_t

# Register plugin_info_t in _ida_loader:
_ida_loader.plugin_info_t_swigregister(plugin_info_t)


def find_plugin(*args):
    r"""find_plugin(name, load_if_needed=False) -> plugin_t *"""
    return _ida_loader.find_plugin(*args)

def get_fileregion_offset(*args):
    r"""get_fileregion_offset(ea) -> qoff64_t"""
    return _ida_loader.get_fileregion_offset(*args)

def get_fileregion_ea(*args):
    r"""get_fileregion_ea(offset) -> ea_t"""
    return _ida_loader.get_fileregion_ea(*args)

def gen_exe_file(*args):
    r"""gen_exe_file(fp) -> int"""
    return _ida_loader.gen_exe_file(*args)

def reload_file(*args):
    r"""reload_file(file, is_remote) -> int"""
    return _ida_loader.reload_file(*args)
MAX_DATABASE_DESCRIPTION = _ida_loader.MAX_DATABASE_DESCRIPTION

class snapshot_t(object):
    r"""Proxy of C++ snapshot_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    id = property(_ida_loader.snapshot_t_id_get, _ida_loader.snapshot_t_id_set, doc=r"""id""")
    flags = property(_ida_loader.snapshot_t_flags_get, _ida_loader.snapshot_t_flags_set, doc=r"""flags""")
    desc = property(_ida_loader.snapshot_t_desc_get, _ida_loader.snapshot_t_desc_set, doc=r"""desc""")
    filename = property(_ida_loader.snapshot_t_filename_get, _ida_loader.snapshot_t_filename_set, doc=r"""filename""")
    children = property(_ida_loader.snapshot_t_children_get, _ida_loader.snapshot_t_children_set, doc=r"""children""")

    def __eq__(self, *args):
        r"""__eq__(self, r) -> bool"""
        return _ida_loader.snapshot_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""__ne__(self, r) -> bool"""
        return _ida_loader.snapshot_t___ne__(self, *args)

    def __lt__(self, *args):
        r"""__lt__(self, r) -> bool"""
        return _ida_loader.snapshot_t___lt__(self, *args)

    def __gt__(self, *args):
        r"""__gt__(self, r) -> bool"""
        return _ida_loader.snapshot_t___gt__(self, *args)

    def __le__(self, *args):
        r"""__le__(self, r) -> bool"""
        return _ida_loader.snapshot_t___le__(self, *args)

    def __ge__(self, *args):
        r"""__ge__(self, r) -> bool"""
        return _ida_loader.snapshot_t___ge__(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_loader.snapshot_t_clear(self, *args)

    def __init__(self, *args):
        r"""__init__(self) -> snapshot_t"""
        _ida_loader.snapshot_t_swiginit(self, _ida_loader.new_snapshot_t(*args))
    __swig_destroy__ = _ida_loader.delete_snapshot_t

# Register snapshot_t in _ida_loader:
_ida_loader.snapshot_t_swigregister(snapshot_t)
SSF_AUTOMATIC = _ida_loader.SSF_AUTOMATIC



def build_snapshot_tree(*args):
    r"""build_snapshot_tree(root) -> bool"""
    return _ida_loader.build_snapshot_tree(*args)
SSUF_DESC = _ida_loader.SSUF_DESC

SSUF_PATH = _ida_loader.SSUF_PATH

SSUF_FLAGS = _ida_loader.SSUF_FLAGS


def flush_buffers(*args):
    r"""flush_buffers() -> int"""
    return _ida_loader.flush_buffers(*args)

def is_trusted_idb(*args):
    r"""is_trusted_idb() -> bool"""
    return _ida_loader.is_trusted_idb(*args)

def save_database(*args):
    r"""save_database(outfile, flags, root=None, attr=None) -> bool"""
    return _ida_loader.save_database(*args)
DBFL_KILL = _ida_loader.DBFL_KILL

DBFL_COMP = _ida_loader.DBFL_COMP

DBFL_BAK = _ida_loader.DBFL_BAK

DBFL_TEMP = _ida_loader.DBFL_TEMP


def is_database_flag(*args):
    r"""is_database_flag(dbfl) -> bool"""
    return _ida_loader.is_database_flag(*args)

def set_database_flag(*args):
    r"""set_database_flag(dbfl, cnd=True)"""
    return _ida_loader.set_database_flag(*args)

def clr_database_flag(*args):
    r"""clr_database_flag(dbfl)"""
    return _ida_loader.clr_database_flag(*args)
PATH_TYPE_CMD = _ida_loader.PATH_TYPE_CMD

PATH_TYPE_IDB = _ida_loader.PATH_TYPE_IDB

PATH_TYPE_ID0 = _ida_loader.PATH_TYPE_ID0


def get_path(*args):
    r"""get_path(pt) -> char const *"""
    return _ida_loader.get_path(*args)

def set_path(*args):
    r"""set_path(pt, path)"""
    return _ida_loader.set_path(*args)

def get_elf_debug_file_directory(*args):
    r"""get_elf_debug_file_directory() -> char const *"""
    return _ida_loader.get_elf_debug_file_directory(*args)

def mem2base(*args):
    r"""mem2base(py_mem, ea, fpos=-1) -> int"""
    return _ida_loader.mem2base(*args)

def load_plugin(*args):
    r"""load_plugin(name) -> PyObject *"""
    return _ida_loader.load_plugin(*args)

def run_plugin(*args):
    r"""run_plugin(plg, arg) -> bool"""
    return _ida_loader.run_plugin(*args)

def load_and_run_plugin(*args):
    r"""load_and_run_plugin(name, arg) -> bool"""
    return _ida_loader.load_and_run_plugin(*args)

if _BC695:
    NEF_TIGHT=0
    @bc695redef
    def save_database(outfile, flags=0):
        if isinstance(flags, bool):
            flags = DBFL_KILL if flags else 0
        return _ida_loader.save_database(outfile, flags)
    save_database_ex=save_database
    MAX_FILE_FORMAT_NAME=64




