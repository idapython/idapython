# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""IDA Plugin SDK API wrapper: idd"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_idd
else:
    import _ida_idd

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_range
class excvec_t(object):
    r"""Proxy of C++ qvector< exception_info_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> excvec_t
        __init__(self, x) -> excvec_t
        """
        _ida_idd.excvec_t_swiginit(self, _ida_idd.new_excvec_t(*args))
    __swig_destroy__ = _ida_idd.delete_excvec_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""pop_back(self)"""
        return _ida_idd.excvec_t_pop_back(self, *args)

    def size(self, *args):
        r"""size(self) -> size_t"""
        return _ida_idd.excvec_t_size(self, *args)

    def empty(self, *args):
        r"""empty(self) -> bool"""
        return _ida_idd.excvec_t_empty(self, *args)

    def at(self, *args):
        r"""at(self, _idx) -> exception_info_t"""
        return _ida_idd.excvec_t_at(self, *args)

    def qclear(self, *args):
        r"""qclear(self)"""
        return _ida_idd.excvec_t_qclear(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_idd.excvec_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.excvec_t_resize(self, *args)

    def grow(self, *args):
        r"""grow(self, x=exception_info_t())"""
        return _ida_idd.excvec_t_grow(self, *args)

    def capacity(self, *args):
        r"""capacity(self) -> size_t"""
        return _ida_idd.excvec_t_capacity(self, *args)

    def reserve(self, *args):
        r"""reserve(self, cnt)"""
        return _ida_idd.excvec_t_reserve(self, *args)

    def truncate(self, *args):
        r"""truncate(self)"""
        return _ida_idd.excvec_t_truncate(self, *args)

    def swap(self, *args):
        r"""swap(self, r)"""
        return _ida_idd.excvec_t_swap(self, *args)

    def extract(self, *args):
        r"""extract(self) -> exception_info_t"""
        return _ida_idd.excvec_t_extract(self, *args)

    def inject(self, *args):
        r"""inject(self, s, len)"""
        return _ida_idd.excvec_t_inject(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> exception_info_t
        begin(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> exception_info_t
        end(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_end(self, *args)

    def insert(self, *args):
        r"""insert(self, it, x) -> exception_info_t"""
        return _ida_idd.excvec_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> exception_info_t
        erase(self, first, last) -> exception_info_t
        """
        return _ida_idd.excvec_t_erase(self, *args)

    def __len__(self, *args):
        r"""__len__(self) -> size_t"""
        return _ida_idd.excvec_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""__getitem__(self, i) -> exception_info_t"""
        return _ida_idd.excvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""__setitem__(self, i, v)"""
        return _ida_idd.excvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register excvec_t in _ida_idd:
_ida_idd.excvec_t_swigregister(excvec_t)

class procinfo_vec_t(object):
    r"""Proxy of C++ qvector< process_info_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> procinfo_vec_t
        __init__(self, x) -> procinfo_vec_t
        """
        _ida_idd.procinfo_vec_t_swiginit(self, _ida_idd.new_procinfo_vec_t(*args))
    __swig_destroy__ = _ida_idd.delete_procinfo_vec_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""pop_back(self)"""
        return _ida_idd.procinfo_vec_t_pop_back(self, *args)

    def size(self, *args):
        r"""size(self) -> size_t"""
        return _ida_idd.procinfo_vec_t_size(self, *args)

    def empty(self, *args):
        r"""empty(self) -> bool"""
        return _ida_idd.procinfo_vec_t_empty(self, *args)

    def at(self, *args):
        r"""at(self, _idx) -> process_info_t"""
        return _ida_idd.procinfo_vec_t_at(self, *args)

    def qclear(self, *args):
        r"""qclear(self)"""
        return _ida_idd.procinfo_vec_t_qclear(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_idd.procinfo_vec_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.procinfo_vec_t_resize(self, *args)

    def grow(self, *args):
        r"""grow(self, x=process_info_t())"""
        return _ida_idd.procinfo_vec_t_grow(self, *args)

    def capacity(self, *args):
        r"""capacity(self) -> size_t"""
        return _ida_idd.procinfo_vec_t_capacity(self, *args)

    def reserve(self, *args):
        r"""reserve(self, cnt)"""
        return _ida_idd.procinfo_vec_t_reserve(self, *args)

    def truncate(self, *args):
        r"""truncate(self)"""
        return _ida_idd.procinfo_vec_t_truncate(self, *args)

    def swap(self, *args):
        r"""swap(self, r)"""
        return _ida_idd.procinfo_vec_t_swap(self, *args)

    def extract(self, *args):
        r"""extract(self) -> process_info_t"""
        return _ida_idd.procinfo_vec_t_extract(self, *args)

    def inject(self, *args):
        r"""inject(self, s, len)"""
        return _ida_idd.procinfo_vec_t_inject(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> process_info_t
        begin(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> process_info_t
        end(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_end(self, *args)

    def insert(self, *args):
        r"""insert(self, it, x) -> process_info_t"""
        return _ida_idd.procinfo_vec_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> process_info_t
        erase(self, first, last) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_erase(self, *args)

    def __len__(self, *args):
        r"""__len__(self) -> size_t"""
        return _ida_idd.procinfo_vec_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""__getitem__(self, i) -> process_info_t"""
        return _ida_idd.procinfo_vec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""__setitem__(self, i, v)"""
        return _ida_idd.procinfo_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register procinfo_vec_t in _ida_idd:
_ida_idd.procinfo_vec_t_swigregister(procinfo_vec_t)

class call_stack_t(object):
    r"""Proxy of C++ qvector< call_stack_info_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> call_stack_t
        __init__(self, x) -> call_stack_t
        """
        _ida_idd.call_stack_t_swiginit(self, _ida_idd.new_call_stack_t(*args))
    __swig_destroy__ = _ida_idd.delete_call_stack_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""pop_back(self)"""
        return _ida_idd.call_stack_t_pop_back(self, *args)

    def size(self, *args):
        r"""size(self) -> size_t"""
        return _ida_idd.call_stack_t_size(self, *args)

    def empty(self, *args):
        r"""empty(self) -> bool"""
        return _ida_idd.call_stack_t_empty(self, *args)

    def at(self, *args):
        r"""at(self, _idx) -> call_stack_info_t"""
        return _ida_idd.call_stack_t_at(self, *args)

    def qclear(self, *args):
        r"""qclear(self)"""
        return _ida_idd.call_stack_t_qclear(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_idd.call_stack_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.call_stack_t_resize(self, *args)

    def grow(self, *args):
        r"""grow(self, x=call_stack_info_t())"""
        return _ida_idd.call_stack_t_grow(self, *args)

    def capacity(self, *args):
        r"""capacity(self) -> size_t"""
        return _ida_idd.call_stack_t_capacity(self, *args)

    def reserve(self, *args):
        r"""reserve(self, cnt)"""
        return _ida_idd.call_stack_t_reserve(self, *args)

    def truncate(self, *args):
        r"""truncate(self)"""
        return _ida_idd.call_stack_t_truncate(self, *args)

    def swap(self, *args):
        r"""swap(self, r)"""
        return _ida_idd.call_stack_t_swap(self, *args)

    def extract(self, *args):
        r"""extract(self) -> call_stack_info_t"""
        return _ida_idd.call_stack_t_extract(self, *args)

    def inject(self, *args):
        r"""inject(self, s, len)"""
        return _ida_idd.call_stack_t_inject(self, *args)

    def __eq__(self, *args):
        r"""__eq__(self, r) -> bool"""
        return _ida_idd.call_stack_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""__ne__(self, r) -> bool"""
        return _ida_idd.call_stack_t___ne__(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> call_stack_info_t
        begin(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> call_stack_info_t
        end(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_end(self, *args)

    def insert(self, *args):
        r"""insert(self, it, x) -> call_stack_info_t"""
        return _ida_idd.call_stack_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> call_stack_info_t
        erase(self, first, last) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_erase(self, *args)

    def find(self, *args):
        r"""
        find(self, x) -> call_stack_info_t
        find(self, x) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_find(self, *args)

    def has(self, *args):
        r"""has(self, x) -> bool"""
        return _ida_idd.call_stack_t_has(self, *args)

    def add_unique(self, *args):
        r"""add_unique(self, x) -> bool"""
        return _ida_idd.call_stack_t_add_unique(self, *args)

    def _del(self, *args):
        r"""_del(self, x) -> bool"""
        return _ida_idd.call_stack_t__del(self, *args)

    def __len__(self, *args):
        r"""__len__(self) -> size_t"""
        return _ida_idd.call_stack_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""__getitem__(self, i) -> call_stack_info_t"""
        return _ida_idd.call_stack_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""__setitem__(self, i, v)"""
        return _ida_idd.call_stack_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register call_stack_t in _ida_idd:
_ida_idd.call_stack_t_swigregister(call_stack_t)

class meminfo_vec_t(object):
    r"""Proxy of C++ qvector< memory_info_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> meminfo_vec_t
        __init__(self, x) -> meminfo_vec_t
        """
        _ida_idd.meminfo_vec_t_swiginit(self, _ida_idd.new_meminfo_vec_t(*args))
    __swig_destroy__ = _ida_idd.delete_meminfo_vec_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""pop_back(self)"""
        return _ida_idd.meminfo_vec_t_pop_back(self, *args)

    def size(self, *args):
        r"""size(self) -> size_t"""
        return _ida_idd.meminfo_vec_t_size(self, *args)

    def empty(self, *args):
        r"""empty(self) -> bool"""
        return _ida_idd.meminfo_vec_t_empty(self, *args)

    def at(self, *args):
        r"""at(self, _idx) -> memory_info_t"""
        return _ida_idd.meminfo_vec_t_at(self, *args)

    def qclear(self, *args):
        r"""qclear(self)"""
        return _ida_idd.meminfo_vec_t_qclear(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_idd.meminfo_vec_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.meminfo_vec_t_resize(self, *args)

    def grow(self, *args):
        r"""grow(self, x=memory_info_t())"""
        return _ida_idd.meminfo_vec_t_grow(self, *args)

    def capacity(self, *args):
        r"""capacity(self) -> size_t"""
        return _ida_idd.meminfo_vec_t_capacity(self, *args)

    def reserve(self, *args):
        r"""reserve(self, cnt)"""
        return _ida_idd.meminfo_vec_t_reserve(self, *args)

    def truncate(self, *args):
        r"""truncate(self)"""
        return _ida_idd.meminfo_vec_t_truncate(self, *args)

    def swap(self, *args):
        r"""swap(self, r)"""
        return _ida_idd.meminfo_vec_t_swap(self, *args)

    def extract(self, *args):
        r"""extract(self) -> memory_info_t"""
        return _ida_idd.meminfo_vec_t_extract(self, *args)

    def inject(self, *args):
        r"""inject(self, s, len)"""
        return _ida_idd.meminfo_vec_t_inject(self, *args)

    def __eq__(self, *args):
        r"""__eq__(self, r) -> bool"""
        return _ida_idd.meminfo_vec_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""__ne__(self, r) -> bool"""
        return _ida_idd.meminfo_vec_t___ne__(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> memory_info_t
        begin(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> memory_info_t
        end(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_end(self, *args)

    def insert(self, *args):
        r"""insert(self, it, x) -> memory_info_t"""
        return _ida_idd.meminfo_vec_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> memory_info_t
        erase(self, first, last) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_erase(self, *args)

    def find(self, *args):
        r"""
        find(self, x) -> memory_info_t
        find(self, x) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_find(self, *args)

    def has(self, *args):
        r"""has(self, x) -> bool"""
        return _ida_idd.meminfo_vec_t_has(self, *args)

    def add_unique(self, *args):
        r"""add_unique(self, x) -> bool"""
        return _ida_idd.meminfo_vec_t_add_unique(self, *args)

    def _del(self, *args):
        r"""_del(self, x) -> bool"""
        return _ida_idd.meminfo_vec_t__del(self, *args)

    def __len__(self, *args):
        r"""__len__(self) -> size_t"""
        return _ida_idd.meminfo_vec_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""__getitem__(self, i) -> memory_info_t"""
        return _ida_idd.meminfo_vec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""__setitem__(self, i, v)"""
        return _ida_idd.meminfo_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register meminfo_vec_t in _ida_idd:
_ida_idd.meminfo_vec_t_swigregister(meminfo_vec_t)

IDD_INTERFACE_VERSION = _ida_idd.IDD_INTERFACE_VERSION

NO_THREAD = _ida_idd.NO_THREAD

class process_info_t(object):
    r"""Proxy of C++ process_info_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pid = property(_ida_idd.process_info_t_pid_get, _ida_idd.process_info_t_pid_set, doc=r"""pid""")
    name = property(_ida_idd.process_info_t_name_get, _ida_idd.process_info_t_name_set, doc=r"""name""")

    def __init__(self, *args):
        r"""__init__(self) -> process_info_t"""
        _ida_idd.process_info_t_swiginit(self, _ida_idd.new_process_info_t(*args))
    __swig_destroy__ = _ida_idd.delete_process_info_t

# Register process_info_t in _ida_idd:
_ida_idd.process_info_t_swigregister(process_info_t)

class debapp_attrs_t(object):
    r"""Proxy of C++ debapp_attrs_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cbsize = property(_ida_idd.debapp_attrs_t_cbsize_get, _ida_idd.debapp_attrs_t_cbsize_set, doc=r"""cbsize""")
    addrsize = property(_ida_idd.debapp_attrs_t_addrsize_get, _ida_idd.debapp_attrs_t_addrsize_set, doc=r"""addrsize""")
    platform = property(_ida_idd.debapp_attrs_t_platform_get, _ida_idd.debapp_attrs_t_platform_set, doc=r"""platform""")
    is_be = property(_ida_idd.debapp_attrs_t_is_be_get, _ida_idd.debapp_attrs_t_is_be_set, doc=r"""is_be""")

    def __init__(self, *args):
        r"""__init__(self) -> debapp_attrs_t"""
        _ida_idd.debapp_attrs_t_swiginit(self, _ida_idd.new_debapp_attrs_t(*args))
    __swig_destroy__ = _ida_idd.delete_debapp_attrs_t

# Register debapp_attrs_t in _ida_idd:
_ida_idd.debapp_attrs_t_swigregister(debapp_attrs_t)
DEF_ADDRSIZE = _ida_idd.DEF_ADDRSIZE


class memory_info_t(ida_range.range_t):
    r"""Proxy of C++ memory_info_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ida_idd.memory_info_t_name_get, _ida_idd.memory_info_t_name_set, doc=r"""name""")
    sclass = property(_ida_idd.memory_info_t_sclass_get, _ida_idd.memory_info_t_sclass_set, doc=r"""sclass""")
    sbase = property(_ida_idd.memory_info_t_sbase_get, _ida_idd.memory_info_t_sbase_set, doc=r"""sbase""")
    bitness = property(_ida_idd.memory_info_t_bitness_get, _ida_idd.memory_info_t_bitness_set, doc=r"""bitness""")
    perm = property(_ida_idd.memory_info_t_perm_get, _ida_idd.memory_info_t_perm_set, doc=r"""perm""")

    def __init__(self, *args):
        r"""__init__(self) -> memory_info_t"""
        _ida_idd.memory_info_t_swiginit(self, _ida_idd.new_memory_info_t(*args))

    def __eq__(self, *args):
        r"""__eq__(self, r) -> bool"""
        return _ida_idd.memory_info_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""__ne__(self, r) -> bool"""
        return _ida_idd.memory_info_t___ne__(self, *args)
    __swig_destroy__ = _ida_idd.delete_memory_info_t

# Register memory_info_t in _ida_idd:
_ida_idd.memory_info_t_swigregister(memory_info_t)

class scattered_segm_t(ida_range.range_t):
    r"""Proxy of C++ scattered_segm_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ida_idd.scattered_segm_t_name_get, _ida_idd.scattered_segm_t_name_set, doc=r"""name""")

    def __init__(self, *args):
        r"""__init__(self) -> scattered_segm_t"""
        _ida_idd.scattered_segm_t_swiginit(self, _ida_idd.new_scattered_segm_t(*args))
    __swig_destroy__ = _ida_idd.delete_scattered_segm_t

# Register scattered_segm_t in _ida_idd:
_ida_idd.scattered_segm_t_swigregister(scattered_segm_t)

NO_EVENT = _ida_idd.NO_EVENT

PROCESS_STARTED = _ida_idd.PROCESS_STARTED

PROCESS_EXITED = _ida_idd.PROCESS_EXITED

THREAD_STARTED = _ida_idd.THREAD_STARTED

THREAD_EXITED = _ida_idd.THREAD_EXITED

BREAKPOINT = _ida_idd.BREAKPOINT

STEP = _ida_idd.STEP

EXCEPTION = _ida_idd.EXCEPTION

LIB_LOADED = _ida_idd.LIB_LOADED

LIB_UNLOADED = _ida_idd.LIB_UNLOADED

INFORMATION = _ida_idd.INFORMATION

PROCESS_ATTACHED = _ida_idd.PROCESS_ATTACHED

PROCESS_DETACHED = _ida_idd.PROCESS_DETACHED

PROCESS_SUSPENDED = _ida_idd.PROCESS_SUSPENDED

TRACE_FULL = _ida_idd.TRACE_FULL


def set_debug_event_code(*args):
    r"""set_debug_event_code(ev, id)"""
    return _ida_idd.set_debug_event_code(*args)
class modinfo_t(object):
    r"""Proxy of C++ modinfo_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ida_idd.modinfo_t_name_get, _ida_idd.modinfo_t_name_set, doc=r"""name""")
    base = property(_ida_idd.modinfo_t_base_get, _ida_idd.modinfo_t_base_set, doc=r"""base""")
    size = property(_ida_idd.modinfo_t_size_get, _ida_idd.modinfo_t_size_set, doc=r"""size""")
    rebase_to = property(_ida_idd.modinfo_t_rebase_to_get, _ida_idd.modinfo_t_rebase_to_set, doc=r"""rebase_to""")

    def __init__(self, *args):
        r"""__init__(self) -> modinfo_t"""
        _ida_idd.modinfo_t_swiginit(self, _ida_idd.new_modinfo_t(*args))
    __swig_destroy__ = _ida_idd.delete_modinfo_t

# Register modinfo_t in _ida_idd:
_ida_idd.modinfo_t_swigregister(modinfo_t)

class bptaddr_t(object):
    r"""Proxy of C++ bptaddr_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hea = property(_ida_idd.bptaddr_t_hea_get, _ida_idd.bptaddr_t_hea_set, doc=r"""hea""")
    kea = property(_ida_idd.bptaddr_t_kea_get, _ida_idd.bptaddr_t_kea_set, doc=r"""kea""")

    def __init__(self, *args):
        r"""__init__(self) -> bptaddr_t"""
        _ida_idd.bptaddr_t_swiginit(self, _ida_idd.new_bptaddr_t(*args))
    __swig_destroy__ = _ida_idd.delete_bptaddr_t

# Register bptaddr_t in _ida_idd:
_ida_idd.bptaddr_t_swigregister(bptaddr_t)

class excinfo_t(object):
    r"""Proxy of C++ excinfo_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_ida_idd.excinfo_t_code_get, _ida_idd.excinfo_t_code_set, doc=r"""code""")
    can_cont = property(_ida_idd.excinfo_t_can_cont_get, _ida_idd.excinfo_t_can_cont_set, doc=r"""can_cont""")
    ea = property(_ida_idd.excinfo_t_ea_get, _ida_idd.excinfo_t_ea_set, doc=r"""ea""")
    info = property(_ida_idd.excinfo_t_info_get, _ida_idd.excinfo_t_info_set, doc=r"""info""")

    def __init__(self, *args):
        r"""__init__(self) -> excinfo_t"""
        _ida_idd.excinfo_t_swiginit(self, _ida_idd.new_excinfo_t(*args))
    __swig_destroy__ = _ida_idd.delete_excinfo_t

# Register excinfo_t in _ida_idd:
_ida_idd.excinfo_t_swigregister(excinfo_t)

class debug_event_t(object):
    r"""Proxy of C++ debug_event_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pid = property(_ida_idd.debug_event_t_pid_get, _ida_idd.debug_event_t_pid_set, doc=r"""pid""")
    tid = property(_ida_idd.debug_event_t_tid_get, _ida_idd.debug_event_t_tid_set, doc=r"""tid""")
    ea = property(_ida_idd.debug_event_t_ea_get, _ida_idd.debug_event_t_ea_set, doc=r"""ea""")
    handled = property(_ida_idd.debug_event_t_handled_get, _ida_idd.debug_event_t_handled_set, doc=r"""handled""")

    def __init__(self, *args):
        r"""
        __init__(self) -> debug_event_t
        __init__(self, r) -> debug_event_t
        """
        _ida_idd.debug_event_t_swiginit(self, _ida_idd.new_debug_event_t(*args))
    __swig_destroy__ = _ida_idd.delete_debug_event_t

    def copy(self, *args):
        r"""copy(self, r) -> debug_event_t"""
        return _ida_idd.debug_event_t_copy(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_idd.debug_event_t_clear(self, *args)

    def clear_all(self, *args):
        r"""clear_all(self)"""
        return _ida_idd.debug_event_t_clear_all(self, *args)

    def eid(self, *args):
        r"""eid(self) -> event_id_t"""
        return _ida_idd.debug_event_t_eid(self, *args)

    def set_eid(self, *args):
        r"""set_eid(self, id)"""
        return _ida_idd.debug_event_t_set_eid(self, *args)

    def modinfo(self, *args):
        r"""
        modinfo(self) -> modinfo_t
        modinfo(self) -> modinfo_t
        """
        return _ida_idd.debug_event_t_modinfo(self, *args)

    def exit_code(self, *args):
        r"""exit_code(self) -> int const &"""
        return _ida_idd.debug_event_t_exit_code(self, *args)

    def info(self, *args):
        r"""
        info(self) -> qstring
        info(self) -> qstring const &
        """
        return _ida_idd.debug_event_t_info(self, *args)

    def bpt(self, *args):
        r"""
        bpt(self) -> bptaddr_t
        bpt(self) -> bptaddr_t
        """
        return _ida_idd.debug_event_t_bpt(self, *args)

    def exc(self, *args):
        r"""
        exc(self) -> excinfo_t
        exc(self) -> excinfo_t
        """
        return _ida_idd.debug_event_t_exc(self, *args)

    def set_modinfo(self, *args):
        r"""set_modinfo(self, id) -> modinfo_t"""
        return _ida_idd.debug_event_t_set_modinfo(self, *args)

    def set_exit_code(self, *args):
        r"""set_exit_code(self, id, code)"""
        return _ida_idd.debug_event_t_set_exit_code(self, *args)

    def set_info(self, *args):
        r"""set_info(self, id) -> qstring &"""
        return _ida_idd.debug_event_t_set_info(self, *args)

    def set_bpt(self, *args):
        r"""set_bpt(self) -> bptaddr_t"""
        return _ida_idd.debug_event_t_set_bpt(self, *args)

    def set_exception(self, *args):
        r"""set_exception(self) -> excinfo_t"""
        return _ida_idd.debug_event_t_set_exception(self, *args)

    def bpt_ea(self, *args):
        r"""bpt_ea(self) -> ea_t"""
        return _ida_idd.debug_event_t_bpt_ea(self, *args)

# Register debug_event_t in _ida_idd:
_ida_idd.debug_event_t_swigregister(debug_event_t)

class exception_info_t(object):
    r"""Proxy of C++ exception_info_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_ida_idd.exception_info_t_code_get, _ida_idd.exception_info_t_code_set, doc=r"""code""")
    flags = property(_ida_idd.exception_info_t_flags_get, _ida_idd.exception_info_t_flags_set, doc=r"""flags""")

    def break_on(self, *args):
        r"""break_on(self) -> bool"""
        return _ida_idd.exception_info_t_break_on(self, *args)

    def handle(self, *args):
        r"""handle(self) -> bool"""
        return _ida_idd.exception_info_t_handle(self, *args)
    name = property(_ida_idd.exception_info_t_name_get, _ida_idd.exception_info_t_name_set, doc=r"""name""")
    desc = property(_ida_idd.exception_info_t_desc_get, _ida_idd.exception_info_t_desc_set, doc=r"""desc""")

    def __init__(self, *args):
        r"""
        __init__(self) -> exception_info_t
        __init__(self, _code, _flags, _name, _desc) -> exception_info_t
        """
        _ida_idd.exception_info_t_swiginit(self, _ida_idd.new_exception_info_t(*args))
    __swig_destroy__ = _ida_idd.delete_exception_info_t

# Register exception_info_t in _ida_idd:
_ida_idd.exception_info_t_swigregister(exception_info_t)
cvar = _ida_idd.cvar
BPT_WRITE = cvar.BPT_WRITE
BPT_READ = cvar.BPT_READ
BPT_RDWR = cvar.BPT_RDWR
BPT_SOFT = cvar.BPT_SOFT
BPT_EXEC = cvar.BPT_EXEC
BPT_DEFAULT = cvar.BPT_DEFAULT
EXC_BREAK = _ida_idd.EXC_BREAK

EXC_HANDLE = _ida_idd.EXC_HANDLE

EXC_MSG = _ida_idd.EXC_MSG

EXC_SILENT = _ida_idd.EXC_SILENT


class regval_t(object):
    r"""Proxy of C++ regval_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rvtype = property(_ida_idd.regval_t_rvtype_get, _ida_idd.regval_t_rvtype_set, doc=r"""rvtype""")
    ival = property(_ida_idd.regval_t_ival_get, _ida_idd.regval_t_ival_set, doc=r"""ival""")
    fval = property(_ida_idd.regval_t_fval_get, _ida_idd.regval_t_fval_set, doc=r"""fval""")
    __swig_destroy__ = _ida_idd.delete_regval_t

    def __init__(self, *args):
        r"""
        __init__(self) -> regval_t
        __init__(self, r) -> regval_t
        """
        _ida_idd.regval_t_swiginit(self, _ida_idd.new_regval_t(*args))

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_idd.regval_t_clear(self, *args)

    def __eq__(self, *args):
        r"""__eq__(self, r) -> bool"""
        return _ida_idd.regval_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""__ne__(self, r) -> bool"""
        return _ida_idd.regval_t___ne__(self, *args)

    def swap(self, *args):
        r"""swap(self, r)"""
        return _ida_idd.regval_t_swap(self, *args)

    def _set_int(self, *args):
        r"""_set_int(self, x)"""
        return _ida_idd.regval_t__set_int(self, *args)

    def _set_float(self, *args):
        r"""_set_float(self, x)"""
        return _ida_idd.regval_t__set_float(self, *args)

    def _set_bytes(self, *args):
        r"""
        _set_bytes(self, data, size)
        _set_bytes(self, v)
        _set_bytes(self) -> bytevec_t &
        """
        return _ida_idd.regval_t__set_bytes(self, *args)

    def set_int(self, *args):
        r"""set_int(self, x)"""
        return _ida_idd.regval_t_set_int(self, *args)

    def set_float(self, *args):
        r"""set_float(self, x)"""
        return _ida_idd.regval_t_set_float(self, *args)

    def set_bytes(self, *args):
        r"""
        set_bytes(self, data, size)
        set_bytes(self, v)
        set_bytes(self) -> bytevec_t &
        """
        return _ida_idd.regval_t_set_bytes(self, *args)

    def bytes(self, *args):
        r"""
        bytes(self) -> bytevec_t
        bytes(self) -> bytevec_t const &
        """
        return _ida_idd.regval_t_bytes(self, *args)

    def get_data(self, *args):
        r"""
        get_data(self)
        get_data(self) -> void const *
        """
        return _ida_idd.regval_t_get_data(self, *args)

    def get_data_size(self, *args):
        r"""get_data_size(self) -> size_t"""
        return _ida_idd.regval_t_get_data_size(self, *args)

# Register regval_t in _ida_idd:
_ida_idd.regval_t_swigregister(regval_t)
RVT_INT = _ida_idd.RVT_INT

RVT_FLOAT = _ida_idd.RVT_FLOAT

RVT_UNAVAILABLE = _ida_idd.RVT_UNAVAILABLE


class call_stack_info_t(object):
    r"""Proxy of C++ call_stack_info_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    callea = property(_ida_idd.call_stack_info_t_callea_get, _ida_idd.call_stack_info_t_callea_set, doc=r"""callea""")
    funcea = property(_ida_idd.call_stack_info_t_funcea_get, _ida_idd.call_stack_info_t_funcea_set, doc=r"""funcea""")
    fp = property(_ida_idd.call_stack_info_t_fp_get, _ida_idd.call_stack_info_t_fp_set, doc=r"""fp""")
    funcok = property(_ida_idd.call_stack_info_t_funcok_get, _ida_idd.call_stack_info_t_funcok_set, doc=r"""funcok""")

    def __eq__(self, *args):
        r"""__eq__(self, r) -> bool"""
        return _ida_idd.call_stack_info_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""__ne__(self, r) -> bool"""
        return _ida_idd.call_stack_info_t___ne__(self, *args)

    def __init__(self, *args):
        r"""__init__(self) -> call_stack_info_t"""
        _ida_idd.call_stack_info_t_swiginit(self, _ida_idd.new_call_stack_info_t(*args))
    __swig_destroy__ = _ida_idd.delete_call_stack_info_t

# Register call_stack_info_t in _ida_idd:
_ida_idd.call_stack_info_t_swigregister(call_stack_info_t)


def dbg_appcall(*args):
    r"""dbg_appcall(retval, func_ea, tid, ptif, argv, argnum) -> error_t"""
    return _ida_idd.dbg_appcall(*args)

def cleanup_appcall(*args):
    r"""cleanup_appcall(tid) -> error_t"""
    return _ida_idd.cleanup_appcall(*args)
class thread_name_t(object):
    r"""Proxy of C++ thread_name_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tid = property(_ida_idd.thread_name_t_tid_get, _ida_idd.thread_name_t_tid_set, doc=r"""tid""")
    name = property(_ida_idd.thread_name_t_name_get, _ida_idd.thread_name_t_name_set, doc=r"""name""")

    def __init__(self, *args):
        r"""__init__(self) -> thread_name_t"""
        _ida_idd.thread_name_t_swiginit(self, _ida_idd.new_thread_name_t(*args))
    __swig_destroy__ = _ida_idd.delete_thread_name_t

# Register thread_name_t in _ida_idd:
_ida_idd.thread_name_t_swigregister(thread_name_t)

RESMOD_NONE = _ida_idd.RESMOD_NONE

RESMOD_INTO = _ida_idd.RESMOD_INTO

RESMOD_OVER = _ida_idd.RESMOD_OVER

RESMOD_OUT = _ida_idd.RESMOD_OUT

RESMOD_SRCINTO = _ida_idd.RESMOD_SRCINTO

RESMOD_SRCOVER = _ida_idd.RESMOD_SRCOVER

RESMOD_SRCOUT = _ida_idd.RESMOD_SRCOUT

RESMOD_USER = _ida_idd.RESMOD_USER

RESMOD_HANDLE = _ida_idd.RESMOD_HANDLE

RESMOD_MAX = _ida_idd.RESMOD_MAX

STEP_TRACE = _ida_idd.STEP_TRACE

INSN_TRACE = _ida_idd.INSN_TRACE

FUNC_TRACE = _ida_idd.FUNC_TRACE

BBLK_TRACE = _ida_idd.BBLK_TRACE

DRC_EVENTS = _ida_idd.DRC_EVENTS

DRC_CRC = _ida_idd.DRC_CRC

DRC_OK = _ida_idd.DRC_OK

DRC_NONE = _ida_idd.DRC_NONE

DRC_FAILED = _ida_idd.DRC_FAILED

DRC_NETERR = _ida_idd.DRC_NETERR

DRC_NOFILE = _ida_idd.DRC_NOFILE

DRC_IDBSEG = _ida_idd.DRC_IDBSEG

DRC_NOPROC = _ida_idd.DRC_NOPROC

DRC_NOCHG = _ida_idd.DRC_NOCHG

DRC_ERROR = _ida_idd.DRC_ERROR

RQ_MASKING = _ida_idd.RQ_MASKING

RQ_SUSPEND = _ida_idd.RQ_SUSPEND

RQ_NOSUSP = _ida_idd.RQ_NOSUSP

RQ_IGNWERR = _ida_idd.RQ_IGNWERR

RQ_SILENT = _ida_idd.RQ_SILENT

RQ_VERBOSE = _ida_idd.RQ_VERBOSE

RQ_SWSCREEN = _ida_idd.RQ_SWSCREEN

RQ__NOTHRRF = _ida_idd.RQ__NOTHRRF

RQ_PROCEXIT = _ida_idd.RQ_PROCEXIT

RQ_IDAIDLE = _ida_idd.RQ_IDAIDLE

RQ_SUSPRUN = _ida_idd.RQ_SUSPRUN

RQ_RESUME = _ida_idd.RQ_RESUME

RQ_RESMOD = _ida_idd.RQ_RESMOD

RQ_RESMOD_SHIFT = _ida_idd.RQ_RESMOD_SHIFT


def dbg_get_registers(*args):
    r"""dbg_get_registers() -> PyObject *"""
    return _ida_idd.dbg_get_registers(*args)

def dbg_get_thread_sreg_base(*args):
    r"""dbg_get_thread_sreg_base(py_tid, py_sreg_value) -> PyObject *"""
    return _ida_idd.dbg_get_thread_sreg_base(*args)

def dbg_read_memory(*args):
    r"""dbg_read_memory(py_ea, py_sz) -> PyObject *"""
    return _ida_idd.dbg_read_memory(*args)

def dbg_write_memory(*args):
    r"""dbg_write_memory(py_ea, py_buf) -> PyObject *"""
    return _ida_idd.dbg_write_memory(*args)

def dbg_get_name(*args):
    r"""dbg_get_name() -> PyObject *"""
    return _ida_idd.dbg_get_name(*args)

def dbg_get_memory_info(*args):
    r"""dbg_get_memory_info() -> PyObject *"""
    return _ida_idd.dbg_get_memory_info(*args)

def appcall(*args):
    r"""appcall(func_ea, tid, _type_or_none, _fields, arg_list) -> PyObject *"""
    return _ida_idd.appcall(*args)

def get_event_module_name(*args):
    r"""get_event_module_name(ev) -> char"""
    return _ida_idd.get_event_module_name(*args)

def get_event_module_base(*args):
    r"""get_event_module_base(ev) -> ea_t"""
    return _ida_idd.get_event_module_base(*args)

def get_event_module_size(*args):
    r"""get_event_module_size(ev) -> asize_t"""
    return _ida_idd.get_event_module_size(*args)

def get_event_exc_info(*args):
    r"""get_event_exc_info(ev) -> char"""
    return _ida_idd.get_event_exc_info(*args)

def get_event_info(*args):
    r"""get_event_info(ev) -> char"""
    return _ida_idd.get_event_info(*args)

def get_event_bpt_hea(*args):
    r"""get_event_bpt_hea(ev) -> ea_t"""
    return _ida_idd.get_event_bpt_hea(*args)

def get_event_exc_code(*args):
    r"""get_event_exc_code(ev) -> uint"""
    return _ida_idd.get_event_exc_code(*args)

def get_event_exc_ea(*args):
    r"""get_event_exc_ea(ev) -> ea_t"""
    return _ida_idd.get_event_exc_ea(*args)

def can_exc_continue(*args):
    r"""can_exc_continue(ev) -> bool"""
    return _ida_idd.can_exc_continue(*args)

#<pycode(py_idd)>
NO_PROCESS = 0xFFFFFFFF
NO_THREAD  = 0

import types
import _ida_idaapi
import _ida_dbg
import _ida_typeinf
import _ida_name
import _ida_bytes
import _ida_ida
import ida_idaapi

dbg_can_query = _ida_dbg.dbg_can_query

# -----------------------------------------------------------------------
class Appcall_array__(object):
    """This class is used with Appcall.array() method"""
    def __init__(self, tp):
        self.__type = tp

    def pack(self, L):
        """Packs a list or tuple into a byref buffer"""
        t = type(L)
        if not (t == list or t == tuple):
            raise ValueError("Either a list or a tuple must be passed")
        self.__size = len(L)
        if self.__size == 1:
            self.__typedobj = Appcall__.typedobj(self.__type + ";")
        else:
            self.__typedobj = Appcall__.typedobj("%s x[%d];" % (self.__type, self.__size))
# Now store the object in a string buffer
        ok, buf = self.__typedobj.store(L)
        if ok:
            return Appcall__.byref(buf)
        else:
            return None

    def try_to_convert_to_list(self, obj):
        """Is this object a list? We check for the existance of attribute zero and attribute self.size-1"""
        if not (hasattr(obj, "0") and hasattr(obj, str(self.__size-1))):
            return obj
# at this point, we are sure we have an "idc list"
# let us convert to a Python list
        return [getattr(obj, str(x)) for x in xrange(0, self.__size)]

    def unpack(self, buf, as_list=True):
        """Unpacks an array back into a list or an object"""
# take the value from the special ref object
        if isinstance(buf, ida_idaapi.PyIdc_cvt_refclass__):
            buf = buf.value

# we can only unpack from strings
        if type(buf) != bytes:
            raise ValueError("Cannot unpack this type!")
# now unpack
        ok, obj = self.__typedobj.retrieve(buf)
        if not ok:
            raise ValueError("Failed while unpacking!")
        if not as_list:
            return obj
        return self.try_to_convert_to_list(obj)


# -----------------------------------------------------------------------
# Wrapper class for the appcall()
class Appcall_callable__(object):
    """
    Helper class to issue appcalls using a natural syntax:
      appcall.FunctionNameInTheDatabase(arguments, ....)
    or
      appcall["Function@8"](arguments, ...)
    or
      f8 = appcall["Function@8"]
      f8(arg1, arg2, ...)
    or
      o = appcall.obj()
      i = byref(5)
      appcall.funcname(arg1, i, "hello", o)
    """
    def __init__(self, ea, tp = None, fld = None):
        """Initializes an appcall with a given function ea"""
        self.__ea     = ea
        self.__type   = tp
        self.__fields = fld
        self.__options = None # Appcall options
        self.__timeout = None # Appcall timeout

    def __get_timeout(self):
        return self.__timeout

    def __set_timeout(self, v):
        self.__timeout = v

    timeout = property(__get_timeout, __set_timeout)
    """An Appcall instance can change its timeout value with this attribute"""

    def __get_options(self):
        return self.__options if self.__options != None else Appcall__.get_appcall_options()

    def __set_options(self, v):
        if self.timeout:
# If timeout value is set, then put the timeout flag and encode the timeout value
            v |= Appcall__.APPCALL_TIMEOUT | (self.timeout << 16)
        else:
# Timeout is not set, then clear the timeout flag
            v &= ~Appcall__.APPCALL_TIMEOUT

        self.__options = v

    options = property(__get_options, __set_options)
    """Sets the Appcall options locally to this Appcall instance"""

    def __call__(self, *args):
        """Make object callable. We redirect execution to idaapi.appcall()"""
        if self.ea is None:
            raise ValueError("Object not callable!")

# convert arguments to a list
        arg_list = list(args)

# Save appcall options and set new global options
        old_opt = Appcall__.get_appcall_options()
        Appcall__.set_appcall_options(self.options)

# Do the Appcall (use the wrapped version)
        e_obj = None
        try:
            r = _ida_idd.appcall(
               self.ea,
               _ida_dbg.get_current_thread(),
               self.type,
               self.fields,
               arg_list)
        except Exception as e:
            e_obj = e

# Restore appcall options
        Appcall__.set_appcall_options(old_opt)

# Return or re-raise exception
        if e_obj:
            raise Exception(e_obj)

        return r

    def __get_ea(self):
        return self.__ea

    def __set_ea(self, val):
        self.__ea = val

    ea = property(__get_ea, __set_ea)
    """Returns or sets the EA associated with this object"""

    def __get_size(self):
        if self.__type == None:
            return -1
        r = _ida_typeinf.calc_type_size(None, self.__type)
        if not r:
            return -1
        return r

    size = property(__get_size)
    """Returns the size of the type"""

    def __get_type(self):
        return self.__type

    type = property(__get_type)
    """Returns the typestring"""

    def __get_fields(self):
        return self.__fields

    fields = property(__get_fields)
    """Returns the field names"""


    def retrieve(self, src=None, flags=0):
        """
        Unpacks a typed object from the database if an ea is given or from a string if a string was passed
        @param src: the address of the object or a string
        @return: Returns a tuple of boolean and object or error number (Bool, Error | Object).
        """

# Nothing passed? Take the address and unpack from the database
        if src is None:
            src = self.ea

        if type(src) == bytes:
            return _ida_typeinf.unpack_object_from_bv(None, self.type, self.fields, src, flags)
        else:
            return _ida_typeinf.unpack_object_from_idb(None, self.type, self.fields, src, flags)

    def store(self, obj, dest_ea=None, base_ea=0, flags=0):
        """
        Packs an object into a given ea if provided or into a string if no address was passed.
        @param obj: The object to pack
        @param dest_ea: If packing to idb this will be the store location
        @param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers

        @return:
            - If packing to a string then a Tuple(Boolean, packed_string or error code)
            - If packing to the database then a return code is returned (0 is success)
        """

# no ea passed? thus pack to a string
        if dest_ea is None:
            return _ida_typeinf.pack_object_to_bv(obj,
                                             None,
                                             self.type,
                                             self.fields,
                                             base_ea,
                                             flags)
        else:
            return _ida_typeinf.pack_object_to_idb(obj,
                                              None,
                                              self.type,
                                              self.fields,
                                              dest_ea,
                                              flags)

# -----------------------------------------------------------------------
class Appcall_consts__(object):
    """Helper class used by Appcall.Consts attribute
    It is used to retrieve constants via attribute access"""
    def __init__(self, default=None):
        self.__default = default

    def __getattr__(self, attr):
        v = Appcall__.valueof(attr, self.__default)
        if v is None:
            raise ValueError("No constant with name " + attr)
        return v

# -----------------------------------------------------------------------
class Appcall__(object):
    APPCALL_MANUAL = 0x1
    """
    Only set up the appcall, do not run it.
    you should call CleanupAppcall() when finished
    """

    APPCALL_DEBEV  = 0x2
    """
    Return debug event information
    If this bit is set, exceptions during appcall
    will generate idc exceptions with full
    information about the exception
    """

    APPCALL_TIMEOUT = 0x4
    """
    Appcall with timeout
    The timeout value in milliseconds is specified
    in the high 2 bytes of the 'options' argument:
    If timed out, errbuf will contain "timeout".
    """

    __name__ = "Appcall__"

    def __init__(self):
        self.__consts = Appcall_consts__()

    def __get_consts(self):
        return self.__consts

    Consts = property(__get_consts)
    """Use Appcall.Consts.CONST_NAME to access constants"""

    @staticmethod
    def __name_or_ea(name_or_ea):
        """
        Function that accepts a name or an ea and checks if the address is enabled.
        If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
        @return:
            - Returns the resolved EA or
            - Raises an exception if the address is not enabled
        """

# a string? try to resolve it
        if type(name_or_ea) == bytes:
            ea = _ida_name.get_name_ea(_ida_idaapi.BADADDR, name_or_ea)
        else:
            ea = name_or_ea
# could not resolve name or invalid address?
        if ea == _ida_idaapi.BADADDR or not _ida_bytes.is_mapped(ea):
            raise ValueError("Undefined function " + name_or_ea)
        return ea

    @staticmethod
    def proto(name_or_ea, prototype, flags = None):
        """
        Allows you to instantiate an appcall (callable object) with the desired prototype
        @param name_or_ea: The name of the function (will be resolved with LocByName())
        @param prototype:
        @return:
            - On failure it raises an exception if the prototype could not be parsed
              or the address is not resolvable
            - Returns a callbable Appcall instance with the given prototypes and flags
        """

# resolve and raise exception on error
        ea = Appcall__.__name_or_ea(name_or_ea)
# parse the type
        if flags is None:
            flags = 1 | 2 | 4 # PT_SIL | PT_NDC | PT_TYP

        result = _ida_typeinf.idc_parse_decl(None, prototype, flags)
        if result is None:
            raise ValueError("Could not parse type: " + prototype)

# Return the callable method with type info
        return Appcall_callable__(ea, result[1], result[2])

    def __getattr__(self, name_or_ea):
        """Allows you to call functions as if they were member functions (by returning a callable object)"""
# resolve and raise exception on error
        ea = self.__name_or_ea(name_or_ea)
        if ea == _ida_idaapi.BADADDR:
            raise ValueError("Undefined function " + name)
# Return the callable method
        return Appcall_callable__(ea)

    def __getitem__(self, idx):
        """
        Use self[func_name] syntax if the function name contains invalid characters for an attribute name
        See __getattr___
        """
        return self.__getattr__(idx)

    @staticmethod
    def valueof(name, default=0):
        """
        Returns the numeric value of a given name string.
        If the name could not be resolved then the default value will be returned
        """
        t, v = _ida_name.get_name_value(_ida_idaapi.BADADDR, name)
        if t == 0: # NT_NONE
          v = default
        return v

    @staticmethod
    def int64(v):
        """Whenever a 64bit number is needed use this method to construct an object"""
        return ida_idaapi.PyIdc_cvt_int64__(v)

    @staticmethod
    def byref(val):
        """
        Method to create references to immutable objects
        Currently we support references to int/strings
        Objects need not be passed by reference (this will be done automatically)
        """
        return ida_idaapi.PyIdc_cvt_refclass__(val)

    @staticmethod
    def buffer(str = None, size = 0, fill="\x00"):
        """
        Creates a string buffer. The returned value (r) will be a byref object.
        Use r.value to get the contents and r.size to get the buffer's size
        """
        if str is None:
            str = ""
        left = size - len(str)
        if left > 0:
            str = str + (fill * left)
        r = Appcall__.byref(str)
        r.size = size
        return r

    @staticmethod
    def obj(**kwds):
        """Returns an empty object or objects with attributes as passed via its keywords arguments"""
        return ida_idaapi.object_t(**kwds)

    @staticmethod
    def cstr(val):
        return ida_idaapi.as_cstr(val)

    @staticmethod
    def unicode(s):
        return ida_idaapi.as_unicode(s)

    @staticmethod
    def array(type_name):
        """Defines an array type. Later you need to pack() / unpack()"""
        return Appcall_array__(type_name)

    @staticmethod
    def typedobj(typestr, ea=None):
        """
        Parses a type string and returns an appcall object.
        One can then use retrieve() member method
        @param ea: Optional parameter that later can be used to retrieve the type
        @return: Appcall object or raises ValueError exception
        """
# parse the type
        result = _ida_typeinf.idc_parse_decl(None, typestr, 1 | 2 | 4) # PT_SIL | PT_NDC | PT_TYP
        if result is None:
            raise ValueError("Could not parse type: " + typestr)
# Return the callable method with type info
        return Appcall_callable__(ea, result[1], result[2])

    @staticmethod
    def set_appcall_options(opt):
        """Method to change the Appcall options globally (not per Appcall)"""
        old_opt = Appcall__.get_appcall_options()
        _ida_ida.cvar.inf.appcall_options = opt
        return old_opt

    @staticmethod
    def get_appcall_options():
        """Return the global Appcall options"""
        return _ida_ida.cvar.inf.appcall_options

    @staticmethod
    def cleanup_appcall(tid = 0):
        """Equivalent to IDC's CleanupAppcall()"""
        return _ida_idd.cleanup_appcall(tid)

Appcall = Appcall__()
#</pycode(py_idd)>


if _BC695:
    PROCESS_NO_THREAD=NO_THREAD




