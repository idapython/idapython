

ida_bytes.ALOPT_IGNCLT
"""
if set, don't stop at codepoints that are not part of the current
'culture'; accept all those that are graphical (this is typically used
used by user-initiated actions creating string literals.)
"""

ida_bytes.ALOPT_IGNHEADS
"""
don't stop if another data item is encountered. only the byte values
will be used to determine the string length. if not set, a defined
data item or instruction will truncate the string
"""

ida_bytes.ALOPT_IGNPRINT
"""
if set, don't stop at non-printable codepoints, but only at the
terminating character (or not unicode-mapped character (e.g., 0x8f in
CP1252))
"""

ida_bytes.ALOPT_MAX4K
"""
accumulated length

if string length is more than 4K, return the
"""

ida_bytes.BIN_SEARCH_BACKWARD
"""
search backward for bytes
"""

ida_bytes.BIN_SEARCH_CASE
"""
case sensitive
"""

ida_bytes.BIN_SEARCH_FORWARD
"""
search forward for bytes
"""

ida_bytes.BIN_SEARCH_INITED
"""
find_byte, find_byter: any initilized value
"""

ida_bytes.BIN_SEARCH_NOBREAK
"""
don't check for Ctrl-Break
"""

ida_bytes.BIN_SEARCH_NOCASE
"""
case insensitive
"""

ida_bytes.BIN_SEARCH_NOSHOW
"""
don't show search progress or update screen
"""

ida_bytes.DELIT_DELNAMES
"""
delete any names at the specified address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_EXPAND
"""
propagate undefined items; for example if removing an instruction
removes all references to the next instruction, then plan to convert
to unexplored the next instruction too.
"""

ida_bytes.DELIT_NOCMT
"""
reject to delete if a comment is in address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_NOTRUNC
"""
even if 'AF_TRFUNC' is set

don't truncate the current function
"""

ida_bytes.DELIT_NOUNAME
"""
reject to delete if a user name is in address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_SIMPLE
"""
simply undefine the specified item(s)
"""

ida_bytes.DTP_NODUP
"""
do not use dup construct
"""

ida_bytes.DT_TYPE
"""
Mask for DATA typing.
"""

ida_bytes.FF_0CHAR
"""
Char ('x')?
"""

ida_bytes.FF_0CUST
"""
Custom representation?
"""

ida_bytes.FF_0ENUM
"""
Enumeration?
"""

ida_bytes.FF_0FLT
"""
Floating point number?
"""

ida_bytes.FF_0FOP
"""
Forced operand?
"""

ida_bytes.FF_0NUMB
"""
Binary number?
"""

ida_bytes.FF_0NUMD
"""
Decimal number?
"""

ida_bytes.FF_0NUMH
"""
Hexadecimal number?
"""

ida_bytes.FF_0NUMO
"""
Octal number?
"""

ida_bytes.FF_0OFF
"""
Offset?
"""

ida_bytes.FF_0SEG
"""
Segment?
"""

ida_bytes.FF_0STK
"""
Stack variable?
"""

ida_bytes.FF_0STRO
"""
Struct offset?
"""

ida_bytes.FF_0VOID
"""
Void (unknown)?
"""

ida_bytes.FF_1CHAR
"""
Char ('x')?
"""

ida_bytes.FF_1CUST
"""
Custom representation?
"""

ida_bytes.FF_1ENUM
"""
Enumeration?
"""

ida_bytes.FF_1FLT
"""
Floating point number?
"""

ida_bytes.FF_1FOP
"""
Forced operand?
"""

ida_bytes.FF_1NUMB
"""
Binary number?
"""

ida_bytes.FF_1NUMD
"""
Decimal number?
"""

ida_bytes.FF_1NUMH
"""
Hexadecimal number?
"""

ida_bytes.FF_1NUMO
"""
Octal number?
"""

ida_bytes.FF_1OFF
"""
Offset?
"""

ida_bytes.FF_1SEG
"""
Segment?
"""

ida_bytes.FF_1STK
"""
Stack variable?
"""

ida_bytes.FF_1STRO
"""
Struct offset?
"""

ida_bytes.FF_1VOID
"""
Void (unknown)?
"""

ida_bytes.FF_ALIGN
"""
alignment directive
"""

ida_bytes.FF_BNOT
"""
Bitwise negation of operands.
"""

ida_bytes.FF_BYTE
"""
byte
"""

ida_bytes.FF_CODE
"""
Code ?
"""

ida_bytes.FF_COMM
"""
Has comment ?
"""

ida_bytes.FF_CUSTOM
"""
custom data type
"""

ida_bytes.FF_DATA
"""
Data ?
"""

ida_bytes.FF_DOUBLE
"""
double
"""

ida_bytes.FF_DWORD
"""
double word
"""

ida_bytes.FF_FLOAT
"""
float
"""

ida_bytes.FF_FLOW
"""
Exec flow from prev instruction.
"""

ida_bytes.FF_FUNC
"""
function start?
"""

ida_bytes.FF_IMMD
"""
Has Immediate value ?
"""

ida_bytes.FF_IVL
"""
Byte has value ?
"""

ida_bytes.FF_JUMP
"""
Has jump table or switch_info?
"""

ida_bytes.FF_LABL
"""
Has dummy name?
"""

ida_bytes.FF_LINE
"""
Has next or prev lines ?
"""

ida_bytes.FF_NAME
"""
Has name ?
"""

ida_bytes.FF_OWORD
"""
octaword/xmm word (16 bytes/128 bits)
"""

ida_bytes.FF_PACKREAL
"""
packed decimal real
"""

ida_bytes.FF_QWORD
"""
quadro word
"""

ida_bytes.FF_REF
"""
has references
"""

ida_bytes.FF_SIGN
"""
Inverted sign of operands.
"""

ida_bytes.FF_STRLIT
"""
string literal
"""

ida_bytes.FF_STRUCT
"""
struct variable
"""

ida_bytes.FF_TAIL
"""
Tail ?
"""

ida_bytes.FF_TBYTE
"""
tbyte
"""

ida_bytes.FF_UNK
"""
Unknown ?
"""

ida_bytes.FF_UNUSED
"""
unused bit (was used for variable bytes)
"""

ida_bytes.FF_WORD
"""
word
"""

ida_bytes.FF_YWORD
"""
ymm word (32 bytes/256 bits)
"""

ida_bytes.FF_ZWORD
"""
zmm word (64 bytes/512 bits)
"""

ida_bytes.GFE_VALUE
"""
get flags with 'FF_IVL' & 'MS_VAL' . It is much slower under remote
debugging because the kernel needs to read the process memory.
"""

ida_bytes.GMB_READALL
"""
if this bit is not set, fail at first uninited byte

try to read all bytes
"""

ida_bytes.GMB_WAITBOX
"""
show wait box (may return -1 in this case)
"""

ida_bytes.ITEM_END_FIXUP
"""
stop at the first fixup
"""

ida_bytes.ITEM_END_INITED
"""
stop when initialization changes i.e.if is_loaded(ea): stop if
uninitialized byte is encounteredif !is_loaded(ea): stop if
initialized byte is encountered
"""

ida_bytes.ITEM_END_NAME
"""
stop at the first named location
"""

ida_bytes.ITEM_END_XREF
"""
stop at the first referenced location
"""

ida_bytes.MS_0TYPE
"""
Mask for 1st arg typing.
"""

ida_bytes.MS_1TYPE
"""
Mask for the type of other operands.
"""

ida_bytes.MS_CLS
"""
Mask for typing.
"""

ida_bytes.MS_CODE
"""
Mask for code bits.
"""

ida_bytes.MS_COMM
"""
Mask of common bits.
"""

ida_bytes.MS_VAL
"""
Mask for byte value.
"""

ida_bytes.OPND_ALL
"""
all operands
"""

ida_bytes.OPND_MASK
"""
mask for operand number
"""

ida_bytes.OPND_OUTER
"""
used only in set, get, del_offset() functions

outer offset base (combined with operand number).
"""

ida_bytes.PSTF_ENC
"""
if encoding is specified, append it
"""

ida_bytes.PSTF_HOTKEY
"""
have hotkey markers part of the name
"""

ida_bytes.PSTF_TBRIEF
"""
use brief name (e.g., in the 'Strings window')
"""

ida_bytes.PSTF_TINLIN
"""
use 'inline' name (e.g., in the structures comments)
"""

ida_bytes.PSTF_TMASK
"""
type mask
"""

ida_bytes.PSTF_TNORM
"""
use normal name
"""

ida_bytes.STRCONV_ESCAPE
"""
convert non-printable characters to C escapes (, , )
"""

ida_bytes.STRCONV_INCLLEN
"""
for Pascal-style strings, include the prefixing length byte(s) as
C-escaped sequence
"""

ida_bytes.STRCONV_REPLCHAR
"""
convert non-printable characters to the Unicode replacement character
(U+FFFD)
"""