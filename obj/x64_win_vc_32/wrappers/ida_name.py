# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""IDA Plugin SDK API wrapper: name"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_name
else:
    import _ida_name

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

class ea_name_vec_t(object):
    r"""Proxy of C++ qvector< ea_name_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> ea_name_vec_t
        __init__(self, x) -> ea_name_vec_t
        """
        _ida_name.ea_name_vec_t_swiginit(self, _ida_name.new_ea_name_vec_t(*args))
    __swig_destroy__ = _ida_name.delete_ea_name_vec_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> ea_name_t
        """
        return _ida_name.ea_name_vec_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""pop_back(self)"""
        return _ida_name.ea_name_vec_t_pop_back(self, *args)

    def size(self, *args):
        r"""size(self) -> size_t"""
        return _ida_name.ea_name_vec_t_size(self, *args)

    def empty(self, *args):
        r"""empty(self) -> bool"""
        return _ida_name.ea_name_vec_t_empty(self, *args)

    def at(self, *args):
        r"""at(self, _idx) -> ea_name_t"""
        return _ida_name.ea_name_vec_t_at(self, *args)

    def qclear(self, *args):
        r"""qclear(self)"""
        return _ida_name.ea_name_vec_t_qclear(self, *args)

    def clear(self, *args):
        r"""clear(self)"""
        return _ida_name.ea_name_vec_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_name.ea_name_vec_t_resize(self, *args)

    def grow(self, *args):
        r"""grow(self, x=ea_name_t())"""
        return _ida_name.ea_name_vec_t_grow(self, *args)

    def capacity(self, *args):
        r"""capacity(self) -> size_t"""
        return _ida_name.ea_name_vec_t_capacity(self, *args)

    def reserve(self, *args):
        r"""reserve(self, cnt)"""
        return _ida_name.ea_name_vec_t_reserve(self, *args)

    def truncate(self, *args):
        r"""truncate(self)"""
        return _ida_name.ea_name_vec_t_truncate(self, *args)

    def swap(self, *args):
        r"""swap(self, r)"""
        return _ida_name.ea_name_vec_t_swap(self, *args)

    def extract(self, *args):
        r"""extract(self) -> ea_name_t"""
        return _ida_name.ea_name_vec_t_extract(self, *args)

    def inject(self, *args):
        r"""inject(self, s, len)"""
        return _ida_name.ea_name_vec_t_inject(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> ea_name_t
        begin(self) -> ea_name_t
        """
        return _ida_name.ea_name_vec_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> ea_name_t
        end(self) -> ea_name_t
        """
        return _ida_name.ea_name_vec_t_end(self, *args)

    def insert(self, *args):
        r"""insert(self, it, x) -> ea_name_t"""
        return _ida_name.ea_name_vec_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> ea_name_t
        erase(self, first, last) -> ea_name_t
        """
        return _ida_name.ea_name_vec_t_erase(self, *args)

    def __len__(self, *args):
        r"""__len__(self) -> size_t"""
        return _ida_name.ea_name_vec_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""__getitem__(self, i) -> ea_name_t"""
        return _ida_name.ea_name_vec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""__setitem__(self, i, v)"""
        return _ida_name.ea_name_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register ea_name_vec_t in _ida_name:
_ida_name.ea_name_vec_t_swigregister(ea_name_vec_t)


def get_name(*args):
    r"""get_name(ea) -> qstring"""
    return _ida_name.get_name(*args)

def get_colored_name(*args):
    r"""get_colored_name(ea) -> qstring"""
    return _ida_name.get_colored_name(*args)
MAXNAMELEN = _ida_name.MAXNAMELEN

FUNC_IMPORT_PREFIX = _ida_name.FUNC_IMPORT_PREFIX


def set_name(*args):
    r"""set_name(ea, name, flags=0) -> bool"""
    return _ida_name.set_name(*args)
SN_CHECK = _ida_name.SN_CHECK

SN_NOCHECK = _ida_name.SN_NOCHECK

SN_PUBLIC = _ida_name.SN_PUBLIC

SN_NON_PUBLIC = _ida_name.SN_NON_PUBLIC

SN_WEAK = _ida_name.SN_WEAK

SN_NON_WEAK = _ida_name.SN_NON_WEAK

SN_AUTO = _ida_name.SN_AUTO

SN_NON_AUTO = _ida_name.SN_NON_AUTO

SN_NOLIST = _ida_name.SN_NOLIST

SN_NOWARN = _ida_name.SN_NOWARN

SN_LOCAL = _ida_name.SN_LOCAL

SN_IDBENC = _ida_name.SN_IDBENC

SN_FORCE = _ida_name.SN_FORCE


def force_name(*args):
    r"""force_name(ea, name, flags=0) -> bool"""
    return _ida_name.force_name(*args)

def del_global_name(*args):
    r"""del_global_name(ea) -> bool"""
    return _ida_name.del_global_name(*args)

def del_local_name(*args):
    r"""del_local_name(ea) -> bool"""
    return _ida_name.del_local_name(*args)

def set_dummy_name(*args):
    r"""set_dummy_name(_from, ea) -> bool"""
    return _ida_name.set_dummy_name(*args)

def make_name_auto(*args):
    r"""make_name_auto(ea) -> bool"""
    return _ida_name.make_name_auto(*args)

def make_name_user(*args):
    r"""make_name_user(ea) -> bool"""
    return _ida_name.make_name_user(*args)
URK_NameChars = _ida_name.URK_NameChars

URK_MangleChars = _ida_name.URK_MangleChars

URK_StrlitChars = _ida_name.URK_StrlitChars

URK_TypeNameChars = _ida_name.URK_TypeNameChars

VNT_IDENT = _ida_name.VNT_IDENT

VNT_TYPE = _ida_name.VNT_TYPE

VNT_UDTMEM = _ida_name.VNT_UDTMEM

VNT_STRLIT = _ida_name.VNT_STRLIT

VNT_VISIBLE = _ida_name.VNT_VISIBLE


def is_valid_cp(*args):
    r"""is_valid_cp(cp, kind, data=None) -> bool"""
    return _ida_name.is_valid_cp(*args)

def set_cp_validity(*args):
    r"""set_cp_validity(kind, cp, endcp=wchar32_t(-1), valid=True)"""
    return _ida_name.set_cp_validity(*args)

def is_ident_cp(*args):
    r"""is_ident_cp(cp) -> bool"""
    return _ida_name.is_ident_cp(*args)

def is_strlit_cp(*args):
    r"""is_strlit_cp(cp, specific_ranges=None) -> bool"""
    return _ida_name.is_strlit_cp(*args)

def is_visible_cp(*args):
    r"""is_visible_cp(cp) -> bool"""
    return _ida_name.is_visible_cp(*args)

def is_ident(*args):
    r"""is_ident(name) -> bool"""
    return _ida_name.is_ident(*args)

def is_uname(*args):
    r"""is_uname(name) -> bool"""
    return _ida_name.is_uname(*args)

def is_valid_typename(*args):
    r"""is_valid_typename(name) -> bool"""
    return _ida_name.is_valid_typename(*args)

def extract_name(*args):
    r"""extract_name(line, x) -> ssize_t"""
    return _ida_name.extract_name(*args)

def hide_name(*args):
    r"""hide_name(ea)"""
    return _ida_name.hide_name(*args)

def show_name(*args):
    r"""show_name(ea)"""
    return _ida_name.show_name(*args)

def get_name_ea(*args):
    r"""get_name_ea(_from, name) -> ea_t"""
    return _ida_name.get_name_ea(*args)

def get_name_base_ea(*args):
    r"""get_name_base_ea(_from, to) -> ea_t"""
    return _ida_name.get_name_base_ea(*args)

def get_name_value(*args):
    r"""get_name_value(_from, name) -> int"""
    return _ida_name.get_name_value(*args)
NT_NONE = _ida_name.NT_NONE

NT_BYTE = _ida_name.NT_BYTE

NT_LOCAL = _ida_name.NT_LOCAL

NT_STKVAR = _ida_name.NT_STKVAR

NT_ENUM = _ida_name.NT_ENUM

NT_ABS = _ida_name.NT_ABS

NT_SEG = _ida_name.NT_SEG

NT_STROFF = _ida_name.NT_STROFF

NT_BMASK = _ida_name.NT_BMASK

NT_REGVAR = _ida_name.NT_REGVAR

GN_VISIBLE = _ida_name.GN_VISIBLE

GN_COLORED = _ida_name.GN_COLORED

GN_DEMANGLED = _ida_name.GN_DEMANGLED

GN_STRICT = _ida_name.GN_STRICT

GN_SHORT = _ida_name.GN_SHORT

GN_LONG = _ida_name.GN_LONG

GN_LOCAL = _ida_name.GN_LOCAL

GN_ISRET = _ida_name.GN_ISRET

GN_NOT_ISRET = _ida_name.GN_NOT_ISRET

GN_NOT_DUMMY = _ida_name.GN_NOT_DUMMY


def get_visible_name(*args):
    r"""get_visible_name(ea, gtn_flags=0) -> qstring"""
    return _ida_name.get_visible_name(*args)

def get_short_name(*args):
    r"""get_short_name(ea, gtn_flags=0) -> qstring"""
    return _ida_name.get_short_name(*args)

def get_long_name(*args):
    r"""get_long_name(ea, gtn_flags=0) -> qstring"""
    return _ida_name.get_long_name(*args)

def get_colored_short_name(*args):
    r"""get_colored_short_name(ea, gtn_flags=0) -> qstring"""
    return _ida_name.get_colored_short_name(*args)

def get_colored_long_name(*args):
    r"""get_colored_long_name(ea, gtn_flags=0) -> qstring"""
    return _ida_name.get_colored_long_name(*args)

def get_demangled_name(*args):
    r"""get_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring"""
    return _ida_name.get_demangled_name(*args)

def get_colored_demangled_name(*args):
    r"""get_colored_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring"""
    return _ida_name.get_colored_demangled_name(*args)

def get_name_color(*args):
    r"""get_name_color(_from, ea) -> color_t"""
    return _ida_name.get_name_color(*args)
GETN_APPZERO = _ida_name.GETN_APPZERO

GETN_NOFIXUP = _ida_name.GETN_NOFIXUP

GETN_NODUMMY = _ida_name.GETN_NODUMMY


def get_name_expr(*args):
    r"""get_name_expr(_from, n, ea, off, flags=0x0001) -> ssize_t"""
    return _ida_name.get_name_expr(*args)

def get_nice_colored_name(*args):
    r"""get_nice_colored_name(ea, flags=0) -> ssize_t"""
    return _ida_name.get_nice_colored_name(*args)
GNCN_NOSEG = _ida_name.GNCN_NOSEG

GNCN_NOCOLOR = _ida_name.GNCN_NOCOLOR

GNCN_NOLABEL = _ida_name.GNCN_NOLABEL

GNCN_NOFUNC = _ida_name.GNCN_NOFUNC

GNCN_SEG_FUNC = _ida_name.GNCN_SEG_FUNC

GNCN_SEGNUM = _ida_name.GNCN_SEGNUM

GNCN_REQFUNC = _ida_name.GNCN_REQFUNC

GNCN_REQNAME = _ida_name.GNCN_REQNAME

GNCN_NODBGNM = _ida_name.GNCN_NODBGNM

GNCN_PREFDBG = _ida_name.GNCN_PREFDBG


def append_struct_fields(*args):
    r"""append_struct_fields(disp, n, path, flags, delta, appzero) -> flags_t"""
    return _ida_name.append_struct_fields(*args)

def is_public_name(*args):
    r"""is_public_name(ea) -> bool"""
    return _ida_name.is_public_name(*args)

def make_name_public(*args):
    r"""make_name_public(ea)"""
    return _ida_name.make_name_public(*args)

def make_name_non_public(*args):
    r"""make_name_non_public(ea)"""
    return _ida_name.make_name_non_public(*args)

def is_weak_name(*args):
    r"""is_weak_name(ea) -> bool"""
    return _ida_name.is_weak_name(*args)

def make_name_weak(*args):
    r"""make_name_weak(ea)"""
    return _ida_name.make_name_weak(*args)

def make_name_non_weak(*args):
    r"""make_name_non_weak(ea)"""
    return _ida_name.make_name_non_weak(*args)

def get_nlist_size(*args):
    r"""get_nlist_size() -> size_t"""
    return _ida_name.get_nlist_size(*args)

def get_nlist_idx(*args):
    r"""get_nlist_idx(ea) -> size_t"""
    return _ida_name.get_nlist_idx(*args)

def is_in_nlist(*args):
    r"""is_in_nlist(ea) -> bool"""
    return _ida_name.is_in_nlist(*args)

def get_nlist_ea(*args):
    r"""get_nlist_ea(idx) -> ea_t"""
    return _ida_name.get_nlist_ea(*args)

def get_nlist_name(*args):
    r"""get_nlist_name(idx) -> char const *"""
    return _ida_name.get_nlist_name(*args)

def rebuild_nlist(*args):
    r"""rebuild_nlist()"""
    return _ida_name.rebuild_nlist(*args)

def reorder_dummy_names(*args):
    r"""reorder_dummy_names()"""
    return _ida_name.reorder_dummy_names(*args)
DEBNAME_EXACT = _ida_name.DEBNAME_EXACT

DEBNAME_LOWER = _ida_name.DEBNAME_LOWER

DEBNAME_UPPER = _ida_name.DEBNAME_UPPER

DEBNAME_NICE = _ida_name.DEBNAME_NICE

class ea_name_t(object):
    r"""Proxy of C++ ea_name_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ea = property(_ida_name.ea_name_t_ea_get, _ida_name.ea_name_t_ea_set, doc=r"""ea""")
    name = property(_ida_name.ea_name_t_name_get, _ida_name.ea_name_t_name_set, doc=r"""name""")

    def __init__(self, *args):
        r"""
        __init__(self) -> ea_name_t
        __init__(self, _ea, _name) -> ea_name_t
        """
        _ida_name.ea_name_t_swiginit(self, _ida_name.new_ea_name_t(*args))
    __swig_destroy__ = _ida_name.delete_ea_name_t

# Register ea_name_t in _ida_name:
_ida_name.ea_name_t_swigregister(ea_name_t)


def set_debug_name(*args):
    r"""set_debug_name(ea, name) -> bool"""
    return _ida_name.set_debug_name(*args)

def get_debug_name(*args):
    r"""get_debug_name(ea_ptr, how) -> ssize_t"""
    return _ida_name.get_debug_name(*args)

def del_debug_names(*args):
    r"""del_debug_names(ea1, ea2)"""
    return _ida_name.del_debug_names(*args)

def get_debug_name_ea(*args):
    r"""get_debug_name_ea(name) -> ea_t"""
    return _ida_name.get_debug_name_ea(*args)
DQT_NPURGED_8 = _ida_name.DQT_NPURGED_8

DQT_NPURGED_4 = _ida_name.DQT_NPURGED_4

DQT_NPURGED_2 = _ida_name.DQT_NPURGED_2

DQT_COMPILER = _ida_name.DQT_COMPILER

DQT_NAME_TYPE = _ida_name.DQT_NAME_TYPE

DQT_FULL = _ida_name.DQT_FULL


def demangle_name(*args):
    r"""demangle_name(name, disable_mask, demreq=DQT_FULL) -> int32"""
    return _ida_name.demangle_name(*args)

def is_name_defined_locally(*args):
    r"""is_name_defined_locally(pfn, name, ignore_name_def, ea1=BADADDR, ea2=BADADDR) -> bool"""
    return _ida_name.is_name_defined_locally(*args)

def cleanup_name(*args):
    r"""cleanup_name(ea, name, flags=0) -> bool"""
    return _ida_name.cleanup_name(*args)
CN_KEEP_TRAILING__DIGITS = _ida_name.CN_KEEP_TRAILING__DIGITS


def get_debug_names(*args):
    r"""
    get_debug_names(names, ea1, ea2)
    get_debug_names(ea1, ea2) -> PyObject *
    """
    return _ida_name.get_debug_names(*args)

def get_ea_name(*args):
    r"""get_ea_name(ea, gtn_flags=0) -> qstring"""
    return _ida_name.get_ea_name(*args)

def validate_name(*args):
    r"""validate_name(name, type, flags=0) -> PyObject *"""
    return _ida_name.validate_name(*args)

#<pycode(py_name)>
import _ida_idaapi
import _ida_funcs
import bisect


class NearestName(object):
    """
    Utility class to help find the nearest name in a given ea/name dictionary
    """
    def __init__(self, ea_names):
        self.update(ea_names)


    def update(self, ea_names):
        """Updates the ea/names map"""
        self._names = ea_names
        self._addrs = ea_names.keys()
        self._addrs.sort()


    def find(self, ea):
        """
        Returns a tupple (ea, name, pos) that is the nearest to the passed ea
        If no name is matched then None is returned
        """
        pos = bisect.bisect_left(self._addrs, ea)
# no match
        if pos >= len(self._addrs):
            return None
# exact match?
        if self._addrs[pos] != ea:
            pos -= 1 # go to previous element
        if pos < 0:
            return None
        return self[pos]


    def _get_item(self, index):
        ea = self._addrs[index]
        return (ea, self._names[ea], index)


    def __iter__(self):
        return (self._get_item(index) for index in xrange(0, len(self._addrs)))


    def __getitem__(self, index):
        """Returns the tupple (ea, name, index)"""
        if index > len(self._addrs):
            raise StopIteration
        return self._get_item(index)

def calc_gtn_flags(fromaddr, ea):
    """
    Calculate flags for get_ea_name() function

    @param fromaddr: the referring address. May be BADADDR.
    @param ea: linear address

    @return: flags
    """
    gtn_flags = 0
    if fromaddr != _ida_idaapi.BADADDR:
        pfn = _ida_funcs.get_func(fromaddr)
        if _ida_funcs.func_contains(pfn, ea):
            gtn_flags = GN_LOCAL
    return gtn_flags

#</pycode(py_name)>


if _BC695:
    GN_INSNLOC=0
    @bc695redef
    def demangle_name(name, mask, demreq=DQT_FULL): # make flag optional, so demangle_name & demangle_name2 can use it
        return _ida_name.demangle_name(name, mask, demreq)
    demangle_name2=demangle_name
    def do_name_anyway(ea, name, maxlen=0):
        return force_name(ea, name)
    extract_name2=extract_name
    get_debug_name2=get_debug_name
    def get_true_name(ea0, ea1=None):
        if ea1 is None:
            ea = ea0
        else:
            ea = ea1
        return get_name(ea)
    is_ident_char=is_ident_cp
    is_visible_char=is_visible_cp
    def make_visible_name(name, sz=0):
        if sz > 0:
            name = name[0:sz]
        return _ida_name.validate_name(name, VNT_VISIBLE)
    def validate_name2(name, sz=0):
        if sz > 0:
            name = name[0:sz]
        return _ida_name.validate_name(name, VNT_IDENT)
    def validate_name3(name):
        return _ida_name.validate_name(name, VNT_IDENT)
    isident=is_ident
    @bc695redef
    def get_name(*args):
        if len(args) == 2:
            if args[0] != _ida_idaapi.BADADDR:
                print("Compatibility get_name(from, ea) was called with non-BADADDR first argument (0x%08x). There is no equivalent in the new API, and the results might be erroneous." % args[0]);
            return _ida_name.get_name(args[1])
        else:
            return _ida_name.get_name(*args)



cvar = _ida_name.cvar
ignore_none = cvar.ignore_none
ignore_regvar = cvar.ignore_regvar
ignore_llabel = cvar.ignore_llabel
ignore_stkvar = cvar.ignore_stkvar
ignore_glabel = cvar.ignore_glabel

