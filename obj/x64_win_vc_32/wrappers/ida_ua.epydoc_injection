

ida_ua.FCBF_CONT
"""
don't stop on decoding, or any other kind of error
"""

ida_ua.FCBF_DELIM
"""
add the 'ash'-specified delimiters around the generated data. Note: if
those are not defined and the INFFL_ALLASM is not set,
'format_charlit()' will return an error
"""

ida_ua.FCBF_ERR_REPL
"""
of a hex representation of the problematic byte

in case of an error, use a CP_REPLCHAR instead
"""

ida_ua.FCBF_FF_LIT
"""
in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER
Y WITH DIAERESIS) If both this, and FCBF_REPL are specified, this will
take precedence
"""

ida_ua.INSN_64BIT
"""
belongs to 64bit segment?
"""

ida_ua.INSN_MACRO
"""
macro instruction
"""

ida_ua.INSN_MODMAC
"""
may modify the database to make room for the macro insn
"""

ida_ua.OF_NO_BASE_DISP
"""
base displacement doesn't exist. meaningful only for 'o_displ' type.
if set, base displacement ( 'op_t::addr' ) doesn't exist.
"""

ida_ua.OF_NUMBER
"""
the operand can be converted to a number only
"""

ida_ua.OF_OUTER_DISP
"""
outer displacement exists. meaningful only for 'o_displ' type. if set,
outer displacement ( 'op_t::value' ) exists.
"""

ida_ua.OF_SHOW
"""
should the operand be displayed?
"""

ida_ua.OOFS_IFSIGN
"""
output sign if needed
"""

ida_ua.OOFS_NEEDSIGN
"""
always out sign (+-)
"""

ida_ua.OOFS_NOSIGN
"""
don't output sign, forbid the user to change the sign
"""

ida_ua.OOFW_16
"""
16 bit width
"""

ida_ua.OOFW_24
"""
24 bit width
"""

ida_ua.OOFW_32
"""
32 bit width
"""

ida_ua.OOFW_64
"""
64 bit width
"""

ida_ua.OOFW_8
"""
8 bit width
"""

ida_ua.OOFW_IMM
"""
take from x.dtype
"""

ida_ua.OOF_ADDR
"""
output x.addr, otherwise x.value
"""

ida_ua.OOF_ANYSERIAL
"""
if enum: select first available serial
"""

ida_ua.OOF_NOBNOT
"""
prohibit use of binary not
"""

ida_ua.OOF_NUMBER
"""
always as a number
"""

ida_ua.OOF_OUTER
"""
output outer operand
"""

ida_ua.OOF_SIGNED
"""
output as signed if < 0
"""

ida_ua.OOF_SIGNMASK
"""
sign symbol (+/-) output
"""

ida_ua.OOF_SPACES
"""
currently works only for floating point numbers

do not suppress leading spaces
"""

ida_ua.OOF_WIDTHMASK
"""
width of value in bits
"""

ida_ua.OOF_ZSTROFF
"""
meaningful only if is_stroff(uFlag) append a struct field name if the
field offset is zero? if 'AFL_ZSTROFF' is set, then this flag is
ignored.
"""

ida_ua.PACK_FORM_DEF
"""
(! 'o_reg' + 'dt_packreal' )

packed factor defined.
"""

ida_ua.dt_bitfild
"""
bit field (mc680x0)
"""

ida_ua.dt_byte
"""
8 bit
"""

ida_ua.dt_byte16
"""
128 bit
"""

ida_ua.dt_byte32
"""
256 bit
"""

ida_ua.dt_byte64
"""
512 bit
"""

ida_ua.dt_code
"""
ptr to code (not used?)
"""

ida_ua.dt_double
"""
8 byte
"""

ida_ua.dt_dword
"""
32 bit
"""

ida_ua.dt_float
"""
4 byte
"""

ida_ua.dt_fword
"""
48 bit
"""

ida_ua.dt_ldbl
"""
long double (which may be different from tbyte)
"""

ida_ua.dt_packreal
"""
packed real format for mc68040
"""

ida_ua.dt_qword
"""
64 bit
"""

ida_ua.dt_string
"""
pointer to asciiz string
"""

ida_ua.dt_tbyte
"""
variable size ({tbyte_size})
"""

ida_ua.dt_unicode
"""
pointer to unicode string
"""

ida_ua.dt_void
"""
none
"""

ida_ua.dt_word
"""
16 bit
"""